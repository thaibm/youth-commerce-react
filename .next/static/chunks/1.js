(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[1],{

/***/ "./node_modules/react-owl-carousel3/lib/OwlCarousel.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-owl-carousel3/lib/OwlCarousel.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n\telse {}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_12__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 13);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\neval(\"// shim for using process in browser\\nvar process = module.exports = {};\\n\\n// cached from whatever global is present so that test runners that stub it\\n// don't break things.  But we need to wrap it in a try catch in case it is\\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\\n// function because try/catches deoptimize in certain engines.\\n\\nvar cachedSetTimeout;\\nvar cachedClearTimeout;\\n\\nfunction defaultSetTimout() {\\n    throw new Error('setTimeout has not been defined');\\n}\\nfunction defaultClearTimeout () {\\n    throw new Error('clearTimeout has not been defined');\\n}\\n(function () {\\n    try {\\n        if (typeof setTimeout === 'function') {\\n            cachedSetTimeout = setTimeout;\\n        } else {\\n            cachedSetTimeout = defaultSetTimout;\\n        }\\n    } catch (e) {\\n        cachedSetTimeout = defaultSetTimout;\\n    }\\n    try {\\n        if (typeof clearTimeout === 'function') {\\n            cachedClearTimeout = clearTimeout;\\n        } else {\\n            cachedClearTimeout = defaultClearTimeout;\\n        }\\n    } catch (e) {\\n        cachedClearTimeout = defaultClearTimeout;\\n    }\\n} ())\\nfunction runTimeout(fun) {\\n    if (cachedSetTimeout === setTimeout) {\\n        //normal enviroments in sane situations\\n        return setTimeout(fun, 0);\\n    }\\n    // if setTimeout wasn't available but was latter defined\\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\\n        cachedSetTimeout = setTimeout;\\n        return setTimeout(fun, 0);\\n    }\\n    try {\\n        // when when somebody has screwed with setTimeout but no I.E. maddness\\n        return cachedSetTimeout(fun, 0);\\n    } catch(e){\\n        try {\\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\\n            return cachedSetTimeout.call(null, fun, 0);\\n        } catch(e){\\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\\n            return cachedSetTimeout.call(this, fun, 0);\\n        }\\n    }\\n\\n\\n}\\nfunction runClearTimeout(marker) {\\n    if (cachedClearTimeout === clearTimeout) {\\n        //normal enviroments in sane situations\\n        return clearTimeout(marker);\\n    }\\n    // if clearTimeout wasn't available but was latter defined\\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\\n        cachedClearTimeout = clearTimeout;\\n        return clearTimeout(marker);\\n    }\\n    try {\\n        // when when somebody has screwed with setTimeout but no I.E. maddness\\n        return cachedClearTimeout(marker);\\n    } catch (e){\\n        try {\\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\\n            return cachedClearTimeout.call(null, marker);\\n        } catch (e){\\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\\n            return cachedClearTimeout.call(this, marker);\\n        }\\n    }\\n\\n\\n\\n}\\nvar queue = [];\\nvar draining = false;\\nvar currentQueue;\\nvar queueIndex = -1;\\n\\nfunction cleanUpNextTick() {\\n    if (!draining || !currentQueue) {\\n        return;\\n    }\\n    draining = false;\\n    if (currentQueue.length) {\\n        queue = currentQueue.concat(queue);\\n    } else {\\n        queueIndex = -1;\\n    }\\n    if (queue.length) {\\n        drainQueue();\\n    }\\n}\\n\\nfunction drainQueue() {\\n    if (draining) {\\n        return;\\n    }\\n    var timeout = runTimeout(cleanUpNextTick);\\n    draining = true;\\n\\n    var len = queue.length;\\n    while(len) {\\n        currentQueue = queue;\\n        queue = [];\\n        while (++queueIndex < len) {\\n            if (currentQueue) {\\n                currentQueue[queueIndex].run();\\n            }\\n        }\\n        queueIndex = -1;\\n        len = queue.length;\\n    }\\n    currentQueue = null;\\n    draining = false;\\n    runClearTimeout(timeout);\\n}\\n\\nprocess.nextTick = function (fun) {\\n    var args = new Array(arguments.length - 1);\\n    if (arguments.length > 1) {\\n        for (var i = 1; i < arguments.length; i++) {\\n            args[i - 1] = arguments[i];\\n        }\\n    }\\n    queue.push(new Item(fun, args));\\n    if (queue.length === 1 && !draining) {\\n        runTimeout(drainQueue);\\n    }\\n};\\n\\n// v8 likes predictible objects\\nfunction Item(fun, array) {\\n    this.fun = fun;\\n    this.array = array;\\n}\\nItem.prototype.run = function () {\\n    this.fun.apply(null, this.array);\\n};\\nprocess.title = 'browser';\\nprocess.browser = true;\\nprocess.env = {};\\nprocess.argv = [];\\nprocess.version = ''; // empty string to avoid regexp issues\\nprocess.versions = {};\\n\\nfunction noop() {}\\n\\nprocess.on = noop;\\nprocess.addListener = noop;\\nprocess.once = noop;\\nprocess.off = noop;\\nprocess.removeListener = noop;\\nprocess.removeAllListeners = noop;\\nprocess.emit = noop;\\nprocess.prependListener = noop;\\nprocess.prependOnceListener = noop;\\n\\nprocess.listeners = function (name) { return [] }\\n\\nprocess.binding = function (name) {\\n    throw new Error('process.binding is not supported');\\n};\\n\\nprocess.cwd = function () { return '/' };\\nprocess.chdir = function (dir) {\\n    throw new Error('process.chdir is not supported');\\n};\\nprocess.umask = function() { return 0; };\\n\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/node-libs-browser/~/process/browser.js\\n// module id = 0\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/node-libs-browser/~/process/browser.js?\");\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\\n * jQuery JavaScript Library v3.3.1\\n * https://jquery.com/\\n *\\n * Includes Sizzle.js\\n * https://sizzlejs.com/\\n *\\n * Copyright JS Foundation and other contributors\\n * Released under the MIT license\\n * https://jquery.org/license\\n *\\n * Date: 2018-01-20T17:24Z\\n */\\n( function( global, factory ) {\\n\\n\\t\\\"use strict\\\";\\n\\n\\tif ( typeof module === \\\"object\\\" && typeof module.exports === \\\"object\\\" ) {\\n\\n\\t\\t// For CommonJS and CommonJS-like environments where a proper `window`\\n\\t\\t// is present, execute the factory and get jQuery.\\n\\t\\t// For environments that do not have a `window` with a `document`\\n\\t\\t// (such as Node.js), expose a factory as module.exports.\\n\\t\\t// This accentuates the need for the creation of a real `window`.\\n\\t\\t// e.g. var jQuery = require(\\\"jquery\\\")(window);\\n\\t\\t// See ticket #14549 for more info.\\n\\t\\tmodule.exports = global.document ?\\n\\t\\t\\tfactory( global, true ) :\\n\\t\\t\\tfunction( w ) {\\n\\t\\t\\t\\tif ( !w.document ) {\\n\\t\\t\\t\\t\\tthrow new Error( \\\"jQuery requires a window with a document\\\" );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn factory( w );\\n\\t\\t\\t};\\n\\t} else {\\n\\t\\tfactory( global );\\n\\t}\\n\\n// Pass this if window is not defined yet\\n} )( typeof window !== \\\"undefined\\\" ? window : this, function( window, noGlobal ) {\\n\\n// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\\n// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\\n// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\\n// enough that all such attempts are guarded in a try block.\\n\\\"use strict\\\";\\n\\nvar arr = [];\\n\\nvar document = window.document;\\n\\nvar getProto = Object.getPrototypeOf;\\n\\nvar slice = arr.slice;\\n\\nvar concat = arr.concat;\\n\\nvar push = arr.push;\\n\\nvar indexOf = arr.indexOf;\\n\\nvar class2type = {};\\n\\nvar toString = class2type.toString;\\n\\nvar hasOwn = class2type.hasOwnProperty;\\n\\nvar fnToString = hasOwn.toString;\\n\\nvar ObjectFunctionString = fnToString.call( Object );\\n\\nvar support = {};\\n\\nvar isFunction = function isFunction( obj ) {\\n\\n      // Support: Chrome <=57, Firefox <=52\\n      // In some browsers, typeof returns \\\"function\\\" for HTML <object> elements\\n      // (i.e., `typeof document.createElement( \\\"object\\\" ) === \\\"function\\\"`).\\n      // We don't want to classify *any* DOM node as a function.\\n      return typeof obj === \\\"function\\\" && typeof obj.nodeType !== \\\"number\\\";\\n  };\\n\\n\\nvar isWindow = function isWindow( obj ) {\\n\\t\\treturn obj != null && obj === obj.window;\\n\\t};\\n\\n\\n\\n\\n\\tvar preservedScriptAttributes = {\\n\\t\\ttype: true,\\n\\t\\tsrc: true,\\n\\t\\tnoModule: true\\n\\t};\\n\\n\\tfunction DOMEval( code, doc, node ) {\\n\\t\\tdoc = doc || document;\\n\\n\\t\\tvar i,\\n\\t\\t\\tscript = doc.createElement( \\\"script\\\" );\\n\\n\\t\\tscript.text = code;\\n\\t\\tif ( node ) {\\n\\t\\t\\tfor ( i in preservedScriptAttributes ) {\\n\\t\\t\\t\\tif ( node[ i ] ) {\\n\\t\\t\\t\\t\\tscript[ i ] = node[ i ];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdoc.head.appendChild( script ).parentNode.removeChild( script );\\n\\t}\\n\\n\\nfunction toType( obj ) {\\n\\tif ( obj == null ) {\\n\\t\\treturn obj + \\\"\\\";\\n\\t}\\n\\n\\t// Support: Android <=2.3 only (functionish RegExp)\\n\\treturn typeof obj === \\\"object\\\" || typeof obj === \\\"function\\\" ?\\n\\t\\tclass2type[ toString.call( obj ) ] || \\\"object\\\" :\\n\\t\\ttypeof obj;\\n}\\n/* global Symbol */\\n// Defining this global in .eslintrc.json would create a danger of using the global\\n// unguarded in another place, it seems safer to define global only for this module\\n\\n\\n\\nvar\\n\\tversion = \\\"3.3.1\\\",\\n\\n\\t// Define a local copy of jQuery\\n\\tjQuery = function( selector, context ) {\\n\\n\\t\\t// The jQuery object is actually just the init constructor 'enhanced'\\n\\t\\t// Need init if jQuery is called (just allow error to be thrown if not included)\\n\\t\\treturn new jQuery.fn.init( selector, context );\\n\\t},\\n\\n\\t// Support: Android <=4.0 only\\n\\t// Make sure we trim BOM and NBSP\\n\\trtrim = /^[\\\\s\\\\uFEFF\\\\xA0]+|[\\\\s\\\\uFEFF\\\\xA0]+$/g;\\n\\njQuery.fn = jQuery.prototype = {\\n\\n\\t// The current version of jQuery being used\\n\\tjquery: version,\\n\\n\\tconstructor: jQuery,\\n\\n\\t// The default length of a jQuery object is 0\\n\\tlength: 0,\\n\\n\\ttoArray: function() {\\n\\t\\treturn slice.call( this );\\n\\t},\\n\\n\\t// Get the Nth element in the matched element set OR\\n\\t// Get the whole matched element set as a clean array\\n\\tget: function( num ) {\\n\\n\\t\\t// Return all the elements in a clean array\\n\\t\\tif ( num == null ) {\\n\\t\\t\\treturn slice.call( this );\\n\\t\\t}\\n\\n\\t\\t// Return just the one element from the set\\n\\t\\treturn num < 0 ? this[ num + this.length ] : this[ num ];\\n\\t},\\n\\n\\t// Take an array of elements and push it onto the stack\\n\\t// (returning the new matched element set)\\n\\tpushStack: function( elems ) {\\n\\n\\t\\t// Build a new jQuery matched element set\\n\\t\\tvar ret = jQuery.merge( this.constructor(), elems );\\n\\n\\t\\t// Add the old object onto the stack (as a reference)\\n\\t\\tret.prevObject = this;\\n\\n\\t\\t// Return the newly-formed element set\\n\\t\\treturn ret;\\n\\t},\\n\\n\\t// Execute a callback for every element in the matched set.\\n\\teach: function( callback ) {\\n\\t\\treturn jQuery.each( this, callback );\\n\\t},\\n\\n\\tmap: function( callback ) {\\n\\t\\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\\n\\t\\t\\treturn callback.call( elem, i, elem );\\n\\t\\t} ) );\\n\\t},\\n\\n\\tslice: function() {\\n\\t\\treturn this.pushStack( slice.apply( this, arguments ) );\\n\\t},\\n\\n\\tfirst: function() {\\n\\t\\treturn this.eq( 0 );\\n\\t},\\n\\n\\tlast: function() {\\n\\t\\treturn this.eq( -1 );\\n\\t},\\n\\n\\teq: function( i ) {\\n\\t\\tvar len = this.length,\\n\\t\\t\\tj = +i + ( i < 0 ? len : 0 );\\n\\t\\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\\n\\t},\\n\\n\\tend: function() {\\n\\t\\treturn this.prevObject || this.constructor();\\n\\t},\\n\\n\\t// For internal use only.\\n\\t// Behaves like an Array's method, not like a jQuery method.\\n\\tpush: push,\\n\\tsort: arr.sort,\\n\\tsplice: arr.splice\\n};\\n\\njQuery.extend = jQuery.fn.extend = function() {\\n\\tvar options, name, src, copy, copyIsArray, clone,\\n\\t\\ttarget = arguments[ 0 ] || {},\\n\\t\\ti = 1,\\n\\t\\tlength = arguments.length,\\n\\t\\tdeep = false;\\n\\n\\t// Handle a deep copy situation\\n\\tif ( typeof target === \\\"boolean\\\" ) {\\n\\t\\tdeep = target;\\n\\n\\t\\t// Skip the boolean and the target\\n\\t\\ttarget = arguments[ i ] || {};\\n\\t\\ti++;\\n\\t}\\n\\n\\t// Handle case when target is a string or something (possible in deep copy)\\n\\tif ( typeof target !== \\\"object\\\" && !isFunction( target ) ) {\\n\\t\\ttarget = {};\\n\\t}\\n\\n\\t// Extend jQuery itself if only one argument is passed\\n\\tif ( i === length ) {\\n\\t\\ttarget = this;\\n\\t\\ti--;\\n\\t}\\n\\n\\tfor ( ; i < length; i++ ) {\\n\\n\\t\\t// Only deal with non-null/undefined values\\n\\t\\tif ( ( options = arguments[ i ] ) != null ) {\\n\\n\\t\\t\\t// Extend the base object\\n\\t\\t\\tfor ( name in options ) {\\n\\t\\t\\t\\tsrc = target[ name ];\\n\\t\\t\\t\\tcopy = options[ name ];\\n\\n\\t\\t\\t\\t// Prevent never-ending loop\\n\\t\\t\\t\\tif ( target === copy ) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Recurse if we're merging plain objects or arrays\\n\\t\\t\\t\\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\\n\\t\\t\\t\\t\\t( copyIsArray = Array.isArray( copy ) ) ) ) {\\n\\n\\t\\t\\t\\t\\tif ( copyIsArray ) {\\n\\t\\t\\t\\t\\t\\tcopyIsArray = false;\\n\\t\\t\\t\\t\\t\\tclone = src && Array.isArray( src ) ? src : [];\\n\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tclone = src && jQuery.isPlainObject( src ) ? src : {};\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Never move original objects, clone them\\n\\t\\t\\t\\t\\ttarget[ name ] = jQuery.extend( deep, clone, copy );\\n\\n\\t\\t\\t\\t// Don't bring in undefined values\\n\\t\\t\\t\\t} else if ( copy !== undefined ) {\\n\\t\\t\\t\\t\\ttarget[ name ] = copy;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Return the modified object\\n\\treturn target;\\n};\\n\\njQuery.extend( {\\n\\n\\t// Unique for each copy of jQuery on the page\\n\\texpando: \\\"jQuery\\\" + ( version + Math.random() ).replace( /\\\\D/g, \\\"\\\" ),\\n\\n\\t// Assume jQuery is ready without the ready module\\n\\tisReady: true,\\n\\n\\terror: function( msg ) {\\n\\t\\tthrow new Error( msg );\\n\\t},\\n\\n\\tnoop: function() {},\\n\\n\\tisPlainObject: function( obj ) {\\n\\t\\tvar proto, Ctor;\\n\\n\\t\\t// Detect obvious negatives\\n\\t\\t// Use toString instead of jQuery.type to catch host objects\\n\\t\\tif ( !obj || toString.call( obj ) !== \\\"[object Object]\\\" ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tproto = getProto( obj );\\n\\n\\t\\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\\n\\t\\tif ( !proto ) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\t// Objects with prototype are plain iff they were constructed by a global Object function\\n\\t\\tCtor = hasOwn.call( proto, \\\"constructor\\\" ) && proto.constructor;\\n\\t\\treturn typeof Ctor === \\\"function\\\" && fnToString.call( Ctor ) === ObjectFunctionString;\\n\\t},\\n\\n\\tisEmptyObject: function( obj ) {\\n\\n\\t\\t/* eslint-disable no-unused-vars */\\n\\t\\t// See https://github.com/eslint/eslint/issues/6125\\n\\t\\tvar name;\\n\\n\\t\\tfor ( name in obj ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t},\\n\\n\\t// Evaluates a script in a global context\\n\\tglobalEval: function( code ) {\\n\\t\\tDOMEval( code );\\n\\t},\\n\\n\\teach: function( obj, callback ) {\\n\\t\\tvar length, i = 0;\\n\\n\\t\\tif ( isArrayLike( obj ) ) {\\n\\t\\t\\tlength = obj.length;\\n\\t\\t\\tfor ( ; i < length; i++ ) {\\n\\t\\t\\t\\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tfor ( i in obj ) {\\n\\t\\t\\t\\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn obj;\\n\\t},\\n\\n\\t// Support: Android <=4.0 only\\n\\ttrim: function( text ) {\\n\\t\\treturn text == null ?\\n\\t\\t\\t\\\"\\\" :\\n\\t\\t\\t( text + \\\"\\\" ).replace( rtrim, \\\"\\\" );\\n\\t},\\n\\n\\t// results is for internal usage only\\n\\tmakeArray: function( arr, results ) {\\n\\t\\tvar ret = results || [];\\n\\n\\t\\tif ( arr != null ) {\\n\\t\\t\\tif ( isArrayLike( Object( arr ) ) ) {\\n\\t\\t\\t\\tjQuery.merge( ret,\\n\\t\\t\\t\\t\\ttypeof arr === \\\"string\\\" ?\\n\\t\\t\\t\\t\\t[ arr ] : arr\\n\\t\\t\\t\\t);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpush.call( ret, arr );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ret;\\n\\t},\\n\\n\\tinArray: function( elem, arr, i ) {\\n\\t\\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\\n\\t},\\n\\n\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t// push.apply(_, arraylike) throws on ancient WebKit\\n\\tmerge: function( first, second ) {\\n\\t\\tvar len = +second.length,\\n\\t\\t\\tj = 0,\\n\\t\\t\\ti = first.length;\\n\\n\\t\\tfor ( ; j < len; j++ ) {\\n\\t\\t\\tfirst[ i++ ] = second[ j ];\\n\\t\\t}\\n\\n\\t\\tfirst.length = i;\\n\\n\\t\\treturn first;\\n\\t},\\n\\n\\tgrep: function( elems, callback, invert ) {\\n\\t\\tvar callbackInverse,\\n\\t\\t\\tmatches = [],\\n\\t\\t\\ti = 0,\\n\\t\\t\\tlength = elems.length,\\n\\t\\t\\tcallbackExpect = !invert;\\n\\n\\t\\t// Go through the array, only saving the items\\n\\t\\t// that pass the validator function\\n\\t\\tfor ( ; i < length; i++ ) {\\n\\t\\t\\tcallbackInverse = !callback( elems[ i ], i );\\n\\t\\t\\tif ( callbackInverse !== callbackExpect ) {\\n\\t\\t\\t\\tmatches.push( elems[ i ] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn matches;\\n\\t},\\n\\n\\t// arg is for internal usage only\\n\\tmap: function( elems, callback, arg ) {\\n\\t\\tvar length, value,\\n\\t\\t\\ti = 0,\\n\\t\\t\\tret = [];\\n\\n\\t\\t// Go through the array, translating each of the items to their new values\\n\\t\\tif ( isArrayLike( elems ) ) {\\n\\t\\t\\tlength = elems.length;\\n\\t\\t\\tfor ( ; i < length; i++ ) {\\n\\t\\t\\t\\tvalue = callback( elems[ i ], i, arg );\\n\\n\\t\\t\\t\\tif ( value != null ) {\\n\\t\\t\\t\\t\\tret.push( value );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t// Go through every key on the object,\\n\\t\\t} else {\\n\\t\\t\\tfor ( i in elems ) {\\n\\t\\t\\t\\tvalue = callback( elems[ i ], i, arg );\\n\\n\\t\\t\\t\\tif ( value != null ) {\\n\\t\\t\\t\\t\\tret.push( value );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Flatten any nested arrays\\n\\t\\treturn concat.apply( [], ret );\\n\\t},\\n\\n\\t// A global GUID counter for objects\\n\\tguid: 1,\\n\\n\\t// jQuery.support is not used in Core but other projects attach their\\n\\t// properties to it so it needs to exist.\\n\\tsupport: support\\n} );\\n\\nif ( typeof Symbol === \\\"function\\\" ) {\\n\\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\\n}\\n\\n// Populate the class2type map\\njQuery.each( \\\"Boolean Number String Function Array Date RegExp Object Error Symbol\\\".split( \\\" \\\" ),\\nfunction( i, name ) {\\n\\tclass2type[ \\\"[object \\\" + name + \\\"]\\\" ] = name.toLowerCase();\\n} );\\n\\nfunction isArrayLike( obj ) {\\n\\n\\t// Support: real iOS 8.2 only (not reproducible in simulator)\\n\\t// `in` check used to prevent JIT error (gh-2145)\\n\\t// hasOwn isn't used here due to false negatives\\n\\t// regarding Nodelist length in IE\\n\\tvar length = !!obj && \\\"length\\\" in obj && obj.length,\\n\\t\\ttype = toType( obj );\\n\\n\\tif ( isFunction( obj ) || isWindow( obj ) ) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\treturn type === \\\"array\\\" || length === 0 ||\\n\\t\\ttypeof length === \\\"number\\\" && length > 0 && ( length - 1 ) in obj;\\n}\\nvar Sizzle =\\n/*!\\n * Sizzle CSS Selector Engine v2.3.3\\n * https://sizzlejs.com/\\n *\\n * Copyright jQuery Foundation and other contributors\\n * Released under the MIT license\\n * http://jquery.org/license\\n *\\n * Date: 2016-08-08\\n */\\n(function( window ) {\\n\\nvar i,\\n\\tsupport,\\n\\tExpr,\\n\\tgetText,\\n\\tisXML,\\n\\ttokenize,\\n\\tcompile,\\n\\tselect,\\n\\toutermostContext,\\n\\tsortInput,\\n\\thasDuplicate,\\n\\n\\t// Local document vars\\n\\tsetDocument,\\n\\tdocument,\\n\\tdocElem,\\n\\tdocumentIsHTML,\\n\\trbuggyQSA,\\n\\trbuggyMatches,\\n\\tmatches,\\n\\tcontains,\\n\\n\\t// Instance-specific data\\n\\texpando = \\\"sizzle\\\" + 1 * new Date(),\\n\\tpreferredDoc = window.document,\\n\\tdirruns = 0,\\n\\tdone = 0,\\n\\tclassCache = createCache(),\\n\\ttokenCache = createCache(),\\n\\tcompilerCache = createCache(),\\n\\tsortOrder = function( a, b ) {\\n\\t\\tif ( a === b ) {\\n\\t\\t\\thasDuplicate = true;\\n\\t\\t}\\n\\t\\treturn 0;\\n\\t},\\n\\n\\t// Instance methods\\n\\thasOwn = ({}).hasOwnProperty,\\n\\tarr = [],\\n\\tpop = arr.pop,\\n\\tpush_native = arr.push,\\n\\tpush = arr.push,\\n\\tslice = arr.slice,\\n\\t// Use a stripped-down indexOf as it's faster than native\\n\\t// https://jsperf.com/thor-indexof-vs-for/5\\n\\tindexOf = function( list, elem ) {\\n\\t\\tvar i = 0,\\n\\t\\t\\tlen = list.length;\\n\\t\\tfor ( ; i < len; i++ ) {\\n\\t\\t\\tif ( list[i] === elem ) {\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t},\\n\\n\\tbooleans = \\\"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\\\",\\n\\n\\t// Regular expressions\\n\\n\\t// http://www.w3.org/TR/css3-selectors/#whitespace\\n\\twhitespace = \\\"[\\\\\\\\x20\\\\\\\\t\\\\\\\\r\\\\\\\\n\\\\\\\\f]\\\",\\n\\n\\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\\n\\tidentifier = \\\"(?:\\\\\\\\\\\\\\\\.|[\\\\\\\\w-]|[^\\\\0-\\\\\\\\xa0])+\\\",\\n\\n\\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\\n\\tattributes = \\\"\\\\\\\\[\\\" + whitespace + \\\"*(\\\" + identifier + \\\")(?:\\\" + whitespace +\\n\\t\\t// Operator (capture 2)\\n\\t\\t\\\"*([*^$|!~]?=)\\\" + whitespace +\\n\\t\\t// \\\"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\\\"\\n\\t\\t\\\"*(?:'((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\'])*)'|\\\\\\\"((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\\\"])*)\\\\\\\"|(\\\" + identifier + \\\"))|)\\\" + whitespace +\\n\\t\\t\\\"*\\\\\\\\]\\\",\\n\\n\\tpseudos = \\\":(\\\" + identifier + \\\")(?:\\\\\\\\((\\\" +\\n\\t\\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\\n\\t\\t// 1. quoted (capture 3; capture 4 or capture 5)\\n\\t\\t\\\"('((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\'])*)'|\\\\\\\"((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\\\"])*)\\\\\\\")|\\\" +\\n\\t\\t// 2. simple (capture 6)\\n\\t\\t\\\"((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\()[\\\\\\\\]]|\\\" + attributes + \\\")*)|\\\" +\\n\\t\\t// 3. anything else (capture 2)\\n\\t\\t\\\".*\\\" +\\n\\t\\t\\\")\\\\\\\\)|)\\\",\\n\\n\\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\\n\\trwhitespace = new RegExp( whitespace + \\\"+\\\", \\\"g\\\" ),\\n\\trtrim = new RegExp( \\\"^\\\" + whitespace + \\\"+|((?:^|[^\\\\\\\\\\\\\\\\])(?:\\\\\\\\\\\\\\\\.)*)\\\" + whitespace + \\\"+$\\\", \\\"g\\\" ),\\n\\n\\trcomma = new RegExp( \\\"^\\\" + whitespace + \\\"*,\\\" + whitespace + \\\"*\\\" ),\\n\\trcombinators = new RegExp( \\\"^\\\" + whitespace + \\\"*([>+~]|\\\" + whitespace + \\\")\\\" + whitespace + \\\"*\\\" ),\\n\\n\\trattributeQuotes = new RegExp( \\\"=\\\" + whitespace + \\\"*([^\\\\\\\\]'\\\\\\\"]*?)\\\" + whitespace + \\\"*\\\\\\\\]\\\", \\\"g\\\" ),\\n\\n\\trpseudo = new RegExp( pseudos ),\\n\\tridentifier = new RegExp( \\\"^\\\" + identifier + \\\"$\\\" ),\\n\\n\\tmatchExpr = {\\n\\t\\t\\\"ID\\\": new RegExp( \\\"^#(\\\" + identifier + \\\")\\\" ),\\n\\t\\t\\\"CLASS\\\": new RegExp( \\\"^\\\\\\\\.(\\\" + identifier + \\\")\\\" ),\\n\\t\\t\\\"TAG\\\": new RegExp( \\\"^(\\\" + identifier + \\\"|[*])\\\" ),\\n\\t\\t\\\"ATTR\\\": new RegExp( \\\"^\\\" + attributes ),\\n\\t\\t\\\"PSEUDO\\\": new RegExp( \\\"^\\\" + pseudos ),\\n\\t\\t\\\"CHILD\\\": new RegExp( \\\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\\\\\(\\\" + whitespace +\\n\\t\\t\\t\\\"*(even|odd|(([+-]|)(\\\\\\\\d*)n|)\\\" + whitespace + \\\"*(?:([+-]|)\\\" + whitespace +\\n\\t\\t\\t\\\"*(\\\\\\\\d+)|))\\\" + whitespace + \\\"*\\\\\\\\)|)\\\", \\\"i\\\" ),\\n\\t\\t\\\"bool\\\": new RegExp( \\\"^(?:\\\" + booleans + \\\")$\\\", \\\"i\\\" ),\\n\\t\\t// For use in libraries implementing .is()\\n\\t\\t// We use this for POS matching in `select`\\n\\t\\t\\\"needsContext\\\": new RegExp( \\\"^\\\" + whitespace + \\\"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\\\\\(\\\" +\\n\\t\\t\\twhitespace + \\\"*((?:-\\\\\\\\d)?\\\\\\\\d*)\\\" + whitespace + \\\"*\\\\\\\\)|)(?=[^-]|$)\\\", \\\"i\\\" )\\n\\t},\\n\\n\\trinputs = /^(?:input|select|textarea|button)$/i,\\n\\trheader = /^h\\\\d$/i,\\n\\n\\trnative = /^[^{]+\\\\{\\\\s*\\\\[native \\\\w/,\\n\\n\\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\\n\\trquickExpr = /^(?:#([\\\\w-]+)|(\\\\w+)|\\\\.([\\\\w-]+))$/,\\n\\n\\trsibling = /[+~]/,\\n\\n\\t// CSS escapes\\n\\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\\n\\trunescape = new RegExp( \\\"\\\\\\\\\\\\\\\\([\\\\\\\\da-f]{1,6}\\\" + whitespace + \\\"?|(\\\" + whitespace + \\\")|.)\\\", \\\"ig\\\" ),\\n\\tfunescape = function( _, escaped, escapedWhitespace ) {\\n\\t\\tvar high = \\\"0x\\\" + escaped - 0x10000;\\n\\t\\t// NaN means non-codepoint\\n\\t\\t// Support: Firefox<24\\n\\t\\t// Workaround erroneous numeric interpretation of +\\\"0x\\\"\\n\\t\\treturn high !== high || escapedWhitespace ?\\n\\t\\t\\tescaped :\\n\\t\\t\\thigh < 0 ?\\n\\t\\t\\t\\t// BMP codepoint\\n\\t\\t\\t\\tString.fromCharCode( high + 0x10000 ) :\\n\\t\\t\\t\\t// Supplemental Plane codepoint (surrogate pair)\\n\\t\\t\\t\\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\\n\\t},\\n\\n\\t// CSS string/identifier serialization\\n\\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\\n\\trcssescape = /([\\\\0-\\\\x1f\\\\x7f]|^-?\\\\d)|^-$|[^\\\\0-\\\\x1f\\\\x7f-\\\\uFFFF\\\\w-]/g,\\n\\tfcssescape = function( ch, asCodePoint ) {\\n\\t\\tif ( asCodePoint ) {\\n\\n\\t\\t\\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\\n\\t\\t\\tif ( ch === \\\"\\\\0\\\" ) {\\n\\t\\t\\t\\treturn \\\"\\\\uFFFD\\\";\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Control characters and (dependent upon position) numbers get escaped as code points\\n\\t\\t\\treturn ch.slice( 0, -1 ) + \\\"\\\\\\\\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + \\\" \\\";\\n\\t\\t}\\n\\n\\t\\t// Other potentially-special ASCII characters get backslash-escaped\\n\\t\\treturn \\\"\\\\\\\\\\\" + ch;\\n\\t},\\n\\n\\t// Used for iframes\\n\\t// See setDocument()\\n\\t// Removing the function wrapper causes a \\\"Permission Denied\\\"\\n\\t// error in IE\\n\\tunloadHandler = function() {\\n\\t\\tsetDocument();\\n\\t},\\n\\n\\tdisabledAncestor = addCombinator(\\n\\t\\tfunction( elem ) {\\n\\t\\t\\treturn elem.disabled === true && (\\\"form\\\" in elem || \\\"label\\\" in elem);\\n\\t\\t},\\n\\t\\t{ dir: \\\"parentNode\\\", next: \\\"legend\\\" }\\n\\t);\\n\\n// Optimize for push.apply( _, NodeList )\\ntry {\\n\\tpush.apply(\\n\\t\\t(arr = slice.call( preferredDoc.childNodes )),\\n\\t\\tpreferredDoc.childNodes\\n\\t);\\n\\t// Support: Android<4.0\\n\\t// Detect silently failing push.apply\\n\\tarr[ preferredDoc.childNodes.length ].nodeType;\\n} catch ( e ) {\\n\\tpush = { apply: arr.length ?\\n\\n\\t\\t// Leverage slice if possible\\n\\t\\tfunction( target, els ) {\\n\\t\\t\\tpush_native.apply( target, slice.call(els) );\\n\\t\\t} :\\n\\n\\t\\t// Support: IE<9\\n\\t\\t// Otherwise append directly\\n\\t\\tfunction( target, els ) {\\n\\t\\t\\tvar j = target.length,\\n\\t\\t\\t\\ti = 0;\\n\\t\\t\\t// Can't trust NodeList.length\\n\\t\\t\\twhile ( (target[j++] = els[i++]) ) {}\\n\\t\\t\\ttarget.length = j - 1;\\n\\t\\t}\\n\\t};\\n}\\n\\nfunction Sizzle( selector, context, results, seed ) {\\n\\tvar m, i, elem, nid, match, groups, newSelector,\\n\\t\\tnewContext = context && context.ownerDocument,\\n\\n\\t\\t// nodeType defaults to 9, since context defaults to document\\n\\t\\tnodeType = context ? context.nodeType : 9;\\n\\n\\tresults = results || [];\\n\\n\\t// Return early from calls with invalid selector or context\\n\\tif ( typeof selector !== \\\"string\\\" || !selector ||\\n\\t\\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\\n\\n\\t\\treturn results;\\n\\t}\\n\\n\\t// Try to shortcut find operations (as opposed to filters) in HTML documents\\n\\tif ( !seed ) {\\n\\n\\t\\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\\n\\t\\t\\tsetDocument( context );\\n\\t\\t}\\n\\t\\tcontext = context || document;\\n\\n\\t\\tif ( documentIsHTML ) {\\n\\n\\t\\t\\t// If the selector is sufficiently simple, try using a \\\"get*By*\\\" DOM method\\n\\t\\t\\t// (excepting DocumentFragment context, where the methods don't exist)\\n\\t\\t\\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\\n\\n\\t\\t\\t\\t// ID selector\\n\\t\\t\\t\\tif ( (m = match[1]) ) {\\n\\n\\t\\t\\t\\t\\t// Document context\\n\\t\\t\\t\\t\\tif ( nodeType === 9 ) {\\n\\t\\t\\t\\t\\t\\tif ( (elem = context.getElementById( m )) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Support: IE, Opera, Webkit\\n\\t\\t\\t\\t\\t\\t\\t// TODO: identify versions\\n\\t\\t\\t\\t\\t\\t\\t// getElementById can match elements by name instead of ID\\n\\t\\t\\t\\t\\t\\t\\tif ( elem.id === m ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tresults.push( elem );\\n\\t\\t\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Element context\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t// Support: IE, Opera, Webkit\\n\\t\\t\\t\\t\\t\\t// TODO: identify versions\\n\\t\\t\\t\\t\\t\\t// getElementById can match elements by name instead of ID\\n\\t\\t\\t\\t\\t\\tif ( newContext && (elem = newContext.getElementById( m )) &&\\n\\t\\t\\t\\t\\t\\t\\tcontains( context, elem ) &&\\n\\t\\t\\t\\t\\t\\t\\telem.id === m ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tresults.push( elem );\\n\\t\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Type selector\\n\\t\\t\\t\\t} else if ( match[2] ) {\\n\\t\\t\\t\\t\\tpush.apply( results, context.getElementsByTagName( selector ) );\\n\\t\\t\\t\\t\\treturn results;\\n\\n\\t\\t\\t\\t// Class selector\\n\\t\\t\\t\\t} else if ( (m = match[3]) && support.getElementsByClassName &&\\n\\t\\t\\t\\t\\tcontext.getElementsByClassName ) {\\n\\n\\t\\t\\t\\t\\tpush.apply( results, context.getElementsByClassName( m ) );\\n\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Take advantage of querySelectorAll\\n\\t\\t\\tif ( support.qsa &&\\n\\t\\t\\t\\t!compilerCache[ selector + \\\" \\\" ] &&\\n\\t\\t\\t\\t(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\\n\\n\\t\\t\\t\\tif ( nodeType !== 1 ) {\\n\\t\\t\\t\\t\\tnewContext = context;\\n\\t\\t\\t\\t\\tnewSelector = selector;\\n\\n\\t\\t\\t\\t// qSA looks outside Element context, which is not what we want\\n\\t\\t\\t\\t// Thanks to Andrew Dupont for this workaround technique\\n\\t\\t\\t\\t// Support: IE <=8\\n\\t\\t\\t\\t// Exclude object elements\\n\\t\\t\\t\\t} else if ( context.nodeName.toLowerCase() !== \\\"object\\\" ) {\\n\\n\\t\\t\\t\\t\\t// Capture the context ID, setting it first if necessary\\n\\t\\t\\t\\t\\tif ( (nid = context.getAttribute( \\\"id\\\" )) ) {\\n\\t\\t\\t\\t\\t\\tnid = nid.replace( rcssescape, fcssescape );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tcontext.setAttribute( \\\"id\\\", (nid = expando) );\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Prefix every selector in the list\\n\\t\\t\\t\\t\\tgroups = tokenize( selector );\\n\\t\\t\\t\\t\\ti = groups.length;\\n\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\tgroups[i] = \\\"#\\\" + nid + \\\" \\\" + toSelector( groups[i] );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tnewSelector = groups.join( \\\",\\\" );\\n\\n\\t\\t\\t\\t\\t// Expand context for sibling selectors\\n\\t\\t\\t\\t\\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\\n\\t\\t\\t\\t\\t\\tcontext;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( newSelector ) {\\n\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\tpush.apply( results,\\n\\t\\t\\t\\t\\t\\t\\tnewContext.querySelectorAll( newSelector )\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t} catch ( qsaError ) {\\n\\t\\t\\t\\t\\t} finally {\\n\\t\\t\\t\\t\\t\\tif ( nid === expando ) {\\n\\t\\t\\t\\t\\t\\t\\tcontext.removeAttribute( \\\"id\\\" );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// All others\\n\\treturn select( selector.replace( rtrim, \\\"$1\\\" ), context, results, seed );\\n}\\n\\n/**\\n * Create key-value caches of limited size\\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\\n *\\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\\n *\\tdeleting the oldest entry\\n */\\nfunction createCache() {\\n\\tvar keys = [];\\n\\n\\tfunction cache( key, value ) {\\n\\t\\t// Use (key + \\\" \\\") to avoid collision with native prototype properties (see Issue #157)\\n\\t\\tif ( keys.push( key + \\\" \\\" ) > Expr.cacheLength ) {\\n\\t\\t\\t// Only keep the most recent entries\\n\\t\\t\\tdelete cache[ keys.shift() ];\\n\\t\\t}\\n\\t\\treturn (cache[ key + \\\" \\\" ] = value);\\n\\t}\\n\\treturn cache;\\n}\\n\\n/**\\n * Mark a function for special use by Sizzle\\n * @param {Function} fn The function to mark\\n */\\nfunction markFunction( fn ) {\\n\\tfn[ expando ] = true;\\n\\treturn fn;\\n}\\n\\n/**\\n * Support testing using an element\\n * @param {Function} fn Passed the created element and returns a boolean result\\n */\\nfunction assert( fn ) {\\n\\tvar el = document.createElement(\\\"fieldset\\\");\\n\\n\\ttry {\\n\\t\\treturn !!fn( el );\\n\\t} catch (e) {\\n\\t\\treturn false;\\n\\t} finally {\\n\\t\\t// Remove from its parent by default\\n\\t\\tif ( el.parentNode ) {\\n\\t\\t\\tel.parentNode.removeChild( el );\\n\\t\\t}\\n\\t\\t// release memory in IE\\n\\t\\tel = null;\\n\\t}\\n}\\n\\n/**\\n * Adds the same handler for all of the specified attrs\\n * @param {String} attrs Pipe-separated list of attributes\\n * @param {Function} handler The method that will be applied\\n */\\nfunction addHandle( attrs, handler ) {\\n\\tvar arr = attrs.split(\\\"|\\\"),\\n\\t\\ti = arr.length;\\n\\n\\twhile ( i-- ) {\\n\\t\\tExpr.attrHandle[ arr[i] ] = handler;\\n\\t}\\n}\\n\\n/**\\n * Checks document order of two siblings\\n * @param {Element} a\\n * @param {Element} b\\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\\n */\\nfunction siblingCheck( a, b ) {\\n\\tvar cur = b && a,\\n\\t\\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\\n\\t\\t\\ta.sourceIndex - b.sourceIndex;\\n\\n\\t// Use IE sourceIndex if available on both nodes\\n\\tif ( diff ) {\\n\\t\\treturn diff;\\n\\t}\\n\\n\\t// Check if b follows a\\n\\tif ( cur ) {\\n\\t\\twhile ( (cur = cur.nextSibling) ) {\\n\\t\\t\\tif ( cur === b ) {\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn a ? 1 : -1;\\n}\\n\\n/**\\n * Returns a function to use in pseudos for input types\\n * @param {String} type\\n */\\nfunction createInputPseudo( type ) {\\n\\treturn function( elem ) {\\n\\t\\tvar name = elem.nodeName.toLowerCase();\\n\\t\\treturn name === \\\"input\\\" && elem.type === type;\\n\\t};\\n}\\n\\n/**\\n * Returns a function to use in pseudos for buttons\\n * @param {String} type\\n */\\nfunction createButtonPseudo( type ) {\\n\\treturn function( elem ) {\\n\\t\\tvar name = elem.nodeName.toLowerCase();\\n\\t\\treturn (name === \\\"input\\\" || name === \\\"button\\\") && elem.type === type;\\n\\t};\\n}\\n\\n/**\\n * Returns a function to use in pseudos for :enabled/:disabled\\n * @param {Boolean} disabled true for :disabled; false for :enabled\\n */\\nfunction createDisabledPseudo( disabled ) {\\n\\n\\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\\n\\treturn function( elem ) {\\n\\n\\t\\t// Only certain elements can match :enabled or :disabled\\n\\t\\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\\n\\t\\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\\n\\t\\tif ( \\\"form\\\" in elem ) {\\n\\n\\t\\t\\t// Check for inherited disabledness on relevant non-disabled elements:\\n\\t\\t\\t// * listed form-associated elements in a disabled fieldset\\n\\t\\t\\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\\n\\t\\t\\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\\n\\t\\t\\t// * option elements in a disabled optgroup\\n\\t\\t\\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\\n\\t\\t\\t// All such elements have a \\\"form\\\" property.\\n\\t\\t\\tif ( elem.parentNode && elem.disabled === false ) {\\n\\n\\t\\t\\t\\t// Option elements defer to a parent optgroup if present\\n\\t\\t\\t\\tif ( \\\"label\\\" in elem ) {\\n\\t\\t\\t\\t\\tif ( \\\"label\\\" in elem.parentNode ) {\\n\\t\\t\\t\\t\\t\\treturn elem.parentNode.disabled === disabled;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\treturn elem.disabled === disabled;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Support: IE 6 - 11\\n\\t\\t\\t\\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\\n\\t\\t\\t\\treturn elem.isDisabled === disabled ||\\n\\n\\t\\t\\t\\t\\t// Where there is no isDisabled, check manually\\n\\t\\t\\t\\t\\t/* jshint -W018 */\\n\\t\\t\\t\\t\\telem.isDisabled !== !disabled &&\\n\\t\\t\\t\\t\\t\\tdisabledAncestor( elem ) === disabled;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn elem.disabled === disabled;\\n\\n\\t\\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\\n\\t\\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\\n\\t\\t// even exist on them, let alone have a boolean value.\\n\\t\\t} else if ( \\\"label\\\" in elem ) {\\n\\t\\t\\treturn elem.disabled === disabled;\\n\\t\\t}\\n\\n\\t\\t// Remaining elements are neither :enabled nor :disabled\\n\\t\\treturn false;\\n\\t};\\n}\\n\\n/**\\n * Returns a function to use in pseudos for positionals\\n * @param {Function} fn\\n */\\nfunction createPositionalPseudo( fn ) {\\n\\treturn markFunction(function( argument ) {\\n\\t\\targument = +argument;\\n\\t\\treturn markFunction(function( seed, matches ) {\\n\\t\\t\\tvar j,\\n\\t\\t\\t\\tmatchIndexes = fn( [], seed.length, argument ),\\n\\t\\t\\t\\ti = matchIndexes.length;\\n\\n\\t\\t\\t// Match elements found at the specified indexes\\n\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\tif ( seed[ (j = matchIndexes[i]) ] ) {\\n\\t\\t\\t\\t\\tseed[j] = !(matches[j] = seed[j]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\t});\\n}\\n\\n/**\\n * Checks a node for validity as a Sizzle context\\n * @param {Element|Object=} context\\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\\n */\\nfunction testContext( context ) {\\n\\treturn context && typeof context.getElementsByTagName !== \\\"undefined\\\" && context;\\n}\\n\\n// Expose support vars for convenience\\nsupport = Sizzle.support = {};\\n\\n/**\\n * Detects XML nodes\\n * @param {Element|Object} elem An element or a document\\n * @returns {Boolean} True iff elem is a non-HTML XML node\\n */\\nisXML = Sizzle.isXML = function( elem ) {\\n\\t// documentElement is verified for cases where it doesn't yet exist\\n\\t// (such as loading iframes in IE - #4833)\\n\\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\\n\\treturn documentElement ? documentElement.nodeName !== \\\"HTML\\\" : false;\\n};\\n\\n/**\\n * Sets document-related variables once based on the current document\\n * @param {Element|Object} [doc] An element or document object to use to set the document\\n * @returns {Object} Returns the current document\\n */\\nsetDocument = Sizzle.setDocument = function( node ) {\\n\\tvar hasCompare, subWindow,\\n\\t\\tdoc = node ? node.ownerDocument || node : preferredDoc;\\n\\n\\t// Return early if doc is invalid or already selected\\n\\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\\n\\t\\treturn document;\\n\\t}\\n\\n\\t// Update global variables\\n\\tdocument = doc;\\n\\tdocElem = document.documentElement;\\n\\tdocumentIsHTML = !isXML( document );\\n\\n\\t// Support: IE 9-11, Edge\\n\\t// Accessing iframe documents after unload throws \\\"permission denied\\\" errors (jQuery #13936)\\n\\tif ( preferredDoc !== document &&\\n\\t\\t(subWindow = document.defaultView) && subWindow.top !== subWindow ) {\\n\\n\\t\\t// Support: IE 11, Edge\\n\\t\\tif ( subWindow.addEventListener ) {\\n\\t\\t\\tsubWindow.addEventListener( \\\"unload\\\", unloadHandler, false );\\n\\n\\t\\t// Support: IE 9 - 10 only\\n\\t\\t} else if ( subWindow.attachEvent ) {\\n\\t\\t\\tsubWindow.attachEvent( \\\"onunload\\\", unloadHandler );\\n\\t\\t}\\n\\t}\\n\\n\\t/* Attributes\\n\\t---------------------------------------------------------------------- */\\n\\n\\t// Support: IE<8\\n\\t// Verify that getAttribute really returns attributes and not properties\\n\\t// (excepting IE8 booleans)\\n\\tsupport.attributes = assert(function( el ) {\\n\\t\\tel.className = \\\"i\\\";\\n\\t\\treturn !el.getAttribute(\\\"className\\\");\\n\\t});\\n\\n\\t/* getElement(s)By*\\n\\t---------------------------------------------------------------------- */\\n\\n\\t// Check if getElementsByTagName(\\\"*\\\") returns only elements\\n\\tsupport.getElementsByTagName = assert(function( el ) {\\n\\t\\tel.appendChild( document.createComment(\\\"\\\") );\\n\\t\\treturn !el.getElementsByTagName(\\\"*\\\").length;\\n\\t});\\n\\n\\t// Support: IE<9\\n\\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\\n\\n\\t// Support: IE<10\\n\\t// Check if getElementById returns elements by name\\n\\t// The broken getElementById methods don't pick up programmatically-set names,\\n\\t// so use a roundabout getElementsByName test\\n\\tsupport.getById = assert(function( el ) {\\n\\t\\tdocElem.appendChild( el ).id = expando;\\n\\t\\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\\n\\t});\\n\\n\\t// ID filter and find\\n\\tif ( support.getById ) {\\n\\t\\tExpr.filter[\\\"ID\\\"] = function( id ) {\\n\\t\\t\\tvar attrId = id.replace( runescape, funescape );\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\treturn elem.getAttribute(\\\"id\\\") === attrId;\\n\\t\\t\\t};\\n\\t\\t};\\n\\t\\tExpr.find[\\\"ID\\\"] = function( id, context ) {\\n\\t\\t\\tif ( typeof context.getElementById !== \\\"undefined\\\" && documentIsHTML ) {\\n\\t\\t\\t\\tvar elem = context.getElementById( id );\\n\\t\\t\\t\\treturn elem ? [ elem ] : [];\\n\\t\\t\\t}\\n\\t\\t};\\n\\t} else {\\n\\t\\tExpr.filter[\\\"ID\\\"] =  function( id ) {\\n\\t\\t\\tvar attrId = id.replace( runescape, funescape );\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\tvar node = typeof elem.getAttributeNode !== \\\"undefined\\\" &&\\n\\t\\t\\t\\t\\telem.getAttributeNode(\\\"id\\\");\\n\\t\\t\\t\\treturn node && node.value === attrId;\\n\\t\\t\\t};\\n\\t\\t};\\n\\n\\t\\t// Support: IE 6 - 7 only\\n\\t\\t// getElementById is not reliable as a find shortcut\\n\\t\\tExpr.find[\\\"ID\\\"] = function( id, context ) {\\n\\t\\t\\tif ( typeof context.getElementById !== \\\"undefined\\\" && documentIsHTML ) {\\n\\t\\t\\t\\tvar node, i, elems,\\n\\t\\t\\t\\t\\telem = context.getElementById( id );\\n\\n\\t\\t\\t\\tif ( elem ) {\\n\\n\\t\\t\\t\\t\\t// Verify the id attribute\\n\\t\\t\\t\\t\\tnode = elem.getAttributeNode(\\\"id\\\");\\n\\t\\t\\t\\t\\tif ( node && node.value === id ) {\\n\\t\\t\\t\\t\\t\\treturn [ elem ];\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Fall back on getElementsByName\\n\\t\\t\\t\\t\\telems = context.getElementsByName( id );\\n\\t\\t\\t\\t\\ti = 0;\\n\\t\\t\\t\\t\\twhile ( (elem = elems[i++]) ) {\\n\\t\\t\\t\\t\\t\\tnode = elem.getAttributeNode(\\\"id\\\");\\n\\t\\t\\t\\t\\t\\tif ( node && node.value === id ) {\\n\\t\\t\\t\\t\\t\\t\\treturn [ elem ];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn [];\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n\\n\\t// Tag\\n\\tExpr.find[\\\"TAG\\\"] = support.getElementsByTagName ?\\n\\t\\tfunction( tag, context ) {\\n\\t\\t\\tif ( typeof context.getElementsByTagName !== \\\"undefined\\\" ) {\\n\\t\\t\\t\\treturn context.getElementsByTagName( tag );\\n\\n\\t\\t\\t// DocumentFragment nodes don't have gEBTN\\n\\t\\t\\t} else if ( support.qsa ) {\\n\\t\\t\\t\\treturn context.querySelectorAll( tag );\\n\\t\\t\\t}\\n\\t\\t} :\\n\\n\\t\\tfunction( tag, context ) {\\n\\t\\t\\tvar elem,\\n\\t\\t\\t\\ttmp = [],\\n\\t\\t\\t\\ti = 0,\\n\\t\\t\\t\\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\\n\\t\\t\\t\\tresults = context.getElementsByTagName( tag );\\n\\n\\t\\t\\t// Filter out possible comments\\n\\t\\t\\tif ( tag === \\\"*\\\" ) {\\n\\t\\t\\t\\twhile ( (elem = results[i++]) ) {\\n\\t\\t\\t\\t\\tif ( elem.nodeType === 1 ) {\\n\\t\\t\\t\\t\\t\\ttmp.push( elem );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn tmp;\\n\\t\\t\\t}\\n\\t\\t\\treturn results;\\n\\t\\t};\\n\\n\\t// Class\\n\\tExpr.find[\\\"CLASS\\\"] = support.getElementsByClassName && function( className, context ) {\\n\\t\\tif ( typeof context.getElementsByClassName !== \\\"undefined\\\" && documentIsHTML ) {\\n\\t\\t\\treturn context.getElementsByClassName( className );\\n\\t\\t}\\n\\t};\\n\\n\\t/* QSA/matchesSelector\\n\\t---------------------------------------------------------------------- */\\n\\n\\t// QSA and matchesSelector support\\n\\n\\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\\n\\trbuggyMatches = [];\\n\\n\\t// qSa(:focus) reports false when true (Chrome 21)\\n\\t// We allow this because of a bug in IE8/9 that throws an error\\n\\t// whenever `document.activeElement` is accessed on an iframe\\n\\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\\n\\t// See https://bugs.jquery.com/ticket/13378\\n\\trbuggyQSA = [];\\n\\n\\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\\n\\t\\t// Build QSA regex\\n\\t\\t// Regex strategy adopted from Diego Perini\\n\\t\\tassert(function( el ) {\\n\\t\\t\\t// Select is set to empty string on purpose\\n\\t\\t\\t// This is to test IE's treatment of not explicitly\\n\\t\\t\\t// setting a boolean content attribute,\\n\\t\\t\\t// since its presence should be enough\\n\\t\\t\\t// https://bugs.jquery.com/ticket/12359\\n\\t\\t\\tdocElem.appendChild( el ).innerHTML = \\\"<a id='\\\" + expando + \\\"'></a>\\\" +\\n\\t\\t\\t\\t\\\"<select id='\\\" + expando + \\\"-\\\\r\\\\\\\\' msallowcapture=''>\\\" +\\n\\t\\t\\t\\t\\\"<option selected=''></option></select>\\\";\\n\\n\\t\\t\\t// Support: IE8, Opera 11-12.16\\n\\t\\t\\t// Nothing should be selected when empty strings follow ^= or $= or *=\\n\\t\\t\\t// The test attribute must be unknown in Opera but \\\"safe\\\" for WinRT\\n\\t\\t\\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\\n\\t\\t\\tif ( el.querySelectorAll(\\\"[msallowcapture^='']\\\").length ) {\\n\\t\\t\\t\\trbuggyQSA.push( \\\"[*^$]=\\\" + whitespace + \\\"*(?:''|\\\\\\\"\\\\\\\")\\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Support: IE8\\n\\t\\t\\t// Boolean attributes and \\\"value\\\" are not treated correctly\\n\\t\\t\\tif ( !el.querySelectorAll(\\\"[selected]\\\").length ) {\\n\\t\\t\\t\\trbuggyQSA.push( \\\"\\\\\\\\[\\\" + whitespace + \\\"*(?:value|\\\" + booleans + \\\")\\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\\n\\t\\t\\tif ( !el.querySelectorAll( \\\"[id~=\\\" + expando + \\\"-]\\\" ).length ) {\\n\\t\\t\\t\\trbuggyQSA.push(\\\"~=\\\");\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Webkit/Opera - :checked should return selected option elements\\n\\t\\t\\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\\n\\t\\t\\t// IE8 throws error here and will not see later tests\\n\\t\\t\\tif ( !el.querySelectorAll(\\\":checked\\\").length ) {\\n\\t\\t\\t\\trbuggyQSA.push(\\\":checked\\\");\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Support: Safari 8+, iOS 8+\\n\\t\\t\\t// https://bugs.webkit.org/show_bug.cgi?id=136851\\n\\t\\t\\t// In-page `selector#id sibling-combinator selector` fails\\n\\t\\t\\tif ( !el.querySelectorAll( \\\"a#\\\" + expando + \\\"+*\\\" ).length ) {\\n\\t\\t\\t\\trbuggyQSA.push(\\\".#.+[+~]\\\");\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tassert(function( el ) {\\n\\t\\t\\tel.innerHTML = \\\"<a href='' disabled='disabled'></a>\\\" +\\n\\t\\t\\t\\t\\\"<select disabled='disabled'><option/></select>\\\";\\n\\n\\t\\t\\t// Support: Windows 8 Native Apps\\n\\t\\t\\t// The type and name attributes are restricted during .innerHTML assignment\\n\\t\\t\\tvar input = document.createElement(\\\"input\\\");\\n\\t\\t\\tinput.setAttribute( \\\"type\\\", \\\"hidden\\\" );\\n\\t\\t\\tel.appendChild( input ).setAttribute( \\\"name\\\", \\\"D\\\" );\\n\\n\\t\\t\\t// Support: IE8\\n\\t\\t\\t// Enforce case-sensitivity of name attribute\\n\\t\\t\\tif ( el.querySelectorAll(\\\"[name=d]\\\").length ) {\\n\\t\\t\\t\\trbuggyQSA.push( \\\"name\\\" + whitespace + \\\"*[*^$|!~]?=\\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\\n\\t\\t\\t// IE8 throws error here and will not see later tests\\n\\t\\t\\tif ( el.querySelectorAll(\\\":enabled\\\").length !== 2 ) {\\n\\t\\t\\t\\trbuggyQSA.push( \\\":enabled\\\", \\\":disabled\\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Support: IE9-11+\\n\\t\\t\\t// IE's :disabled selector does not pick up the children of disabled fieldsets\\n\\t\\t\\tdocElem.appendChild( el ).disabled = true;\\n\\t\\t\\tif ( el.querySelectorAll(\\\":disabled\\\").length !== 2 ) {\\n\\t\\t\\t\\trbuggyQSA.push( \\\":enabled\\\", \\\":disabled\\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Opera 10-11 does not throw on post-comma invalid pseudos\\n\\t\\t\\tel.querySelectorAll(\\\"*,:x\\\");\\n\\t\\t\\trbuggyQSA.push(\\\",.*:\\\");\\n\\t\\t});\\n\\t}\\n\\n\\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\\n\\t\\tdocElem.webkitMatchesSelector ||\\n\\t\\tdocElem.mozMatchesSelector ||\\n\\t\\tdocElem.oMatchesSelector ||\\n\\t\\tdocElem.msMatchesSelector) )) ) {\\n\\n\\t\\tassert(function( el ) {\\n\\t\\t\\t// Check to see if it's possible to do matchesSelector\\n\\t\\t\\t// on a disconnected node (IE 9)\\n\\t\\t\\tsupport.disconnectedMatch = matches.call( el, \\\"*\\\" );\\n\\n\\t\\t\\t// This should fail with an exception\\n\\t\\t\\t// Gecko does not error, returns false instead\\n\\t\\t\\tmatches.call( el, \\\"[s!='']:x\\\" );\\n\\t\\t\\trbuggyMatches.push( \\\"!=\\\", pseudos );\\n\\t\\t});\\n\\t}\\n\\n\\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\\\"|\\\") );\\n\\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\\\"|\\\") );\\n\\n\\t/* Contains\\n\\t---------------------------------------------------------------------- */\\n\\thasCompare = rnative.test( docElem.compareDocumentPosition );\\n\\n\\t// Element contains another\\n\\t// Purposefully self-exclusive\\n\\t// As in, an element does not contain itself\\n\\tcontains = hasCompare || rnative.test( docElem.contains ) ?\\n\\t\\tfunction( a, b ) {\\n\\t\\t\\tvar adown = a.nodeType === 9 ? a.documentElement : a,\\n\\t\\t\\t\\tbup = b && b.parentNode;\\n\\t\\t\\treturn a === bup || !!( bup && bup.nodeType === 1 && (\\n\\t\\t\\t\\tadown.contains ?\\n\\t\\t\\t\\t\\tadown.contains( bup ) :\\n\\t\\t\\t\\t\\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\\n\\t\\t\\t));\\n\\t\\t} :\\n\\t\\tfunction( a, b ) {\\n\\t\\t\\tif ( b ) {\\n\\t\\t\\t\\twhile ( (b = b.parentNode) ) {\\n\\t\\t\\t\\t\\tif ( b === a ) {\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t};\\n\\n\\t/* Sorting\\n\\t---------------------------------------------------------------------- */\\n\\n\\t// Document order sorting\\n\\tsortOrder = hasCompare ?\\n\\tfunction( a, b ) {\\n\\n\\t\\t// Flag for duplicate removal\\n\\t\\tif ( a === b ) {\\n\\t\\t\\thasDuplicate = true;\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\t// Sort on method existence if only one input has compareDocumentPosition\\n\\t\\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\\n\\t\\tif ( compare ) {\\n\\t\\t\\treturn compare;\\n\\t\\t}\\n\\n\\t\\t// Calculate position if both inputs belong to the same document\\n\\t\\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\\n\\t\\t\\ta.compareDocumentPosition( b ) :\\n\\n\\t\\t\\t// Otherwise we know they are disconnected\\n\\t\\t\\t1;\\n\\n\\t\\t// Disconnected nodes\\n\\t\\tif ( compare & 1 ||\\n\\t\\t\\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\\n\\n\\t\\t\\t// Choose the first element that is related to our preferred document\\n\\t\\t\\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t\\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Maintain original order\\n\\t\\t\\treturn sortInput ?\\n\\t\\t\\t\\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\\n\\t\\t\\t\\t0;\\n\\t\\t}\\n\\n\\t\\treturn compare & 4 ? -1 : 1;\\n\\t} :\\n\\tfunction( a, b ) {\\n\\t\\t// Exit early if the nodes are identical\\n\\t\\tif ( a === b ) {\\n\\t\\t\\thasDuplicate = true;\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tvar cur,\\n\\t\\t\\ti = 0,\\n\\t\\t\\taup = a.parentNode,\\n\\t\\t\\tbup = b.parentNode,\\n\\t\\t\\tap = [ a ],\\n\\t\\t\\tbp = [ b ];\\n\\n\\t\\t// Parentless nodes are either documents or disconnected\\n\\t\\tif ( !aup || !bup ) {\\n\\t\\t\\treturn a === document ? -1 :\\n\\t\\t\\t\\tb === document ? 1 :\\n\\t\\t\\t\\taup ? -1 :\\n\\t\\t\\t\\tbup ? 1 :\\n\\t\\t\\t\\tsortInput ?\\n\\t\\t\\t\\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\\n\\t\\t\\t\\t0;\\n\\n\\t\\t// If the nodes are siblings, we can do a quick check\\n\\t\\t} else if ( aup === bup ) {\\n\\t\\t\\treturn siblingCheck( a, b );\\n\\t\\t}\\n\\n\\t\\t// Otherwise we need full lists of their ancestors for comparison\\n\\t\\tcur = a;\\n\\t\\twhile ( (cur = cur.parentNode) ) {\\n\\t\\t\\tap.unshift( cur );\\n\\t\\t}\\n\\t\\tcur = b;\\n\\t\\twhile ( (cur = cur.parentNode) ) {\\n\\t\\t\\tbp.unshift( cur );\\n\\t\\t}\\n\\n\\t\\t// Walk down the tree looking for a discrepancy\\n\\t\\twhile ( ap[i] === bp[i] ) {\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n\\t\\treturn i ?\\n\\t\\t\\t// Do a sibling check if the nodes have a common ancestor\\n\\t\\t\\tsiblingCheck( ap[i], bp[i] ) :\\n\\n\\t\\t\\t// Otherwise nodes in our document sort first\\n\\t\\t\\tap[i] === preferredDoc ? -1 :\\n\\t\\t\\tbp[i] === preferredDoc ? 1 :\\n\\t\\t\\t0;\\n\\t};\\n\\n\\treturn document;\\n};\\n\\nSizzle.matches = function( expr, elements ) {\\n\\treturn Sizzle( expr, null, null, elements );\\n};\\n\\nSizzle.matchesSelector = function( elem, expr ) {\\n\\t// Set document vars if needed\\n\\tif ( ( elem.ownerDocument || elem ) !== document ) {\\n\\t\\tsetDocument( elem );\\n\\t}\\n\\n\\t// Make sure that attribute selectors are quoted\\n\\texpr = expr.replace( rattributeQuotes, \\\"='$1']\\\" );\\n\\n\\tif ( support.matchesSelector && documentIsHTML &&\\n\\t\\t!compilerCache[ expr + \\\" \\\" ] &&\\n\\t\\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\\n\\t\\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\\n\\n\\t\\ttry {\\n\\t\\t\\tvar ret = matches.call( elem, expr );\\n\\n\\t\\t\\t// IE 9's matchesSelector returns false on disconnected nodes\\n\\t\\t\\tif ( ret || support.disconnectedMatch ||\\n\\t\\t\\t\\t\\t// As well, disconnected nodes are said to be in a document\\n\\t\\t\\t\\t\\t// fragment in IE 9\\n\\t\\t\\t\\t\\telem.document && elem.document.nodeType !== 11 ) {\\n\\t\\t\\t\\treturn ret;\\n\\t\\t\\t}\\n\\t\\t} catch (e) {}\\n\\t}\\n\\n\\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\\n};\\n\\nSizzle.contains = function( context, elem ) {\\n\\t// Set document vars if needed\\n\\tif ( ( context.ownerDocument || context ) !== document ) {\\n\\t\\tsetDocument( context );\\n\\t}\\n\\treturn contains( context, elem );\\n};\\n\\nSizzle.attr = function( elem, name ) {\\n\\t// Set document vars if needed\\n\\tif ( ( elem.ownerDocument || elem ) !== document ) {\\n\\t\\tsetDocument( elem );\\n\\t}\\n\\n\\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\\n\\t\\t// Don't get fooled by Object.prototype properties (jQuery #13807)\\n\\t\\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\\n\\t\\t\\tfn( elem, name, !documentIsHTML ) :\\n\\t\\t\\tundefined;\\n\\n\\treturn val !== undefined ?\\n\\t\\tval :\\n\\t\\tsupport.attributes || !documentIsHTML ?\\n\\t\\t\\telem.getAttribute( name ) :\\n\\t\\t\\t(val = elem.getAttributeNode(name)) && val.specified ?\\n\\t\\t\\t\\tval.value :\\n\\t\\t\\t\\tnull;\\n};\\n\\nSizzle.escape = function( sel ) {\\n\\treturn (sel + \\\"\\\").replace( rcssescape, fcssescape );\\n};\\n\\nSizzle.error = function( msg ) {\\n\\tthrow new Error( \\\"Syntax error, unrecognized expression: \\\" + msg );\\n};\\n\\n/**\\n * Document sorting and removing duplicates\\n * @param {ArrayLike} results\\n */\\nSizzle.uniqueSort = function( results ) {\\n\\tvar elem,\\n\\t\\tduplicates = [],\\n\\t\\tj = 0,\\n\\t\\ti = 0;\\n\\n\\t// Unless we *know* we can detect duplicates, assume their presence\\n\\thasDuplicate = !support.detectDuplicates;\\n\\tsortInput = !support.sortStable && results.slice( 0 );\\n\\tresults.sort( sortOrder );\\n\\n\\tif ( hasDuplicate ) {\\n\\t\\twhile ( (elem = results[i++]) ) {\\n\\t\\t\\tif ( elem === results[ i ] ) {\\n\\t\\t\\t\\tj = duplicates.push( i );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile ( j-- ) {\\n\\t\\t\\tresults.splice( duplicates[ j ], 1 );\\n\\t\\t}\\n\\t}\\n\\n\\t// Clear input after sorting to release objects\\n\\t// See https://github.com/jquery/sizzle/pull/225\\n\\tsortInput = null;\\n\\n\\treturn results;\\n};\\n\\n/**\\n * Utility function for retrieving the text value of an array of DOM nodes\\n * @param {Array|Element} elem\\n */\\ngetText = Sizzle.getText = function( elem ) {\\n\\tvar node,\\n\\t\\tret = \\\"\\\",\\n\\t\\ti = 0,\\n\\t\\tnodeType = elem.nodeType;\\n\\n\\tif ( !nodeType ) {\\n\\t\\t// If no nodeType, this is expected to be an array\\n\\t\\twhile ( (node = elem[i++]) ) {\\n\\t\\t\\t// Do not traverse comment nodes\\n\\t\\t\\tret += getText( node );\\n\\t\\t}\\n\\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\\n\\t\\t// Use textContent for elements\\n\\t\\t// innerText usage removed for consistency of new lines (jQuery #11153)\\n\\t\\tif ( typeof elem.textContent === \\\"string\\\" ) {\\n\\t\\t\\treturn elem.textContent;\\n\\t\\t} else {\\n\\t\\t\\t// Traverse its children\\n\\t\\t\\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\\n\\t\\t\\t\\tret += getText( elem );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} else if ( nodeType === 3 || nodeType === 4 ) {\\n\\t\\treturn elem.nodeValue;\\n\\t}\\n\\t// Do not include comment or processing instruction nodes\\n\\n\\treturn ret;\\n};\\n\\nExpr = Sizzle.selectors = {\\n\\n\\t// Can be adjusted by the user\\n\\tcacheLength: 50,\\n\\n\\tcreatePseudo: markFunction,\\n\\n\\tmatch: matchExpr,\\n\\n\\tattrHandle: {},\\n\\n\\tfind: {},\\n\\n\\trelative: {\\n\\t\\t\\\">\\\": { dir: \\\"parentNode\\\", first: true },\\n\\t\\t\\\" \\\": { dir: \\\"parentNode\\\" },\\n\\t\\t\\\"+\\\": { dir: \\\"previousSibling\\\", first: true },\\n\\t\\t\\\"~\\\": { dir: \\\"previousSibling\\\" }\\n\\t},\\n\\n\\tpreFilter: {\\n\\t\\t\\\"ATTR\\\": function( match ) {\\n\\t\\t\\tmatch[1] = match[1].replace( runescape, funescape );\\n\\n\\t\\t\\t// Move the given value to match[3] whether quoted or unquoted\\n\\t\\t\\tmatch[3] = ( match[3] || match[4] || match[5] || \\\"\\\" ).replace( runescape, funescape );\\n\\n\\t\\t\\tif ( match[2] === \\\"~=\\\" ) {\\n\\t\\t\\t\\tmatch[3] = \\\" \\\" + match[3] + \\\" \\\";\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn match.slice( 0, 4 );\\n\\t\\t},\\n\\n\\t\\t\\\"CHILD\\\": function( match ) {\\n\\t\\t\\t/* matches from matchExpr[\\\"CHILD\\\"]\\n\\t\\t\\t\\t1 type (only|nth|...)\\n\\t\\t\\t\\t2 what (child|of-type)\\n\\t\\t\\t\\t3 argument (even|odd|\\\\d*|\\\\d*n([+-]\\\\d+)?|...)\\n\\t\\t\\t\\t4 xn-component of xn+y argument ([+-]?\\\\d*n|)\\n\\t\\t\\t\\t5 sign of xn-component\\n\\t\\t\\t\\t6 x of xn-component\\n\\t\\t\\t\\t7 sign of y-component\\n\\t\\t\\t\\t8 y of y-component\\n\\t\\t\\t*/\\n\\t\\t\\tmatch[1] = match[1].toLowerCase();\\n\\n\\t\\t\\tif ( match[1].slice( 0, 3 ) === \\\"nth\\\" ) {\\n\\t\\t\\t\\t// nth-* requires argument\\n\\t\\t\\t\\tif ( !match[3] ) {\\n\\t\\t\\t\\t\\tSizzle.error( match[0] );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// numeric x and y parameters for Expr.filter.CHILD\\n\\t\\t\\t\\t// remember that false/true cast respectively to 0/1\\n\\t\\t\\t\\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \\\"even\\\" || match[3] === \\\"odd\\\" ) );\\n\\t\\t\\t\\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \\\"odd\\\" );\\n\\n\\t\\t\\t// other types prohibit arguments\\n\\t\\t\\t} else if ( match[3] ) {\\n\\t\\t\\t\\tSizzle.error( match[0] );\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn match;\\n\\t\\t},\\n\\n\\t\\t\\\"PSEUDO\\\": function( match ) {\\n\\t\\t\\tvar excess,\\n\\t\\t\\t\\tunquoted = !match[6] && match[2];\\n\\n\\t\\t\\tif ( matchExpr[\\\"CHILD\\\"].test( match[0] ) ) {\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Accept quoted arguments as-is\\n\\t\\t\\tif ( match[3] ) {\\n\\t\\t\\t\\tmatch[2] = match[4] || match[5] || \\\"\\\";\\n\\n\\t\\t\\t// Strip excess characters from unquoted arguments\\n\\t\\t\\t} else if ( unquoted && rpseudo.test( unquoted ) &&\\n\\t\\t\\t\\t// Get excess from tokenize (recursively)\\n\\t\\t\\t\\t(excess = tokenize( unquoted, true )) &&\\n\\t\\t\\t\\t// advance to the next closing parenthesis\\n\\t\\t\\t\\t(excess = unquoted.indexOf( \\\")\\\", unquoted.length - excess ) - unquoted.length) ) {\\n\\n\\t\\t\\t\\t// excess is a negative index\\n\\t\\t\\t\\tmatch[0] = match[0].slice( 0, excess );\\n\\t\\t\\t\\tmatch[2] = unquoted.slice( 0, excess );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Return only captures needed by the pseudo filter method (type and argument)\\n\\t\\t\\treturn match.slice( 0, 3 );\\n\\t\\t}\\n\\t},\\n\\n\\tfilter: {\\n\\n\\t\\t\\\"TAG\\\": function( nodeNameSelector ) {\\n\\t\\t\\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\\n\\t\\t\\treturn nodeNameSelector === \\\"*\\\" ?\\n\\t\\t\\t\\tfunction() { return true; } :\\n\\t\\t\\t\\tfunction( elem ) {\\n\\t\\t\\t\\t\\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\\n\\t\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\t\\\"CLASS\\\": function( className ) {\\n\\t\\t\\tvar pattern = classCache[ className + \\\" \\\" ];\\n\\n\\t\\t\\treturn pattern ||\\n\\t\\t\\t\\t(pattern = new RegExp( \\\"(^|\\\" + whitespace + \\\")\\\" + className + \\\"(\\\" + whitespace + \\\"|$)\\\" )) &&\\n\\t\\t\\t\\tclassCache( className, function( elem ) {\\n\\t\\t\\t\\t\\treturn pattern.test( typeof elem.className === \\\"string\\\" && elem.className || typeof elem.getAttribute !== \\\"undefined\\\" && elem.getAttribute(\\\"class\\\") || \\\"\\\" );\\n\\t\\t\\t\\t});\\n\\t\\t},\\n\\n\\t\\t\\\"ATTR\\\": function( name, operator, check ) {\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\tvar result = Sizzle.attr( elem, name );\\n\\n\\t\\t\\t\\tif ( result == null ) {\\n\\t\\t\\t\\t\\treturn operator === \\\"!=\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( !operator ) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tresult += \\\"\\\";\\n\\n\\t\\t\\t\\treturn operator === \\\"=\\\" ? result === check :\\n\\t\\t\\t\\t\\toperator === \\\"!=\\\" ? result !== check :\\n\\t\\t\\t\\t\\toperator === \\\"^=\\\" ? check && result.indexOf( check ) === 0 :\\n\\t\\t\\t\\t\\toperator === \\\"*=\\\" ? check && result.indexOf( check ) > -1 :\\n\\t\\t\\t\\t\\toperator === \\\"$=\\\" ? check && result.slice( -check.length ) === check :\\n\\t\\t\\t\\t\\toperator === \\\"~=\\\" ? ( \\\" \\\" + result.replace( rwhitespace, \\\" \\\" ) + \\\" \\\" ).indexOf( check ) > -1 :\\n\\t\\t\\t\\t\\toperator === \\\"|=\\\" ? result === check || result.slice( 0, check.length + 1 ) === check + \\\"-\\\" :\\n\\t\\t\\t\\t\\tfalse;\\n\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\t\\\"CHILD\\\": function( type, what, argument, first, last ) {\\n\\t\\t\\tvar simple = type.slice( 0, 3 ) !== \\\"nth\\\",\\n\\t\\t\\t\\tforward = type.slice( -4 ) !== \\\"last\\\",\\n\\t\\t\\t\\tofType = what === \\\"of-type\\\";\\n\\n\\t\\t\\treturn first === 1 && last === 0 ?\\n\\n\\t\\t\\t\\t// Shortcut for :nth-*(n)\\n\\t\\t\\t\\tfunction( elem ) {\\n\\t\\t\\t\\t\\treturn !!elem.parentNode;\\n\\t\\t\\t\\t} :\\n\\n\\t\\t\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\t\\t\\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\\n\\t\\t\\t\\t\\t\\tdir = simple !== forward ? \\\"nextSibling\\\" : \\\"previousSibling\\\",\\n\\t\\t\\t\\t\\t\\tparent = elem.parentNode,\\n\\t\\t\\t\\t\\t\\tname = ofType && elem.nodeName.toLowerCase(),\\n\\t\\t\\t\\t\\t\\tuseCache = !xml && !ofType,\\n\\t\\t\\t\\t\\t\\tdiff = false;\\n\\n\\t\\t\\t\\t\\tif ( parent ) {\\n\\n\\t\\t\\t\\t\\t\\t// :(first|last|only)-(child|of-type)\\n\\t\\t\\t\\t\\t\\tif ( simple ) {\\n\\t\\t\\t\\t\\t\\t\\twhile ( dir ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tnode = elem;\\n\\t\\t\\t\\t\\t\\t\\t\\twhile ( (node = node[ dir ]) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( ofType ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnode.nodeName.toLowerCase() === name :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnode.nodeType === 1 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t// Reverse direction for :only-* (if we haven't yet done so)\\n\\t\\t\\t\\t\\t\\t\\t\\tstart = dir = type === \\\"only\\\" && !start && \\\"nextSibling\\\";\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tstart = [ forward ? parent.firstChild : parent.lastChild ];\\n\\n\\t\\t\\t\\t\\t\\t// non-xml :nth-child(...) stores cache data on `parent`\\n\\t\\t\\t\\t\\t\\tif ( forward && useCache ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Seek `elem` from a previously-cached index\\n\\n\\t\\t\\t\\t\\t\\t\\t// ...in a gzip-friendly way\\n\\t\\t\\t\\t\\t\\t\\tnode = parent;\\n\\t\\t\\t\\t\\t\\t\\touterCache = node[ expando ] || (node[ expando ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\t// Support: IE <9 only\\n\\t\\t\\t\\t\\t\\t\\t// Defend against cloned attroperties (jQuery gh-1709)\\n\\t\\t\\t\\t\\t\\t\\tuniqueCache = outerCache[ node.uniqueID ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\t(outerCache[ node.uniqueID ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\tcache = uniqueCache[ type ] || [];\\n\\t\\t\\t\\t\\t\\t\\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\\n\\t\\t\\t\\t\\t\\t\\tdiff = nodeIndex && cache[ 2 ];\\n\\t\\t\\t\\t\\t\\t\\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\\n\\n\\t\\t\\t\\t\\t\\t\\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Fallback to seeking `elem` from the start\\n\\t\\t\\t\\t\\t\\t\\t\\t(diff = nodeIndex = 0) || start.pop()) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// When found, cache indexes on `parent` and break\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( node.nodeType === 1 && ++diff && node === elem ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t// Use previously-cached element index if available\\n\\t\\t\\t\\t\\t\\t\\tif ( useCache ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t// ...in a gzip-friendly way\\n\\t\\t\\t\\t\\t\\t\\t\\tnode = elem;\\n\\t\\t\\t\\t\\t\\t\\t\\touterCache = node[ expando ] || (node[ expando ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Support: IE <9 only\\n\\t\\t\\t\\t\\t\\t\\t\\t// Defend against cloned attroperties (jQuery gh-1709)\\n\\t\\t\\t\\t\\t\\t\\t\\tuniqueCache = outerCache[ node.uniqueID ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t(outerCache[ node.uniqueID ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcache = uniqueCache[ type ] || [];\\n\\t\\t\\t\\t\\t\\t\\t\\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\\n\\t\\t\\t\\t\\t\\t\\t\\tdiff = nodeIndex;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t// xml :nth-child(...)\\n\\t\\t\\t\\t\\t\\t\\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\\n\\t\\t\\t\\t\\t\\t\\tif ( diff === false ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t// Use the same loop as above to seek `elem` from the start\\n\\t\\t\\t\\t\\t\\t\\t\\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t(diff = nodeIndex = 0) || start.pop()) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( ( ofType ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnode.nodeName.toLowerCase() === name :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnode.nodeType === 1 ) &&\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t++diff ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Cache the index of each encountered element\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( useCache ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\touterCache = node[ expando ] || (node[ expando ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: IE <9 only\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Defend against cloned attroperties (jQuery gh-1709)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tuniqueCache = outerCache[ node.uniqueID ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t(outerCache[ node.uniqueID ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tuniqueCache[ type ] = [ dirruns, diff ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( node === elem ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// Incorporate the offset, then check against cycle size\\n\\t\\t\\t\\t\\t\\tdiff -= last;\\n\\t\\t\\t\\t\\t\\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\t\\\"PSEUDO\\\": function( pseudo, argument ) {\\n\\t\\t\\t// pseudo-class names are case-insensitive\\n\\t\\t\\t// http://www.w3.org/TR/selectors/#pseudo-classes\\n\\t\\t\\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\\n\\t\\t\\t// Remember that setFilters inherits from pseudos\\n\\t\\t\\tvar args,\\n\\t\\t\\t\\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\\n\\t\\t\\t\\t\\tSizzle.error( \\\"unsupported pseudo: \\\" + pseudo );\\n\\n\\t\\t\\t// The user may use createPseudo to indicate that\\n\\t\\t\\t// arguments are needed to create the filter function\\n\\t\\t\\t// just as Sizzle does\\n\\t\\t\\tif ( fn[ expando ] ) {\\n\\t\\t\\t\\treturn fn( argument );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// But maintain support for old signatures\\n\\t\\t\\tif ( fn.length > 1 ) {\\n\\t\\t\\t\\targs = [ pseudo, pseudo, \\\"\\\", argument ];\\n\\t\\t\\t\\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\\n\\t\\t\\t\\t\\tmarkFunction(function( seed, matches ) {\\n\\t\\t\\t\\t\\t\\tvar idx,\\n\\t\\t\\t\\t\\t\\t\\tmatched = fn( seed, argument ),\\n\\t\\t\\t\\t\\t\\t\\ti = matched.length;\\n\\t\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\t\\tidx = indexOf( seed, matched[i] );\\n\\t\\t\\t\\t\\t\\t\\tseed[ idx ] = !( matches[ idx ] = matched[i] );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}) :\\n\\t\\t\\t\\t\\tfunction( elem ) {\\n\\t\\t\\t\\t\\t\\treturn fn( elem, 0, args );\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn fn;\\n\\t\\t}\\n\\t},\\n\\n\\tpseudos: {\\n\\t\\t// Potentially complex pseudos\\n\\t\\t\\\"not\\\": markFunction(function( selector ) {\\n\\t\\t\\t// Trim the selector passed to compile\\n\\t\\t\\t// to avoid treating leading and trailing\\n\\t\\t\\t// spaces as combinators\\n\\t\\t\\tvar input = [],\\n\\t\\t\\t\\tresults = [],\\n\\t\\t\\t\\tmatcher = compile( selector.replace( rtrim, \\\"$1\\\" ) );\\n\\n\\t\\t\\treturn matcher[ expando ] ?\\n\\t\\t\\t\\tmarkFunction(function( seed, matches, context, xml ) {\\n\\t\\t\\t\\t\\tvar elem,\\n\\t\\t\\t\\t\\t\\tunmatched = matcher( seed, null, xml, [] ),\\n\\t\\t\\t\\t\\t\\ti = seed.length;\\n\\n\\t\\t\\t\\t\\t// Match elements unmatched by `matcher`\\n\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\tif ( (elem = unmatched[i]) ) {\\n\\t\\t\\t\\t\\t\\t\\tseed[i] = !(matches[i] = elem);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}) :\\n\\t\\t\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\t\\t\\tinput[0] = elem;\\n\\t\\t\\t\\t\\tmatcher( input, null, xml, results );\\n\\t\\t\\t\\t\\t// Don't keep the element (issue #299)\\n\\t\\t\\t\\t\\tinput[0] = null;\\n\\t\\t\\t\\t\\treturn !results.pop();\\n\\t\\t\\t\\t};\\n\\t\\t}),\\n\\n\\t\\t\\\"has\\\": markFunction(function( selector ) {\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\treturn Sizzle( selector, elem ).length > 0;\\n\\t\\t\\t};\\n\\t\\t}),\\n\\n\\t\\t\\\"contains\\\": markFunction(function( text ) {\\n\\t\\t\\ttext = text.replace( runescape, funescape );\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\\n\\t\\t\\t};\\n\\t\\t}),\\n\\n\\t\\t// \\\"Whether an element is represented by a :lang() selector\\n\\t\\t// is based solely on the element's language value\\n\\t\\t// being equal to the identifier C,\\n\\t\\t// or beginning with the identifier C immediately followed by \\\"-\\\".\\n\\t\\t// The matching of C against the element's language value is performed case-insensitively.\\n\\t\\t// The identifier C does not have to be a valid language name.\\\"\\n\\t\\t// http://www.w3.org/TR/selectors/#lang-pseudo\\n\\t\\t\\\"lang\\\": markFunction( function( lang ) {\\n\\t\\t\\t// lang value must be a valid identifier\\n\\t\\t\\tif ( !ridentifier.test(lang || \\\"\\\") ) {\\n\\t\\t\\t\\tSizzle.error( \\\"unsupported lang: \\\" + lang );\\n\\t\\t\\t}\\n\\t\\t\\tlang = lang.replace( runescape, funescape ).toLowerCase();\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\tvar elemLang;\\n\\t\\t\\t\\tdo {\\n\\t\\t\\t\\t\\tif ( (elemLang = documentIsHTML ?\\n\\t\\t\\t\\t\\t\\telem.lang :\\n\\t\\t\\t\\t\\t\\telem.getAttribute(\\\"xml:lang\\\") || elem.getAttribute(\\\"lang\\\")) ) {\\n\\n\\t\\t\\t\\t\\t\\telemLang = elemLang.toLowerCase();\\n\\t\\t\\t\\t\\t\\treturn elemLang === lang || elemLang.indexOf( lang + \\\"-\\\" ) === 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t};\\n\\t\\t}),\\n\\n\\t\\t// Miscellaneous\\n\\t\\t\\\"target\\\": function( elem ) {\\n\\t\\t\\tvar hash = window.location && window.location.hash;\\n\\t\\t\\treturn hash && hash.slice( 1 ) === elem.id;\\n\\t\\t},\\n\\n\\t\\t\\\"root\\\": function( elem ) {\\n\\t\\t\\treturn elem === docElem;\\n\\t\\t},\\n\\n\\t\\t\\\"focus\\\": function( elem ) {\\n\\t\\t\\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\\n\\t\\t},\\n\\n\\t\\t// Boolean properties\\n\\t\\t\\\"enabled\\\": createDisabledPseudo( false ),\\n\\t\\t\\\"disabled\\\": createDisabledPseudo( true ),\\n\\n\\t\\t\\\"checked\\\": function( elem ) {\\n\\t\\t\\t// In CSS3, :checked should return both checked and selected elements\\n\\t\\t\\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\\n\\t\\t\\tvar nodeName = elem.nodeName.toLowerCase();\\n\\t\\t\\treturn (nodeName === \\\"input\\\" && !!elem.checked) || (nodeName === \\\"option\\\" && !!elem.selected);\\n\\t\\t},\\n\\n\\t\\t\\\"selected\\\": function( elem ) {\\n\\t\\t\\t// Accessing this property makes selected-by-default\\n\\t\\t\\t// options in Safari work properly\\n\\t\\t\\tif ( elem.parentNode ) {\\n\\t\\t\\t\\telem.parentNode.selectedIndex;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn elem.selected === true;\\n\\t\\t},\\n\\n\\t\\t// Contents\\n\\t\\t\\\"empty\\\": function( elem ) {\\n\\t\\t\\t// http://www.w3.org/TR/selectors/#empty-pseudo\\n\\t\\t\\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\\n\\t\\t\\t//   but not by others (comment: 8; processing instruction: 7; etc.)\\n\\t\\t\\t// nodeType < 6 works because attributes (2) do not appear as children\\n\\t\\t\\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\\n\\t\\t\\t\\tif ( elem.nodeType < 6 ) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t},\\n\\n\\t\\t\\\"parent\\\": function( elem ) {\\n\\t\\t\\treturn !Expr.pseudos[\\\"empty\\\"]( elem );\\n\\t\\t},\\n\\n\\t\\t// Element/input types\\n\\t\\t\\\"header\\\": function( elem ) {\\n\\t\\t\\treturn rheader.test( elem.nodeName );\\n\\t\\t},\\n\\n\\t\\t\\\"input\\\": function( elem ) {\\n\\t\\t\\treturn rinputs.test( elem.nodeName );\\n\\t\\t},\\n\\n\\t\\t\\\"button\\\": function( elem ) {\\n\\t\\t\\tvar name = elem.nodeName.toLowerCase();\\n\\t\\t\\treturn name === \\\"input\\\" && elem.type === \\\"button\\\" || name === \\\"button\\\";\\n\\t\\t},\\n\\n\\t\\t\\\"text\\\": function( elem ) {\\n\\t\\t\\tvar attr;\\n\\t\\t\\treturn elem.nodeName.toLowerCase() === \\\"input\\\" &&\\n\\t\\t\\t\\telem.type === \\\"text\\\" &&\\n\\n\\t\\t\\t\\t// Support: IE<8\\n\\t\\t\\t\\t// New HTML5 attribute values (e.g., \\\"search\\\") appear with elem.type === \\\"text\\\"\\n\\t\\t\\t\\t( (attr = elem.getAttribute(\\\"type\\\")) == null || attr.toLowerCase() === \\\"text\\\" );\\n\\t\\t},\\n\\n\\t\\t// Position-in-collection\\n\\t\\t\\\"first\\\": createPositionalPseudo(function() {\\n\\t\\t\\treturn [ 0 ];\\n\\t\\t}),\\n\\n\\t\\t\\\"last\\\": createPositionalPseudo(function( matchIndexes, length ) {\\n\\t\\t\\treturn [ length - 1 ];\\n\\t\\t}),\\n\\n\\t\\t\\\"eq\\\": createPositionalPseudo(function( matchIndexes, length, argument ) {\\n\\t\\t\\treturn [ argument < 0 ? argument + length : argument ];\\n\\t\\t}),\\n\\n\\t\\t\\\"even\\\": createPositionalPseudo(function( matchIndexes, length ) {\\n\\t\\t\\tvar i = 0;\\n\\t\\t\\tfor ( ; i < length; i += 2 ) {\\n\\t\\t\\t\\tmatchIndexes.push( i );\\n\\t\\t\\t}\\n\\t\\t\\treturn matchIndexes;\\n\\t\\t}),\\n\\n\\t\\t\\\"odd\\\": createPositionalPseudo(function( matchIndexes, length ) {\\n\\t\\t\\tvar i = 1;\\n\\t\\t\\tfor ( ; i < length; i += 2 ) {\\n\\t\\t\\t\\tmatchIndexes.push( i );\\n\\t\\t\\t}\\n\\t\\t\\treturn matchIndexes;\\n\\t\\t}),\\n\\n\\t\\t\\\"lt\\\": createPositionalPseudo(function( matchIndexes, length, argument ) {\\n\\t\\t\\tvar i = argument < 0 ? argument + length : argument;\\n\\t\\t\\tfor ( ; --i >= 0; ) {\\n\\t\\t\\t\\tmatchIndexes.push( i );\\n\\t\\t\\t}\\n\\t\\t\\treturn matchIndexes;\\n\\t\\t}),\\n\\n\\t\\t\\\"gt\\\": createPositionalPseudo(function( matchIndexes, length, argument ) {\\n\\t\\t\\tvar i = argument < 0 ? argument + length : argument;\\n\\t\\t\\tfor ( ; ++i < length; ) {\\n\\t\\t\\t\\tmatchIndexes.push( i );\\n\\t\\t\\t}\\n\\t\\t\\treturn matchIndexes;\\n\\t\\t})\\n\\t}\\n};\\n\\nExpr.pseudos[\\\"nth\\\"] = Expr.pseudos[\\\"eq\\\"];\\n\\n// Add button/input type pseudos\\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\\n\\tExpr.pseudos[ i ] = createInputPseudo( i );\\n}\\nfor ( i in { submit: true, reset: true } ) {\\n\\tExpr.pseudos[ i ] = createButtonPseudo( i );\\n}\\n\\n// Easy API for creating new setFilters\\nfunction setFilters() {}\\nsetFilters.prototype = Expr.filters = Expr.pseudos;\\nExpr.setFilters = new setFilters();\\n\\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\\n\\tvar matched, match, tokens, type,\\n\\t\\tsoFar, groups, preFilters,\\n\\t\\tcached = tokenCache[ selector + \\\" \\\" ];\\n\\n\\tif ( cached ) {\\n\\t\\treturn parseOnly ? 0 : cached.slice( 0 );\\n\\t}\\n\\n\\tsoFar = selector;\\n\\tgroups = [];\\n\\tpreFilters = Expr.preFilter;\\n\\n\\twhile ( soFar ) {\\n\\n\\t\\t// Comma and first run\\n\\t\\tif ( !matched || (match = rcomma.exec( soFar )) ) {\\n\\t\\t\\tif ( match ) {\\n\\t\\t\\t\\t// Don't consume trailing commas as valid\\n\\t\\t\\t\\tsoFar = soFar.slice( match[0].length ) || soFar;\\n\\t\\t\\t}\\n\\t\\t\\tgroups.push( (tokens = []) );\\n\\t\\t}\\n\\n\\t\\tmatched = false;\\n\\n\\t\\t// Combinators\\n\\t\\tif ( (match = rcombinators.exec( soFar )) ) {\\n\\t\\t\\tmatched = match.shift();\\n\\t\\t\\ttokens.push({\\n\\t\\t\\t\\tvalue: matched,\\n\\t\\t\\t\\t// Cast descendant combinators to space\\n\\t\\t\\t\\ttype: match[0].replace( rtrim, \\\" \\\" )\\n\\t\\t\\t});\\n\\t\\t\\tsoFar = soFar.slice( matched.length );\\n\\t\\t}\\n\\n\\t\\t// Filters\\n\\t\\tfor ( type in Expr.filter ) {\\n\\t\\t\\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\\n\\t\\t\\t\\t(match = preFilters[ type ]( match ))) ) {\\n\\t\\t\\t\\tmatched = match.shift();\\n\\t\\t\\t\\ttokens.push({\\n\\t\\t\\t\\t\\tvalue: matched,\\n\\t\\t\\t\\t\\ttype: type,\\n\\t\\t\\t\\t\\tmatches: match\\n\\t\\t\\t\\t});\\n\\t\\t\\t\\tsoFar = soFar.slice( matched.length );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( !matched ) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\t// Return the length of the invalid excess\\n\\t// if we're just parsing\\n\\t// Otherwise, throw an error or return tokens\\n\\treturn parseOnly ?\\n\\t\\tsoFar.length :\\n\\t\\tsoFar ?\\n\\t\\t\\tSizzle.error( selector ) :\\n\\t\\t\\t// Cache the tokens\\n\\t\\t\\ttokenCache( selector, groups ).slice( 0 );\\n};\\n\\nfunction toSelector( tokens ) {\\n\\tvar i = 0,\\n\\t\\tlen = tokens.length,\\n\\t\\tselector = \\\"\\\";\\n\\tfor ( ; i < len; i++ ) {\\n\\t\\tselector += tokens[i].value;\\n\\t}\\n\\treturn selector;\\n}\\n\\nfunction addCombinator( matcher, combinator, base ) {\\n\\tvar dir = combinator.dir,\\n\\t\\tskip = combinator.next,\\n\\t\\tkey = skip || dir,\\n\\t\\tcheckNonElements = base && key === \\\"parentNode\\\",\\n\\t\\tdoneName = done++;\\n\\n\\treturn combinator.first ?\\n\\t\\t// Check against closest ancestor/preceding element\\n\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\twhile ( (elem = elem[ dir ]) ) {\\n\\t\\t\\t\\tif ( elem.nodeType === 1 || checkNonElements ) {\\n\\t\\t\\t\\t\\treturn matcher( elem, context, xml );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t} :\\n\\n\\t\\t// Check against all ancestor/preceding elements\\n\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\tvar oldCache, uniqueCache, outerCache,\\n\\t\\t\\t\\tnewCache = [ dirruns, doneName ];\\n\\n\\t\\t\\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\\n\\t\\t\\tif ( xml ) {\\n\\t\\t\\t\\twhile ( (elem = elem[ dir ]) ) {\\n\\t\\t\\t\\t\\tif ( elem.nodeType === 1 || checkNonElements ) {\\n\\t\\t\\t\\t\\t\\tif ( matcher( elem, context, xml ) ) {\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\twhile ( (elem = elem[ dir ]) ) {\\n\\t\\t\\t\\t\\tif ( elem.nodeType === 1 || checkNonElements ) {\\n\\t\\t\\t\\t\\t\\touterCache = elem[ expando ] || (elem[ expando ] = {});\\n\\n\\t\\t\\t\\t\\t\\t// Support: IE <9 only\\n\\t\\t\\t\\t\\t\\t// Defend against cloned attroperties (jQuery gh-1709)\\n\\t\\t\\t\\t\\t\\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\\n\\n\\t\\t\\t\\t\\t\\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\\n\\t\\t\\t\\t\\t\\t\\telem = elem[ dir ] || elem;\\n\\t\\t\\t\\t\\t\\t} else if ( (oldCache = uniqueCache[ key ]) &&\\n\\t\\t\\t\\t\\t\\t\\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Assign to newCache so results back-propagate to previous elements\\n\\t\\t\\t\\t\\t\\t\\treturn (newCache[ 2 ] = oldCache[ 2 ]);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t// Reuse newcache so results back-propagate to previous elements\\n\\t\\t\\t\\t\\t\\t\\tuniqueCache[ key ] = newCache;\\n\\n\\t\\t\\t\\t\\t\\t\\t// A match means we're done; a fail means we have to keep checking\\n\\t\\t\\t\\t\\t\\t\\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t};\\n}\\n\\nfunction elementMatcher( matchers ) {\\n\\treturn matchers.length > 1 ?\\n\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\tvar i = matchers.length;\\n\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\tif ( !matchers[i]( elem, context, xml ) ) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t} :\\n\\t\\tmatchers[0];\\n}\\n\\nfunction multipleContexts( selector, contexts, results ) {\\n\\tvar i = 0,\\n\\t\\tlen = contexts.length;\\n\\tfor ( ; i < len; i++ ) {\\n\\t\\tSizzle( selector, contexts[i], results );\\n\\t}\\n\\treturn results;\\n}\\n\\nfunction condense( unmatched, map, filter, context, xml ) {\\n\\tvar elem,\\n\\t\\tnewUnmatched = [],\\n\\t\\ti = 0,\\n\\t\\tlen = unmatched.length,\\n\\t\\tmapped = map != null;\\n\\n\\tfor ( ; i < len; i++ ) {\\n\\t\\tif ( (elem = unmatched[i]) ) {\\n\\t\\t\\tif ( !filter || filter( elem, context, xml ) ) {\\n\\t\\t\\t\\tnewUnmatched.push( elem );\\n\\t\\t\\t\\tif ( mapped ) {\\n\\t\\t\\t\\t\\tmap.push( i );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn newUnmatched;\\n}\\n\\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\\n\\tif ( postFilter && !postFilter[ expando ] ) {\\n\\t\\tpostFilter = setMatcher( postFilter );\\n\\t}\\n\\tif ( postFinder && !postFinder[ expando ] ) {\\n\\t\\tpostFinder = setMatcher( postFinder, postSelector );\\n\\t}\\n\\treturn markFunction(function( seed, results, context, xml ) {\\n\\t\\tvar temp, i, elem,\\n\\t\\t\\tpreMap = [],\\n\\t\\t\\tpostMap = [],\\n\\t\\t\\tpreexisting = results.length,\\n\\n\\t\\t\\t// Get initial elements from seed or context\\n\\t\\t\\telems = seed || multipleContexts( selector || \\\"*\\\", context.nodeType ? [ context ] : context, [] ),\\n\\n\\t\\t\\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\\n\\t\\t\\tmatcherIn = preFilter && ( seed || !selector ) ?\\n\\t\\t\\t\\tcondense( elems, preMap, preFilter, context, xml ) :\\n\\t\\t\\t\\telems,\\n\\n\\t\\t\\tmatcherOut = matcher ?\\n\\t\\t\\t\\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\\n\\t\\t\\t\\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\\n\\n\\t\\t\\t\\t\\t// ...intermediate processing is necessary\\n\\t\\t\\t\\t\\t[] :\\n\\n\\t\\t\\t\\t\\t// ...otherwise use results directly\\n\\t\\t\\t\\t\\tresults :\\n\\t\\t\\t\\tmatcherIn;\\n\\n\\t\\t// Find primary matches\\n\\t\\tif ( matcher ) {\\n\\t\\t\\tmatcher( matcherIn, matcherOut, context, xml );\\n\\t\\t}\\n\\n\\t\\t// Apply postFilter\\n\\t\\tif ( postFilter ) {\\n\\t\\t\\ttemp = condense( matcherOut, postMap );\\n\\t\\t\\tpostFilter( temp, [], context, xml );\\n\\n\\t\\t\\t// Un-match failing elements by moving them back to matcherIn\\n\\t\\t\\ti = temp.length;\\n\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\tif ( (elem = temp[i]) ) {\\n\\t\\t\\t\\t\\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( seed ) {\\n\\t\\t\\tif ( postFinder || preFilter ) {\\n\\t\\t\\t\\tif ( postFinder ) {\\n\\t\\t\\t\\t\\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\\n\\t\\t\\t\\t\\ttemp = [];\\n\\t\\t\\t\\t\\ti = matcherOut.length;\\n\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\tif ( (elem = matcherOut[i]) ) {\\n\\t\\t\\t\\t\\t\\t\\t// Restore matcherIn since elem is not yet a final match\\n\\t\\t\\t\\t\\t\\t\\ttemp.push( (matcherIn[i] = elem) );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tpostFinder( null, (matcherOut = []), temp, xml );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Move matched elements from seed to results to keep them synchronized\\n\\t\\t\\t\\ti = matcherOut.length;\\n\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\tif ( (elem = matcherOut[i]) &&\\n\\t\\t\\t\\t\\t\\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\\n\\n\\t\\t\\t\\t\\t\\tseed[temp] = !(results[temp] = elem);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t// Add elements to results, through postFinder if defined\\n\\t\\t} else {\\n\\t\\t\\tmatcherOut = condense(\\n\\t\\t\\t\\tmatcherOut === results ?\\n\\t\\t\\t\\t\\tmatcherOut.splice( preexisting, matcherOut.length ) :\\n\\t\\t\\t\\t\\tmatcherOut\\n\\t\\t\\t);\\n\\t\\t\\tif ( postFinder ) {\\n\\t\\t\\t\\tpostFinder( null, results, matcherOut, xml );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpush.apply( results, matcherOut );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t});\\n}\\n\\nfunction matcherFromTokens( tokens ) {\\n\\tvar checkContext, matcher, j,\\n\\t\\tlen = tokens.length,\\n\\t\\tleadingRelative = Expr.relative[ tokens[0].type ],\\n\\t\\timplicitRelative = leadingRelative || Expr.relative[\\\" \\\"],\\n\\t\\ti = leadingRelative ? 1 : 0,\\n\\n\\t\\t// The foundational matcher ensures that elements are reachable from top-level context(s)\\n\\t\\tmatchContext = addCombinator( function( elem ) {\\n\\t\\t\\treturn elem === checkContext;\\n\\t\\t}, implicitRelative, true ),\\n\\t\\tmatchAnyContext = addCombinator( function( elem ) {\\n\\t\\t\\treturn indexOf( checkContext, elem ) > -1;\\n\\t\\t}, implicitRelative, true ),\\n\\t\\tmatchers = [ function( elem, context, xml ) {\\n\\t\\t\\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\\n\\t\\t\\t\\t(checkContext = context).nodeType ?\\n\\t\\t\\t\\t\\tmatchContext( elem, context, xml ) :\\n\\t\\t\\t\\t\\tmatchAnyContext( elem, context, xml ) );\\n\\t\\t\\t// Avoid hanging onto element (issue #299)\\n\\t\\t\\tcheckContext = null;\\n\\t\\t\\treturn ret;\\n\\t\\t} ];\\n\\n\\tfor ( ; i < len; i++ ) {\\n\\t\\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\\n\\t\\t\\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\\n\\t\\t} else {\\n\\t\\t\\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\\n\\n\\t\\t\\t// Return special upon seeing a positional matcher\\n\\t\\t\\tif ( matcher[ expando ] ) {\\n\\t\\t\\t\\t// Find the next relative operator (if any) for proper handling\\n\\t\\t\\t\\tj = ++i;\\n\\t\\t\\t\\tfor ( ; j < len; j++ ) {\\n\\t\\t\\t\\t\\tif ( Expr.relative[ tokens[j].type ] ) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn setMatcher(\\n\\t\\t\\t\\t\\ti > 1 && elementMatcher( matchers ),\\n\\t\\t\\t\\t\\ti > 1 && toSelector(\\n\\t\\t\\t\\t\\t\\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\\n\\t\\t\\t\\t\\t\\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \\\" \\\" ? \\\"*\\\" : \\\"\\\" })\\n\\t\\t\\t\\t\\t).replace( rtrim, \\\"$1\\\" ),\\n\\t\\t\\t\\t\\tmatcher,\\n\\t\\t\\t\\t\\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\\n\\t\\t\\t\\t\\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\\n\\t\\t\\t\\t\\tj < len && toSelector( tokens )\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t\\tmatchers.push( matcher );\\n\\t\\t}\\n\\t}\\n\\n\\treturn elementMatcher( matchers );\\n}\\n\\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\\n\\tvar bySet = setMatchers.length > 0,\\n\\t\\tbyElement = elementMatchers.length > 0,\\n\\t\\tsuperMatcher = function( seed, context, xml, results, outermost ) {\\n\\t\\t\\tvar elem, j, matcher,\\n\\t\\t\\t\\tmatchedCount = 0,\\n\\t\\t\\t\\ti = \\\"0\\\",\\n\\t\\t\\t\\tunmatched = seed && [],\\n\\t\\t\\t\\tsetMatched = [],\\n\\t\\t\\t\\tcontextBackup = outermostContext,\\n\\t\\t\\t\\t// We must always have either seed elements or outermost context\\n\\t\\t\\t\\telems = seed || byElement && Expr.find[\\\"TAG\\\"]( \\\"*\\\", outermost ),\\n\\t\\t\\t\\t// Use integer dirruns iff this is the outermost matcher\\n\\t\\t\\t\\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\\n\\t\\t\\t\\tlen = elems.length;\\n\\n\\t\\t\\tif ( outermost ) {\\n\\t\\t\\t\\toutermostContext = context === document || context || outermost;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Add elements passing elementMatchers directly to results\\n\\t\\t\\t// Support: IE<9, Safari\\n\\t\\t\\t// Tolerate NodeList properties (IE: \\\"length\\\"; Safari: <number>) matching elements by id\\n\\t\\t\\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\\n\\t\\t\\t\\tif ( byElement && elem ) {\\n\\t\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\t\\tif ( !context && elem.ownerDocument !== document ) {\\n\\t\\t\\t\\t\\t\\tsetDocument( elem );\\n\\t\\t\\t\\t\\t\\txml = !documentIsHTML;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\twhile ( (matcher = elementMatchers[j++]) ) {\\n\\t\\t\\t\\t\\t\\tif ( matcher( elem, context || document, xml) ) {\\n\\t\\t\\t\\t\\t\\t\\tresults.push( elem );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( outermost ) {\\n\\t\\t\\t\\t\\t\\tdirruns = dirrunsUnique;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Track unmatched elements for set filters\\n\\t\\t\\t\\tif ( bySet ) {\\n\\t\\t\\t\\t\\t// They will have gone through all possible matchers\\n\\t\\t\\t\\t\\tif ( (elem = !matcher && elem) ) {\\n\\t\\t\\t\\t\\t\\tmatchedCount--;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Lengthen the array for every element, matched or not\\n\\t\\t\\t\\t\\tif ( seed ) {\\n\\t\\t\\t\\t\\t\\tunmatched.push( elem );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\\n\\t\\t\\t// makes the latter nonnegative.\\n\\t\\t\\tmatchedCount += i;\\n\\n\\t\\t\\t// Apply set filters to unmatched elements\\n\\t\\t\\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\\n\\t\\t\\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\\n\\t\\t\\t// no element matchers and no seed.\\n\\t\\t\\t// Incrementing an initially-string \\\"0\\\" `i` allows `i` to remain a string only in that\\n\\t\\t\\t// case, which will result in a \\\"00\\\" `matchedCount` that differs from `i` but is also\\n\\t\\t\\t// numerically zero.\\n\\t\\t\\tif ( bySet && i !== matchedCount ) {\\n\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\twhile ( (matcher = setMatchers[j++]) ) {\\n\\t\\t\\t\\t\\tmatcher( unmatched, setMatched, context, xml );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( seed ) {\\n\\t\\t\\t\\t\\t// Reintegrate element matches to eliminate the need for sorting\\n\\t\\t\\t\\t\\tif ( matchedCount > 0 ) {\\n\\t\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\t\\tif ( !(unmatched[i] || setMatched[i]) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tsetMatched[i] = pop.call( results );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Discard index placeholder values to get only actual matches\\n\\t\\t\\t\\t\\tsetMatched = condense( setMatched );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Add matches to results\\n\\t\\t\\t\\tpush.apply( results, setMatched );\\n\\n\\t\\t\\t\\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\\n\\t\\t\\t\\tif ( outermost && !seed && setMatched.length > 0 &&\\n\\t\\t\\t\\t\\t( matchedCount + setMatchers.length ) > 1 ) {\\n\\n\\t\\t\\t\\t\\tSizzle.uniqueSort( results );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Override manipulation of globals by nested matchers\\n\\t\\t\\tif ( outermost ) {\\n\\t\\t\\t\\tdirruns = dirrunsUnique;\\n\\t\\t\\t\\toutermostContext = contextBackup;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn unmatched;\\n\\t\\t};\\n\\n\\treturn bySet ?\\n\\t\\tmarkFunction( superMatcher ) :\\n\\t\\tsuperMatcher;\\n}\\n\\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\\n\\tvar i,\\n\\t\\tsetMatchers = [],\\n\\t\\telementMatchers = [],\\n\\t\\tcached = compilerCache[ selector + \\\" \\\" ];\\n\\n\\tif ( !cached ) {\\n\\t\\t// Generate a function of recursive functions that can be used to check each element\\n\\t\\tif ( !match ) {\\n\\t\\t\\tmatch = tokenize( selector );\\n\\t\\t}\\n\\t\\ti = match.length;\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\tcached = matcherFromTokens( match[i] );\\n\\t\\t\\tif ( cached[ expando ] ) {\\n\\t\\t\\t\\tsetMatchers.push( cached );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\telementMatchers.push( cached );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Cache the compiled function\\n\\t\\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\\n\\n\\t\\t// Save selector and tokenization\\n\\t\\tcached.selector = selector;\\n\\t}\\n\\treturn cached;\\n};\\n\\n/**\\n * A low-level selection function that works with Sizzle's compiled\\n *  selector functions\\n * @param {String|Function} selector A selector or a pre-compiled\\n *  selector function built with Sizzle.compile\\n * @param {Element} context\\n * @param {Array} [results]\\n * @param {Array} [seed] A set of elements to match against\\n */\\nselect = Sizzle.select = function( selector, context, results, seed ) {\\n\\tvar i, tokens, token, type, find,\\n\\t\\tcompiled = typeof selector === \\\"function\\\" && selector,\\n\\t\\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\\n\\n\\tresults = results || [];\\n\\n\\t// Try to minimize operations if there is only one selector in the list and no seed\\n\\t// (the latter of which guarantees us context)\\n\\tif ( match.length === 1 ) {\\n\\n\\t\\t// Reduce context if the leading compound selector is an ID\\n\\t\\ttokens = match[0] = match[0].slice( 0 );\\n\\t\\tif ( tokens.length > 2 && (token = tokens[0]).type === \\\"ID\\\" &&\\n\\t\\t\\t\\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {\\n\\n\\t\\t\\tcontext = ( Expr.find[\\\"ID\\\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\\n\\t\\t\\tif ( !context ) {\\n\\t\\t\\t\\treturn results;\\n\\n\\t\\t\\t// Precompiled matchers will still verify ancestry, so step up a level\\n\\t\\t\\t} else if ( compiled ) {\\n\\t\\t\\t\\tcontext = context.parentNode;\\n\\t\\t\\t}\\n\\n\\t\\t\\tselector = selector.slice( tokens.shift().value.length );\\n\\t\\t}\\n\\n\\t\\t// Fetch a seed set for right-to-left matching\\n\\t\\ti = matchExpr[\\\"needsContext\\\"].test( selector ) ? 0 : tokens.length;\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\ttoken = tokens[i];\\n\\n\\t\\t\\t// Abort if we hit a combinator\\n\\t\\t\\tif ( Expr.relative[ (type = token.type) ] ) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif ( (find = Expr.find[ type ]) ) {\\n\\t\\t\\t\\t// Search, expanding context for leading sibling combinators\\n\\t\\t\\t\\tif ( (seed = find(\\n\\t\\t\\t\\t\\ttoken.matches[0].replace( runescape, funescape ),\\n\\t\\t\\t\\t\\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\\n\\t\\t\\t\\t)) ) {\\n\\n\\t\\t\\t\\t\\t// If seed is empty or no tokens remain, we can return early\\n\\t\\t\\t\\t\\ttokens.splice( i, 1 );\\n\\t\\t\\t\\t\\tselector = seed.length && toSelector( tokens );\\n\\t\\t\\t\\t\\tif ( !selector ) {\\n\\t\\t\\t\\t\\t\\tpush.apply( results, seed );\\n\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Compile and execute a filtering function if one is not provided\\n\\t// Provide `match` to avoid retokenization if we modified the selector above\\n\\t( compiled || compile( selector, match ) )(\\n\\t\\tseed,\\n\\t\\tcontext,\\n\\t\\t!documentIsHTML,\\n\\t\\tresults,\\n\\t\\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\\n\\t);\\n\\treturn results;\\n};\\n\\n// One-time assignments\\n\\n// Sort stability\\nsupport.sortStable = expando.split(\\\"\\\").sort( sortOrder ).join(\\\"\\\") === expando;\\n\\n// Support: Chrome 14-35+\\n// Always assume duplicates if they aren't passed to the comparison function\\nsupport.detectDuplicates = !!hasDuplicate;\\n\\n// Initialize against the default document\\nsetDocument();\\n\\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\\n// Detached nodes confoundingly follow *each other*\\nsupport.sortDetached = assert(function( el ) {\\n\\t// Should return 1, but returns 4 (following)\\n\\treturn el.compareDocumentPosition( document.createElement(\\\"fieldset\\\") ) & 1;\\n});\\n\\n// Support: IE<8\\n// Prevent attribute/property \\\"interpolation\\\"\\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\\nif ( !assert(function( el ) {\\n\\tel.innerHTML = \\\"<a href='#'></a>\\\";\\n\\treturn el.firstChild.getAttribute(\\\"href\\\") === \\\"#\\\" ;\\n}) ) {\\n\\taddHandle( \\\"type|href|height|width\\\", function( elem, name, isXML ) {\\n\\t\\tif ( !isXML ) {\\n\\t\\t\\treturn elem.getAttribute( name, name.toLowerCase() === \\\"type\\\" ? 1 : 2 );\\n\\t\\t}\\n\\t});\\n}\\n\\n// Support: IE<9\\n// Use defaultValue in place of getAttribute(\\\"value\\\")\\nif ( !support.attributes || !assert(function( el ) {\\n\\tel.innerHTML = \\\"<input/>\\\";\\n\\tel.firstChild.setAttribute( \\\"value\\\", \\\"\\\" );\\n\\treturn el.firstChild.getAttribute( \\\"value\\\" ) === \\\"\\\";\\n}) ) {\\n\\taddHandle( \\\"value\\\", function( elem, name, isXML ) {\\n\\t\\tif ( !isXML && elem.nodeName.toLowerCase() === \\\"input\\\" ) {\\n\\t\\t\\treturn elem.defaultValue;\\n\\t\\t}\\n\\t});\\n}\\n\\n// Support: IE<9\\n// Use getAttributeNode to fetch booleans when getAttribute lies\\nif ( !assert(function( el ) {\\n\\treturn el.getAttribute(\\\"disabled\\\") == null;\\n}) ) {\\n\\taddHandle( booleans, function( elem, name, isXML ) {\\n\\t\\tvar val;\\n\\t\\tif ( !isXML ) {\\n\\t\\t\\treturn elem[ name ] === true ? name.toLowerCase() :\\n\\t\\t\\t\\t\\t(val = elem.getAttributeNode( name )) && val.specified ?\\n\\t\\t\\t\\t\\tval.value :\\n\\t\\t\\t\\tnull;\\n\\t\\t}\\n\\t});\\n}\\n\\nreturn Sizzle;\\n\\n})( window );\\n\\n\\n\\njQuery.find = Sizzle;\\njQuery.expr = Sizzle.selectors;\\n\\n// Deprecated\\njQuery.expr[ \\\":\\\" ] = jQuery.expr.pseudos;\\njQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\\njQuery.text = Sizzle.getText;\\njQuery.isXMLDoc = Sizzle.isXML;\\njQuery.contains = Sizzle.contains;\\njQuery.escapeSelector = Sizzle.escape;\\n\\n\\n\\n\\nvar dir = function( elem, dir, until ) {\\n\\tvar matched = [],\\n\\t\\ttruncate = until !== undefined;\\n\\n\\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\\n\\t\\tif ( elem.nodeType === 1 ) {\\n\\t\\t\\tif ( truncate && jQuery( elem ).is( until ) ) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tmatched.push( elem );\\n\\t\\t}\\n\\t}\\n\\treturn matched;\\n};\\n\\n\\nvar siblings = function( n, elem ) {\\n\\tvar matched = [];\\n\\n\\tfor ( ; n; n = n.nextSibling ) {\\n\\t\\tif ( n.nodeType === 1 && n !== elem ) {\\n\\t\\t\\tmatched.push( n );\\n\\t\\t}\\n\\t}\\n\\n\\treturn matched;\\n};\\n\\n\\nvar rneedsContext = jQuery.expr.match.needsContext;\\n\\n\\n\\nfunction nodeName( elem, name ) {\\n\\n  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\\n\\n};\\nvar rsingleTag = ( /^<([a-z][^\\\\/\\\\0>:\\\\x20\\\\t\\\\r\\\\n\\\\f]*)[\\\\x20\\\\t\\\\r\\\\n\\\\f]*\\\\/?>(?:<\\\\/\\\\1>|)$/i );\\n\\n\\n\\n// Implement the identical functionality for filter and not\\nfunction winnow( elements, qualifier, not ) {\\n\\tif ( isFunction( qualifier ) ) {\\n\\t\\treturn jQuery.grep( elements, function( elem, i ) {\\n\\t\\t\\treturn !!qualifier.call( elem, i, elem ) !== not;\\n\\t\\t} );\\n\\t}\\n\\n\\t// Single element\\n\\tif ( qualifier.nodeType ) {\\n\\t\\treturn jQuery.grep( elements, function( elem ) {\\n\\t\\t\\treturn ( elem === qualifier ) !== not;\\n\\t\\t} );\\n\\t}\\n\\n\\t// Arraylike of elements (jQuery, arguments, Array)\\n\\tif ( typeof qualifier !== \\\"string\\\" ) {\\n\\t\\treturn jQuery.grep( elements, function( elem ) {\\n\\t\\t\\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\\n\\t\\t} );\\n\\t}\\n\\n\\t// Filtered directly for both simple and complex selectors\\n\\treturn jQuery.filter( qualifier, elements, not );\\n}\\n\\njQuery.filter = function( expr, elems, not ) {\\n\\tvar elem = elems[ 0 ];\\n\\n\\tif ( not ) {\\n\\t\\texpr = \\\":not(\\\" + expr + \\\")\\\";\\n\\t}\\n\\n\\tif ( elems.length === 1 && elem.nodeType === 1 ) {\\n\\t\\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\\n\\t}\\n\\n\\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\\n\\t\\treturn elem.nodeType === 1;\\n\\t} ) );\\n};\\n\\njQuery.fn.extend( {\\n\\tfind: function( selector ) {\\n\\t\\tvar i, ret,\\n\\t\\t\\tlen = this.length,\\n\\t\\t\\tself = this;\\n\\n\\t\\tif ( typeof selector !== \\\"string\\\" ) {\\n\\t\\t\\treturn this.pushStack( jQuery( selector ).filter( function() {\\n\\t\\t\\t\\tfor ( i = 0; i < len; i++ ) {\\n\\t\\t\\t\\t\\tif ( jQuery.contains( self[ i ], this ) ) {\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} ) );\\n\\t\\t}\\n\\n\\t\\tret = this.pushStack( [] );\\n\\n\\t\\tfor ( i = 0; i < len; i++ ) {\\n\\t\\t\\tjQuery.find( selector, self[ i ], ret );\\n\\t\\t}\\n\\n\\t\\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\\n\\t},\\n\\tfilter: function( selector ) {\\n\\t\\treturn this.pushStack( winnow( this, selector || [], false ) );\\n\\t},\\n\\tnot: function( selector ) {\\n\\t\\treturn this.pushStack( winnow( this, selector || [], true ) );\\n\\t},\\n\\tis: function( selector ) {\\n\\t\\treturn !!winnow(\\n\\t\\t\\tthis,\\n\\n\\t\\t\\t// If this is a positional/relative selector, check membership in the returned set\\n\\t\\t\\t// so $(\\\"p:first\\\").is(\\\"p:last\\\") won't return true for a doc with two \\\"p\\\".\\n\\t\\t\\ttypeof selector === \\\"string\\\" && rneedsContext.test( selector ) ?\\n\\t\\t\\t\\tjQuery( selector ) :\\n\\t\\t\\t\\tselector || [],\\n\\t\\t\\tfalse\\n\\t\\t).length;\\n\\t}\\n} );\\n\\n\\n// Initialize a jQuery object\\n\\n\\n// A central reference to the root jQuery(document)\\nvar rootjQuery,\\n\\n\\t// A simple way to check for HTML strings\\n\\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\\n\\t// Strict HTML recognition (#11290: must start with <)\\n\\t// Shortcut simple #id case for speed\\n\\trquickExpr = /^(?:\\\\s*(<[\\\\w\\\\W]+>)[^>]*|#([\\\\w-]+))$/,\\n\\n\\tinit = jQuery.fn.init = function( selector, context, root ) {\\n\\t\\tvar match, elem;\\n\\n\\t\\t// HANDLE: $(\\\"\\\"), $(null), $(undefined), $(false)\\n\\t\\tif ( !selector ) {\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\n\\t\\t// Method init() accepts an alternate rootjQuery\\n\\t\\t// so migrate can support jQuery.sub (gh-2101)\\n\\t\\troot = root || rootjQuery;\\n\\n\\t\\t// Handle HTML strings\\n\\t\\tif ( typeof selector === \\\"string\\\" ) {\\n\\t\\t\\tif ( selector[ 0 ] === \\\"<\\\" &&\\n\\t\\t\\t\\tselector[ selector.length - 1 ] === \\\">\\\" &&\\n\\t\\t\\t\\tselector.length >= 3 ) {\\n\\n\\t\\t\\t\\t// Assume that strings that start and end with <> are HTML and skip the regex check\\n\\t\\t\\t\\tmatch = [ null, selector, null ];\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmatch = rquickExpr.exec( selector );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Match html or make sure no context is specified for #id\\n\\t\\t\\tif ( match && ( match[ 1 ] || !context ) ) {\\n\\n\\t\\t\\t\\t// HANDLE: $(html) -> $(array)\\n\\t\\t\\t\\tif ( match[ 1 ] ) {\\n\\t\\t\\t\\t\\tcontext = context instanceof jQuery ? context[ 0 ] : context;\\n\\n\\t\\t\\t\\t\\t// Option to run scripts is true for back-compat\\n\\t\\t\\t\\t\\t// Intentionally let the error be thrown if parseHTML is not present\\n\\t\\t\\t\\t\\tjQuery.merge( this, jQuery.parseHTML(\\n\\t\\t\\t\\t\\t\\tmatch[ 1 ],\\n\\t\\t\\t\\t\\t\\tcontext && context.nodeType ? context.ownerDocument || context : document,\\n\\t\\t\\t\\t\\t\\ttrue\\n\\t\\t\\t\\t\\t) );\\n\\n\\t\\t\\t\\t\\t// HANDLE: $(html, props)\\n\\t\\t\\t\\t\\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\\n\\t\\t\\t\\t\\t\\tfor ( match in context ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Properties of context are called as methods if possible\\n\\t\\t\\t\\t\\t\\t\\tif ( isFunction( this[ match ] ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tthis[ match ]( context[ match ] );\\n\\n\\t\\t\\t\\t\\t\\t\\t// ...and otherwise set as attributes\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tthis.attr( match, context[ match ] );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t\\t// HANDLE: $(#id)\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\telem = document.getElementById( match[ 2 ] );\\n\\n\\t\\t\\t\\t\\tif ( elem ) {\\n\\n\\t\\t\\t\\t\\t\\t// Inject the element directly into the jQuery object\\n\\t\\t\\t\\t\\t\\tthis[ 0 ] = elem;\\n\\t\\t\\t\\t\\t\\tthis.length = 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t// HANDLE: $(expr, $(...))\\n\\t\\t\\t} else if ( !context || context.jquery ) {\\n\\t\\t\\t\\treturn ( context || root ).find( selector );\\n\\n\\t\\t\\t// HANDLE: $(expr, context)\\n\\t\\t\\t// (which is just equivalent to: $(context).find(expr)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn this.constructor( context ).find( selector );\\n\\t\\t\\t}\\n\\n\\t\\t// HANDLE: $(DOMElement)\\n\\t\\t} else if ( selector.nodeType ) {\\n\\t\\t\\tthis[ 0 ] = selector;\\n\\t\\t\\tthis.length = 1;\\n\\t\\t\\treturn this;\\n\\n\\t\\t// HANDLE: $(function)\\n\\t\\t// Shortcut for document ready\\n\\t\\t} else if ( isFunction( selector ) ) {\\n\\t\\t\\treturn root.ready !== undefined ?\\n\\t\\t\\t\\troot.ready( selector ) :\\n\\n\\t\\t\\t\\t// Execute immediately if ready is not present\\n\\t\\t\\t\\tselector( jQuery );\\n\\t\\t}\\n\\n\\t\\treturn jQuery.makeArray( selector, this );\\n\\t};\\n\\n// Give the init function the jQuery prototype for later instantiation\\ninit.prototype = jQuery.fn;\\n\\n// Initialize central reference\\nrootjQuery = jQuery( document );\\n\\n\\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\\n\\n\\t// Methods guaranteed to produce a unique set when starting from a unique set\\n\\tguaranteedUnique = {\\n\\t\\tchildren: true,\\n\\t\\tcontents: true,\\n\\t\\tnext: true,\\n\\t\\tprev: true\\n\\t};\\n\\njQuery.fn.extend( {\\n\\thas: function( target ) {\\n\\t\\tvar targets = jQuery( target, this ),\\n\\t\\t\\tl = targets.length;\\n\\n\\t\\treturn this.filter( function() {\\n\\t\\t\\tvar i = 0;\\n\\t\\t\\tfor ( ; i < l; i++ ) {\\n\\t\\t\\t\\tif ( jQuery.contains( this, targets[ i ] ) ) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tclosest: function( selectors, context ) {\\n\\t\\tvar cur,\\n\\t\\t\\ti = 0,\\n\\t\\t\\tl = this.length,\\n\\t\\t\\tmatched = [],\\n\\t\\t\\ttargets = typeof selectors !== \\\"string\\\" && jQuery( selectors );\\n\\n\\t\\t// Positional selectors never match, since there's no _selection_ context\\n\\t\\tif ( !rneedsContext.test( selectors ) ) {\\n\\t\\t\\tfor ( ; i < l; i++ ) {\\n\\t\\t\\t\\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\\n\\n\\t\\t\\t\\t\\t// Always skip document fragments\\n\\t\\t\\t\\t\\tif ( cur.nodeType < 11 && ( targets ?\\n\\t\\t\\t\\t\\t\\ttargets.index( cur ) > -1 :\\n\\n\\t\\t\\t\\t\\t\\t// Don't pass non-elements to Sizzle\\n\\t\\t\\t\\t\\t\\tcur.nodeType === 1 &&\\n\\t\\t\\t\\t\\t\\t\\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\\n\\n\\t\\t\\t\\t\\t\\tmatched.push( cur );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\\n\\t},\\n\\n\\t// Determine the position of an element within the set\\n\\tindex: function( elem ) {\\n\\n\\t\\t// No argument, return index in parent\\n\\t\\tif ( !elem ) {\\n\\t\\t\\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\\n\\t\\t}\\n\\n\\t\\t// Index in selector\\n\\t\\tif ( typeof elem === \\\"string\\\" ) {\\n\\t\\t\\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\\n\\t\\t}\\n\\n\\t\\t// Locate the position of the desired element\\n\\t\\treturn indexOf.call( this,\\n\\n\\t\\t\\t// If it receives a jQuery object, the first element is used\\n\\t\\t\\telem.jquery ? elem[ 0 ] : elem\\n\\t\\t);\\n\\t},\\n\\n\\tadd: function( selector, context ) {\\n\\t\\treturn this.pushStack(\\n\\t\\t\\tjQuery.uniqueSort(\\n\\t\\t\\t\\tjQuery.merge( this.get(), jQuery( selector, context ) )\\n\\t\\t\\t)\\n\\t\\t);\\n\\t},\\n\\n\\taddBack: function( selector ) {\\n\\t\\treturn this.add( selector == null ?\\n\\t\\t\\tthis.prevObject : this.prevObject.filter( selector )\\n\\t\\t);\\n\\t}\\n} );\\n\\nfunction sibling( cur, dir ) {\\n\\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\\n\\treturn cur;\\n}\\n\\njQuery.each( {\\n\\tparent: function( elem ) {\\n\\t\\tvar parent = elem.parentNode;\\n\\t\\treturn parent && parent.nodeType !== 11 ? parent : null;\\n\\t},\\n\\tparents: function( elem ) {\\n\\t\\treturn dir( elem, \\\"parentNode\\\" );\\n\\t},\\n\\tparentsUntil: function( elem, i, until ) {\\n\\t\\treturn dir( elem, \\\"parentNode\\\", until );\\n\\t},\\n\\tnext: function( elem ) {\\n\\t\\treturn sibling( elem, \\\"nextSibling\\\" );\\n\\t},\\n\\tprev: function( elem ) {\\n\\t\\treturn sibling( elem, \\\"previousSibling\\\" );\\n\\t},\\n\\tnextAll: function( elem ) {\\n\\t\\treturn dir( elem, \\\"nextSibling\\\" );\\n\\t},\\n\\tprevAll: function( elem ) {\\n\\t\\treturn dir( elem, \\\"previousSibling\\\" );\\n\\t},\\n\\tnextUntil: function( elem, i, until ) {\\n\\t\\treturn dir( elem, \\\"nextSibling\\\", until );\\n\\t},\\n\\tprevUntil: function( elem, i, until ) {\\n\\t\\treturn dir( elem, \\\"previousSibling\\\", until );\\n\\t},\\n\\tsiblings: function( elem ) {\\n\\t\\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\\n\\t},\\n\\tchildren: function( elem ) {\\n\\t\\treturn siblings( elem.firstChild );\\n\\t},\\n\\tcontents: function( elem ) {\\n        if ( nodeName( elem, \\\"iframe\\\" ) ) {\\n            return elem.contentDocument;\\n        }\\n\\n        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\\n        // Treat the template element as a regular one in browsers that\\n        // don't support it.\\n        if ( nodeName( elem, \\\"template\\\" ) ) {\\n            elem = elem.content || elem;\\n        }\\n\\n        return jQuery.merge( [], elem.childNodes );\\n\\t}\\n}, function( name, fn ) {\\n\\tjQuery.fn[ name ] = function( until, selector ) {\\n\\t\\tvar matched = jQuery.map( this, fn, until );\\n\\n\\t\\tif ( name.slice( -5 ) !== \\\"Until\\\" ) {\\n\\t\\t\\tselector = until;\\n\\t\\t}\\n\\n\\t\\tif ( selector && typeof selector === \\\"string\\\" ) {\\n\\t\\t\\tmatched = jQuery.filter( selector, matched );\\n\\t\\t}\\n\\n\\t\\tif ( this.length > 1 ) {\\n\\n\\t\\t\\t// Remove duplicates\\n\\t\\t\\tif ( !guaranteedUnique[ name ] ) {\\n\\t\\t\\t\\tjQuery.uniqueSort( matched );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Reverse order for parents* and prev-derivatives\\n\\t\\t\\tif ( rparentsprev.test( name ) ) {\\n\\t\\t\\t\\tmatched.reverse();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this.pushStack( matched );\\n\\t};\\n} );\\nvar rnothtmlwhite = ( /[^\\\\x20\\\\t\\\\r\\\\n\\\\f]+/g );\\n\\n\\n\\n// Convert String-formatted options into Object-formatted ones\\nfunction createOptions( options ) {\\n\\tvar object = {};\\n\\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\\n\\t\\tobject[ flag ] = true;\\n\\t} );\\n\\treturn object;\\n}\\n\\n/*\\n * Create a callback list using the following parameters:\\n *\\n *\\toptions: an optional list of space-separated options that will change how\\n *\\t\\t\\tthe callback list behaves or a more traditional option object\\n *\\n * By default a callback list will act like an event callback list and can be\\n * \\\"fired\\\" multiple times.\\n *\\n * Possible options:\\n *\\n *\\tonce:\\t\\t\\twill ensure the callback list can only be fired once (like a Deferred)\\n *\\n *\\tmemory:\\t\\t\\twill keep track of previous values and will call any callback added\\n *\\t\\t\\t\\t\\tafter the list has been fired right away with the latest \\\"memorized\\\"\\n *\\t\\t\\t\\t\\tvalues (like a Deferred)\\n *\\n *\\tunique:\\t\\t\\twill ensure a callback can only be added once (no duplicate in the list)\\n *\\n *\\tstopOnFalse:\\tinterrupt callings when a callback returns false\\n *\\n */\\njQuery.Callbacks = function( options ) {\\n\\n\\t// Convert options from String-formatted to Object-formatted if needed\\n\\t// (we check in cache first)\\n\\toptions = typeof options === \\\"string\\\" ?\\n\\t\\tcreateOptions( options ) :\\n\\t\\tjQuery.extend( {}, options );\\n\\n\\tvar // Flag to know if list is currently firing\\n\\t\\tfiring,\\n\\n\\t\\t// Last fire value for non-forgettable lists\\n\\t\\tmemory,\\n\\n\\t\\t// Flag to know if list was already fired\\n\\t\\tfired,\\n\\n\\t\\t// Flag to prevent firing\\n\\t\\tlocked,\\n\\n\\t\\t// Actual callback list\\n\\t\\tlist = [],\\n\\n\\t\\t// Queue of execution data for repeatable lists\\n\\t\\tqueue = [],\\n\\n\\t\\t// Index of currently firing callback (modified by add/remove as needed)\\n\\t\\tfiringIndex = -1,\\n\\n\\t\\t// Fire callbacks\\n\\t\\tfire = function() {\\n\\n\\t\\t\\t// Enforce single-firing\\n\\t\\t\\tlocked = locked || options.once;\\n\\n\\t\\t\\t// Execute callbacks for all pending executions,\\n\\t\\t\\t// respecting firingIndex overrides and runtime changes\\n\\t\\t\\tfired = firing = true;\\n\\t\\t\\tfor ( ; queue.length; firingIndex = -1 ) {\\n\\t\\t\\t\\tmemory = queue.shift();\\n\\t\\t\\t\\twhile ( ++firingIndex < list.length ) {\\n\\n\\t\\t\\t\\t\\t// Run callback and check for early termination\\n\\t\\t\\t\\t\\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\\n\\t\\t\\t\\t\\t\\toptions.stopOnFalse ) {\\n\\n\\t\\t\\t\\t\\t\\t// Jump to end and forget the data so .add doesn't re-fire\\n\\t\\t\\t\\t\\t\\tfiringIndex = list.length;\\n\\t\\t\\t\\t\\t\\tmemory = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Forget the data if we're done with it\\n\\t\\t\\tif ( !options.memory ) {\\n\\t\\t\\t\\tmemory = false;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfiring = false;\\n\\n\\t\\t\\t// Clean up if we're done firing for good\\n\\t\\t\\tif ( locked ) {\\n\\n\\t\\t\\t\\t// Keep an empty list if we have data for future add calls\\n\\t\\t\\t\\tif ( memory ) {\\n\\t\\t\\t\\t\\tlist = [];\\n\\n\\t\\t\\t\\t// Otherwise, this object is spent\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tlist = \\\"\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\t// Actual Callbacks object\\n\\t\\tself = {\\n\\n\\t\\t\\t// Add a callback or a collection of callbacks to the list\\n\\t\\t\\tadd: function() {\\n\\t\\t\\t\\tif ( list ) {\\n\\n\\t\\t\\t\\t\\t// If we have memory from a past run, we should fire after adding\\n\\t\\t\\t\\t\\tif ( memory && !firing ) {\\n\\t\\t\\t\\t\\t\\tfiringIndex = list.length - 1;\\n\\t\\t\\t\\t\\t\\tqueue.push( memory );\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t( function add( args ) {\\n\\t\\t\\t\\t\\t\\tjQuery.each( args, function( _, arg ) {\\n\\t\\t\\t\\t\\t\\t\\tif ( isFunction( arg ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( !options.unique || !self.has( arg ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tlist.push( arg );\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t} else if ( arg && arg.length && toType( arg ) !== \\\"string\\\" ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Inspect recursively\\n\\t\\t\\t\\t\\t\\t\\t\\tadd( arg );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t} )( arguments );\\n\\n\\t\\t\\t\\t\\tif ( memory && !firing ) {\\n\\t\\t\\t\\t\\t\\tfire();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Remove a callback from the list\\n\\t\\t\\tremove: function() {\\n\\t\\t\\t\\tjQuery.each( arguments, function( _, arg ) {\\n\\t\\t\\t\\t\\tvar index;\\n\\t\\t\\t\\t\\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\\n\\t\\t\\t\\t\\t\\tlist.splice( index, 1 );\\n\\n\\t\\t\\t\\t\\t\\t// Handle firing indexes\\n\\t\\t\\t\\t\\t\\tif ( index <= firingIndex ) {\\n\\t\\t\\t\\t\\t\\t\\tfiringIndex--;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} );\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Check if a given callback is in the list.\\n\\t\\t\\t// If no argument is given, return whether or not list has callbacks attached.\\n\\t\\t\\thas: function( fn ) {\\n\\t\\t\\t\\treturn fn ?\\n\\t\\t\\t\\t\\tjQuery.inArray( fn, list ) > -1 :\\n\\t\\t\\t\\t\\tlist.length > 0;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Remove all callbacks from the list\\n\\t\\t\\tempty: function() {\\n\\t\\t\\t\\tif ( list ) {\\n\\t\\t\\t\\t\\tlist = [];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Disable .fire and .add\\n\\t\\t\\t// Abort any current/pending executions\\n\\t\\t\\t// Clear all callbacks and values\\n\\t\\t\\tdisable: function() {\\n\\t\\t\\t\\tlocked = queue = [];\\n\\t\\t\\t\\tlist = memory = \\\"\\\";\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\t\\t\\tdisabled: function() {\\n\\t\\t\\t\\treturn !list;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Disable .fire\\n\\t\\t\\t// Also disable .add unless we have memory (since it would have no effect)\\n\\t\\t\\t// Abort any pending executions\\n\\t\\t\\tlock: function() {\\n\\t\\t\\t\\tlocked = queue = [];\\n\\t\\t\\t\\tif ( !memory && !firing ) {\\n\\t\\t\\t\\t\\tlist = memory = \\\"\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\t\\t\\tlocked: function() {\\n\\t\\t\\t\\treturn !!locked;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Call all callbacks with the given context and arguments\\n\\t\\t\\tfireWith: function( context, args ) {\\n\\t\\t\\t\\tif ( !locked ) {\\n\\t\\t\\t\\t\\targs = args || [];\\n\\t\\t\\t\\t\\targs = [ context, args.slice ? args.slice() : args ];\\n\\t\\t\\t\\t\\tqueue.push( args );\\n\\t\\t\\t\\t\\tif ( !firing ) {\\n\\t\\t\\t\\t\\t\\tfire();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Call all the callbacks with the given arguments\\n\\t\\t\\tfire: function() {\\n\\t\\t\\t\\tself.fireWith( this, arguments );\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// To know if the callbacks have already been called at least once\\n\\t\\t\\tfired: function() {\\n\\t\\t\\t\\treturn !!fired;\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\treturn self;\\n};\\n\\n\\nfunction Identity( v ) {\\n\\treturn v;\\n}\\nfunction Thrower( ex ) {\\n\\tthrow ex;\\n}\\n\\nfunction adoptValue( value, resolve, reject, noValue ) {\\n\\tvar method;\\n\\n\\ttry {\\n\\n\\t\\t// Check for promise aspect first to privilege synchronous behavior\\n\\t\\tif ( value && isFunction( ( method = value.promise ) ) ) {\\n\\t\\t\\tmethod.call( value ).done( resolve ).fail( reject );\\n\\n\\t\\t// Other thenables\\n\\t\\t} else if ( value && isFunction( ( method = value.then ) ) ) {\\n\\t\\t\\tmethod.call( value, resolve, reject );\\n\\n\\t\\t// Other non-thenables\\n\\t\\t} else {\\n\\n\\t\\t\\t// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\\n\\t\\t\\t// * false: [ value ].slice( 0 ) => resolve( value )\\n\\t\\t\\t// * true: [ value ].slice( 1 ) => resolve()\\n\\t\\t\\tresolve.apply( undefined, [ value ].slice( noValue ) );\\n\\t\\t}\\n\\n\\t// For Promises/A+, convert exceptions into rejections\\n\\t// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\\n\\t// Deferred#then to conditionally suppress rejection.\\n\\t} catch ( value ) {\\n\\n\\t\\t// Support: Android 4.0 only\\n\\t\\t// Strict mode functions invoked without .call/.apply get global-object context\\n\\t\\treject.apply( undefined, [ value ] );\\n\\t}\\n}\\n\\njQuery.extend( {\\n\\n\\tDeferred: function( func ) {\\n\\t\\tvar tuples = [\\n\\n\\t\\t\\t\\t// action, add listener, callbacks,\\n\\t\\t\\t\\t// ... .then handlers, argument index, [final state]\\n\\t\\t\\t\\t[ \\\"notify\\\", \\\"progress\\\", jQuery.Callbacks( \\\"memory\\\" ),\\n\\t\\t\\t\\t\\tjQuery.Callbacks( \\\"memory\\\" ), 2 ],\\n\\t\\t\\t\\t[ \\\"resolve\\\", \\\"done\\\", jQuery.Callbacks( \\\"once memory\\\" ),\\n\\t\\t\\t\\t\\tjQuery.Callbacks( \\\"once memory\\\" ), 0, \\\"resolved\\\" ],\\n\\t\\t\\t\\t[ \\\"reject\\\", \\\"fail\\\", jQuery.Callbacks( \\\"once memory\\\" ),\\n\\t\\t\\t\\t\\tjQuery.Callbacks( \\\"once memory\\\" ), 1, \\\"rejected\\\" ]\\n\\t\\t\\t],\\n\\t\\t\\tstate = \\\"pending\\\",\\n\\t\\t\\tpromise = {\\n\\t\\t\\t\\tstate: function() {\\n\\t\\t\\t\\t\\treturn state;\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\talways: function() {\\n\\t\\t\\t\\t\\tdeferred.done( arguments ).fail( arguments );\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\\"catch\\\": function( fn ) {\\n\\t\\t\\t\\t\\treturn promise.then( null, fn );\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Keep pipe for back-compat\\n\\t\\t\\t\\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\\n\\t\\t\\t\\t\\tvar fns = arguments;\\n\\n\\t\\t\\t\\t\\treturn jQuery.Deferred( function( newDefer ) {\\n\\t\\t\\t\\t\\t\\tjQuery.each( tuples, function( i, tuple ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\\n\\t\\t\\t\\t\\t\\t\\tvar fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\\n\\n\\t\\t\\t\\t\\t\\t\\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\\n\\t\\t\\t\\t\\t\\t\\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\\n\\t\\t\\t\\t\\t\\t\\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\\n\\t\\t\\t\\t\\t\\t\\tdeferred[ tuple[ 1 ] ]( function() {\\n\\t\\t\\t\\t\\t\\t\\t\\tvar returned = fn && fn.apply( this, arguments );\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( returned && isFunction( returned.promise ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturned.promise()\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t.progress( newDefer.notify )\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t.done( newDefer.resolve )\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t.fail( newDefer.reject );\\n\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnewDefer[ tuple[ 0 ] + \\\"With\\\" ](\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthis,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfn ? [ returned ] : arguments\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t\\tfns = null;\\n\\t\\t\\t\\t\\t} ).promise();\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tthen: function( onFulfilled, onRejected, onProgress ) {\\n\\t\\t\\t\\t\\tvar maxDepth = 0;\\n\\t\\t\\t\\t\\tfunction resolve( depth, deferred, handler, special ) {\\n\\t\\t\\t\\t\\t\\treturn function() {\\n\\t\\t\\t\\t\\t\\t\\tvar that = this,\\n\\t\\t\\t\\t\\t\\t\\t\\targs = arguments,\\n\\t\\t\\t\\t\\t\\t\\t\\tmightThrow = function() {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tvar returned, then;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.3.3.3\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-59\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Ignore double-resolution attempts\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( depth < maxDepth ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturned = handler.apply( that, args );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-48\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( returned === deferred.promise() ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthrow new TypeError( \\\"Thenable self-resolution\\\" );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ sections 2.3.3.1, 3.5\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-54\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-75\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Retrieve `then` only once\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tthen = returned &&\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.4\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-64\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Only check objects and functions for thenability\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t( typeof returned === \\\"object\\\" ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttypeof returned === \\\"function\\\" ) &&\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturned.then;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Handle a returned thenable\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( isFunction( then ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Special processors (notify) just wait for resolution\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( special ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthen.call(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturned,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Identity, special ),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Thrower, special )\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Normal processors (resolve) also hook into progress\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// ...and disregard older resolution values\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tmaxDepth++;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthen.call(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturned,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Identity, special ),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Thrower, special ),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Identity,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tdeferred.notifyWith )\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Handle all other returned values\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Only substitute handlers pass on context\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// and multiple values (non-spec behavior)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( handler !== Identity ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthat = undefined;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\targs = [ returned ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Process the value(s)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Default process is resolve\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t( special || deferred.resolveWith )( that, args );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Only normal processors (resolve) catch and reject exceptions\\n\\t\\t\\t\\t\\t\\t\\t\\tprocess = special ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tmightThrow :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tfunction() {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tmightThrow();\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t} catch ( e ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( jQuery.Deferred.exceptionHook ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tjQuery.Deferred.exceptionHook( e,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tprocess.stackTrace );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.3.3.4.1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-61\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Ignore post-resolution exceptions\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( depth + 1 >= maxDepth ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Only substitute handlers pass on context\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// and multiple values (non-spec behavior)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( handler !== Thrower ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthat = undefined;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\targs = [ e ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tdeferred.rejectWith( that, args );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.3.3.1\\n\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-57\\n\\t\\t\\t\\t\\t\\t\\t// Re-resolve promises immediately to dodge false rejection from\\n\\t\\t\\t\\t\\t\\t\\t// subsequent errors\\n\\t\\t\\t\\t\\t\\t\\tif ( depth ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tprocess();\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Call an optional hook to record the stack, in case of exception\\n\\t\\t\\t\\t\\t\\t\\t\\t// since it's otherwise lost when execution goes async\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( jQuery.Deferred.getStackHook ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tprocess.stackTrace = jQuery.Deferred.getStackHook();\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\twindow.setTimeout( process );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn jQuery.Deferred( function( newDefer ) {\\n\\n\\t\\t\\t\\t\\t\\t// progress_handlers.add( ... )\\n\\t\\t\\t\\t\\t\\ttuples[ 0 ][ 3 ].add(\\n\\t\\t\\t\\t\\t\\t\\tresolve(\\n\\t\\t\\t\\t\\t\\t\\t\\t0,\\n\\t\\t\\t\\t\\t\\t\\t\\tnewDefer,\\n\\t\\t\\t\\t\\t\\t\\t\\tisFunction( onProgress ) ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tonProgress :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tIdentity,\\n\\t\\t\\t\\t\\t\\t\\t\\tnewDefer.notifyWith\\n\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t// fulfilled_handlers.add( ... )\\n\\t\\t\\t\\t\\t\\ttuples[ 1 ][ 3 ].add(\\n\\t\\t\\t\\t\\t\\t\\tresolve(\\n\\t\\t\\t\\t\\t\\t\\t\\t0,\\n\\t\\t\\t\\t\\t\\t\\t\\tnewDefer,\\n\\t\\t\\t\\t\\t\\t\\t\\tisFunction( onFulfilled ) ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tonFulfilled :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tIdentity\\n\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t// rejected_handlers.add( ... )\\n\\t\\t\\t\\t\\t\\ttuples[ 2 ][ 3 ].add(\\n\\t\\t\\t\\t\\t\\t\\tresolve(\\n\\t\\t\\t\\t\\t\\t\\t\\t0,\\n\\t\\t\\t\\t\\t\\t\\t\\tnewDefer,\\n\\t\\t\\t\\t\\t\\t\\t\\tisFunction( onRejected ) ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tonRejected :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tThrower\\n\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t} ).promise();\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Get a promise for this deferred\\n\\t\\t\\t\\t// If obj is provided, the promise aspect is added to the object\\n\\t\\t\\t\\tpromise: function( obj ) {\\n\\t\\t\\t\\t\\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tdeferred = {};\\n\\n\\t\\t// Add list-specific methods\\n\\t\\tjQuery.each( tuples, function( i, tuple ) {\\n\\t\\t\\tvar list = tuple[ 2 ],\\n\\t\\t\\t\\tstateString = tuple[ 5 ];\\n\\n\\t\\t\\t// promise.progress = list.add\\n\\t\\t\\t// promise.done = list.add\\n\\t\\t\\t// promise.fail = list.add\\n\\t\\t\\tpromise[ tuple[ 1 ] ] = list.add;\\n\\n\\t\\t\\t// Handle state\\n\\t\\t\\tif ( stateString ) {\\n\\t\\t\\t\\tlist.add(\\n\\t\\t\\t\\t\\tfunction() {\\n\\n\\t\\t\\t\\t\\t\\t// state = \\\"resolved\\\" (i.e., fulfilled)\\n\\t\\t\\t\\t\\t\\t// state = \\\"rejected\\\"\\n\\t\\t\\t\\t\\t\\tstate = stateString;\\n\\t\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t\\t// rejected_callbacks.disable\\n\\t\\t\\t\\t\\t// fulfilled_callbacks.disable\\n\\t\\t\\t\\t\\ttuples[ 3 - i ][ 2 ].disable,\\n\\n\\t\\t\\t\\t\\t// rejected_handlers.disable\\n\\t\\t\\t\\t\\t// fulfilled_handlers.disable\\n\\t\\t\\t\\t\\ttuples[ 3 - i ][ 3 ].disable,\\n\\n\\t\\t\\t\\t\\t// progress_callbacks.lock\\n\\t\\t\\t\\t\\ttuples[ 0 ][ 2 ].lock,\\n\\n\\t\\t\\t\\t\\t// progress_handlers.lock\\n\\t\\t\\t\\t\\ttuples[ 0 ][ 3 ].lock\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// progress_handlers.fire\\n\\t\\t\\t// fulfilled_handlers.fire\\n\\t\\t\\t// rejected_handlers.fire\\n\\t\\t\\tlist.add( tuple[ 3 ].fire );\\n\\n\\t\\t\\t// deferred.notify = function() { deferred.notifyWith(...) }\\n\\t\\t\\t// deferred.resolve = function() { deferred.resolveWith(...) }\\n\\t\\t\\t// deferred.reject = function() { deferred.rejectWith(...) }\\n\\t\\t\\tdeferred[ tuple[ 0 ] ] = function() {\\n\\t\\t\\t\\tdeferred[ tuple[ 0 ] + \\\"With\\\" ]( this === deferred ? undefined : this, arguments );\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t};\\n\\n\\t\\t\\t// deferred.notifyWith = list.fireWith\\n\\t\\t\\t// deferred.resolveWith = list.fireWith\\n\\t\\t\\t// deferred.rejectWith = list.fireWith\\n\\t\\t\\tdeferred[ tuple[ 0 ] + \\\"With\\\" ] = list.fireWith;\\n\\t\\t} );\\n\\n\\t\\t// Make the deferred a promise\\n\\t\\tpromise.promise( deferred );\\n\\n\\t\\t// Call given func if any\\n\\t\\tif ( func ) {\\n\\t\\t\\tfunc.call( deferred, deferred );\\n\\t\\t}\\n\\n\\t\\t// All done!\\n\\t\\treturn deferred;\\n\\t},\\n\\n\\t// Deferred helper\\n\\twhen: function( singleValue ) {\\n\\t\\tvar\\n\\n\\t\\t\\t// count of uncompleted subordinates\\n\\t\\t\\tremaining = arguments.length,\\n\\n\\t\\t\\t// count of unprocessed arguments\\n\\t\\t\\ti = remaining,\\n\\n\\t\\t\\t// subordinate fulfillment data\\n\\t\\t\\tresolveContexts = Array( i ),\\n\\t\\t\\tresolveValues = slice.call( arguments ),\\n\\n\\t\\t\\t// the master Deferred\\n\\t\\t\\tmaster = jQuery.Deferred(),\\n\\n\\t\\t\\t// subordinate callback factory\\n\\t\\t\\tupdateFunc = function( i ) {\\n\\t\\t\\t\\treturn function( value ) {\\n\\t\\t\\t\\t\\tresolveContexts[ i ] = this;\\n\\t\\t\\t\\t\\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\\n\\t\\t\\t\\t\\tif ( !( --remaining ) ) {\\n\\t\\t\\t\\t\\t\\tmaster.resolveWith( resolveContexts, resolveValues );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t};\\n\\t\\t\\t};\\n\\n\\t\\t// Single- and empty arguments are adopted like Promise.resolve\\n\\t\\tif ( remaining <= 1 ) {\\n\\t\\t\\tadoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,\\n\\t\\t\\t\\t!remaining );\\n\\n\\t\\t\\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\\n\\t\\t\\tif ( master.state() === \\\"pending\\\" ||\\n\\t\\t\\t\\tisFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\\n\\n\\t\\t\\t\\treturn master.then();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Multiple arguments are aggregated like Promise.all array elements\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\tadoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\\n\\t\\t}\\n\\n\\t\\treturn master.promise();\\n\\t}\\n} );\\n\\n\\n// These usually indicate a programmer mistake during development,\\n// warn about them ASAP rather than swallowing them by default.\\nvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\\n\\njQuery.Deferred.exceptionHook = function( error, stack ) {\\n\\n\\t// Support: IE 8 - 9 only\\n\\t// Console exists when dev tools are open, which can happen at any time\\n\\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\\n\\t\\twindow.console.warn( \\\"jQuery.Deferred exception: \\\" + error.message, error.stack, stack );\\n\\t}\\n};\\n\\n\\n\\n\\njQuery.readyException = function( error ) {\\n\\twindow.setTimeout( function() {\\n\\t\\tthrow error;\\n\\t} );\\n};\\n\\n\\n\\n\\n// The deferred used on DOM ready\\nvar readyList = jQuery.Deferred();\\n\\njQuery.fn.ready = function( fn ) {\\n\\n\\treadyList\\n\\t\\t.then( fn )\\n\\n\\t\\t// Wrap jQuery.readyException in a function so that the lookup\\n\\t\\t// happens at the time of error handling instead of callback\\n\\t\\t// registration.\\n\\t\\t.catch( function( error ) {\\n\\t\\t\\tjQuery.readyException( error );\\n\\t\\t} );\\n\\n\\treturn this;\\n};\\n\\njQuery.extend( {\\n\\n\\t// Is the DOM ready to be used? Set to true once it occurs.\\n\\tisReady: false,\\n\\n\\t// A counter to track how many items to wait for before\\n\\t// the ready event fires. See #6781\\n\\treadyWait: 1,\\n\\n\\t// Handle when the DOM is ready\\n\\tready: function( wait ) {\\n\\n\\t\\t// Abort if there are pending holds or we're already ready\\n\\t\\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Remember that the DOM is ready\\n\\t\\tjQuery.isReady = true;\\n\\n\\t\\t// If a normal DOM Ready event fired, decrement, and wait if need be\\n\\t\\tif ( wait !== true && --jQuery.readyWait > 0 ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// If there are functions bound, to execute\\n\\t\\treadyList.resolveWith( document, [ jQuery ] );\\n\\t}\\n} );\\n\\njQuery.ready.then = readyList.then;\\n\\n// The ready event handler and self cleanup method\\nfunction completed() {\\n\\tdocument.removeEventListener( \\\"DOMContentLoaded\\\", completed );\\n\\twindow.removeEventListener( \\\"load\\\", completed );\\n\\tjQuery.ready();\\n}\\n\\n// Catch cases where $(document).ready() is called\\n// after the browser event has already occurred.\\n// Support: IE <=9 - 10 only\\n// Older IE sometimes signals \\\"interactive\\\" too soon\\nif ( document.readyState === \\\"complete\\\" ||\\n\\t( document.readyState !== \\\"loading\\\" && !document.documentElement.doScroll ) ) {\\n\\n\\t// Handle it asynchronously to allow scripts the opportunity to delay ready\\n\\twindow.setTimeout( jQuery.ready );\\n\\n} else {\\n\\n\\t// Use the handy event callback\\n\\tdocument.addEventListener( \\\"DOMContentLoaded\\\", completed );\\n\\n\\t// A fallback to window.onload, that will always work\\n\\twindow.addEventListener( \\\"load\\\", completed );\\n}\\n\\n\\n\\n\\n// Multifunctional method to get and set values of a collection\\n// The value/s can optionally be executed if it's a function\\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\\n\\tvar i = 0,\\n\\t\\tlen = elems.length,\\n\\t\\tbulk = key == null;\\n\\n\\t// Sets many values\\n\\tif ( toType( key ) === \\\"object\\\" ) {\\n\\t\\tchainable = true;\\n\\t\\tfor ( i in key ) {\\n\\t\\t\\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\\n\\t\\t}\\n\\n\\t// Sets one value\\n\\t} else if ( value !== undefined ) {\\n\\t\\tchainable = true;\\n\\n\\t\\tif ( !isFunction( value ) ) {\\n\\t\\t\\traw = true;\\n\\t\\t}\\n\\n\\t\\tif ( bulk ) {\\n\\n\\t\\t\\t// Bulk operations run against the entire set\\n\\t\\t\\tif ( raw ) {\\n\\t\\t\\t\\tfn.call( elems, value );\\n\\t\\t\\t\\tfn = null;\\n\\n\\t\\t\\t// ...except when executing function values\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbulk = fn;\\n\\t\\t\\t\\tfn = function( elem, key, value ) {\\n\\t\\t\\t\\t\\treturn bulk.call( jQuery( elem ), value );\\n\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( fn ) {\\n\\t\\t\\tfor ( ; i < len; i++ ) {\\n\\t\\t\\t\\tfn(\\n\\t\\t\\t\\t\\telems[ i ], key, raw ?\\n\\t\\t\\t\\t\\tvalue :\\n\\t\\t\\t\\t\\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif ( chainable ) {\\n\\t\\treturn elems;\\n\\t}\\n\\n\\t// Gets\\n\\tif ( bulk ) {\\n\\t\\treturn fn.call( elems );\\n\\t}\\n\\n\\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\\n};\\n\\n\\n// Matches dashed string for camelizing\\nvar rmsPrefix = /^-ms-/,\\n\\trdashAlpha = /-([a-z])/g;\\n\\n// Used by camelCase as callback to replace()\\nfunction fcamelCase( all, letter ) {\\n\\treturn letter.toUpperCase();\\n}\\n\\n// Convert dashed to camelCase; used by the css and data modules\\n// Support: IE <=9 - 11, Edge 12 - 15\\n// Microsoft forgot to hump their vendor prefix (#9572)\\nfunction camelCase( string ) {\\n\\treturn string.replace( rmsPrefix, \\\"ms-\\\" ).replace( rdashAlpha, fcamelCase );\\n}\\nvar acceptData = function( owner ) {\\n\\n\\t// Accepts only:\\n\\t//  - Node\\n\\t//    - Node.ELEMENT_NODE\\n\\t//    - Node.DOCUMENT_NODE\\n\\t//  - Object\\n\\t//    - Any\\n\\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\\n};\\n\\n\\n\\n\\nfunction Data() {\\n\\tthis.expando = jQuery.expando + Data.uid++;\\n}\\n\\nData.uid = 1;\\n\\nData.prototype = {\\n\\n\\tcache: function( owner ) {\\n\\n\\t\\t// Check if the owner object already has a cache\\n\\t\\tvar value = owner[ this.expando ];\\n\\n\\t\\t// If not, create one\\n\\t\\tif ( !value ) {\\n\\t\\t\\tvalue = {};\\n\\n\\t\\t\\t// We can accept data for non-element nodes in modern browsers,\\n\\t\\t\\t// but we should not, see #8335.\\n\\t\\t\\t// Always return an empty object.\\n\\t\\t\\tif ( acceptData( owner ) ) {\\n\\n\\t\\t\\t\\t// If it is a node unlikely to be stringify-ed or looped over\\n\\t\\t\\t\\t// use plain assignment\\n\\t\\t\\t\\tif ( owner.nodeType ) {\\n\\t\\t\\t\\t\\towner[ this.expando ] = value;\\n\\n\\t\\t\\t\\t// Otherwise secure it in a non-enumerable property\\n\\t\\t\\t\\t// configurable must be true to allow the property to be\\n\\t\\t\\t\\t// deleted when data is removed\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tObject.defineProperty( owner, this.expando, {\\n\\t\\t\\t\\t\\t\\tvalue: value,\\n\\t\\t\\t\\t\\t\\tconfigurable: true\\n\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn value;\\n\\t},\\n\\tset: function( owner, data, value ) {\\n\\t\\tvar prop,\\n\\t\\t\\tcache = this.cache( owner );\\n\\n\\t\\t// Handle: [ owner, key, value ] args\\n\\t\\t// Always use camelCase key (gh-2257)\\n\\t\\tif ( typeof data === \\\"string\\\" ) {\\n\\t\\t\\tcache[ camelCase( data ) ] = value;\\n\\n\\t\\t// Handle: [ owner, { properties } ] args\\n\\t\\t} else {\\n\\n\\t\\t\\t// Copy the properties one-by-one to the cache object\\n\\t\\t\\tfor ( prop in data ) {\\n\\t\\t\\t\\tcache[ camelCase( prop ) ] = data[ prop ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn cache;\\n\\t},\\n\\tget: function( owner, key ) {\\n\\t\\treturn key === undefined ?\\n\\t\\t\\tthis.cache( owner ) :\\n\\n\\t\\t\\t// Always use camelCase key (gh-2257)\\n\\t\\t\\towner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];\\n\\t},\\n\\taccess: function( owner, key, value ) {\\n\\n\\t\\t// In cases where either:\\n\\t\\t//\\n\\t\\t//   1. No key was specified\\n\\t\\t//   2. A string key was specified, but no value provided\\n\\t\\t//\\n\\t\\t// Take the \\\"read\\\" path and allow the get method to determine\\n\\t\\t// which value to return, respectively either:\\n\\t\\t//\\n\\t\\t//   1. The entire cache object\\n\\t\\t//   2. The data stored at the key\\n\\t\\t//\\n\\t\\tif ( key === undefined ||\\n\\t\\t\\t\\t( ( key && typeof key === \\\"string\\\" ) && value === undefined ) ) {\\n\\n\\t\\t\\treturn this.get( owner, key );\\n\\t\\t}\\n\\n\\t\\t// When the key is not a string, or both a key and value\\n\\t\\t// are specified, set or extend (existing objects) with either:\\n\\t\\t//\\n\\t\\t//   1. An object of properties\\n\\t\\t//   2. A key and value\\n\\t\\t//\\n\\t\\tthis.set( owner, key, value );\\n\\n\\t\\t// Since the \\\"set\\\" path can have two possible entry points\\n\\t\\t// return the expected data based on which path was taken[*]\\n\\t\\treturn value !== undefined ? value : key;\\n\\t},\\n\\tremove: function( owner, key ) {\\n\\t\\tvar i,\\n\\t\\t\\tcache = owner[ this.expando ];\\n\\n\\t\\tif ( cache === undefined ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( key !== undefined ) {\\n\\n\\t\\t\\t// Support array or space separated string of keys\\n\\t\\t\\tif ( Array.isArray( key ) ) {\\n\\n\\t\\t\\t\\t// If key is an array of keys...\\n\\t\\t\\t\\t// We always set camelCase keys, so remove that.\\n\\t\\t\\t\\tkey = key.map( camelCase );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tkey = camelCase( key );\\n\\n\\t\\t\\t\\t// If a key with the spaces exists, use it.\\n\\t\\t\\t\\t// Otherwise, create an array by matching non-whitespace\\n\\t\\t\\t\\tkey = key in cache ?\\n\\t\\t\\t\\t\\t[ key ] :\\n\\t\\t\\t\\t\\t( key.match( rnothtmlwhite ) || [] );\\n\\t\\t\\t}\\n\\n\\t\\t\\ti = key.length;\\n\\n\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\tdelete cache[ key[ i ] ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Remove the expando if there's no more data\\n\\t\\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\\n\\n\\t\\t\\t// Support: Chrome <=35 - 45\\n\\t\\t\\t// Webkit & Blink performance suffers when deleting properties\\n\\t\\t\\t// from DOM nodes, so set to undefined instead\\n\\t\\t\\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\\n\\t\\t\\tif ( owner.nodeType ) {\\n\\t\\t\\t\\towner[ this.expando ] = undefined;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdelete owner[ this.expando ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\thasData: function( owner ) {\\n\\t\\tvar cache = owner[ this.expando ];\\n\\t\\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\\n\\t}\\n};\\nvar dataPriv = new Data();\\n\\nvar dataUser = new Data();\\n\\n\\n\\n//\\tImplementation Summary\\n//\\n//\\t1. Enforce API surface and semantic compatibility with 1.9.x branch\\n//\\t2. Improve the module's maintainability by reducing the storage\\n//\\t\\tpaths to a single mechanism.\\n//\\t3. Use the same single mechanism to support \\\"private\\\" and \\\"user\\\" data.\\n//\\t4. _Never_ expose \\\"private\\\" data to user code (TODO: Drop _data, _removeData)\\n//\\t5. Avoid exposing implementation details on user objects (eg. expando properties)\\n//\\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\\n\\nvar rbrace = /^(?:\\\\{[\\\\w\\\\W]*\\\\}|\\\\[[\\\\w\\\\W]*\\\\])$/,\\n\\trmultiDash = /[A-Z]/g;\\n\\nfunction getData( data ) {\\n\\tif ( data === \\\"true\\\" ) {\\n\\t\\treturn true;\\n\\t}\\n\\n\\tif ( data === \\\"false\\\" ) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\tif ( data === \\\"null\\\" ) {\\n\\t\\treturn null;\\n\\t}\\n\\n\\t// Only convert to a number if it doesn't change the string\\n\\tif ( data === +data + \\\"\\\" ) {\\n\\t\\treturn +data;\\n\\t}\\n\\n\\tif ( rbrace.test( data ) ) {\\n\\t\\treturn JSON.parse( data );\\n\\t}\\n\\n\\treturn data;\\n}\\n\\nfunction dataAttr( elem, key, data ) {\\n\\tvar name;\\n\\n\\t// If nothing was found internally, try to fetch any\\n\\t// data from the HTML5 data-* attribute\\n\\tif ( data === undefined && elem.nodeType === 1 ) {\\n\\t\\tname = \\\"data-\\\" + key.replace( rmultiDash, \\\"-$&\\\" ).toLowerCase();\\n\\t\\tdata = elem.getAttribute( name );\\n\\n\\t\\tif ( typeof data === \\\"string\\\" ) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tdata = getData( data );\\n\\t\\t\\t} catch ( e ) {}\\n\\n\\t\\t\\t// Make sure we set the data so it isn't changed later\\n\\t\\t\\tdataUser.set( elem, key, data );\\n\\t\\t} else {\\n\\t\\t\\tdata = undefined;\\n\\t\\t}\\n\\t}\\n\\treturn data;\\n}\\n\\njQuery.extend( {\\n\\thasData: function( elem ) {\\n\\t\\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\\n\\t},\\n\\n\\tdata: function( elem, name, data ) {\\n\\t\\treturn dataUser.access( elem, name, data );\\n\\t},\\n\\n\\tremoveData: function( elem, name ) {\\n\\t\\tdataUser.remove( elem, name );\\n\\t},\\n\\n\\t// TODO: Now that all calls to _data and _removeData have been replaced\\n\\t// with direct calls to dataPriv methods, these can be deprecated.\\n\\t_data: function( elem, name, data ) {\\n\\t\\treturn dataPriv.access( elem, name, data );\\n\\t},\\n\\n\\t_removeData: function( elem, name ) {\\n\\t\\tdataPriv.remove( elem, name );\\n\\t}\\n} );\\n\\njQuery.fn.extend( {\\n\\tdata: function( key, value ) {\\n\\t\\tvar i, name, data,\\n\\t\\t\\telem = this[ 0 ],\\n\\t\\t\\tattrs = elem && elem.attributes;\\n\\n\\t\\t// Gets all values\\n\\t\\tif ( key === undefined ) {\\n\\t\\t\\tif ( this.length ) {\\n\\t\\t\\t\\tdata = dataUser.get( elem );\\n\\n\\t\\t\\t\\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \\\"hasDataAttrs\\\" ) ) {\\n\\t\\t\\t\\t\\ti = attrs.length;\\n\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\n\\t\\t\\t\\t\\t\\t// Support: IE 11 only\\n\\t\\t\\t\\t\\t\\t// The attrs elements can be null (#14894)\\n\\t\\t\\t\\t\\t\\tif ( attrs[ i ] ) {\\n\\t\\t\\t\\t\\t\\t\\tname = attrs[ i ].name;\\n\\t\\t\\t\\t\\t\\t\\tif ( name.indexOf( \\\"data-\\\" ) === 0 ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tname = camelCase( name.slice( 5 ) );\\n\\t\\t\\t\\t\\t\\t\\t\\tdataAttr( elem, name, data[ name ] );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tdataPriv.set( elem, \\\"hasDataAttrs\\\", true );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn data;\\n\\t\\t}\\n\\n\\t\\t// Sets multiple values\\n\\t\\tif ( typeof key === \\\"object\\\" ) {\\n\\t\\t\\treturn this.each( function() {\\n\\t\\t\\t\\tdataUser.set( this, key );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\treturn access( this, function( value ) {\\n\\t\\t\\tvar data;\\n\\n\\t\\t\\t// The calling jQuery object (element matches) is not empty\\n\\t\\t\\t// (and therefore has an element appears at this[ 0 ]) and the\\n\\t\\t\\t// `value` parameter was not undefined. An empty jQuery object\\n\\t\\t\\t// will result in `undefined` for elem = this[ 0 ] which will\\n\\t\\t\\t// throw an exception if an attempt to read a data cache is made.\\n\\t\\t\\tif ( elem && value === undefined ) {\\n\\n\\t\\t\\t\\t// Attempt to get data from the cache\\n\\t\\t\\t\\t// The key will always be camelCased in Data\\n\\t\\t\\t\\tdata = dataUser.get( elem, key );\\n\\t\\t\\t\\tif ( data !== undefined ) {\\n\\t\\t\\t\\t\\treturn data;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Attempt to \\\"discover\\\" the data in\\n\\t\\t\\t\\t// HTML5 custom data-* attrs\\n\\t\\t\\t\\tdata = dataAttr( elem, key );\\n\\t\\t\\t\\tif ( data !== undefined ) {\\n\\t\\t\\t\\t\\treturn data;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// We tried really hard, but the data doesn't exist.\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Set the data...\\n\\t\\t\\tthis.each( function() {\\n\\n\\t\\t\\t\\t// We always store the camelCased key\\n\\t\\t\\t\\tdataUser.set( this, key, value );\\n\\t\\t\\t} );\\n\\t\\t}, null, value, arguments.length > 1, null, true );\\n\\t},\\n\\n\\tremoveData: function( key ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tdataUser.remove( this, key );\\n\\t\\t} );\\n\\t}\\n} );\\n\\n\\njQuery.extend( {\\n\\tqueue: function( elem, type, data ) {\\n\\t\\tvar queue;\\n\\n\\t\\tif ( elem ) {\\n\\t\\t\\ttype = ( type || \\\"fx\\\" ) + \\\"queue\\\";\\n\\t\\t\\tqueue = dataPriv.get( elem, type );\\n\\n\\t\\t\\t// Speed up dequeue by getting out quickly if this is just a lookup\\n\\t\\t\\tif ( data ) {\\n\\t\\t\\t\\tif ( !queue || Array.isArray( data ) ) {\\n\\t\\t\\t\\t\\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tqueue.push( data );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn queue || [];\\n\\t\\t}\\n\\t},\\n\\n\\tdequeue: function( elem, type ) {\\n\\t\\ttype = type || \\\"fx\\\";\\n\\n\\t\\tvar queue = jQuery.queue( elem, type ),\\n\\t\\t\\tstartLength = queue.length,\\n\\t\\t\\tfn = queue.shift(),\\n\\t\\t\\thooks = jQuery._queueHooks( elem, type ),\\n\\t\\t\\tnext = function() {\\n\\t\\t\\t\\tjQuery.dequeue( elem, type );\\n\\t\\t\\t};\\n\\n\\t\\t// If the fx queue is dequeued, always remove the progress sentinel\\n\\t\\tif ( fn === \\\"inprogress\\\" ) {\\n\\t\\t\\tfn = queue.shift();\\n\\t\\t\\tstartLength--;\\n\\t\\t}\\n\\n\\t\\tif ( fn ) {\\n\\n\\t\\t\\t// Add a progress sentinel to prevent the fx queue from being\\n\\t\\t\\t// automatically dequeued\\n\\t\\t\\tif ( type === \\\"fx\\\" ) {\\n\\t\\t\\t\\tqueue.unshift( \\\"inprogress\\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Clear up the last queue stop function\\n\\t\\t\\tdelete hooks.stop;\\n\\t\\t\\tfn.call( elem, next, hooks );\\n\\t\\t}\\n\\n\\t\\tif ( !startLength && hooks ) {\\n\\t\\t\\thooks.empty.fire();\\n\\t\\t}\\n\\t},\\n\\n\\t// Not public - generate a queueHooks object, or return the current one\\n\\t_queueHooks: function( elem, type ) {\\n\\t\\tvar key = type + \\\"queueHooks\\\";\\n\\t\\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\\n\\t\\t\\tempty: jQuery.Callbacks( \\\"once memory\\\" ).add( function() {\\n\\t\\t\\t\\tdataPriv.remove( elem, [ type + \\\"queue\\\", key ] );\\n\\t\\t\\t} )\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.fn.extend( {\\n\\tqueue: function( type, data ) {\\n\\t\\tvar setter = 2;\\n\\n\\t\\tif ( typeof type !== \\\"string\\\" ) {\\n\\t\\t\\tdata = type;\\n\\t\\t\\ttype = \\\"fx\\\";\\n\\t\\t\\tsetter--;\\n\\t\\t}\\n\\n\\t\\tif ( arguments.length < setter ) {\\n\\t\\t\\treturn jQuery.queue( this[ 0 ], type );\\n\\t\\t}\\n\\n\\t\\treturn data === undefined ?\\n\\t\\t\\tthis :\\n\\t\\t\\tthis.each( function() {\\n\\t\\t\\t\\tvar queue = jQuery.queue( this, type, data );\\n\\n\\t\\t\\t\\t// Ensure a hooks for this queue\\n\\t\\t\\t\\tjQuery._queueHooks( this, type );\\n\\n\\t\\t\\t\\tif ( type === \\\"fx\\\" && queue[ 0 ] !== \\\"inprogress\\\" ) {\\n\\t\\t\\t\\t\\tjQuery.dequeue( this, type );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\t},\\n\\tdequeue: function( type ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tjQuery.dequeue( this, type );\\n\\t\\t} );\\n\\t},\\n\\tclearQueue: function( type ) {\\n\\t\\treturn this.queue( type || \\\"fx\\\", [] );\\n\\t},\\n\\n\\t// Get a promise resolved when queues of a certain type\\n\\t// are emptied (fx is the type by default)\\n\\tpromise: function( type, obj ) {\\n\\t\\tvar tmp,\\n\\t\\t\\tcount = 1,\\n\\t\\t\\tdefer = jQuery.Deferred(),\\n\\t\\t\\telements = this,\\n\\t\\t\\ti = this.length,\\n\\t\\t\\tresolve = function() {\\n\\t\\t\\t\\tif ( !( --count ) ) {\\n\\t\\t\\t\\t\\tdefer.resolveWith( elements, [ elements ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\n\\t\\tif ( typeof type !== \\\"string\\\" ) {\\n\\t\\t\\tobj = type;\\n\\t\\t\\ttype = undefined;\\n\\t\\t}\\n\\t\\ttype = type || \\\"fx\\\";\\n\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\ttmp = dataPriv.get( elements[ i ], type + \\\"queueHooks\\\" );\\n\\t\\t\\tif ( tmp && tmp.empty ) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\ttmp.empty.add( resolve );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresolve();\\n\\t\\treturn defer.promise( obj );\\n\\t}\\n} );\\nvar pnum = ( /[+-]?(?:\\\\d*\\\\.|)\\\\d+(?:[eE][+-]?\\\\d+|)/ ).source;\\n\\nvar rcssNum = new RegExp( \\\"^(?:([+-])=|)(\\\" + pnum + \\\")([a-z%]*)$\\\", \\\"i\\\" );\\n\\n\\nvar cssExpand = [ \\\"Top\\\", \\\"Right\\\", \\\"Bottom\\\", \\\"Left\\\" ];\\n\\nvar isHiddenWithinTree = function( elem, el ) {\\n\\n\\t\\t// isHiddenWithinTree might be called from jQuery#filter function;\\n\\t\\t// in that case, element will be second argument\\n\\t\\telem = el || elem;\\n\\n\\t\\t// Inline style trumps all\\n\\t\\treturn elem.style.display === \\\"none\\\" ||\\n\\t\\t\\telem.style.display === \\\"\\\" &&\\n\\n\\t\\t\\t// Otherwise, check computed style\\n\\t\\t\\t// Support: Firefox <=43 - 45\\n\\t\\t\\t// Disconnected elements can have computed display: none, so first confirm that elem is\\n\\t\\t\\t// in the document.\\n\\t\\t\\tjQuery.contains( elem.ownerDocument, elem ) &&\\n\\n\\t\\t\\tjQuery.css( elem, \\\"display\\\" ) === \\\"none\\\";\\n\\t};\\n\\nvar swap = function( elem, options, callback, args ) {\\n\\tvar ret, name,\\n\\t\\told = {};\\n\\n\\t// Remember the old values, and insert the new ones\\n\\tfor ( name in options ) {\\n\\t\\told[ name ] = elem.style[ name ];\\n\\t\\telem.style[ name ] = options[ name ];\\n\\t}\\n\\n\\tret = callback.apply( elem, args || [] );\\n\\n\\t// Revert the old values\\n\\tfor ( name in options ) {\\n\\t\\telem.style[ name ] = old[ name ];\\n\\t}\\n\\n\\treturn ret;\\n};\\n\\n\\n\\n\\nfunction adjustCSS( elem, prop, valueParts, tween ) {\\n\\tvar adjusted, scale,\\n\\t\\tmaxIterations = 20,\\n\\t\\tcurrentValue = tween ?\\n\\t\\t\\tfunction() {\\n\\t\\t\\t\\treturn tween.cur();\\n\\t\\t\\t} :\\n\\t\\t\\tfunction() {\\n\\t\\t\\t\\treturn jQuery.css( elem, prop, \\\"\\\" );\\n\\t\\t\\t},\\n\\t\\tinitial = currentValue(),\\n\\t\\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \\\"\\\" : \\\"px\\\" ),\\n\\n\\t\\t// Starting value computation is required for potential unit mismatches\\n\\t\\tinitialInUnit = ( jQuery.cssNumber[ prop ] || unit !== \\\"px\\\" && +initial ) &&\\n\\t\\t\\trcssNum.exec( jQuery.css( elem, prop ) );\\n\\n\\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\\n\\n\\t\\t// Support: Firefox <=54\\n\\t\\t// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)\\n\\t\\tinitial = initial / 2;\\n\\n\\t\\t// Trust units reported by jQuery.css\\n\\t\\tunit = unit || initialInUnit[ 3 ];\\n\\n\\t\\t// Iteratively approximate from a nonzero starting point\\n\\t\\tinitialInUnit = +initial || 1;\\n\\n\\t\\twhile ( maxIterations-- ) {\\n\\n\\t\\t\\t// Evaluate and update our best guess (doubling guesses that zero out).\\n\\t\\t\\t// Finish if the scale equals or crosses 1 (making the old*new product non-positive).\\n\\t\\t\\tjQuery.style( elem, prop, initialInUnit + unit );\\n\\t\\t\\tif ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {\\n\\t\\t\\t\\tmaxIterations = 0;\\n\\t\\t\\t}\\n\\t\\t\\tinitialInUnit = initialInUnit / scale;\\n\\n\\t\\t}\\n\\n\\t\\tinitialInUnit = initialInUnit * 2;\\n\\t\\tjQuery.style( elem, prop, initialInUnit + unit );\\n\\n\\t\\t// Make sure we update the tween properties later on\\n\\t\\tvalueParts = valueParts || [];\\n\\t}\\n\\n\\tif ( valueParts ) {\\n\\t\\tinitialInUnit = +initialInUnit || +initial || 0;\\n\\n\\t\\t// Apply relative offset (+=/-=) if specified\\n\\t\\tadjusted = valueParts[ 1 ] ?\\n\\t\\t\\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\\n\\t\\t\\t+valueParts[ 2 ];\\n\\t\\tif ( tween ) {\\n\\t\\t\\ttween.unit = unit;\\n\\t\\t\\ttween.start = initialInUnit;\\n\\t\\t\\ttween.end = adjusted;\\n\\t\\t}\\n\\t}\\n\\treturn adjusted;\\n}\\n\\n\\nvar defaultDisplayMap = {};\\n\\nfunction getDefaultDisplay( elem ) {\\n\\tvar temp,\\n\\t\\tdoc = elem.ownerDocument,\\n\\t\\tnodeName = elem.nodeName,\\n\\t\\tdisplay = defaultDisplayMap[ nodeName ];\\n\\n\\tif ( display ) {\\n\\t\\treturn display;\\n\\t}\\n\\n\\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\\n\\tdisplay = jQuery.css( temp, \\\"display\\\" );\\n\\n\\ttemp.parentNode.removeChild( temp );\\n\\n\\tif ( display === \\\"none\\\" ) {\\n\\t\\tdisplay = \\\"block\\\";\\n\\t}\\n\\tdefaultDisplayMap[ nodeName ] = display;\\n\\n\\treturn display;\\n}\\n\\nfunction showHide( elements, show ) {\\n\\tvar display, elem,\\n\\t\\tvalues = [],\\n\\t\\tindex = 0,\\n\\t\\tlength = elements.length;\\n\\n\\t// Determine new display value for elements that need to change\\n\\tfor ( ; index < length; index++ ) {\\n\\t\\telem = elements[ index ];\\n\\t\\tif ( !elem.style ) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tdisplay = elem.style.display;\\n\\t\\tif ( show ) {\\n\\n\\t\\t\\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\\n\\t\\t\\t// check is required in this first loop unless we have a nonempty display value (either\\n\\t\\t\\t// inline or about-to-be-restored)\\n\\t\\t\\tif ( display === \\\"none\\\" ) {\\n\\t\\t\\t\\tvalues[ index ] = dataPriv.get( elem, \\\"display\\\" ) || null;\\n\\t\\t\\t\\tif ( !values[ index ] ) {\\n\\t\\t\\t\\t\\telem.style.display = \\\"\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif ( elem.style.display === \\\"\\\" && isHiddenWithinTree( elem ) ) {\\n\\t\\t\\t\\tvalues[ index ] = getDefaultDisplay( elem );\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tif ( display !== \\\"none\\\" ) {\\n\\t\\t\\t\\tvalues[ index ] = \\\"none\\\";\\n\\n\\t\\t\\t\\t// Remember what we're overwriting\\n\\t\\t\\t\\tdataPriv.set( elem, \\\"display\\\", display );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Set the display of the elements in a second loop to avoid constant reflow\\n\\tfor ( index = 0; index < length; index++ ) {\\n\\t\\tif ( values[ index ] != null ) {\\n\\t\\t\\telements[ index ].style.display = values[ index ];\\n\\t\\t}\\n\\t}\\n\\n\\treturn elements;\\n}\\n\\njQuery.fn.extend( {\\n\\tshow: function() {\\n\\t\\treturn showHide( this, true );\\n\\t},\\n\\thide: function() {\\n\\t\\treturn showHide( this );\\n\\t},\\n\\ttoggle: function( state ) {\\n\\t\\tif ( typeof state === \\\"boolean\\\" ) {\\n\\t\\t\\treturn state ? this.show() : this.hide();\\n\\t\\t}\\n\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tif ( isHiddenWithinTree( this ) ) {\\n\\t\\t\\t\\tjQuery( this ).show();\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tjQuery( this ).hide();\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t}\\n} );\\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\\n\\nvar rtagName = ( /<([a-z][^\\\\/\\\\0>\\\\x20\\\\t\\\\r\\\\n\\\\f]+)/i );\\n\\nvar rscriptType = ( /^$|^module$|\\\\/(?:java|ecma)script/i );\\n\\n\\n\\n// We have to close these tags to support XHTML (#13200)\\nvar wrapMap = {\\n\\n\\t// Support: IE <=9 only\\n\\toption: [ 1, \\\"<select multiple='multiple'>\\\", \\\"</select>\\\" ],\\n\\n\\t// XHTML parsers do not magically insert elements in the\\n\\t// same way that tag soup parsers do. So we cannot shorten\\n\\t// this by omitting <tbody> or other required elements.\\n\\tthead: [ 1, \\\"<table>\\\", \\\"</table>\\\" ],\\n\\tcol: [ 2, \\\"<table><colgroup>\\\", \\\"</colgroup></table>\\\" ],\\n\\ttr: [ 2, \\\"<table><tbody>\\\", \\\"</tbody></table>\\\" ],\\n\\ttd: [ 3, \\\"<table><tbody><tr>\\\", \\\"</tr></tbody></table>\\\" ],\\n\\n\\t_default: [ 0, \\\"\\\", \\\"\\\" ]\\n};\\n\\n// Support: IE <=9 only\\nwrapMap.optgroup = wrapMap.option;\\n\\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\\nwrapMap.th = wrapMap.td;\\n\\n\\nfunction getAll( context, tag ) {\\n\\n\\t// Support: IE <=9 - 11 only\\n\\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\\n\\tvar ret;\\n\\n\\tif ( typeof context.getElementsByTagName !== \\\"undefined\\\" ) {\\n\\t\\tret = context.getElementsByTagName( tag || \\\"*\\\" );\\n\\n\\t} else if ( typeof context.querySelectorAll !== \\\"undefined\\\" ) {\\n\\t\\tret = context.querySelectorAll( tag || \\\"*\\\" );\\n\\n\\t} else {\\n\\t\\tret = [];\\n\\t}\\n\\n\\tif ( tag === undefined || tag && nodeName( context, tag ) ) {\\n\\t\\treturn jQuery.merge( [ context ], ret );\\n\\t}\\n\\n\\treturn ret;\\n}\\n\\n\\n// Mark scripts as having already been evaluated\\nfunction setGlobalEval( elems, refElements ) {\\n\\tvar i = 0,\\n\\t\\tl = elems.length;\\n\\n\\tfor ( ; i < l; i++ ) {\\n\\t\\tdataPriv.set(\\n\\t\\t\\telems[ i ],\\n\\t\\t\\t\\\"globalEval\\\",\\n\\t\\t\\t!refElements || dataPriv.get( refElements[ i ], \\\"globalEval\\\" )\\n\\t\\t);\\n\\t}\\n}\\n\\n\\nvar rhtml = /<|&#?\\\\w+;/;\\n\\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\\n\\tvar elem, tmp, tag, wrap, contains, j,\\n\\t\\tfragment = context.createDocumentFragment(),\\n\\t\\tnodes = [],\\n\\t\\ti = 0,\\n\\t\\tl = elems.length;\\n\\n\\tfor ( ; i < l; i++ ) {\\n\\t\\telem = elems[ i ];\\n\\n\\t\\tif ( elem || elem === 0 ) {\\n\\n\\t\\t\\t// Add nodes directly\\n\\t\\t\\tif ( toType( elem ) === \\\"object\\\" ) {\\n\\n\\t\\t\\t\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t\\t\\t\\t// push.apply(_, arraylike) throws on ancient WebKit\\n\\t\\t\\t\\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\\n\\n\\t\\t\\t// Convert non-html into a text node\\n\\t\\t\\t} else if ( !rhtml.test( elem ) ) {\\n\\t\\t\\t\\tnodes.push( context.createTextNode( elem ) );\\n\\n\\t\\t\\t// Convert html into DOM nodes\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttmp = tmp || fragment.appendChild( context.createElement( \\\"div\\\" ) );\\n\\n\\t\\t\\t\\t// Deserialize a standard representation\\n\\t\\t\\t\\ttag = ( rtagName.exec( elem ) || [ \\\"\\\", \\\"\\\" ] )[ 1 ].toLowerCase();\\n\\t\\t\\t\\twrap = wrapMap[ tag ] || wrapMap._default;\\n\\t\\t\\t\\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\\n\\n\\t\\t\\t\\t// Descend through wrappers to the right content\\n\\t\\t\\t\\tj = wrap[ 0 ];\\n\\t\\t\\t\\twhile ( j-- ) {\\n\\t\\t\\t\\t\\ttmp = tmp.lastChild;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t\\t\\t\\t// push.apply(_, arraylike) throws on ancient WebKit\\n\\t\\t\\t\\tjQuery.merge( nodes, tmp.childNodes );\\n\\n\\t\\t\\t\\t// Remember the top-level container\\n\\t\\t\\t\\ttmp = fragment.firstChild;\\n\\n\\t\\t\\t\\t// Ensure the created nodes are orphaned (#12392)\\n\\t\\t\\t\\ttmp.textContent = \\\"\\\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Remove wrapper from fragment\\n\\tfragment.textContent = \\\"\\\";\\n\\n\\ti = 0;\\n\\twhile ( ( elem = nodes[ i++ ] ) ) {\\n\\n\\t\\t// Skip elements already in the context collection (trac-4087)\\n\\t\\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\\n\\t\\t\\tif ( ignored ) {\\n\\t\\t\\t\\tignored.push( elem );\\n\\t\\t\\t}\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tcontains = jQuery.contains( elem.ownerDocument, elem );\\n\\n\\t\\t// Append to fragment\\n\\t\\ttmp = getAll( fragment.appendChild( elem ), \\\"script\\\" );\\n\\n\\t\\t// Preserve script evaluation history\\n\\t\\tif ( contains ) {\\n\\t\\t\\tsetGlobalEval( tmp );\\n\\t\\t}\\n\\n\\t\\t// Capture executables\\n\\t\\tif ( scripts ) {\\n\\t\\t\\tj = 0;\\n\\t\\t\\twhile ( ( elem = tmp[ j++ ] ) ) {\\n\\t\\t\\t\\tif ( rscriptType.test( elem.type || \\\"\\\" ) ) {\\n\\t\\t\\t\\t\\tscripts.push( elem );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn fragment;\\n}\\n\\n\\n( function() {\\n\\tvar fragment = document.createDocumentFragment(),\\n\\t\\tdiv = fragment.appendChild( document.createElement( \\\"div\\\" ) ),\\n\\t\\tinput = document.createElement( \\\"input\\\" );\\n\\n\\t// Support: Android 4.0 - 4.3 only\\n\\t// Check state lost if the name is set (#11217)\\n\\t// Support: Windows Web Apps (WWA)\\n\\t// `name` and `type` must use .setAttribute for WWA (#14901)\\n\\tinput.setAttribute( \\\"type\\\", \\\"radio\\\" );\\n\\tinput.setAttribute( \\\"checked\\\", \\\"checked\\\" );\\n\\tinput.setAttribute( \\\"name\\\", \\\"t\\\" );\\n\\n\\tdiv.appendChild( input );\\n\\n\\t// Support: Android <=4.1 only\\n\\t// Older WebKit doesn't clone checked state correctly in fragments\\n\\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\\n\\n\\t// Support: IE <=11 only\\n\\t// Make sure textarea (and checkbox) defaultValue is properly cloned\\n\\tdiv.innerHTML = \\\"<textarea>x</textarea>\\\";\\n\\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\\n} )();\\nvar documentElement = document.documentElement;\\n\\n\\n\\nvar\\n\\trkeyEvent = /^key/,\\n\\trmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\\n\\trtypenamespace = /^([^.]*)(?:\\\\.(.+)|)/;\\n\\nfunction returnTrue() {\\n\\treturn true;\\n}\\n\\nfunction returnFalse() {\\n\\treturn false;\\n}\\n\\n// Support: IE <=9 only\\n// See #13393 for more info\\nfunction safeActiveElement() {\\n\\ttry {\\n\\t\\treturn document.activeElement;\\n\\t} catch ( err ) { }\\n}\\n\\nfunction on( elem, types, selector, data, fn, one ) {\\n\\tvar origFn, type;\\n\\n\\t// Types can be a map of types/handlers\\n\\tif ( typeof types === \\\"object\\\" ) {\\n\\n\\t\\t// ( types-Object, selector, data )\\n\\t\\tif ( typeof selector !== \\\"string\\\" ) {\\n\\n\\t\\t\\t// ( types-Object, data )\\n\\t\\t\\tdata = data || selector;\\n\\t\\t\\tselector = undefined;\\n\\t\\t}\\n\\t\\tfor ( type in types ) {\\n\\t\\t\\ton( elem, type, selector, data, types[ type ], one );\\n\\t\\t}\\n\\t\\treturn elem;\\n\\t}\\n\\n\\tif ( data == null && fn == null ) {\\n\\n\\t\\t// ( types, fn )\\n\\t\\tfn = selector;\\n\\t\\tdata = selector = undefined;\\n\\t} else if ( fn == null ) {\\n\\t\\tif ( typeof selector === \\\"string\\\" ) {\\n\\n\\t\\t\\t// ( types, selector, fn )\\n\\t\\t\\tfn = data;\\n\\t\\t\\tdata = undefined;\\n\\t\\t} else {\\n\\n\\t\\t\\t// ( types, data, fn )\\n\\t\\t\\tfn = data;\\n\\t\\t\\tdata = selector;\\n\\t\\t\\tselector = undefined;\\n\\t\\t}\\n\\t}\\n\\tif ( fn === false ) {\\n\\t\\tfn = returnFalse;\\n\\t} else if ( !fn ) {\\n\\t\\treturn elem;\\n\\t}\\n\\n\\tif ( one === 1 ) {\\n\\t\\torigFn = fn;\\n\\t\\tfn = function( event ) {\\n\\n\\t\\t\\t// Can use an empty set, since event contains the info\\n\\t\\t\\tjQuery().off( event );\\n\\t\\t\\treturn origFn.apply( this, arguments );\\n\\t\\t};\\n\\n\\t\\t// Use same guid so caller can remove using origFn\\n\\t\\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\\n\\t}\\n\\treturn elem.each( function() {\\n\\t\\tjQuery.event.add( this, types, fn, data, selector );\\n\\t} );\\n}\\n\\n/*\\n * Helper functions for managing events -- not part of the public interface.\\n * Props to Dean Edwards' addEvent library for many of the ideas.\\n */\\njQuery.event = {\\n\\n\\tglobal: {},\\n\\n\\tadd: function( elem, types, handler, data, selector ) {\\n\\n\\t\\tvar handleObjIn, eventHandle, tmp,\\n\\t\\t\\tevents, t, handleObj,\\n\\t\\t\\tspecial, handlers, type, namespaces, origType,\\n\\t\\t\\telemData = dataPriv.get( elem );\\n\\n\\t\\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\\n\\t\\tif ( !elemData ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Caller can pass in an object of custom data in lieu of the handler\\n\\t\\tif ( handler.handler ) {\\n\\t\\t\\thandleObjIn = handler;\\n\\t\\t\\thandler = handleObjIn.handler;\\n\\t\\t\\tselector = handleObjIn.selector;\\n\\t\\t}\\n\\n\\t\\t// Ensure that invalid selectors throw exceptions at attach time\\n\\t\\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\\n\\t\\tif ( selector ) {\\n\\t\\t\\tjQuery.find.matchesSelector( documentElement, selector );\\n\\t\\t}\\n\\n\\t\\t// Make sure that the handler has a unique ID, used to find/remove it later\\n\\t\\tif ( !handler.guid ) {\\n\\t\\t\\thandler.guid = jQuery.guid++;\\n\\t\\t}\\n\\n\\t\\t// Init the element's event structure and main handler, if this is the first\\n\\t\\tif ( !( events = elemData.events ) ) {\\n\\t\\t\\tevents = elemData.events = {};\\n\\t\\t}\\n\\t\\tif ( !( eventHandle = elemData.handle ) ) {\\n\\t\\t\\teventHandle = elemData.handle = function( e ) {\\n\\n\\t\\t\\t\\t// Discard the second event of a jQuery.event.trigger() and\\n\\t\\t\\t\\t// when an event is called after a page has unloaded\\n\\t\\t\\t\\treturn typeof jQuery !== \\\"undefined\\\" && jQuery.event.triggered !== e.type ?\\n\\t\\t\\t\\t\\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\\n\\t\\t\\t};\\n\\t\\t}\\n\\n\\t\\t// Handle multiple events separated by a space\\n\\t\\ttypes = ( types || \\\"\\\" ).match( rnothtmlwhite ) || [ \\\"\\\" ];\\n\\t\\tt = types.length;\\n\\t\\twhile ( t-- ) {\\n\\t\\t\\ttmp = rtypenamespace.exec( types[ t ] ) || [];\\n\\t\\t\\ttype = origType = tmp[ 1 ];\\n\\t\\t\\tnamespaces = ( tmp[ 2 ] || \\\"\\\" ).split( \\\".\\\" ).sort();\\n\\n\\t\\t\\t// There *must* be a type, no attaching namespace-only handlers\\n\\t\\t\\tif ( !type ) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If event changes its type, use the special event handlers for the changed type\\n\\t\\t\\tspecial = jQuery.event.special[ type ] || {};\\n\\n\\t\\t\\t// If selector defined, determine special event api type, otherwise given type\\n\\t\\t\\ttype = ( selector ? special.delegateType : special.bindType ) || type;\\n\\n\\t\\t\\t// Update special based on newly reset type\\n\\t\\t\\tspecial = jQuery.event.special[ type ] || {};\\n\\n\\t\\t\\t// handleObj is passed to all event handlers\\n\\t\\t\\thandleObj = jQuery.extend( {\\n\\t\\t\\t\\ttype: type,\\n\\t\\t\\t\\torigType: origType,\\n\\t\\t\\t\\tdata: data,\\n\\t\\t\\t\\thandler: handler,\\n\\t\\t\\t\\tguid: handler.guid,\\n\\t\\t\\t\\tselector: selector,\\n\\t\\t\\t\\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\\n\\t\\t\\t\\tnamespace: namespaces.join( \\\".\\\" )\\n\\t\\t\\t}, handleObjIn );\\n\\n\\t\\t\\t// Init the event handler queue if we're the first\\n\\t\\t\\tif ( !( handlers = events[ type ] ) ) {\\n\\t\\t\\t\\thandlers = events[ type ] = [];\\n\\t\\t\\t\\thandlers.delegateCount = 0;\\n\\n\\t\\t\\t\\t// Only use addEventListener if the special events handler returns false\\n\\t\\t\\t\\tif ( !special.setup ||\\n\\t\\t\\t\\t\\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\\n\\n\\t\\t\\t\\t\\tif ( elem.addEventListener ) {\\n\\t\\t\\t\\t\\t\\telem.addEventListener( type, eventHandle );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( special.add ) {\\n\\t\\t\\t\\tspecial.add.call( elem, handleObj );\\n\\n\\t\\t\\t\\tif ( !handleObj.handler.guid ) {\\n\\t\\t\\t\\t\\thandleObj.handler.guid = handler.guid;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Add to the element's handler list, delegates in front\\n\\t\\t\\tif ( selector ) {\\n\\t\\t\\t\\thandlers.splice( handlers.delegateCount++, 0, handleObj );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\thandlers.push( handleObj );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Keep track of which events have ever been used, for event optimization\\n\\t\\t\\tjQuery.event.global[ type ] = true;\\n\\t\\t}\\n\\n\\t},\\n\\n\\t// Detach an event or set of events from an element\\n\\tremove: function( elem, types, handler, selector, mappedTypes ) {\\n\\n\\t\\tvar j, origCount, tmp,\\n\\t\\t\\tevents, t, handleObj,\\n\\t\\t\\tspecial, handlers, type, namespaces, origType,\\n\\t\\t\\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\\n\\n\\t\\tif ( !elemData || !( events = elemData.events ) ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Once for each type.namespace in types; type may be omitted\\n\\t\\ttypes = ( types || \\\"\\\" ).match( rnothtmlwhite ) || [ \\\"\\\" ];\\n\\t\\tt = types.length;\\n\\t\\twhile ( t-- ) {\\n\\t\\t\\ttmp = rtypenamespace.exec( types[ t ] ) || [];\\n\\t\\t\\ttype = origType = tmp[ 1 ];\\n\\t\\t\\tnamespaces = ( tmp[ 2 ] || \\\"\\\" ).split( \\\".\\\" ).sort();\\n\\n\\t\\t\\t// Unbind all events (on this namespace, if provided) for the element\\n\\t\\t\\tif ( !type ) {\\n\\t\\t\\t\\tfor ( type in events ) {\\n\\t\\t\\t\\t\\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tspecial = jQuery.event.special[ type ] || {};\\n\\t\\t\\ttype = ( selector ? special.delegateType : special.bindType ) || type;\\n\\t\\t\\thandlers = events[ type ] || [];\\n\\t\\t\\ttmp = tmp[ 2 ] &&\\n\\t\\t\\t\\tnew RegExp( \\\"(^|\\\\\\\\.)\\\" + namespaces.join( \\\"\\\\\\\\.(?:.*\\\\\\\\.|)\\\" ) + \\\"(\\\\\\\\.|$)\\\" );\\n\\n\\t\\t\\t// Remove matching events\\n\\t\\t\\torigCount = j = handlers.length;\\n\\t\\t\\twhile ( j-- ) {\\n\\t\\t\\t\\thandleObj = handlers[ j ];\\n\\n\\t\\t\\t\\tif ( ( mappedTypes || origType === handleObj.origType ) &&\\n\\t\\t\\t\\t\\t( !handler || handler.guid === handleObj.guid ) &&\\n\\t\\t\\t\\t\\t( !tmp || tmp.test( handleObj.namespace ) ) &&\\n\\t\\t\\t\\t\\t( !selector || selector === handleObj.selector ||\\n\\t\\t\\t\\t\\t\\tselector === \\\"**\\\" && handleObj.selector ) ) {\\n\\t\\t\\t\\t\\thandlers.splice( j, 1 );\\n\\n\\t\\t\\t\\t\\tif ( handleObj.selector ) {\\n\\t\\t\\t\\t\\t\\thandlers.delegateCount--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( special.remove ) {\\n\\t\\t\\t\\t\\t\\tspecial.remove.call( elem, handleObj );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Remove generic event handler if we removed something and no more handlers exist\\n\\t\\t\\t// (avoids potential for endless recursion during removal of special event handlers)\\n\\t\\t\\tif ( origCount && !handlers.length ) {\\n\\t\\t\\t\\tif ( !special.teardown ||\\n\\t\\t\\t\\t\\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\\n\\n\\t\\t\\t\\t\\tjQuery.removeEvent( elem, type, elemData.handle );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tdelete events[ type ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Remove data and the expando if it's no longer used\\n\\t\\tif ( jQuery.isEmptyObject( events ) ) {\\n\\t\\t\\tdataPriv.remove( elem, \\\"handle events\\\" );\\n\\t\\t}\\n\\t},\\n\\n\\tdispatch: function( nativeEvent ) {\\n\\n\\t\\t// Make a writable jQuery.Event from the native event object\\n\\t\\tvar event = jQuery.event.fix( nativeEvent );\\n\\n\\t\\tvar i, j, ret, matched, handleObj, handlerQueue,\\n\\t\\t\\targs = new Array( arguments.length ),\\n\\t\\t\\thandlers = ( dataPriv.get( this, \\\"events\\\" ) || {} )[ event.type ] || [],\\n\\t\\t\\tspecial = jQuery.event.special[ event.type ] || {};\\n\\n\\t\\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\\n\\t\\targs[ 0 ] = event;\\n\\n\\t\\tfor ( i = 1; i < arguments.length; i++ ) {\\n\\t\\t\\targs[ i ] = arguments[ i ];\\n\\t\\t}\\n\\n\\t\\tevent.delegateTarget = this;\\n\\n\\t\\t// Call the preDispatch hook for the mapped type, and let it bail if desired\\n\\t\\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Determine handlers\\n\\t\\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\\n\\n\\t\\t// Run delegates first; they may want to stop propagation beneath us\\n\\t\\ti = 0;\\n\\t\\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\\n\\t\\t\\tevent.currentTarget = matched.elem;\\n\\n\\t\\t\\tj = 0;\\n\\t\\t\\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\\n\\t\\t\\t\\t!event.isImmediatePropagationStopped() ) {\\n\\n\\t\\t\\t\\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\\n\\t\\t\\t\\t// a subset or equal to those in the bound event (both can have no namespace).\\n\\t\\t\\t\\tif ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {\\n\\n\\t\\t\\t\\t\\tevent.handleObj = handleObj;\\n\\t\\t\\t\\t\\tevent.data = handleObj.data;\\n\\n\\t\\t\\t\\t\\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\\n\\t\\t\\t\\t\\t\\thandleObj.handler ).apply( matched.elem, args );\\n\\n\\t\\t\\t\\t\\tif ( ret !== undefined ) {\\n\\t\\t\\t\\t\\t\\tif ( ( event.result = ret ) === false ) {\\n\\t\\t\\t\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\t\\t\\t\\tevent.stopPropagation();\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Call the postDispatch hook for the mapped type\\n\\t\\tif ( special.postDispatch ) {\\n\\t\\t\\tspecial.postDispatch.call( this, event );\\n\\t\\t}\\n\\n\\t\\treturn event.result;\\n\\t},\\n\\n\\thandlers: function( event, handlers ) {\\n\\t\\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\\n\\t\\t\\thandlerQueue = [],\\n\\t\\t\\tdelegateCount = handlers.delegateCount,\\n\\t\\t\\tcur = event.target;\\n\\n\\t\\t// Find delegate handlers\\n\\t\\tif ( delegateCount &&\\n\\n\\t\\t\\t// Support: IE <=9\\n\\t\\t\\t// Black-hole SVG <use> instance trees (trac-13180)\\n\\t\\t\\tcur.nodeType &&\\n\\n\\t\\t\\t// Support: Firefox <=42\\n\\t\\t\\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\\n\\t\\t\\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\\n\\t\\t\\t// Support: IE 11 only\\n\\t\\t\\t// ...but not arrow key \\\"clicks\\\" of radio inputs, which can have `button` -1 (gh-2343)\\n\\t\\t\\t!( event.type === \\\"click\\\" && event.button >= 1 ) ) {\\n\\n\\t\\t\\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\\n\\n\\t\\t\\t\\t// Don't check non-elements (#13208)\\n\\t\\t\\t\\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\\n\\t\\t\\t\\tif ( cur.nodeType === 1 && !( event.type === \\\"click\\\" && cur.disabled === true ) ) {\\n\\t\\t\\t\\t\\tmatchedHandlers = [];\\n\\t\\t\\t\\t\\tmatchedSelectors = {};\\n\\t\\t\\t\\t\\tfor ( i = 0; i < delegateCount; i++ ) {\\n\\t\\t\\t\\t\\t\\thandleObj = handlers[ i ];\\n\\n\\t\\t\\t\\t\\t\\t// Don't conflict with Object.prototype properties (#13203)\\n\\t\\t\\t\\t\\t\\tsel = handleObj.selector + \\\" \\\";\\n\\n\\t\\t\\t\\t\\t\\tif ( matchedSelectors[ sel ] === undefined ) {\\n\\t\\t\\t\\t\\t\\t\\tmatchedSelectors[ sel ] = handleObj.needsContext ?\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery( sel, this ).index( cur ) > -1 :\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery.find( sel, this, null, [ cur ] ).length;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif ( matchedSelectors[ sel ] ) {\\n\\t\\t\\t\\t\\t\\t\\tmatchedHandlers.push( handleObj );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( matchedHandlers.length ) {\\n\\t\\t\\t\\t\\t\\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Add the remaining (directly-bound) handlers\\n\\t\\tcur = this;\\n\\t\\tif ( delegateCount < handlers.length ) {\\n\\t\\t\\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\\n\\t\\t}\\n\\n\\t\\treturn handlerQueue;\\n\\t},\\n\\n\\taddProp: function( name, hook ) {\\n\\t\\tObject.defineProperty( jQuery.Event.prototype, name, {\\n\\t\\t\\tenumerable: true,\\n\\t\\t\\tconfigurable: true,\\n\\n\\t\\t\\tget: isFunction( hook ) ?\\n\\t\\t\\t\\tfunction() {\\n\\t\\t\\t\\t\\tif ( this.originalEvent ) {\\n\\t\\t\\t\\t\\t\\t\\treturn hook( this.originalEvent );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} :\\n\\t\\t\\t\\tfunction() {\\n\\t\\t\\t\\t\\tif ( this.originalEvent ) {\\n\\t\\t\\t\\t\\t\\t\\treturn this.originalEvent[ name ];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\tset: function( value ) {\\n\\t\\t\\t\\tObject.defineProperty( this, name, {\\n\\t\\t\\t\\t\\tenumerable: true,\\n\\t\\t\\t\\t\\tconfigurable: true,\\n\\t\\t\\t\\t\\twritable: true,\\n\\t\\t\\t\\t\\tvalue: value\\n\\t\\t\\t\\t} );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tfix: function( originalEvent ) {\\n\\t\\treturn originalEvent[ jQuery.expando ] ?\\n\\t\\t\\toriginalEvent :\\n\\t\\t\\tnew jQuery.Event( originalEvent );\\n\\t},\\n\\n\\tspecial: {\\n\\t\\tload: {\\n\\n\\t\\t\\t// Prevent triggered image.load events from bubbling to window.load\\n\\t\\t\\tnoBubble: true\\n\\t\\t},\\n\\t\\tfocus: {\\n\\n\\t\\t\\t// Fire native event if possible so blur/focus sequence is correct\\n\\t\\t\\ttrigger: function() {\\n\\t\\t\\t\\tif ( this !== safeActiveElement() && this.focus ) {\\n\\t\\t\\t\\t\\tthis.focus();\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tdelegateType: \\\"focusin\\\"\\n\\t\\t},\\n\\t\\tblur: {\\n\\t\\t\\ttrigger: function() {\\n\\t\\t\\t\\tif ( this === safeActiveElement() && this.blur ) {\\n\\t\\t\\t\\t\\tthis.blur();\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tdelegateType: \\\"focusout\\\"\\n\\t\\t},\\n\\t\\tclick: {\\n\\n\\t\\t\\t// For checkbox, fire native event so checked state will be right\\n\\t\\t\\ttrigger: function() {\\n\\t\\t\\t\\tif ( this.type === \\\"checkbox\\\" && this.click && nodeName( this, \\\"input\\\" ) ) {\\n\\t\\t\\t\\t\\tthis.click();\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\n\\t\\t\\t// For cross-browser consistency, don't fire native .click() on links\\n\\t\\t\\t_default: function( event ) {\\n\\t\\t\\t\\treturn nodeName( event.target, \\\"a\\\" );\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tbeforeunload: {\\n\\t\\t\\tpostDispatch: function( event ) {\\n\\n\\t\\t\\t\\t// Support: Firefox 20+\\n\\t\\t\\t\\t// Firefox doesn't alert if the returnValue field is not set.\\n\\t\\t\\t\\tif ( event.result !== undefined && event.originalEvent ) {\\n\\t\\t\\t\\t\\tevent.originalEvent.returnValue = event.result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\n\\njQuery.removeEvent = function( elem, type, handle ) {\\n\\n\\t// This \\\"if\\\" is needed for plain objects\\n\\tif ( elem.removeEventListener ) {\\n\\t\\telem.removeEventListener( type, handle );\\n\\t}\\n};\\n\\njQuery.Event = function( src, props ) {\\n\\n\\t// Allow instantiation without the 'new' keyword\\n\\tif ( !( this instanceof jQuery.Event ) ) {\\n\\t\\treturn new jQuery.Event( src, props );\\n\\t}\\n\\n\\t// Event object\\n\\tif ( src && src.type ) {\\n\\t\\tthis.originalEvent = src;\\n\\t\\tthis.type = src.type;\\n\\n\\t\\t// Events bubbling up the document may have been marked as prevented\\n\\t\\t// by a handler lower down the tree; reflect the correct value.\\n\\t\\tthis.isDefaultPrevented = src.defaultPrevented ||\\n\\t\\t\\t\\tsrc.defaultPrevented === undefined &&\\n\\n\\t\\t\\t\\t// Support: Android <=2.3 only\\n\\t\\t\\t\\tsrc.returnValue === false ?\\n\\t\\t\\treturnTrue :\\n\\t\\t\\treturnFalse;\\n\\n\\t\\t// Create target properties\\n\\t\\t// Support: Safari <=6 - 7 only\\n\\t\\t// Target should not be a text node (#504, #13143)\\n\\t\\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\\n\\t\\t\\tsrc.target.parentNode :\\n\\t\\t\\tsrc.target;\\n\\n\\t\\tthis.currentTarget = src.currentTarget;\\n\\t\\tthis.relatedTarget = src.relatedTarget;\\n\\n\\t// Event type\\n\\t} else {\\n\\t\\tthis.type = src;\\n\\t}\\n\\n\\t// Put explicitly provided properties onto the event object\\n\\tif ( props ) {\\n\\t\\tjQuery.extend( this, props );\\n\\t}\\n\\n\\t// Create a timestamp if incoming event doesn't have one\\n\\tthis.timeStamp = src && src.timeStamp || Date.now();\\n\\n\\t// Mark it as fixed\\n\\tthis[ jQuery.expando ] = true;\\n};\\n\\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\\n// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\\njQuery.Event.prototype = {\\n\\tconstructor: jQuery.Event,\\n\\tisDefaultPrevented: returnFalse,\\n\\tisPropagationStopped: returnFalse,\\n\\tisImmediatePropagationStopped: returnFalse,\\n\\tisSimulated: false,\\n\\n\\tpreventDefault: function() {\\n\\t\\tvar e = this.originalEvent;\\n\\n\\t\\tthis.isDefaultPrevented = returnTrue;\\n\\n\\t\\tif ( e && !this.isSimulated ) {\\n\\t\\t\\te.preventDefault();\\n\\t\\t}\\n\\t},\\n\\tstopPropagation: function() {\\n\\t\\tvar e = this.originalEvent;\\n\\n\\t\\tthis.isPropagationStopped = returnTrue;\\n\\n\\t\\tif ( e && !this.isSimulated ) {\\n\\t\\t\\te.stopPropagation();\\n\\t\\t}\\n\\t},\\n\\tstopImmediatePropagation: function() {\\n\\t\\tvar e = this.originalEvent;\\n\\n\\t\\tthis.isImmediatePropagationStopped = returnTrue;\\n\\n\\t\\tif ( e && !this.isSimulated ) {\\n\\t\\t\\te.stopImmediatePropagation();\\n\\t\\t}\\n\\n\\t\\tthis.stopPropagation();\\n\\t}\\n};\\n\\n// Includes all common event props including KeyEvent and MouseEvent specific props\\njQuery.each( {\\n\\taltKey: true,\\n\\tbubbles: true,\\n\\tcancelable: true,\\n\\tchangedTouches: true,\\n\\tctrlKey: true,\\n\\tdetail: true,\\n\\teventPhase: true,\\n\\tmetaKey: true,\\n\\tpageX: true,\\n\\tpageY: true,\\n\\tshiftKey: true,\\n\\tview: true,\\n\\t\\\"char\\\": true,\\n\\tcharCode: true,\\n\\tkey: true,\\n\\tkeyCode: true,\\n\\tbutton: true,\\n\\tbuttons: true,\\n\\tclientX: true,\\n\\tclientY: true,\\n\\toffsetX: true,\\n\\toffsetY: true,\\n\\tpointerId: true,\\n\\tpointerType: true,\\n\\tscreenX: true,\\n\\tscreenY: true,\\n\\ttargetTouches: true,\\n\\ttoElement: true,\\n\\ttouches: true,\\n\\n\\twhich: function( event ) {\\n\\t\\tvar button = event.button;\\n\\n\\t\\t// Add which for key events\\n\\t\\tif ( event.which == null && rkeyEvent.test( event.type ) ) {\\n\\t\\t\\treturn event.charCode != null ? event.charCode : event.keyCode;\\n\\t\\t}\\n\\n\\t\\t// Add which for click: 1 === left; 2 === middle; 3 === right\\n\\t\\tif ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {\\n\\t\\t\\tif ( button & 1 ) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( button & 2 ) {\\n\\t\\t\\t\\treturn 3;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( button & 4 ) {\\n\\t\\t\\t\\treturn 2;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\treturn event.which;\\n\\t}\\n}, jQuery.event.addProp );\\n\\n// Create mouseenter/leave events using mouseover/out and event-time checks\\n// so that event delegation works in jQuery.\\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\\n//\\n// Support: Safari 7 only\\n// Safari sends mouseenter too often; see:\\n// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\\n// for the description of the bug (it existed in older Chrome versions as well).\\njQuery.each( {\\n\\tmouseenter: \\\"mouseover\\\",\\n\\tmouseleave: \\\"mouseout\\\",\\n\\tpointerenter: \\\"pointerover\\\",\\n\\tpointerleave: \\\"pointerout\\\"\\n}, function( orig, fix ) {\\n\\tjQuery.event.special[ orig ] = {\\n\\t\\tdelegateType: fix,\\n\\t\\tbindType: fix,\\n\\n\\t\\thandle: function( event ) {\\n\\t\\t\\tvar ret,\\n\\t\\t\\t\\ttarget = this,\\n\\t\\t\\t\\trelated = event.relatedTarget,\\n\\t\\t\\t\\thandleObj = event.handleObj;\\n\\n\\t\\t\\t// For mouseenter/leave call the handler if related is outside the target.\\n\\t\\t\\t// NB: No relatedTarget if the mouse left/entered the browser window\\n\\t\\t\\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\\n\\t\\t\\t\\tevent.type = handleObj.origType;\\n\\t\\t\\t\\tret = handleObj.handler.apply( this, arguments );\\n\\t\\t\\t\\tevent.type = fix;\\n\\t\\t\\t}\\n\\t\\t\\treturn ret;\\n\\t\\t}\\n\\t};\\n} );\\n\\njQuery.fn.extend( {\\n\\n\\ton: function( types, selector, data, fn ) {\\n\\t\\treturn on( this, types, selector, data, fn );\\n\\t},\\n\\tone: function( types, selector, data, fn ) {\\n\\t\\treturn on( this, types, selector, data, fn, 1 );\\n\\t},\\n\\toff: function( types, selector, fn ) {\\n\\t\\tvar handleObj, type;\\n\\t\\tif ( types && types.preventDefault && types.handleObj ) {\\n\\n\\t\\t\\t// ( event )  dispatched jQuery.Event\\n\\t\\t\\thandleObj = types.handleObj;\\n\\t\\t\\tjQuery( types.delegateTarget ).off(\\n\\t\\t\\t\\thandleObj.namespace ?\\n\\t\\t\\t\\t\\thandleObj.origType + \\\".\\\" + handleObj.namespace :\\n\\t\\t\\t\\t\\thandleObj.origType,\\n\\t\\t\\t\\thandleObj.selector,\\n\\t\\t\\t\\thandleObj.handler\\n\\t\\t\\t);\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\t\\tif ( typeof types === \\\"object\\\" ) {\\n\\n\\t\\t\\t// ( types-object [, selector] )\\n\\t\\t\\tfor ( type in types ) {\\n\\t\\t\\t\\tthis.off( type, selector, types[ type ] );\\n\\t\\t\\t}\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\t\\tif ( selector === false || typeof selector === \\\"function\\\" ) {\\n\\n\\t\\t\\t// ( types [, fn] )\\n\\t\\t\\tfn = selector;\\n\\t\\t\\tselector = undefined;\\n\\t\\t}\\n\\t\\tif ( fn === false ) {\\n\\t\\t\\tfn = returnFalse;\\n\\t\\t}\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tjQuery.event.remove( this, types, fn, selector );\\n\\t\\t} );\\n\\t}\\n} );\\n\\n\\nvar\\n\\n\\t/* eslint-disable max-len */\\n\\n\\t// See https://github.com/eslint/eslint/issues/3229\\n\\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\\\/\\\\0>\\\\x20\\\\t\\\\r\\\\n\\\\f]*)[^>]*)\\\\/>/gi,\\n\\n\\t/* eslint-enable */\\n\\n\\t// Support: IE <=10 - 11, Edge 12 - 13 only\\n\\t// In IE/Edge using regex groups here causes severe slowdowns.\\n\\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\\n\\trnoInnerhtml = /<script|<style|<link/i,\\n\\n\\t// checked=\\\"checked\\\" or checked\\n\\trchecked = /checked\\\\s*(?:[^=]|=\\\\s*.checked.)/i,\\n\\trcleanScript = /^\\\\s*<!(?:\\\\[CDATA\\\\[|--)|(?:\\\\]\\\\]|--)>\\\\s*$/g;\\n\\n// Prefer a tbody over its parent table for containing new rows\\nfunction manipulationTarget( elem, content ) {\\n\\tif ( nodeName( elem, \\\"table\\\" ) &&\\n\\t\\tnodeName( content.nodeType !== 11 ? content : content.firstChild, \\\"tr\\\" ) ) {\\n\\n\\t\\treturn jQuery( elem ).children( \\\"tbody\\\" )[ 0 ] || elem;\\n\\t}\\n\\n\\treturn elem;\\n}\\n\\n// Replace/restore the type attribute of script elements for safe DOM manipulation\\nfunction disableScript( elem ) {\\n\\telem.type = ( elem.getAttribute( \\\"type\\\" ) !== null ) + \\\"/\\\" + elem.type;\\n\\treturn elem;\\n}\\nfunction restoreScript( elem ) {\\n\\tif ( ( elem.type || \\\"\\\" ).slice( 0, 5 ) === \\\"true/\\\" ) {\\n\\t\\telem.type = elem.type.slice( 5 );\\n\\t} else {\\n\\t\\telem.removeAttribute( \\\"type\\\" );\\n\\t}\\n\\n\\treturn elem;\\n}\\n\\nfunction cloneCopyEvent( src, dest ) {\\n\\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\\n\\n\\tif ( dest.nodeType !== 1 ) {\\n\\t\\treturn;\\n\\t}\\n\\n\\t// 1. Copy private data: events, handlers, etc.\\n\\tif ( dataPriv.hasData( src ) ) {\\n\\t\\tpdataOld = dataPriv.access( src );\\n\\t\\tpdataCur = dataPriv.set( dest, pdataOld );\\n\\t\\tevents = pdataOld.events;\\n\\n\\t\\tif ( events ) {\\n\\t\\t\\tdelete pdataCur.handle;\\n\\t\\t\\tpdataCur.events = {};\\n\\n\\t\\t\\tfor ( type in events ) {\\n\\t\\t\\t\\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\\n\\t\\t\\t\\t\\tjQuery.event.add( dest, type, events[ type ][ i ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// 2. Copy user data\\n\\tif ( dataUser.hasData( src ) ) {\\n\\t\\tudataOld = dataUser.access( src );\\n\\t\\tudataCur = jQuery.extend( {}, udataOld );\\n\\n\\t\\tdataUser.set( dest, udataCur );\\n\\t}\\n}\\n\\n// Fix IE bugs, see support tests\\nfunction fixInput( src, dest ) {\\n\\tvar nodeName = dest.nodeName.toLowerCase();\\n\\n\\t// Fails to persist the checked state of a cloned checkbox or radio button.\\n\\tif ( nodeName === \\\"input\\\" && rcheckableType.test( src.type ) ) {\\n\\t\\tdest.checked = src.checked;\\n\\n\\t// Fails to return the selected option to the default selected state when cloning options\\n\\t} else if ( nodeName === \\\"input\\\" || nodeName === \\\"textarea\\\" ) {\\n\\t\\tdest.defaultValue = src.defaultValue;\\n\\t}\\n}\\n\\nfunction domManip( collection, args, callback, ignored ) {\\n\\n\\t// Flatten any nested arrays\\n\\targs = concat.apply( [], args );\\n\\n\\tvar fragment, first, scripts, hasScripts, node, doc,\\n\\t\\ti = 0,\\n\\t\\tl = collection.length,\\n\\t\\tiNoClone = l - 1,\\n\\t\\tvalue = args[ 0 ],\\n\\t\\tvalueIsFunction = isFunction( value );\\n\\n\\t// We can't cloneNode fragments that contain checked, in WebKit\\n\\tif ( valueIsFunction ||\\n\\t\\t\\t( l > 1 && typeof value === \\\"string\\\" &&\\n\\t\\t\\t\\t!support.checkClone && rchecked.test( value ) ) ) {\\n\\t\\treturn collection.each( function( index ) {\\n\\t\\t\\tvar self = collection.eq( index );\\n\\t\\t\\tif ( valueIsFunction ) {\\n\\t\\t\\t\\targs[ 0 ] = value.call( this, index, self.html() );\\n\\t\\t\\t}\\n\\t\\t\\tdomManip( self, args, callback, ignored );\\n\\t\\t} );\\n\\t}\\n\\n\\tif ( l ) {\\n\\t\\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\\n\\t\\tfirst = fragment.firstChild;\\n\\n\\t\\tif ( fragment.childNodes.length === 1 ) {\\n\\t\\t\\tfragment = first;\\n\\t\\t}\\n\\n\\t\\t// Require either new content or an interest in ignored elements to invoke the callback\\n\\t\\tif ( first || ignored ) {\\n\\t\\t\\tscripts = jQuery.map( getAll( fragment, \\\"script\\\" ), disableScript );\\n\\t\\t\\thasScripts = scripts.length;\\n\\n\\t\\t\\t// Use the original fragment for the last item\\n\\t\\t\\t// instead of the first because it can end up\\n\\t\\t\\t// being emptied incorrectly in certain situations (#8070).\\n\\t\\t\\tfor ( ; i < l; i++ ) {\\n\\t\\t\\t\\tnode = fragment;\\n\\n\\t\\t\\t\\tif ( i !== iNoClone ) {\\n\\t\\t\\t\\t\\tnode = jQuery.clone( node, true, true );\\n\\n\\t\\t\\t\\t\\t// Keep references to cloned scripts for later restoration\\n\\t\\t\\t\\t\\tif ( hasScripts ) {\\n\\n\\t\\t\\t\\t\\t\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t\\t\\t\\t\\t\\t// push.apply(_, arraylike) throws on ancient WebKit\\n\\t\\t\\t\\t\\t\\tjQuery.merge( scripts, getAll( node, \\\"script\\\" ) );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcallback.call( collection[ i ], node, i );\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( hasScripts ) {\\n\\t\\t\\t\\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\\n\\n\\t\\t\\t\\t// Reenable scripts\\n\\t\\t\\t\\tjQuery.map( scripts, restoreScript );\\n\\n\\t\\t\\t\\t// Evaluate executable scripts on first document insertion\\n\\t\\t\\t\\tfor ( i = 0; i < hasScripts; i++ ) {\\n\\t\\t\\t\\t\\tnode = scripts[ i ];\\n\\t\\t\\t\\t\\tif ( rscriptType.test( node.type || \\\"\\\" ) &&\\n\\t\\t\\t\\t\\t\\t!dataPriv.access( node, \\\"globalEval\\\" ) &&\\n\\t\\t\\t\\t\\t\\tjQuery.contains( doc, node ) ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( node.src && ( node.type || \\\"\\\" ).toLowerCase()  !== \\\"module\\\" ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Optional AJAX dependency, but won't run scripts if not present\\n\\t\\t\\t\\t\\t\\t\\tif ( jQuery._evalUrl ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery._evalUrl( node.src );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tDOMEval( node.textContent.replace( rcleanScript, \\\"\\\" ), doc, node );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn collection;\\n}\\n\\nfunction remove( elem, selector, keepData ) {\\n\\tvar node,\\n\\t\\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\\n\\t\\ti = 0;\\n\\n\\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\\n\\t\\tif ( !keepData && node.nodeType === 1 ) {\\n\\t\\t\\tjQuery.cleanData( getAll( node ) );\\n\\t\\t}\\n\\n\\t\\tif ( node.parentNode ) {\\n\\t\\t\\tif ( keepData && jQuery.contains( node.ownerDocument, node ) ) {\\n\\t\\t\\t\\tsetGlobalEval( getAll( node, \\\"script\\\" ) );\\n\\t\\t\\t}\\n\\t\\t\\tnode.parentNode.removeChild( node );\\n\\t\\t}\\n\\t}\\n\\n\\treturn elem;\\n}\\n\\njQuery.extend( {\\n\\thtmlPrefilter: function( html ) {\\n\\t\\treturn html.replace( rxhtmlTag, \\\"<$1></$2>\\\" );\\n\\t},\\n\\n\\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\\n\\t\\tvar i, l, srcElements, destElements,\\n\\t\\t\\tclone = elem.cloneNode( true ),\\n\\t\\t\\tinPage = jQuery.contains( elem.ownerDocument, elem );\\n\\n\\t\\t// Fix IE cloning issues\\n\\t\\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\\n\\t\\t\\t\\t!jQuery.isXMLDoc( elem ) ) {\\n\\n\\t\\t\\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\\n\\t\\t\\tdestElements = getAll( clone );\\n\\t\\t\\tsrcElements = getAll( elem );\\n\\n\\t\\t\\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\\n\\t\\t\\t\\tfixInput( srcElements[ i ], destElements[ i ] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Copy the events from the original to the clone\\n\\t\\tif ( dataAndEvents ) {\\n\\t\\t\\tif ( deepDataAndEvents ) {\\n\\t\\t\\t\\tsrcElements = srcElements || getAll( elem );\\n\\t\\t\\t\\tdestElements = destElements || getAll( clone );\\n\\n\\t\\t\\t\\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\\n\\t\\t\\t\\t\\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcloneCopyEvent( elem, clone );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Preserve script evaluation history\\n\\t\\tdestElements = getAll( clone, \\\"script\\\" );\\n\\t\\tif ( destElements.length > 0 ) {\\n\\t\\t\\tsetGlobalEval( destElements, !inPage && getAll( elem, \\\"script\\\" ) );\\n\\t\\t}\\n\\n\\t\\t// Return the cloned set\\n\\t\\treturn clone;\\n\\t},\\n\\n\\tcleanData: function( elems ) {\\n\\t\\tvar data, elem, type,\\n\\t\\t\\tspecial = jQuery.event.special,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\\n\\t\\t\\tif ( acceptData( elem ) ) {\\n\\t\\t\\t\\tif ( ( data = elem[ dataPriv.expando ] ) ) {\\n\\t\\t\\t\\t\\tif ( data.events ) {\\n\\t\\t\\t\\t\\t\\tfor ( type in data.events ) {\\n\\t\\t\\t\\t\\t\\t\\tif ( special[ type ] ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery.event.remove( elem, type );\\n\\n\\t\\t\\t\\t\\t\\t\\t// This is a shortcut to avoid jQuery.event.remove's overhead\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery.removeEvent( elem, type, data.handle );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Support: Chrome <=35 - 45+\\n\\t\\t\\t\\t\\t// Assign undefined instead of using delete, see Data#remove\\n\\t\\t\\t\\t\\telem[ dataPriv.expando ] = undefined;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( elem[ dataUser.expando ] ) {\\n\\n\\t\\t\\t\\t\\t// Support: Chrome <=35 - 45+\\n\\t\\t\\t\\t\\t// Assign undefined instead of using delete, see Data#remove\\n\\t\\t\\t\\t\\telem[ dataUser.expando ] = undefined;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n} );\\n\\njQuery.fn.extend( {\\n\\tdetach: function( selector ) {\\n\\t\\treturn remove( this, selector, true );\\n\\t},\\n\\n\\tremove: function( selector ) {\\n\\t\\treturn remove( this, selector );\\n\\t},\\n\\n\\ttext: function( value ) {\\n\\t\\treturn access( this, function( value ) {\\n\\t\\t\\treturn value === undefined ?\\n\\t\\t\\t\\tjQuery.text( this ) :\\n\\t\\t\\t\\tthis.empty().each( function() {\\n\\t\\t\\t\\t\\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\\n\\t\\t\\t\\t\\t\\tthis.textContent = value;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} );\\n\\t\\t}, null, value, arguments.length );\\n\\t},\\n\\n\\tappend: function() {\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\\n\\t\\t\\t\\tvar target = manipulationTarget( this, elem );\\n\\t\\t\\t\\ttarget.appendChild( elem );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tprepend: function() {\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\\n\\t\\t\\t\\tvar target = manipulationTarget( this, elem );\\n\\t\\t\\t\\ttarget.insertBefore( elem, target.firstChild );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tbefore: function() {\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tif ( this.parentNode ) {\\n\\t\\t\\t\\tthis.parentNode.insertBefore( elem, this );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tafter: function() {\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tif ( this.parentNode ) {\\n\\t\\t\\t\\tthis.parentNode.insertBefore( elem, this.nextSibling );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tempty: function() {\\n\\t\\tvar elem,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\\n\\t\\t\\tif ( elem.nodeType === 1 ) {\\n\\n\\t\\t\\t\\t// Prevent memory leaks\\n\\t\\t\\t\\tjQuery.cleanData( getAll( elem, false ) );\\n\\n\\t\\t\\t\\t// Remove any remaining nodes\\n\\t\\t\\t\\telem.textContent = \\\"\\\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\tclone: function( dataAndEvents, deepDataAndEvents ) {\\n\\t\\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\\n\\t\\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\\n\\n\\t\\treturn this.map( function() {\\n\\t\\t\\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\\n\\t\\t} );\\n\\t},\\n\\n\\thtml: function( value ) {\\n\\t\\treturn access( this, function( value ) {\\n\\t\\t\\tvar elem = this[ 0 ] || {},\\n\\t\\t\\t\\ti = 0,\\n\\t\\t\\t\\tl = this.length;\\n\\n\\t\\t\\tif ( value === undefined && elem.nodeType === 1 ) {\\n\\t\\t\\t\\treturn elem.innerHTML;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// See if we can take a shortcut and just use innerHTML\\n\\t\\t\\tif ( typeof value === \\\"string\\\" && !rnoInnerhtml.test( value ) &&\\n\\t\\t\\t\\t!wrapMap[ ( rtagName.exec( value ) || [ \\\"\\\", \\\"\\\" ] )[ 1 ].toLowerCase() ] ) {\\n\\n\\t\\t\\t\\tvalue = jQuery.htmlPrefilter( value );\\n\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tfor ( ; i < l; i++ ) {\\n\\t\\t\\t\\t\\t\\telem = this[ i ] || {};\\n\\n\\t\\t\\t\\t\\t\\t// Remove element nodes and prevent memory leaks\\n\\t\\t\\t\\t\\t\\tif ( elem.nodeType === 1 ) {\\n\\t\\t\\t\\t\\t\\t\\tjQuery.cleanData( getAll( elem, false ) );\\n\\t\\t\\t\\t\\t\\t\\telem.innerHTML = value;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\telem = 0;\\n\\n\\t\\t\\t\\t// If using innerHTML throws an exception, use the fallback method\\n\\t\\t\\t\\t} catch ( e ) {}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( elem ) {\\n\\t\\t\\t\\tthis.empty().append( value );\\n\\t\\t\\t}\\n\\t\\t}, null, value, arguments.length );\\n\\t},\\n\\n\\treplaceWith: function() {\\n\\t\\tvar ignored = [];\\n\\n\\t\\t// Make the changes, replacing each non-ignored context element with the new content\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tvar parent = this.parentNode;\\n\\n\\t\\t\\tif ( jQuery.inArray( this, ignored ) < 0 ) {\\n\\t\\t\\t\\tjQuery.cleanData( getAll( this ) );\\n\\t\\t\\t\\tif ( parent ) {\\n\\t\\t\\t\\t\\tparent.replaceChild( elem, this );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t// Force callback invocation\\n\\t\\t}, ignored );\\n\\t}\\n} );\\n\\njQuery.each( {\\n\\tappendTo: \\\"append\\\",\\n\\tprependTo: \\\"prepend\\\",\\n\\tinsertBefore: \\\"before\\\",\\n\\tinsertAfter: \\\"after\\\",\\n\\treplaceAll: \\\"replaceWith\\\"\\n}, function( name, original ) {\\n\\tjQuery.fn[ name ] = function( selector ) {\\n\\t\\tvar elems,\\n\\t\\t\\tret = [],\\n\\t\\t\\tinsert = jQuery( selector ),\\n\\t\\t\\tlast = insert.length - 1,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tfor ( ; i <= last; i++ ) {\\n\\t\\t\\telems = i === last ? this : this.clone( true );\\n\\t\\t\\tjQuery( insert[ i ] )[ original ]( elems );\\n\\n\\t\\t\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t\\t\\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\\n\\t\\t\\tpush.apply( ret, elems.get() );\\n\\t\\t}\\n\\n\\t\\treturn this.pushStack( ret );\\n\\t};\\n} );\\nvar rnumnonpx = new RegExp( \\\"^(\\\" + pnum + \\\")(?!px)[a-z%]+$\\\", \\\"i\\\" );\\n\\nvar getStyles = function( elem ) {\\n\\n\\t\\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\\n\\t\\t// IE throws on elements created in popups\\n\\t\\t// FF meanwhile throws on frame elements through \\\"defaultView.getComputedStyle\\\"\\n\\t\\tvar view = elem.ownerDocument.defaultView;\\n\\n\\t\\tif ( !view || !view.opener ) {\\n\\t\\t\\tview = window;\\n\\t\\t}\\n\\n\\t\\treturn view.getComputedStyle( elem );\\n\\t};\\n\\nvar rboxStyle = new RegExp( cssExpand.join( \\\"|\\\" ), \\\"i\\\" );\\n\\n\\n\\n( function() {\\n\\n\\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\\n\\t// so they're executed at the same time to save the second computation.\\n\\tfunction computeStyleTests() {\\n\\n\\t\\t// This is a singleton, we need to execute it only once\\n\\t\\tif ( !div ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tcontainer.style.cssText = \\\"position:absolute;left:-11111px;width:60px;\\\" +\\n\\t\\t\\t\\\"margin-top:1px;padding:0;border:0\\\";\\n\\t\\tdiv.style.cssText =\\n\\t\\t\\t\\\"position:relative;display:block;box-sizing:border-box;overflow:scroll;\\\" +\\n\\t\\t\\t\\\"margin:auto;border:1px;padding:1px;\\\" +\\n\\t\\t\\t\\\"width:60%;top:1%\\\";\\n\\t\\tdocumentElement.appendChild( container ).appendChild( div );\\n\\n\\t\\tvar divStyle = window.getComputedStyle( div );\\n\\t\\tpixelPositionVal = divStyle.top !== \\\"1%\\\";\\n\\n\\t\\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\\n\\t\\treliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;\\n\\n\\t\\t// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3\\n\\t\\t// Some styles come back with percentage values, even though they shouldn't\\n\\t\\tdiv.style.right = \\\"60%\\\";\\n\\t\\tpixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;\\n\\n\\t\\t// Support: IE 9 - 11 only\\n\\t\\t// Detect misreporting of content dimensions for box-sizing:border-box elements\\n\\t\\tboxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;\\n\\n\\t\\t// Support: IE 9 only\\n\\t\\t// Detect overflow:scroll screwiness (gh-3699)\\n\\t\\tdiv.style.position = \\\"absolute\\\";\\n\\t\\tscrollboxSizeVal = div.offsetWidth === 36 || \\\"absolute\\\";\\n\\n\\t\\tdocumentElement.removeChild( container );\\n\\n\\t\\t// Nullify the div so it wouldn't be stored in the memory and\\n\\t\\t// it will also be a sign that checks already performed\\n\\t\\tdiv = null;\\n\\t}\\n\\n\\tfunction roundPixelMeasures( measure ) {\\n\\t\\treturn Math.round( parseFloat( measure ) );\\n\\t}\\n\\n\\tvar pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,\\n\\t\\treliableMarginLeftVal,\\n\\t\\tcontainer = document.createElement( \\\"div\\\" ),\\n\\t\\tdiv = document.createElement( \\\"div\\\" );\\n\\n\\t// Finish early in limited (non-browser) environments\\n\\tif ( !div.style ) {\\n\\t\\treturn;\\n\\t}\\n\\n\\t// Support: IE <=9 - 11 only\\n\\t// Style of cloned element affects source element cloned (#8908)\\n\\tdiv.style.backgroundClip = \\\"content-box\\\";\\n\\tdiv.cloneNode( true ).style.backgroundClip = \\\"\\\";\\n\\tsupport.clearCloneStyle = div.style.backgroundClip === \\\"content-box\\\";\\n\\n\\tjQuery.extend( support, {\\n\\t\\tboxSizingReliable: function() {\\n\\t\\t\\tcomputeStyleTests();\\n\\t\\t\\treturn boxSizingReliableVal;\\n\\t\\t},\\n\\t\\tpixelBoxStyles: function() {\\n\\t\\t\\tcomputeStyleTests();\\n\\t\\t\\treturn pixelBoxStylesVal;\\n\\t\\t},\\n\\t\\tpixelPosition: function() {\\n\\t\\t\\tcomputeStyleTests();\\n\\t\\t\\treturn pixelPositionVal;\\n\\t\\t},\\n\\t\\treliableMarginLeft: function() {\\n\\t\\t\\tcomputeStyleTests();\\n\\t\\t\\treturn reliableMarginLeftVal;\\n\\t\\t},\\n\\t\\tscrollboxSize: function() {\\n\\t\\t\\tcomputeStyleTests();\\n\\t\\t\\treturn scrollboxSizeVal;\\n\\t\\t}\\n\\t} );\\n} )();\\n\\n\\nfunction curCSS( elem, name, computed ) {\\n\\tvar width, minWidth, maxWidth, ret,\\n\\n\\t\\t// Support: Firefox 51+\\n\\t\\t// Retrieving style before computed somehow\\n\\t\\t// fixes an issue with getting wrong values\\n\\t\\t// on detached elements\\n\\t\\tstyle = elem.style;\\n\\n\\tcomputed = computed || getStyles( elem );\\n\\n\\t// getPropertyValue is needed for:\\n\\t//   .css('filter') (IE 9 only, #12537)\\n\\t//   .css('--customProperty) (#3144)\\n\\tif ( computed ) {\\n\\t\\tret = computed.getPropertyValue( name ) || computed[ name ];\\n\\n\\t\\tif ( ret === \\\"\\\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\\n\\t\\t\\tret = jQuery.style( elem, name );\\n\\t\\t}\\n\\n\\t\\t// A tribute to the \\\"awesome hack by Dean Edwards\\\"\\n\\t\\t// Android Browser returns percentage for some values,\\n\\t\\t// but width seems to be reliably pixels.\\n\\t\\t// This is against the CSSOM draft spec:\\n\\t\\t// https://drafts.csswg.org/cssom/#resolved-values\\n\\t\\tif ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {\\n\\n\\t\\t\\t// Remember the original values\\n\\t\\t\\twidth = style.width;\\n\\t\\t\\tminWidth = style.minWidth;\\n\\t\\t\\tmaxWidth = style.maxWidth;\\n\\n\\t\\t\\t// Put in the new values to get a computed value out\\n\\t\\t\\tstyle.minWidth = style.maxWidth = style.width = ret;\\n\\t\\t\\tret = computed.width;\\n\\n\\t\\t\\t// Revert the changed values\\n\\t\\t\\tstyle.width = width;\\n\\t\\t\\tstyle.minWidth = minWidth;\\n\\t\\t\\tstyle.maxWidth = maxWidth;\\n\\t\\t}\\n\\t}\\n\\n\\treturn ret !== undefined ?\\n\\n\\t\\t// Support: IE <=9 - 11 only\\n\\t\\t// IE returns zIndex value as an integer.\\n\\t\\tret + \\\"\\\" :\\n\\t\\tret;\\n}\\n\\n\\nfunction addGetHookIf( conditionFn, hookFn ) {\\n\\n\\t// Define the hook, we'll check on the first run if it's really needed.\\n\\treturn {\\n\\t\\tget: function() {\\n\\t\\t\\tif ( conditionFn() ) {\\n\\n\\t\\t\\t\\t// Hook not needed (or it's not possible to use it due\\n\\t\\t\\t\\t// to missing dependency), remove it.\\n\\t\\t\\t\\tdelete this.get;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Hook needed; redefine it so that the support test is not executed again.\\n\\t\\t\\treturn ( this.get = hookFn ).apply( this, arguments );\\n\\t\\t}\\n\\t};\\n}\\n\\n\\nvar\\n\\n\\t// Swappable if display is none or starts with table\\n\\t// except \\\"table\\\", \\\"table-cell\\\", or \\\"table-caption\\\"\\n\\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\\n\\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\\n\\trcustomProp = /^--/,\\n\\tcssShow = { position: \\\"absolute\\\", visibility: \\\"hidden\\\", display: \\\"block\\\" },\\n\\tcssNormalTransform = {\\n\\t\\tletterSpacing: \\\"0\\\",\\n\\t\\tfontWeight: \\\"400\\\"\\n\\t},\\n\\n\\tcssPrefixes = [ \\\"Webkit\\\", \\\"Moz\\\", \\\"ms\\\" ],\\n\\temptyStyle = document.createElement( \\\"div\\\" ).style;\\n\\n// Return a css property mapped to a potentially vendor prefixed property\\nfunction vendorPropName( name ) {\\n\\n\\t// Shortcut for names that are not vendor prefixed\\n\\tif ( name in emptyStyle ) {\\n\\t\\treturn name;\\n\\t}\\n\\n\\t// Check for vendor prefixed names\\n\\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\\n\\t\\ti = cssPrefixes.length;\\n\\n\\twhile ( i-- ) {\\n\\t\\tname = cssPrefixes[ i ] + capName;\\n\\t\\tif ( name in emptyStyle ) {\\n\\t\\t\\treturn name;\\n\\t\\t}\\n\\t}\\n}\\n\\n// Return a property mapped along what jQuery.cssProps suggests or to\\n// a vendor prefixed property.\\nfunction finalPropName( name ) {\\n\\tvar ret = jQuery.cssProps[ name ];\\n\\tif ( !ret ) {\\n\\t\\tret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;\\n\\t}\\n\\treturn ret;\\n}\\n\\nfunction setPositiveNumber( elem, value, subtract ) {\\n\\n\\t// Any relative (+/-) values have already been\\n\\t// normalized at this point\\n\\tvar matches = rcssNum.exec( value );\\n\\treturn matches ?\\n\\n\\t\\t// Guard against undefined \\\"subtract\\\", e.g., when used as in cssHooks\\n\\t\\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \\\"px\\\" ) :\\n\\t\\tvalue;\\n}\\n\\nfunction boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {\\n\\tvar i = dimension === \\\"width\\\" ? 1 : 0,\\n\\t\\textra = 0,\\n\\t\\tdelta = 0;\\n\\n\\t// Adjustment may not be necessary\\n\\tif ( box === ( isBorderBox ? \\\"border\\\" : \\\"content\\\" ) ) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tfor ( ; i < 4; i += 2 ) {\\n\\n\\t\\t// Both box models exclude margin\\n\\t\\tif ( box === \\\"margin\\\" ) {\\n\\t\\t\\tdelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );\\n\\t\\t}\\n\\n\\t\\t// If we get here with a content-box, we're seeking \\\"padding\\\" or \\\"border\\\" or \\\"margin\\\"\\n\\t\\tif ( !isBorderBox ) {\\n\\n\\t\\t\\t// Add padding\\n\\t\\t\\tdelta += jQuery.css( elem, \\\"padding\\\" + cssExpand[ i ], true, styles );\\n\\n\\t\\t\\t// For \\\"border\\\" or \\\"margin\\\", add border\\n\\t\\t\\tif ( box !== \\\"padding\\\" ) {\\n\\t\\t\\t\\tdelta += jQuery.css( elem, \\\"border\\\" + cssExpand[ i ] + \\\"Width\\\", true, styles );\\n\\n\\t\\t\\t// But still keep track of it otherwise\\n\\t\\t\\t} else {\\n\\t\\t\\t\\textra += jQuery.css( elem, \\\"border\\\" + cssExpand[ i ] + \\\"Width\\\", true, styles );\\n\\t\\t\\t}\\n\\n\\t\\t// If we get here with a border-box (content + padding + border), we're seeking \\\"content\\\" or\\n\\t\\t// \\\"padding\\\" or \\\"margin\\\"\\n\\t\\t} else {\\n\\n\\t\\t\\t// For \\\"content\\\", subtract padding\\n\\t\\t\\tif ( box === \\\"content\\\" ) {\\n\\t\\t\\t\\tdelta -= jQuery.css( elem, \\\"padding\\\" + cssExpand[ i ], true, styles );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// For \\\"content\\\" or \\\"padding\\\", subtract border\\n\\t\\t\\tif ( box !== \\\"margin\\\" ) {\\n\\t\\t\\t\\tdelta -= jQuery.css( elem, \\\"border\\\" + cssExpand[ i ] + \\\"Width\\\", true, styles );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Account for positive content-box scroll gutter when requested by providing computedVal\\n\\tif ( !isBorderBox && computedVal >= 0 ) {\\n\\n\\t\\t// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border\\n\\t\\t// Assuming integer scroll gutter, subtract the rest and round down\\n\\t\\tdelta += Math.max( 0, Math.ceil(\\n\\t\\t\\telem[ \\\"offset\\\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\\n\\t\\t\\tcomputedVal -\\n\\t\\t\\tdelta -\\n\\t\\t\\textra -\\n\\t\\t\\t0.5\\n\\t\\t) );\\n\\t}\\n\\n\\treturn delta;\\n}\\n\\nfunction getWidthOrHeight( elem, dimension, extra ) {\\n\\n\\t// Start with computed style\\n\\tvar styles = getStyles( elem ),\\n\\t\\tval = curCSS( elem, dimension, styles ),\\n\\t\\tisBorderBox = jQuery.css( elem, \\\"boxSizing\\\", false, styles ) === \\\"border-box\\\",\\n\\t\\tvalueIsBorderBox = isBorderBox;\\n\\n\\t// Support: Firefox <=54\\n\\t// Return a confounding non-pixel value or feign ignorance, as appropriate.\\n\\tif ( rnumnonpx.test( val ) ) {\\n\\t\\tif ( !extra ) {\\n\\t\\t\\treturn val;\\n\\t\\t}\\n\\t\\tval = \\\"auto\\\";\\n\\t}\\n\\n\\t// Check for style in case a browser which returns unreliable values\\n\\t// for getComputedStyle silently falls back to the reliable elem.style\\n\\tvalueIsBorderBox = valueIsBorderBox &&\\n\\t\\t( support.boxSizingReliable() || val === elem.style[ dimension ] );\\n\\n\\t// Fall back to offsetWidth/offsetHeight when value is \\\"auto\\\"\\n\\t// This happens for inline elements with no explicit setting (gh-3571)\\n\\t// Support: Android <=4.1 - 4.3 only\\n\\t// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)\\n\\tif ( val === \\\"auto\\\" ||\\n\\t\\t!parseFloat( val ) && jQuery.css( elem, \\\"display\\\", false, styles ) === \\\"inline\\\" ) {\\n\\n\\t\\tval = elem[ \\\"offset\\\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ];\\n\\n\\t\\t// offsetWidth/offsetHeight provide border-box values\\n\\t\\tvalueIsBorderBox = true;\\n\\t}\\n\\n\\t// Normalize \\\"\\\" and auto\\n\\tval = parseFloat( val ) || 0;\\n\\n\\t// Adjust for the element's box model\\n\\treturn ( val +\\n\\t\\tboxModelAdjustment(\\n\\t\\t\\telem,\\n\\t\\t\\tdimension,\\n\\t\\t\\textra || ( isBorderBox ? \\\"border\\\" : \\\"content\\\" ),\\n\\t\\t\\tvalueIsBorderBox,\\n\\t\\t\\tstyles,\\n\\n\\t\\t\\t// Provide the current computed size to request scroll gutter calculation (gh-3589)\\n\\t\\t\\tval\\n\\t\\t)\\n\\t) + \\\"px\\\";\\n}\\n\\njQuery.extend( {\\n\\n\\t// Add in style property hooks for overriding the default\\n\\t// behavior of getting and setting a style property\\n\\tcssHooks: {\\n\\t\\topacity: {\\n\\t\\t\\tget: function( elem, computed ) {\\n\\t\\t\\t\\tif ( computed ) {\\n\\n\\t\\t\\t\\t\\t// We should always get a number back from opacity\\n\\t\\t\\t\\t\\tvar ret = curCSS( elem, \\\"opacity\\\" );\\n\\t\\t\\t\\t\\treturn ret === \\\"\\\" ? \\\"1\\\" : ret;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\t// Don't automatically add \\\"px\\\" to these possibly-unitless properties\\n\\tcssNumber: {\\n\\t\\t\\\"animationIterationCount\\\": true,\\n\\t\\t\\\"columnCount\\\": true,\\n\\t\\t\\\"fillOpacity\\\": true,\\n\\t\\t\\\"flexGrow\\\": true,\\n\\t\\t\\\"flexShrink\\\": true,\\n\\t\\t\\\"fontWeight\\\": true,\\n\\t\\t\\\"lineHeight\\\": true,\\n\\t\\t\\\"opacity\\\": true,\\n\\t\\t\\\"order\\\": true,\\n\\t\\t\\\"orphans\\\": true,\\n\\t\\t\\\"widows\\\": true,\\n\\t\\t\\\"zIndex\\\": true,\\n\\t\\t\\\"zoom\\\": true\\n\\t},\\n\\n\\t// Add in properties whose names you wish to fix before\\n\\t// setting or getting the value\\n\\tcssProps: {},\\n\\n\\t// Get and set the style property on a DOM Node\\n\\tstyle: function( elem, name, value, extra ) {\\n\\n\\t\\t// Don't set styles on text and comment nodes\\n\\t\\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Make sure that we're working with the right name\\n\\t\\tvar ret, type, hooks,\\n\\t\\t\\torigName = camelCase( name ),\\n\\t\\t\\tisCustomProp = rcustomProp.test( name ),\\n\\t\\t\\tstyle = elem.style;\\n\\n\\t\\t// Make sure that we're working with the right name. We don't\\n\\t\\t// want to query the value if it is a CSS custom property\\n\\t\\t// since they are user-defined.\\n\\t\\tif ( !isCustomProp ) {\\n\\t\\t\\tname = finalPropName( origName );\\n\\t\\t}\\n\\n\\t\\t// Gets hook for the prefixed version, then unprefixed version\\n\\t\\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\\n\\n\\t\\t// Check if we're setting a value\\n\\t\\tif ( value !== undefined ) {\\n\\t\\t\\ttype = typeof value;\\n\\n\\t\\t\\t// Convert \\\"+=\\\" or \\\"-=\\\" to relative numbers (#7345)\\n\\t\\t\\tif ( type === \\\"string\\\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\\n\\t\\t\\t\\tvalue = adjustCSS( elem, name, ret );\\n\\n\\t\\t\\t\\t// Fixes bug #9237\\n\\t\\t\\t\\ttype = \\\"number\\\";\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Make sure that null and NaN values aren't set (#7116)\\n\\t\\t\\tif ( value == null || value !== value ) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If a number was passed in, add the unit (except for certain CSS properties)\\n\\t\\t\\tif ( type === \\\"number\\\" ) {\\n\\t\\t\\t\\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \\\"\\\" : \\\"px\\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// background-* props affect original clone's values\\n\\t\\t\\tif ( !support.clearCloneStyle && value === \\\"\\\" && name.indexOf( \\\"background\\\" ) === 0 ) {\\n\\t\\t\\t\\tstyle[ name ] = \\\"inherit\\\";\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If a hook was provided, use that value, otherwise just set the specified value\\n\\t\\t\\tif ( !hooks || !( \\\"set\\\" in hooks ) ||\\n\\t\\t\\t\\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\\n\\n\\t\\t\\t\\tif ( isCustomProp ) {\\n\\t\\t\\t\\t\\tstyle.setProperty( name, value );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tstyle[ name ] = value;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t} else {\\n\\n\\t\\t\\t// If a hook was provided get the non-computed value from there\\n\\t\\t\\tif ( hooks && \\\"get\\\" in hooks &&\\n\\t\\t\\t\\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\\n\\n\\t\\t\\t\\treturn ret;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Otherwise just get the value from the style object\\n\\t\\t\\treturn style[ name ];\\n\\t\\t}\\n\\t},\\n\\n\\tcss: function( elem, name, extra, styles ) {\\n\\t\\tvar val, num, hooks,\\n\\t\\t\\torigName = camelCase( name ),\\n\\t\\t\\tisCustomProp = rcustomProp.test( name );\\n\\n\\t\\t// Make sure that we're working with the right name. We don't\\n\\t\\t// want to modify the value if it is a CSS custom property\\n\\t\\t// since they are user-defined.\\n\\t\\tif ( !isCustomProp ) {\\n\\t\\t\\tname = finalPropName( origName );\\n\\t\\t}\\n\\n\\t\\t// Try prefixed name followed by the unprefixed name\\n\\t\\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\\n\\n\\t\\t// If a hook was provided get the computed value from there\\n\\t\\tif ( hooks && \\\"get\\\" in hooks ) {\\n\\t\\t\\tval = hooks.get( elem, true, extra );\\n\\t\\t}\\n\\n\\t\\t// Otherwise, if a way to get the computed value exists, use that\\n\\t\\tif ( val === undefined ) {\\n\\t\\t\\tval = curCSS( elem, name, styles );\\n\\t\\t}\\n\\n\\t\\t// Convert \\\"normal\\\" to computed value\\n\\t\\tif ( val === \\\"normal\\\" && name in cssNormalTransform ) {\\n\\t\\t\\tval = cssNormalTransform[ name ];\\n\\t\\t}\\n\\n\\t\\t// Make numeric if forced or a qualifier was provided and val looks numeric\\n\\t\\tif ( extra === \\\"\\\" || extra ) {\\n\\t\\t\\tnum = parseFloat( val );\\n\\t\\t\\treturn extra === true || isFinite( num ) ? num || 0 : val;\\n\\t\\t}\\n\\n\\t\\treturn val;\\n\\t}\\n} );\\n\\njQuery.each( [ \\\"height\\\", \\\"width\\\" ], function( i, dimension ) {\\n\\tjQuery.cssHooks[ dimension ] = {\\n\\t\\tget: function( elem, computed, extra ) {\\n\\t\\t\\tif ( computed ) {\\n\\n\\t\\t\\t\\t// Certain elements can have dimension info if we invisibly show them\\n\\t\\t\\t\\t// but it must have a current display style that would benefit\\n\\t\\t\\t\\treturn rdisplayswap.test( jQuery.css( elem, \\\"display\\\" ) ) &&\\n\\n\\t\\t\\t\\t\\t// Support: Safari 8+\\n\\t\\t\\t\\t\\t// Table columns in Safari have non-zero offsetWidth & zero\\n\\t\\t\\t\\t\\t// getBoundingClientRect().width unless display is changed.\\n\\t\\t\\t\\t\\t// Support: IE <=11 only\\n\\t\\t\\t\\t\\t// Running getBoundingClientRect on a disconnected node\\n\\t\\t\\t\\t\\t// in IE throws an error.\\n\\t\\t\\t\\t\\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\\n\\t\\t\\t\\t\\t\\tswap( elem, cssShow, function() {\\n\\t\\t\\t\\t\\t\\t\\treturn getWidthOrHeight( elem, dimension, extra );\\n\\t\\t\\t\\t\\t\\t} ) :\\n\\t\\t\\t\\t\\t\\tgetWidthOrHeight( elem, dimension, extra );\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tset: function( elem, value, extra ) {\\n\\t\\t\\tvar matches,\\n\\t\\t\\t\\tstyles = getStyles( elem ),\\n\\t\\t\\t\\tisBorderBox = jQuery.css( elem, \\\"boxSizing\\\", false, styles ) === \\\"border-box\\\",\\n\\t\\t\\t\\tsubtract = extra && boxModelAdjustment(\\n\\t\\t\\t\\t\\telem,\\n\\t\\t\\t\\t\\tdimension,\\n\\t\\t\\t\\t\\textra,\\n\\t\\t\\t\\t\\tisBorderBox,\\n\\t\\t\\t\\t\\tstyles\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t// Account for unreliable border-box dimensions by comparing offset* to computed and\\n\\t\\t\\t// faking a content-box to get border and padding (gh-3699)\\n\\t\\t\\tif ( isBorderBox && support.scrollboxSize() === styles.position ) {\\n\\t\\t\\t\\tsubtract -= Math.ceil(\\n\\t\\t\\t\\t\\telem[ \\\"offset\\\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\\n\\t\\t\\t\\t\\tparseFloat( styles[ dimension ] ) -\\n\\t\\t\\t\\t\\tboxModelAdjustment( elem, dimension, \\\"border\\\", false, styles ) -\\n\\t\\t\\t\\t\\t0.5\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Convert to pixels if value adjustment is needed\\n\\t\\t\\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\\n\\t\\t\\t\\t( matches[ 3 ] || \\\"px\\\" ) !== \\\"px\\\" ) {\\n\\n\\t\\t\\t\\telem.style[ dimension ] = value;\\n\\t\\t\\t\\tvalue = jQuery.css( elem, dimension );\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn setPositiveNumber( elem, value, subtract );\\n\\t\\t}\\n\\t};\\n} );\\n\\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\\n\\tfunction( elem, computed ) {\\n\\t\\tif ( computed ) {\\n\\t\\t\\treturn ( parseFloat( curCSS( elem, \\\"marginLeft\\\" ) ) ||\\n\\t\\t\\t\\telem.getBoundingClientRect().left -\\n\\t\\t\\t\\t\\tswap( elem, { marginLeft: 0 }, function() {\\n\\t\\t\\t\\t\\t\\treturn elem.getBoundingClientRect().left;\\n\\t\\t\\t\\t\\t} )\\n\\t\\t\\t\\t) + \\\"px\\\";\\n\\t\\t}\\n\\t}\\n);\\n\\n// These hooks are used by animate to expand properties\\njQuery.each( {\\n\\tmargin: \\\"\\\",\\n\\tpadding: \\\"\\\",\\n\\tborder: \\\"Width\\\"\\n}, function( prefix, suffix ) {\\n\\tjQuery.cssHooks[ prefix + suffix ] = {\\n\\t\\texpand: function( value ) {\\n\\t\\t\\tvar i = 0,\\n\\t\\t\\t\\texpanded = {},\\n\\n\\t\\t\\t\\t// Assumes a single number if not a string\\n\\t\\t\\t\\tparts = typeof value === \\\"string\\\" ? value.split( \\\" \\\" ) : [ value ];\\n\\n\\t\\t\\tfor ( ; i < 4; i++ ) {\\n\\t\\t\\t\\texpanded[ prefix + cssExpand[ i ] + suffix ] =\\n\\t\\t\\t\\t\\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn expanded;\\n\\t\\t}\\n\\t};\\n\\n\\tif ( prefix !== \\\"margin\\\" ) {\\n\\t\\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\\n\\t}\\n} );\\n\\njQuery.fn.extend( {\\n\\tcss: function( name, value ) {\\n\\t\\treturn access( this, function( elem, name, value ) {\\n\\t\\t\\tvar styles, len,\\n\\t\\t\\t\\tmap = {},\\n\\t\\t\\t\\ti = 0;\\n\\n\\t\\t\\tif ( Array.isArray( name ) ) {\\n\\t\\t\\t\\tstyles = getStyles( elem );\\n\\t\\t\\t\\tlen = name.length;\\n\\n\\t\\t\\t\\tfor ( ; i < len; i++ ) {\\n\\t\\t\\t\\t\\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn map;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn value !== undefined ?\\n\\t\\t\\t\\tjQuery.style( elem, name, value ) :\\n\\t\\t\\t\\tjQuery.css( elem, name );\\n\\t\\t}, name, value, arguments.length > 1 );\\n\\t}\\n} );\\n\\n\\nfunction Tween( elem, options, prop, end, easing ) {\\n\\treturn new Tween.prototype.init( elem, options, prop, end, easing );\\n}\\njQuery.Tween = Tween;\\n\\nTween.prototype = {\\n\\tconstructor: Tween,\\n\\tinit: function( elem, options, prop, end, easing, unit ) {\\n\\t\\tthis.elem = elem;\\n\\t\\tthis.prop = prop;\\n\\t\\tthis.easing = easing || jQuery.easing._default;\\n\\t\\tthis.options = options;\\n\\t\\tthis.start = this.now = this.cur();\\n\\t\\tthis.end = end;\\n\\t\\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \\\"\\\" : \\\"px\\\" );\\n\\t},\\n\\tcur: function() {\\n\\t\\tvar hooks = Tween.propHooks[ this.prop ];\\n\\n\\t\\treturn hooks && hooks.get ?\\n\\t\\t\\thooks.get( this ) :\\n\\t\\t\\tTween.propHooks._default.get( this );\\n\\t},\\n\\trun: function( percent ) {\\n\\t\\tvar eased,\\n\\t\\t\\thooks = Tween.propHooks[ this.prop ];\\n\\n\\t\\tif ( this.options.duration ) {\\n\\t\\t\\tthis.pos = eased = jQuery.easing[ this.easing ](\\n\\t\\t\\t\\tpercent, this.options.duration * percent, 0, 1, this.options.duration\\n\\t\\t\\t);\\n\\t\\t} else {\\n\\t\\t\\tthis.pos = eased = percent;\\n\\t\\t}\\n\\t\\tthis.now = ( this.end - this.start ) * eased + this.start;\\n\\n\\t\\tif ( this.options.step ) {\\n\\t\\t\\tthis.options.step.call( this.elem, this.now, this );\\n\\t\\t}\\n\\n\\t\\tif ( hooks && hooks.set ) {\\n\\t\\t\\thooks.set( this );\\n\\t\\t} else {\\n\\t\\t\\tTween.propHooks._default.set( this );\\n\\t\\t}\\n\\t\\treturn this;\\n\\t}\\n};\\n\\nTween.prototype.init.prototype = Tween.prototype;\\n\\nTween.propHooks = {\\n\\t_default: {\\n\\t\\tget: function( tween ) {\\n\\t\\t\\tvar result;\\n\\n\\t\\t\\t// Use a property on the element directly when it is not a DOM element,\\n\\t\\t\\t// or when there is no matching style property that exists.\\n\\t\\t\\tif ( tween.elem.nodeType !== 1 ||\\n\\t\\t\\t\\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\\n\\t\\t\\t\\treturn tween.elem[ tween.prop ];\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Passing an empty string as a 3rd parameter to .css will automatically\\n\\t\\t\\t// attempt a parseFloat and fallback to a string if the parse fails.\\n\\t\\t\\t// Simple values such as \\\"10px\\\" are parsed to Float;\\n\\t\\t\\t// complex values such as \\\"rotate(1rad)\\\" are returned as-is.\\n\\t\\t\\tresult = jQuery.css( tween.elem, tween.prop, \\\"\\\" );\\n\\n\\t\\t\\t// Empty strings, null, undefined and \\\"auto\\\" are converted to 0.\\n\\t\\t\\treturn !result || result === \\\"auto\\\" ? 0 : result;\\n\\t\\t},\\n\\t\\tset: function( tween ) {\\n\\n\\t\\t\\t// Use step hook for back compat.\\n\\t\\t\\t// Use cssHook if its there.\\n\\t\\t\\t// Use .style if available and use plain properties where available.\\n\\t\\t\\tif ( jQuery.fx.step[ tween.prop ] ) {\\n\\t\\t\\t\\tjQuery.fx.step[ tween.prop ]( tween );\\n\\t\\t\\t} else if ( tween.elem.nodeType === 1 &&\\n\\t\\t\\t\\t( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||\\n\\t\\t\\t\\t\\tjQuery.cssHooks[ tween.prop ] ) ) {\\n\\t\\t\\t\\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttween.elem[ tween.prop ] = tween.now;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\n\\n// Support: IE <=9 only\\n// Panic based approach to setting things on disconnected nodes\\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\\n\\tset: function( tween ) {\\n\\t\\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\\n\\t\\t\\ttween.elem[ tween.prop ] = tween.now;\\n\\t\\t}\\n\\t}\\n};\\n\\njQuery.easing = {\\n\\tlinear: function( p ) {\\n\\t\\treturn p;\\n\\t},\\n\\tswing: function( p ) {\\n\\t\\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\\n\\t},\\n\\t_default: \\\"swing\\\"\\n};\\n\\njQuery.fx = Tween.prototype.init;\\n\\n// Back compat <1.8 extension point\\njQuery.fx.step = {};\\n\\n\\n\\n\\nvar\\n\\tfxNow, inProgress,\\n\\trfxtypes = /^(?:toggle|show|hide)$/,\\n\\trrun = /queueHooks$/;\\n\\nfunction schedule() {\\n\\tif ( inProgress ) {\\n\\t\\tif ( document.hidden === false && window.requestAnimationFrame ) {\\n\\t\\t\\twindow.requestAnimationFrame( schedule );\\n\\t\\t} else {\\n\\t\\t\\twindow.setTimeout( schedule, jQuery.fx.interval );\\n\\t\\t}\\n\\n\\t\\tjQuery.fx.tick();\\n\\t}\\n}\\n\\n// Animations created synchronously will run synchronously\\nfunction createFxNow() {\\n\\twindow.setTimeout( function() {\\n\\t\\tfxNow = undefined;\\n\\t} );\\n\\treturn ( fxNow = Date.now() );\\n}\\n\\n// Generate parameters to create a standard animation\\nfunction genFx( type, includeWidth ) {\\n\\tvar which,\\n\\t\\ti = 0,\\n\\t\\tattrs = { height: type };\\n\\n\\t// If we include width, step value is 1 to do all cssExpand values,\\n\\t// otherwise step value is 2 to skip over Left and Right\\n\\tincludeWidth = includeWidth ? 1 : 0;\\n\\tfor ( ; i < 4; i += 2 - includeWidth ) {\\n\\t\\twhich = cssExpand[ i ];\\n\\t\\tattrs[ \\\"margin\\\" + which ] = attrs[ \\\"padding\\\" + which ] = type;\\n\\t}\\n\\n\\tif ( includeWidth ) {\\n\\t\\tattrs.opacity = attrs.width = type;\\n\\t}\\n\\n\\treturn attrs;\\n}\\n\\nfunction createTween( value, prop, animation ) {\\n\\tvar tween,\\n\\t\\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \\\"*\\\" ] ),\\n\\t\\tindex = 0,\\n\\t\\tlength = collection.length;\\n\\tfor ( ; index < length; index++ ) {\\n\\t\\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\\n\\n\\t\\t\\t// We're done with this property\\n\\t\\t\\treturn tween;\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction defaultPrefilter( elem, props, opts ) {\\n\\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\\n\\t\\tisBox = \\\"width\\\" in props || \\\"height\\\" in props,\\n\\t\\tanim = this,\\n\\t\\torig = {},\\n\\t\\tstyle = elem.style,\\n\\t\\thidden = elem.nodeType && isHiddenWithinTree( elem ),\\n\\t\\tdataShow = dataPriv.get( elem, \\\"fxshow\\\" );\\n\\n\\t// Queue-skipping animations hijack the fx hooks\\n\\tif ( !opts.queue ) {\\n\\t\\thooks = jQuery._queueHooks( elem, \\\"fx\\\" );\\n\\t\\tif ( hooks.unqueued == null ) {\\n\\t\\t\\thooks.unqueued = 0;\\n\\t\\t\\toldfire = hooks.empty.fire;\\n\\t\\t\\thooks.empty.fire = function() {\\n\\t\\t\\t\\tif ( !hooks.unqueued ) {\\n\\t\\t\\t\\t\\toldfire();\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t}\\n\\t\\thooks.unqueued++;\\n\\n\\t\\tanim.always( function() {\\n\\n\\t\\t\\t// Ensure the complete handler is called before this completes\\n\\t\\t\\tanim.always( function() {\\n\\t\\t\\t\\thooks.unqueued--;\\n\\t\\t\\t\\tif ( !jQuery.queue( elem, \\\"fx\\\" ).length ) {\\n\\t\\t\\t\\t\\thooks.empty.fire();\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\t\\t} );\\n\\t}\\n\\n\\t// Detect show/hide animations\\n\\tfor ( prop in props ) {\\n\\t\\tvalue = props[ prop ];\\n\\t\\tif ( rfxtypes.test( value ) ) {\\n\\t\\t\\tdelete props[ prop ];\\n\\t\\t\\ttoggle = toggle || value === \\\"toggle\\\";\\n\\t\\t\\tif ( value === ( hidden ? \\\"hide\\\" : \\\"show\\\" ) ) {\\n\\n\\t\\t\\t\\t// Pretend to be hidden if this is a \\\"show\\\" and\\n\\t\\t\\t\\t// there is still data from a stopped show/hide\\n\\t\\t\\t\\tif ( value === \\\"show\\\" && dataShow && dataShow[ prop ] !== undefined ) {\\n\\t\\t\\t\\t\\thidden = true;\\n\\n\\t\\t\\t\\t// Ignore all other no-op show/hide data\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\\n\\t\\t}\\n\\t}\\n\\n\\t// Bail out if this is a no-op like .hide().hide()\\n\\tpropTween = !jQuery.isEmptyObject( props );\\n\\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\\n\\t\\treturn;\\n\\t}\\n\\n\\t// Restrict \\\"overflow\\\" and \\\"display\\\" styles during box animations\\n\\tif ( isBox && elem.nodeType === 1 ) {\\n\\n\\t\\t// Support: IE <=9 - 11, Edge 12 - 15\\n\\t\\t// Record all 3 overflow attributes because IE does not infer the shorthand\\n\\t\\t// from identically-valued overflowX and overflowY and Edge just mirrors\\n\\t\\t// the overflowX value there.\\n\\t\\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\\n\\n\\t\\t// Identify a display type, preferring old show/hide data over the CSS cascade\\n\\t\\trestoreDisplay = dataShow && dataShow.display;\\n\\t\\tif ( restoreDisplay == null ) {\\n\\t\\t\\trestoreDisplay = dataPriv.get( elem, \\\"display\\\" );\\n\\t\\t}\\n\\t\\tdisplay = jQuery.css( elem, \\\"display\\\" );\\n\\t\\tif ( display === \\\"none\\\" ) {\\n\\t\\t\\tif ( restoreDisplay ) {\\n\\t\\t\\t\\tdisplay = restoreDisplay;\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// Get nonempty value(s) by temporarily forcing visibility\\n\\t\\t\\t\\tshowHide( [ elem ], true );\\n\\t\\t\\t\\trestoreDisplay = elem.style.display || restoreDisplay;\\n\\t\\t\\t\\tdisplay = jQuery.css( elem, \\\"display\\\" );\\n\\t\\t\\t\\tshowHide( [ elem ] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Animate inline elements as inline-block\\n\\t\\tif ( display === \\\"inline\\\" || display === \\\"inline-block\\\" && restoreDisplay != null ) {\\n\\t\\t\\tif ( jQuery.css( elem, \\\"float\\\" ) === \\\"none\\\" ) {\\n\\n\\t\\t\\t\\t// Restore the original display value at the end of pure show/hide animations\\n\\t\\t\\t\\tif ( !propTween ) {\\n\\t\\t\\t\\t\\tanim.done( function() {\\n\\t\\t\\t\\t\\t\\tstyle.display = restoreDisplay;\\n\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\tif ( restoreDisplay == null ) {\\n\\t\\t\\t\\t\\t\\tdisplay = style.display;\\n\\t\\t\\t\\t\\t\\trestoreDisplay = display === \\\"none\\\" ? \\\"\\\" : display;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstyle.display = \\\"inline-block\\\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif ( opts.overflow ) {\\n\\t\\tstyle.overflow = \\\"hidden\\\";\\n\\t\\tanim.always( function() {\\n\\t\\t\\tstyle.overflow = opts.overflow[ 0 ];\\n\\t\\t\\tstyle.overflowX = opts.overflow[ 1 ];\\n\\t\\t\\tstyle.overflowY = opts.overflow[ 2 ];\\n\\t\\t} );\\n\\t}\\n\\n\\t// Implement show/hide animations\\n\\tpropTween = false;\\n\\tfor ( prop in orig ) {\\n\\n\\t\\t// General show/hide setup for this element animation\\n\\t\\tif ( !propTween ) {\\n\\t\\t\\tif ( dataShow ) {\\n\\t\\t\\t\\tif ( \\\"hidden\\\" in dataShow ) {\\n\\t\\t\\t\\t\\thidden = dataShow.hidden;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdataShow = dataPriv.access( elem, \\\"fxshow\\\", { display: restoreDisplay } );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Store hidden/visible for toggle so `.stop().toggle()` \\\"reverses\\\"\\n\\t\\t\\tif ( toggle ) {\\n\\t\\t\\t\\tdataShow.hidden = !hidden;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Show elements before animating them\\n\\t\\t\\tif ( hidden ) {\\n\\t\\t\\t\\tshowHide( [ elem ], true );\\n\\t\\t\\t}\\n\\n\\t\\t\\t/* eslint-disable no-loop-func */\\n\\n\\t\\t\\tanim.done( function() {\\n\\n\\t\\t\\t/* eslint-enable no-loop-func */\\n\\n\\t\\t\\t\\t// The final step of a \\\"hide\\\" animation is actually hiding the element\\n\\t\\t\\t\\tif ( !hidden ) {\\n\\t\\t\\t\\t\\tshowHide( [ elem ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdataPriv.remove( elem, \\\"fxshow\\\" );\\n\\t\\t\\t\\tfor ( prop in orig ) {\\n\\t\\t\\t\\t\\tjQuery.style( elem, prop, orig[ prop ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\t// Per-property setup\\n\\t\\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\\n\\t\\tif ( !( prop in dataShow ) ) {\\n\\t\\t\\tdataShow[ prop ] = propTween.start;\\n\\t\\t\\tif ( hidden ) {\\n\\t\\t\\t\\tpropTween.end = propTween.start;\\n\\t\\t\\t\\tpropTween.start = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction propFilter( props, specialEasing ) {\\n\\tvar index, name, easing, value, hooks;\\n\\n\\t// camelCase, specialEasing and expand cssHook pass\\n\\tfor ( index in props ) {\\n\\t\\tname = camelCase( index );\\n\\t\\teasing = specialEasing[ name ];\\n\\t\\tvalue = props[ index ];\\n\\t\\tif ( Array.isArray( value ) ) {\\n\\t\\t\\teasing = value[ 1 ];\\n\\t\\t\\tvalue = props[ index ] = value[ 0 ];\\n\\t\\t}\\n\\n\\t\\tif ( index !== name ) {\\n\\t\\t\\tprops[ name ] = value;\\n\\t\\t\\tdelete props[ index ];\\n\\t\\t}\\n\\n\\t\\thooks = jQuery.cssHooks[ name ];\\n\\t\\tif ( hooks && \\\"expand\\\" in hooks ) {\\n\\t\\t\\tvalue = hooks.expand( value );\\n\\t\\t\\tdelete props[ name ];\\n\\n\\t\\t\\t// Not quite $.extend, this won't overwrite existing keys.\\n\\t\\t\\t// Reusing 'index' because we have the correct \\\"name\\\"\\n\\t\\t\\tfor ( index in value ) {\\n\\t\\t\\t\\tif ( !( index in props ) ) {\\n\\t\\t\\t\\t\\tprops[ index ] = value[ index ];\\n\\t\\t\\t\\t\\tspecialEasing[ index ] = easing;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tspecialEasing[ name ] = easing;\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction Animation( elem, properties, options ) {\\n\\tvar result,\\n\\t\\tstopped,\\n\\t\\tindex = 0,\\n\\t\\tlength = Animation.prefilters.length,\\n\\t\\tdeferred = jQuery.Deferred().always( function() {\\n\\n\\t\\t\\t// Don't match elem in the :animated selector\\n\\t\\t\\tdelete tick.elem;\\n\\t\\t} ),\\n\\t\\ttick = function() {\\n\\t\\t\\tif ( stopped ) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tvar currentTime = fxNow || createFxNow(),\\n\\t\\t\\t\\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\\n\\n\\t\\t\\t\\t// Support: Android 2.3 only\\n\\t\\t\\t\\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\\n\\t\\t\\t\\ttemp = remaining / animation.duration || 0,\\n\\t\\t\\t\\tpercent = 1 - temp,\\n\\t\\t\\t\\tindex = 0,\\n\\t\\t\\t\\tlength = animation.tweens.length;\\n\\n\\t\\t\\tfor ( ; index < length; index++ ) {\\n\\t\\t\\t\\tanimation.tweens[ index ].run( percent );\\n\\t\\t\\t}\\n\\n\\t\\t\\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\\n\\n\\t\\t\\t// If there's more to do, yield\\n\\t\\t\\tif ( percent < 1 && length ) {\\n\\t\\t\\t\\treturn remaining;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If this was an empty animation, synthesize a final progress notification\\n\\t\\t\\tif ( !length ) {\\n\\t\\t\\t\\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Resolve the animation and report its conclusion\\n\\t\\t\\tdeferred.resolveWith( elem, [ animation ] );\\n\\t\\t\\treturn false;\\n\\t\\t},\\n\\t\\tanimation = deferred.promise( {\\n\\t\\t\\telem: elem,\\n\\t\\t\\tprops: jQuery.extend( {}, properties ),\\n\\t\\t\\topts: jQuery.extend( true, {\\n\\t\\t\\t\\tspecialEasing: {},\\n\\t\\t\\t\\teasing: jQuery.easing._default\\n\\t\\t\\t}, options ),\\n\\t\\t\\toriginalProperties: properties,\\n\\t\\t\\toriginalOptions: options,\\n\\t\\t\\tstartTime: fxNow || createFxNow(),\\n\\t\\t\\tduration: options.duration,\\n\\t\\t\\ttweens: [],\\n\\t\\t\\tcreateTween: function( prop, end ) {\\n\\t\\t\\t\\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\\n\\t\\t\\t\\t\\t\\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\\n\\t\\t\\t\\tanimation.tweens.push( tween );\\n\\t\\t\\t\\treturn tween;\\n\\t\\t\\t},\\n\\t\\t\\tstop: function( gotoEnd ) {\\n\\t\\t\\t\\tvar index = 0,\\n\\n\\t\\t\\t\\t\\t// If we are going to the end, we want to run all the tweens\\n\\t\\t\\t\\t\\t// otherwise we skip this part\\n\\t\\t\\t\\t\\tlength = gotoEnd ? animation.tweens.length : 0;\\n\\t\\t\\t\\tif ( stopped ) {\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstopped = true;\\n\\t\\t\\t\\tfor ( ; index < length; index++ ) {\\n\\t\\t\\t\\t\\tanimation.tweens[ index ].run( 1 );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Resolve when we played the last frame; otherwise, reject\\n\\t\\t\\t\\tif ( gotoEnd ) {\\n\\t\\t\\t\\t\\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\\n\\t\\t\\t\\t\\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t}\\n\\t\\t} ),\\n\\t\\tprops = animation.props;\\n\\n\\tpropFilter( props, animation.opts.specialEasing );\\n\\n\\tfor ( ; index < length; index++ ) {\\n\\t\\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\\n\\t\\tif ( result ) {\\n\\t\\t\\tif ( isFunction( result.stop ) ) {\\n\\t\\t\\t\\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\\n\\t\\t\\t\\t\\tresult.stop.bind( result );\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n\\n\\tjQuery.map( props, createTween, animation );\\n\\n\\tif ( isFunction( animation.opts.start ) ) {\\n\\t\\tanimation.opts.start.call( elem, animation );\\n\\t}\\n\\n\\t// Attach callbacks from options\\n\\tanimation\\n\\t\\t.progress( animation.opts.progress )\\n\\t\\t.done( animation.opts.done, animation.opts.complete )\\n\\t\\t.fail( animation.opts.fail )\\n\\t\\t.always( animation.opts.always );\\n\\n\\tjQuery.fx.timer(\\n\\t\\tjQuery.extend( tick, {\\n\\t\\t\\telem: elem,\\n\\t\\t\\tanim: animation,\\n\\t\\t\\tqueue: animation.opts.queue\\n\\t\\t} )\\n\\t);\\n\\n\\treturn animation;\\n}\\n\\njQuery.Animation = jQuery.extend( Animation, {\\n\\n\\ttweeners: {\\n\\t\\t\\\"*\\\": [ function( prop, value ) {\\n\\t\\t\\tvar tween = this.createTween( prop, value );\\n\\t\\t\\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\\n\\t\\t\\treturn tween;\\n\\t\\t} ]\\n\\t},\\n\\n\\ttweener: function( props, callback ) {\\n\\t\\tif ( isFunction( props ) ) {\\n\\t\\t\\tcallback = props;\\n\\t\\t\\tprops = [ \\\"*\\\" ];\\n\\t\\t} else {\\n\\t\\t\\tprops = props.match( rnothtmlwhite );\\n\\t\\t}\\n\\n\\t\\tvar prop,\\n\\t\\t\\tindex = 0,\\n\\t\\t\\tlength = props.length;\\n\\n\\t\\tfor ( ; index < length; index++ ) {\\n\\t\\t\\tprop = props[ index ];\\n\\t\\t\\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\\n\\t\\t\\tAnimation.tweeners[ prop ].unshift( callback );\\n\\t\\t}\\n\\t},\\n\\n\\tprefilters: [ defaultPrefilter ],\\n\\n\\tprefilter: function( callback, prepend ) {\\n\\t\\tif ( prepend ) {\\n\\t\\t\\tAnimation.prefilters.unshift( callback );\\n\\t\\t} else {\\n\\t\\t\\tAnimation.prefilters.push( callback );\\n\\t\\t}\\n\\t}\\n} );\\n\\njQuery.speed = function( speed, easing, fn ) {\\n\\tvar opt = speed && typeof speed === \\\"object\\\" ? jQuery.extend( {}, speed ) : {\\n\\t\\tcomplete: fn || !fn && easing ||\\n\\t\\t\\tisFunction( speed ) && speed,\\n\\t\\tduration: speed,\\n\\t\\teasing: fn && easing || easing && !isFunction( easing ) && easing\\n\\t};\\n\\n\\t// Go to the end state if fx are off\\n\\tif ( jQuery.fx.off ) {\\n\\t\\topt.duration = 0;\\n\\n\\t} else {\\n\\t\\tif ( typeof opt.duration !== \\\"number\\\" ) {\\n\\t\\t\\tif ( opt.duration in jQuery.fx.speeds ) {\\n\\t\\t\\t\\topt.duration = jQuery.fx.speeds[ opt.duration ];\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\topt.duration = jQuery.fx.speeds._default;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Normalize opt.queue - true/undefined/null -> \\\"fx\\\"\\n\\tif ( opt.queue == null || opt.queue === true ) {\\n\\t\\topt.queue = \\\"fx\\\";\\n\\t}\\n\\n\\t// Queueing\\n\\topt.old = opt.complete;\\n\\n\\topt.complete = function() {\\n\\t\\tif ( isFunction( opt.old ) ) {\\n\\t\\t\\topt.old.call( this );\\n\\t\\t}\\n\\n\\t\\tif ( opt.queue ) {\\n\\t\\t\\tjQuery.dequeue( this, opt.queue );\\n\\t\\t}\\n\\t};\\n\\n\\treturn opt;\\n};\\n\\njQuery.fn.extend( {\\n\\tfadeTo: function( speed, to, easing, callback ) {\\n\\n\\t\\t// Show any hidden elements after setting opacity to 0\\n\\t\\treturn this.filter( isHiddenWithinTree ).css( \\\"opacity\\\", 0 ).show()\\n\\n\\t\\t\\t// Animate to the value specified\\n\\t\\t\\t.end().animate( { opacity: to }, speed, easing, callback );\\n\\t},\\n\\tanimate: function( prop, speed, easing, callback ) {\\n\\t\\tvar empty = jQuery.isEmptyObject( prop ),\\n\\t\\t\\toptall = jQuery.speed( speed, easing, callback ),\\n\\t\\t\\tdoAnimation = function() {\\n\\n\\t\\t\\t\\t// Operate on a copy of prop so per-property easing won't be lost\\n\\t\\t\\t\\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\\n\\n\\t\\t\\t\\t// Empty animations, or finishing resolves immediately\\n\\t\\t\\t\\tif ( empty || dataPriv.get( this, \\\"finish\\\" ) ) {\\n\\t\\t\\t\\t\\tanim.stop( true );\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t\\tdoAnimation.finish = doAnimation;\\n\\n\\t\\treturn empty || optall.queue === false ?\\n\\t\\t\\tthis.each( doAnimation ) :\\n\\t\\t\\tthis.queue( optall.queue, doAnimation );\\n\\t},\\n\\tstop: function( type, clearQueue, gotoEnd ) {\\n\\t\\tvar stopQueue = function( hooks ) {\\n\\t\\t\\tvar stop = hooks.stop;\\n\\t\\t\\tdelete hooks.stop;\\n\\t\\t\\tstop( gotoEnd );\\n\\t\\t};\\n\\n\\t\\tif ( typeof type !== \\\"string\\\" ) {\\n\\t\\t\\tgotoEnd = clearQueue;\\n\\t\\t\\tclearQueue = type;\\n\\t\\t\\ttype = undefined;\\n\\t\\t}\\n\\t\\tif ( clearQueue && type !== false ) {\\n\\t\\t\\tthis.queue( type || \\\"fx\\\", [] );\\n\\t\\t}\\n\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tvar dequeue = true,\\n\\t\\t\\t\\tindex = type != null && type + \\\"queueHooks\\\",\\n\\t\\t\\t\\ttimers = jQuery.timers,\\n\\t\\t\\t\\tdata = dataPriv.get( this );\\n\\n\\t\\t\\tif ( index ) {\\n\\t\\t\\t\\tif ( data[ index ] && data[ index ].stop ) {\\n\\t\\t\\t\\t\\tstopQueue( data[ index ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor ( index in data ) {\\n\\t\\t\\t\\t\\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\\n\\t\\t\\t\\t\\t\\tstopQueue( data[ index ] );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( index = timers.length; index--; ) {\\n\\t\\t\\t\\tif ( timers[ index ].elem === this &&\\n\\t\\t\\t\\t\\t( type == null || timers[ index ].queue === type ) ) {\\n\\n\\t\\t\\t\\t\\ttimers[ index ].anim.stop( gotoEnd );\\n\\t\\t\\t\\t\\tdequeue = false;\\n\\t\\t\\t\\t\\ttimers.splice( index, 1 );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Start the next in the queue if the last step wasn't forced.\\n\\t\\t\\t// Timers currently will call their complete callbacks, which\\n\\t\\t\\t// will dequeue but only if they were gotoEnd.\\n\\t\\t\\tif ( dequeue || !gotoEnd ) {\\n\\t\\t\\t\\tjQuery.dequeue( this, type );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\tfinish: function( type ) {\\n\\t\\tif ( type !== false ) {\\n\\t\\t\\ttype = type || \\\"fx\\\";\\n\\t\\t}\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tvar index,\\n\\t\\t\\t\\tdata = dataPriv.get( this ),\\n\\t\\t\\t\\tqueue = data[ type + \\\"queue\\\" ],\\n\\t\\t\\t\\thooks = data[ type + \\\"queueHooks\\\" ],\\n\\t\\t\\t\\ttimers = jQuery.timers,\\n\\t\\t\\t\\tlength = queue ? queue.length : 0;\\n\\n\\t\\t\\t// Enable finishing flag on private data\\n\\t\\t\\tdata.finish = true;\\n\\n\\t\\t\\t// Empty the queue first\\n\\t\\t\\tjQuery.queue( this, type, [] );\\n\\n\\t\\t\\tif ( hooks && hooks.stop ) {\\n\\t\\t\\t\\thooks.stop.call( this, true );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Look for any active animations, and finish them\\n\\t\\t\\tfor ( index = timers.length; index--; ) {\\n\\t\\t\\t\\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\\n\\t\\t\\t\\t\\ttimers[ index ].anim.stop( true );\\n\\t\\t\\t\\t\\ttimers.splice( index, 1 );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Look for any animations in the old queue and finish them\\n\\t\\t\\tfor ( index = 0; index < length; index++ ) {\\n\\t\\t\\t\\tif ( queue[ index ] && queue[ index ].finish ) {\\n\\t\\t\\t\\t\\tqueue[ index ].finish.call( this );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Turn off finishing flag\\n\\t\\t\\tdelete data.finish;\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.each( [ \\\"toggle\\\", \\\"show\\\", \\\"hide\\\" ], function( i, name ) {\\n\\tvar cssFn = jQuery.fn[ name ];\\n\\tjQuery.fn[ name ] = function( speed, easing, callback ) {\\n\\t\\treturn speed == null || typeof speed === \\\"boolean\\\" ?\\n\\t\\t\\tcssFn.apply( this, arguments ) :\\n\\t\\t\\tthis.animate( genFx( name, true ), speed, easing, callback );\\n\\t};\\n} );\\n\\n// Generate shortcuts for custom animations\\njQuery.each( {\\n\\tslideDown: genFx( \\\"show\\\" ),\\n\\tslideUp: genFx( \\\"hide\\\" ),\\n\\tslideToggle: genFx( \\\"toggle\\\" ),\\n\\tfadeIn: { opacity: \\\"show\\\" },\\n\\tfadeOut: { opacity: \\\"hide\\\" },\\n\\tfadeToggle: { opacity: \\\"toggle\\\" }\\n}, function( name, props ) {\\n\\tjQuery.fn[ name ] = function( speed, easing, callback ) {\\n\\t\\treturn this.animate( props, speed, easing, callback );\\n\\t};\\n} );\\n\\njQuery.timers = [];\\njQuery.fx.tick = function() {\\n\\tvar timer,\\n\\t\\ti = 0,\\n\\t\\ttimers = jQuery.timers;\\n\\n\\tfxNow = Date.now();\\n\\n\\tfor ( ; i < timers.length; i++ ) {\\n\\t\\ttimer = timers[ i ];\\n\\n\\t\\t// Run the timer and safely remove it when done (allowing for external removal)\\n\\t\\tif ( !timer() && timers[ i ] === timer ) {\\n\\t\\t\\ttimers.splice( i--, 1 );\\n\\t\\t}\\n\\t}\\n\\n\\tif ( !timers.length ) {\\n\\t\\tjQuery.fx.stop();\\n\\t}\\n\\tfxNow = undefined;\\n};\\n\\njQuery.fx.timer = function( timer ) {\\n\\tjQuery.timers.push( timer );\\n\\tjQuery.fx.start();\\n};\\n\\njQuery.fx.interval = 13;\\njQuery.fx.start = function() {\\n\\tif ( inProgress ) {\\n\\t\\treturn;\\n\\t}\\n\\n\\tinProgress = true;\\n\\tschedule();\\n};\\n\\njQuery.fx.stop = function() {\\n\\tinProgress = null;\\n};\\n\\njQuery.fx.speeds = {\\n\\tslow: 600,\\n\\tfast: 200,\\n\\n\\t// Default speed\\n\\t_default: 400\\n};\\n\\n\\n// Based off of the plugin by Clint Helfers, with permission.\\n// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\\njQuery.fn.delay = function( time, type ) {\\n\\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\\n\\ttype = type || \\\"fx\\\";\\n\\n\\treturn this.queue( type, function( next, hooks ) {\\n\\t\\tvar timeout = window.setTimeout( next, time );\\n\\t\\thooks.stop = function() {\\n\\t\\t\\twindow.clearTimeout( timeout );\\n\\t\\t};\\n\\t} );\\n};\\n\\n\\n( function() {\\n\\tvar input = document.createElement( \\\"input\\\" ),\\n\\t\\tselect = document.createElement( \\\"select\\\" ),\\n\\t\\topt = select.appendChild( document.createElement( \\\"option\\\" ) );\\n\\n\\tinput.type = \\\"checkbox\\\";\\n\\n\\t// Support: Android <=4.3 only\\n\\t// Default value for a checkbox should be \\\"on\\\"\\n\\tsupport.checkOn = input.value !== \\\"\\\";\\n\\n\\t// Support: IE <=11 only\\n\\t// Must access selectedIndex to make default options select\\n\\tsupport.optSelected = opt.selected;\\n\\n\\t// Support: IE <=11 only\\n\\t// An input loses its value after becoming a radio\\n\\tinput = document.createElement( \\\"input\\\" );\\n\\tinput.value = \\\"t\\\";\\n\\tinput.type = \\\"radio\\\";\\n\\tsupport.radioValue = input.value === \\\"t\\\";\\n} )();\\n\\n\\nvar boolHook,\\n\\tattrHandle = jQuery.expr.attrHandle;\\n\\njQuery.fn.extend( {\\n\\tattr: function( name, value ) {\\n\\t\\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\\n\\t},\\n\\n\\tremoveAttr: function( name ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tjQuery.removeAttr( this, name );\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.extend( {\\n\\tattr: function( elem, name, value ) {\\n\\t\\tvar ret, hooks,\\n\\t\\t\\tnType = elem.nodeType;\\n\\n\\t\\t// Don't get/set attributes on text, comment and attribute nodes\\n\\t\\tif ( nType === 3 || nType === 8 || nType === 2 ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Fallback to prop when attributes are not supported\\n\\t\\tif ( typeof elem.getAttribute === \\\"undefined\\\" ) {\\n\\t\\t\\treturn jQuery.prop( elem, name, value );\\n\\t\\t}\\n\\n\\t\\t// Attribute hooks are determined by the lowercase version\\n\\t\\t// Grab necessary hook if one is defined\\n\\t\\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\\n\\t\\t\\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\\n\\t\\t\\t\\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\\n\\t\\t}\\n\\n\\t\\tif ( value !== undefined ) {\\n\\t\\t\\tif ( value === null ) {\\n\\t\\t\\t\\tjQuery.removeAttr( elem, name );\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( hooks && \\\"set\\\" in hooks &&\\n\\t\\t\\t\\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\\n\\t\\t\\t\\treturn ret;\\n\\t\\t\\t}\\n\\n\\t\\t\\telem.setAttribute( name, value + \\\"\\\" );\\n\\t\\t\\treturn value;\\n\\t\\t}\\n\\n\\t\\tif ( hooks && \\\"get\\\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\\n\\t\\t\\treturn ret;\\n\\t\\t}\\n\\n\\t\\tret = jQuery.find.attr( elem, name );\\n\\n\\t\\t// Non-existent attributes return null, we normalize to undefined\\n\\t\\treturn ret == null ? undefined : ret;\\n\\t},\\n\\n\\tattrHooks: {\\n\\t\\ttype: {\\n\\t\\t\\tset: function( elem, value ) {\\n\\t\\t\\t\\tif ( !support.radioValue && value === \\\"radio\\\" &&\\n\\t\\t\\t\\t\\tnodeName( elem, \\\"input\\\" ) ) {\\n\\t\\t\\t\\t\\tvar val = elem.value;\\n\\t\\t\\t\\t\\telem.setAttribute( \\\"type\\\", value );\\n\\t\\t\\t\\t\\tif ( val ) {\\n\\t\\t\\t\\t\\t\\telem.value = val;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn value;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\tremoveAttr: function( elem, value ) {\\n\\t\\tvar name,\\n\\t\\t\\ti = 0,\\n\\n\\t\\t\\t// Attribute names can contain non-HTML whitespace characters\\n\\t\\t\\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\\n\\t\\t\\tattrNames = value && value.match( rnothtmlwhite );\\n\\n\\t\\tif ( attrNames && elem.nodeType === 1 ) {\\n\\t\\t\\twhile ( ( name = attrNames[ i++ ] ) ) {\\n\\t\\t\\t\\telem.removeAttribute( name );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n} );\\n\\n// Hooks for boolean attributes\\nboolHook = {\\n\\tset: function( elem, value, name ) {\\n\\t\\tif ( value === false ) {\\n\\n\\t\\t\\t// Remove boolean attributes when set to false\\n\\t\\t\\tjQuery.removeAttr( elem, name );\\n\\t\\t} else {\\n\\t\\t\\telem.setAttribute( name, name );\\n\\t\\t}\\n\\t\\treturn name;\\n\\t}\\n};\\n\\njQuery.each( jQuery.expr.match.bool.source.match( /\\\\w+/g ), function( i, name ) {\\n\\tvar getter = attrHandle[ name ] || jQuery.find.attr;\\n\\n\\tattrHandle[ name ] = function( elem, name, isXML ) {\\n\\t\\tvar ret, handle,\\n\\t\\t\\tlowercaseName = name.toLowerCase();\\n\\n\\t\\tif ( !isXML ) {\\n\\n\\t\\t\\t// Avoid an infinite loop by temporarily removing this function from the getter\\n\\t\\t\\thandle = attrHandle[ lowercaseName ];\\n\\t\\t\\tattrHandle[ lowercaseName ] = ret;\\n\\t\\t\\tret = getter( elem, name, isXML ) != null ?\\n\\t\\t\\t\\tlowercaseName :\\n\\t\\t\\t\\tnull;\\n\\t\\t\\tattrHandle[ lowercaseName ] = handle;\\n\\t\\t}\\n\\t\\treturn ret;\\n\\t};\\n} );\\n\\n\\n\\n\\nvar rfocusable = /^(?:input|select|textarea|button)$/i,\\n\\trclickable = /^(?:a|area)$/i;\\n\\njQuery.fn.extend( {\\n\\tprop: function( name, value ) {\\n\\t\\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\\n\\t},\\n\\n\\tremoveProp: function( name ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tdelete this[ jQuery.propFix[ name ] || name ];\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.extend( {\\n\\tprop: function( elem, name, value ) {\\n\\t\\tvar ret, hooks,\\n\\t\\t\\tnType = elem.nodeType;\\n\\n\\t\\t// Don't get/set properties on text, comment and attribute nodes\\n\\t\\tif ( nType === 3 || nType === 8 || nType === 2 ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\\n\\n\\t\\t\\t// Fix name and attach hooks\\n\\t\\t\\tname = jQuery.propFix[ name ] || name;\\n\\t\\t\\thooks = jQuery.propHooks[ name ];\\n\\t\\t}\\n\\n\\t\\tif ( value !== undefined ) {\\n\\t\\t\\tif ( hooks && \\\"set\\\" in hooks &&\\n\\t\\t\\t\\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\\n\\t\\t\\t\\treturn ret;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ( elem[ name ] = value );\\n\\t\\t}\\n\\n\\t\\tif ( hooks && \\\"get\\\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\\n\\t\\t\\treturn ret;\\n\\t\\t}\\n\\n\\t\\treturn elem[ name ];\\n\\t},\\n\\n\\tpropHooks: {\\n\\t\\ttabIndex: {\\n\\t\\t\\tget: function( elem ) {\\n\\n\\t\\t\\t\\t// Support: IE <=9 - 11 only\\n\\t\\t\\t\\t// elem.tabIndex doesn't always return the\\n\\t\\t\\t\\t// correct value when it hasn't been explicitly set\\n\\t\\t\\t\\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\\n\\t\\t\\t\\t// Use proper attribute retrieval(#12072)\\n\\t\\t\\t\\tvar tabindex = jQuery.find.attr( elem, \\\"tabindex\\\" );\\n\\n\\t\\t\\t\\tif ( tabindex ) {\\n\\t\\t\\t\\t\\treturn parseInt( tabindex, 10 );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (\\n\\t\\t\\t\\t\\trfocusable.test( elem.nodeName ) ||\\n\\t\\t\\t\\t\\trclickable.test( elem.nodeName ) &&\\n\\t\\t\\t\\t\\telem.href\\n\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\tpropFix: {\\n\\t\\t\\\"for\\\": \\\"htmlFor\\\",\\n\\t\\t\\\"class\\\": \\\"className\\\"\\n\\t}\\n} );\\n\\n// Support: IE <=11 only\\n// Accessing the selectedIndex property\\n// forces the browser to respect setting selected\\n// on the option\\n// The getter ensures a default option is selected\\n// when in an optgroup\\n// eslint rule \\\"no-unused-expressions\\\" is disabled for this code\\n// since it considers such accessions noop\\nif ( !support.optSelected ) {\\n\\tjQuery.propHooks.selected = {\\n\\t\\tget: function( elem ) {\\n\\n\\t\\t\\t/* eslint no-unused-expressions: \\\"off\\\" */\\n\\n\\t\\t\\tvar parent = elem.parentNode;\\n\\t\\t\\tif ( parent && parent.parentNode ) {\\n\\t\\t\\t\\tparent.parentNode.selectedIndex;\\n\\t\\t\\t}\\n\\t\\t\\treturn null;\\n\\t\\t},\\n\\t\\tset: function( elem ) {\\n\\n\\t\\t\\t/* eslint no-unused-expressions: \\\"off\\\" */\\n\\n\\t\\t\\tvar parent = elem.parentNode;\\n\\t\\t\\tif ( parent ) {\\n\\t\\t\\t\\tparent.selectedIndex;\\n\\n\\t\\t\\t\\tif ( parent.parentNode ) {\\n\\t\\t\\t\\t\\tparent.parentNode.selectedIndex;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n}\\n\\njQuery.each( [\\n\\t\\\"tabIndex\\\",\\n\\t\\\"readOnly\\\",\\n\\t\\\"maxLength\\\",\\n\\t\\\"cellSpacing\\\",\\n\\t\\\"cellPadding\\\",\\n\\t\\\"rowSpan\\\",\\n\\t\\\"colSpan\\\",\\n\\t\\\"useMap\\\",\\n\\t\\\"frameBorder\\\",\\n\\t\\\"contentEditable\\\"\\n], function() {\\n\\tjQuery.propFix[ this.toLowerCase() ] = this;\\n} );\\n\\n\\n\\n\\n\\t// Strip and collapse whitespace according to HTML spec\\n\\t// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\\n\\tfunction stripAndCollapse( value ) {\\n\\t\\tvar tokens = value.match( rnothtmlwhite ) || [];\\n\\t\\treturn tokens.join( \\\" \\\" );\\n\\t}\\n\\n\\nfunction getClass( elem ) {\\n\\treturn elem.getAttribute && elem.getAttribute( \\\"class\\\" ) || \\\"\\\";\\n}\\n\\nfunction classesToArray( value ) {\\n\\tif ( Array.isArray( value ) ) {\\n\\t\\treturn value;\\n\\t}\\n\\tif ( typeof value === \\\"string\\\" ) {\\n\\t\\treturn value.match( rnothtmlwhite ) || [];\\n\\t}\\n\\treturn [];\\n}\\n\\njQuery.fn.extend( {\\n\\taddClass: function( value ) {\\n\\t\\tvar classes, elem, cur, curValue, clazz, j, finalValue,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tif ( isFunction( value ) ) {\\n\\t\\t\\treturn this.each( function( j ) {\\n\\t\\t\\t\\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\tclasses = classesToArray( value );\\n\\n\\t\\tif ( classes.length ) {\\n\\t\\t\\twhile ( ( elem = this[ i++ ] ) ) {\\n\\t\\t\\t\\tcurValue = getClass( elem );\\n\\t\\t\\t\\tcur = elem.nodeType === 1 && ( \\\" \\\" + stripAndCollapse( curValue ) + \\\" \\\" );\\n\\n\\t\\t\\t\\tif ( cur ) {\\n\\t\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\t\\twhile ( ( clazz = classes[ j++ ] ) ) {\\n\\t\\t\\t\\t\\t\\tif ( cur.indexOf( \\\" \\\" + clazz + \\\" \\\" ) < 0 ) {\\n\\t\\t\\t\\t\\t\\t\\tcur += clazz + \\\" \\\";\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Only assign if different to avoid unneeded rendering.\\n\\t\\t\\t\\t\\tfinalValue = stripAndCollapse( cur );\\n\\t\\t\\t\\t\\tif ( curValue !== finalValue ) {\\n\\t\\t\\t\\t\\t\\telem.setAttribute( \\\"class\\\", finalValue );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\tremoveClass: function( value ) {\\n\\t\\tvar classes, elem, cur, curValue, clazz, j, finalValue,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tif ( isFunction( value ) ) {\\n\\t\\t\\treturn this.each( function( j ) {\\n\\t\\t\\t\\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\tif ( !arguments.length ) {\\n\\t\\t\\treturn this.attr( \\\"class\\\", \\\"\\\" );\\n\\t\\t}\\n\\n\\t\\tclasses = classesToArray( value );\\n\\n\\t\\tif ( classes.length ) {\\n\\t\\t\\twhile ( ( elem = this[ i++ ] ) ) {\\n\\t\\t\\t\\tcurValue = getClass( elem );\\n\\n\\t\\t\\t\\t// This expression is here for better compressibility (see addClass)\\n\\t\\t\\t\\tcur = elem.nodeType === 1 && ( \\\" \\\" + stripAndCollapse( curValue ) + \\\" \\\" );\\n\\n\\t\\t\\t\\tif ( cur ) {\\n\\t\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\t\\twhile ( ( clazz = classes[ j++ ] ) ) {\\n\\n\\t\\t\\t\\t\\t\\t// Remove *all* instances\\n\\t\\t\\t\\t\\t\\twhile ( cur.indexOf( \\\" \\\" + clazz + \\\" \\\" ) > -1 ) {\\n\\t\\t\\t\\t\\t\\t\\tcur = cur.replace( \\\" \\\" + clazz + \\\" \\\", \\\" \\\" );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Only assign if different to avoid unneeded rendering.\\n\\t\\t\\t\\t\\tfinalValue = stripAndCollapse( cur );\\n\\t\\t\\t\\t\\tif ( curValue !== finalValue ) {\\n\\t\\t\\t\\t\\t\\telem.setAttribute( \\\"class\\\", finalValue );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\ttoggleClass: function( value, stateVal ) {\\n\\t\\tvar type = typeof value,\\n\\t\\t\\tisValidValue = type === \\\"string\\\" || Array.isArray( value );\\n\\n\\t\\tif ( typeof stateVal === \\\"boolean\\\" && isValidValue ) {\\n\\t\\t\\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\\n\\t\\t}\\n\\n\\t\\tif ( isFunction( value ) ) {\\n\\t\\t\\treturn this.each( function( i ) {\\n\\t\\t\\t\\tjQuery( this ).toggleClass(\\n\\t\\t\\t\\t\\tvalue.call( this, i, getClass( this ), stateVal ),\\n\\t\\t\\t\\t\\tstateVal\\n\\t\\t\\t\\t);\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tvar className, i, self, classNames;\\n\\n\\t\\t\\tif ( isValidValue ) {\\n\\n\\t\\t\\t\\t// Toggle individual class names\\n\\t\\t\\t\\ti = 0;\\n\\t\\t\\t\\tself = jQuery( this );\\n\\t\\t\\t\\tclassNames = classesToArray( value );\\n\\n\\t\\t\\t\\twhile ( ( className = classNames[ i++ ] ) ) {\\n\\n\\t\\t\\t\\t\\t// Check each className given, space separated list\\n\\t\\t\\t\\t\\tif ( self.hasClass( className ) ) {\\n\\t\\t\\t\\t\\t\\tself.removeClass( className );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tself.addClass( className );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t// Toggle whole class name\\n\\t\\t\\t} else if ( value === undefined || type === \\\"boolean\\\" ) {\\n\\t\\t\\t\\tclassName = getClass( this );\\n\\t\\t\\t\\tif ( className ) {\\n\\n\\t\\t\\t\\t\\t// Store className if set\\n\\t\\t\\t\\t\\tdataPriv.set( this, \\\"__className__\\\", className );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// If the element has a class name or if we're passed `false`,\\n\\t\\t\\t\\t// then remove the whole classname (if there was one, the above saved it).\\n\\t\\t\\t\\t// Otherwise bring back whatever was previously saved (if anything),\\n\\t\\t\\t\\t// falling back to the empty string if nothing was stored.\\n\\t\\t\\t\\tif ( this.setAttribute ) {\\n\\t\\t\\t\\t\\tthis.setAttribute( \\\"class\\\",\\n\\t\\t\\t\\t\\t\\tclassName || value === false ?\\n\\t\\t\\t\\t\\t\\t\\\"\\\" :\\n\\t\\t\\t\\t\\t\\tdataPriv.get( this, \\\"__className__\\\" ) || \\\"\\\"\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\thasClass: function( selector ) {\\n\\t\\tvar className, elem,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tclassName = \\\" \\\" + selector + \\\" \\\";\\n\\t\\twhile ( ( elem = this[ i++ ] ) ) {\\n\\t\\t\\tif ( elem.nodeType === 1 &&\\n\\t\\t\\t\\t( \\\" \\\" + stripAndCollapse( getClass( elem ) ) + \\\" \\\" ).indexOf( className ) > -1 ) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n} );\\n\\n\\n\\n\\nvar rreturn = /\\\\r/g;\\n\\njQuery.fn.extend( {\\n\\tval: function( value ) {\\n\\t\\tvar hooks, ret, valueIsFunction,\\n\\t\\t\\telem = this[ 0 ];\\n\\n\\t\\tif ( !arguments.length ) {\\n\\t\\t\\tif ( elem ) {\\n\\t\\t\\t\\thooks = jQuery.valHooks[ elem.type ] ||\\n\\t\\t\\t\\t\\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\\n\\n\\t\\t\\t\\tif ( hooks &&\\n\\t\\t\\t\\t\\t\\\"get\\\" in hooks &&\\n\\t\\t\\t\\t\\t( ret = hooks.get( elem, \\\"value\\\" ) ) !== undefined\\n\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\treturn ret;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tret = elem.value;\\n\\n\\t\\t\\t\\t// Handle most common string cases\\n\\t\\t\\t\\tif ( typeof ret === \\\"string\\\" ) {\\n\\t\\t\\t\\t\\treturn ret.replace( rreturn, \\\"\\\" );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Handle cases where value is null/undef or number\\n\\t\\t\\t\\treturn ret == null ? \\\"\\\" : ret;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tvalueIsFunction = isFunction( value );\\n\\n\\t\\treturn this.each( function( i ) {\\n\\t\\t\\tvar val;\\n\\n\\t\\t\\tif ( this.nodeType !== 1 ) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( valueIsFunction ) {\\n\\t\\t\\t\\tval = value.call( this, i, jQuery( this ).val() );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tval = value;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Treat null/undefined as \\\"\\\"; convert numbers to string\\n\\t\\t\\tif ( val == null ) {\\n\\t\\t\\t\\tval = \\\"\\\";\\n\\n\\t\\t\\t} else if ( typeof val === \\\"number\\\" ) {\\n\\t\\t\\t\\tval += \\\"\\\";\\n\\n\\t\\t\\t} else if ( Array.isArray( val ) ) {\\n\\t\\t\\t\\tval = jQuery.map( val, function( value ) {\\n\\t\\t\\t\\t\\treturn value == null ? \\\"\\\" : value + \\\"\\\";\\n\\t\\t\\t\\t} );\\n\\t\\t\\t}\\n\\n\\t\\t\\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\\n\\n\\t\\t\\t// If set returns undefined, fall back to normal setting\\n\\t\\t\\tif ( !hooks || !( \\\"set\\\" in hooks ) || hooks.set( this, val, \\\"value\\\" ) === undefined ) {\\n\\t\\t\\t\\tthis.value = val;\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.extend( {\\n\\tvalHooks: {\\n\\t\\toption: {\\n\\t\\t\\tget: function( elem ) {\\n\\n\\t\\t\\t\\tvar val = jQuery.find.attr( elem, \\\"value\\\" );\\n\\t\\t\\t\\treturn val != null ?\\n\\t\\t\\t\\t\\tval :\\n\\n\\t\\t\\t\\t\\t// Support: IE <=10 - 11 only\\n\\t\\t\\t\\t\\t// option.text throws exceptions (#14686, #14858)\\n\\t\\t\\t\\t\\t// Strip and collapse whitespace\\n\\t\\t\\t\\t\\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\\n\\t\\t\\t\\t\\tstripAndCollapse( jQuery.text( elem ) );\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tselect: {\\n\\t\\t\\tget: function( elem ) {\\n\\t\\t\\t\\tvar value, option, i,\\n\\t\\t\\t\\t\\toptions = elem.options,\\n\\t\\t\\t\\t\\tindex = elem.selectedIndex,\\n\\t\\t\\t\\t\\tone = elem.type === \\\"select-one\\\",\\n\\t\\t\\t\\t\\tvalues = one ? null : [],\\n\\t\\t\\t\\t\\tmax = one ? index + 1 : options.length;\\n\\n\\t\\t\\t\\tif ( index < 0 ) {\\n\\t\\t\\t\\t\\ti = max;\\n\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ti = one ? index : 0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Loop through all the selected options\\n\\t\\t\\t\\tfor ( ; i < max; i++ ) {\\n\\t\\t\\t\\t\\toption = options[ i ];\\n\\n\\t\\t\\t\\t\\t// Support: IE <=9 only\\n\\t\\t\\t\\t\\t// IE8-9 doesn't update selected after form reset (#2551)\\n\\t\\t\\t\\t\\tif ( ( option.selected || i === index ) &&\\n\\n\\t\\t\\t\\t\\t\\t\\t// Don't return options that are disabled or in a disabled optgroup\\n\\t\\t\\t\\t\\t\\t\\t!option.disabled &&\\n\\t\\t\\t\\t\\t\\t\\t( !option.parentNode.disabled ||\\n\\t\\t\\t\\t\\t\\t\\t\\t!nodeName( option.parentNode, \\\"optgroup\\\" ) ) ) {\\n\\n\\t\\t\\t\\t\\t\\t// Get the specific value for the option\\n\\t\\t\\t\\t\\t\\tvalue = jQuery( option ).val();\\n\\n\\t\\t\\t\\t\\t\\t// We don't need an array for one selects\\n\\t\\t\\t\\t\\t\\tif ( one ) {\\n\\t\\t\\t\\t\\t\\t\\treturn value;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// Multi-Selects return an array\\n\\t\\t\\t\\t\\t\\tvalues.push( value );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn values;\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function( elem, value ) {\\n\\t\\t\\t\\tvar optionSet, option,\\n\\t\\t\\t\\t\\toptions = elem.options,\\n\\t\\t\\t\\t\\tvalues = jQuery.makeArray( value ),\\n\\t\\t\\t\\t\\ti = options.length;\\n\\n\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\toption = options[ i ];\\n\\n\\t\\t\\t\\t\\t/* eslint-disable no-cond-assign */\\n\\n\\t\\t\\t\\t\\tif ( option.selected =\\n\\t\\t\\t\\t\\t\\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\\n\\t\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\t\\toptionSet = true;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t/* eslint-enable no-cond-assign */\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Force browsers to behave consistently when non-matching value is set\\n\\t\\t\\t\\tif ( !optionSet ) {\\n\\t\\t\\t\\t\\telem.selectedIndex = -1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn values;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n} );\\n\\n// Radios and checkboxes getter/setter\\njQuery.each( [ \\\"radio\\\", \\\"checkbox\\\" ], function() {\\n\\tjQuery.valHooks[ this ] = {\\n\\t\\tset: function( elem, value ) {\\n\\t\\t\\tif ( Array.isArray( value ) ) {\\n\\t\\t\\t\\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\tif ( !support.checkOn ) {\\n\\t\\tjQuery.valHooks[ this ].get = function( elem ) {\\n\\t\\t\\treturn elem.getAttribute( \\\"value\\\" ) === null ? \\\"on\\\" : elem.value;\\n\\t\\t};\\n\\t}\\n} );\\n\\n\\n\\n\\n// Return jQuery for attributes-only inclusion\\n\\n\\nsupport.focusin = \\\"onfocusin\\\" in window;\\n\\n\\nvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\\n\\tstopPropagationCallback = function( e ) {\\n\\t\\te.stopPropagation();\\n\\t};\\n\\njQuery.extend( jQuery.event, {\\n\\n\\ttrigger: function( event, data, elem, onlyHandlers ) {\\n\\n\\t\\tvar i, cur, tmp, bubbleType, ontype, handle, special, lastElement,\\n\\t\\t\\teventPath = [ elem || document ],\\n\\t\\t\\ttype = hasOwn.call( event, \\\"type\\\" ) ? event.type : event,\\n\\t\\t\\tnamespaces = hasOwn.call( event, \\\"namespace\\\" ) ? event.namespace.split( \\\".\\\" ) : [];\\n\\n\\t\\tcur = lastElement = tmp = elem = elem || document;\\n\\n\\t\\t// Don't do events on text and comment nodes\\n\\t\\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\\n\\t\\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( type.indexOf( \\\".\\\" ) > -1 ) {\\n\\n\\t\\t\\t// Namespaced trigger; create a regexp to match event type in handle()\\n\\t\\t\\tnamespaces = type.split( \\\".\\\" );\\n\\t\\t\\ttype = namespaces.shift();\\n\\t\\t\\tnamespaces.sort();\\n\\t\\t}\\n\\t\\tontype = type.indexOf( \\\":\\\" ) < 0 && \\\"on\\\" + type;\\n\\n\\t\\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\\n\\t\\tevent = event[ jQuery.expando ] ?\\n\\t\\t\\tevent :\\n\\t\\t\\tnew jQuery.Event( type, typeof event === \\\"object\\\" && event );\\n\\n\\t\\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\\n\\t\\tevent.isTrigger = onlyHandlers ? 2 : 3;\\n\\t\\tevent.namespace = namespaces.join( \\\".\\\" );\\n\\t\\tevent.rnamespace = event.namespace ?\\n\\t\\t\\tnew RegExp( \\\"(^|\\\\\\\\.)\\\" + namespaces.join( \\\"\\\\\\\\.(?:.*\\\\\\\\.|)\\\" ) + \\\"(\\\\\\\\.|$)\\\" ) :\\n\\t\\t\\tnull;\\n\\n\\t\\t// Clean up the event in case it is being reused\\n\\t\\tevent.result = undefined;\\n\\t\\tif ( !event.target ) {\\n\\t\\t\\tevent.target = elem;\\n\\t\\t}\\n\\n\\t\\t// Clone any incoming data and prepend the event, creating the handler arg list\\n\\t\\tdata = data == null ?\\n\\t\\t\\t[ event ] :\\n\\t\\t\\tjQuery.makeArray( data, [ event ] );\\n\\n\\t\\t// Allow special events to draw outside the lines\\n\\t\\tspecial = jQuery.event.special[ type ] || {};\\n\\t\\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Determine event propagation path in advance, per W3C events spec (#9951)\\n\\t\\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\\n\\t\\tif ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {\\n\\n\\t\\t\\tbubbleType = special.delegateType || type;\\n\\t\\t\\tif ( !rfocusMorph.test( bubbleType + type ) ) {\\n\\t\\t\\t\\tcur = cur.parentNode;\\n\\t\\t\\t}\\n\\t\\t\\tfor ( ; cur; cur = cur.parentNode ) {\\n\\t\\t\\t\\teventPath.push( cur );\\n\\t\\t\\t\\ttmp = cur;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\\n\\t\\t\\tif ( tmp === ( elem.ownerDocument || document ) ) {\\n\\t\\t\\t\\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Fire handlers on the event path\\n\\t\\ti = 0;\\n\\t\\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\\n\\t\\t\\tlastElement = cur;\\n\\t\\t\\tevent.type = i > 1 ?\\n\\t\\t\\t\\tbubbleType :\\n\\t\\t\\t\\tspecial.bindType || type;\\n\\n\\t\\t\\t// jQuery handler\\n\\t\\t\\thandle = ( dataPriv.get( cur, \\\"events\\\" ) || {} )[ event.type ] &&\\n\\t\\t\\t\\tdataPriv.get( cur, \\\"handle\\\" );\\n\\t\\t\\tif ( handle ) {\\n\\t\\t\\t\\thandle.apply( cur, data );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Native handler\\n\\t\\t\\thandle = ontype && cur[ ontype ];\\n\\t\\t\\tif ( handle && handle.apply && acceptData( cur ) ) {\\n\\t\\t\\t\\tevent.result = handle.apply( cur, data );\\n\\t\\t\\t\\tif ( event.result === false ) {\\n\\t\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tevent.type = type;\\n\\n\\t\\t// If nobody prevented the default action, do it now\\n\\t\\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\\n\\n\\t\\t\\tif ( ( !special._default ||\\n\\t\\t\\t\\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\\n\\t\\t\\t\\tacceptData( elem ) ) {\\n\\n\\t\\t\\t\\t// Call a native DOM method on the target with the same name as the event.\\n\\t\\t\\t\\t// Don't do default actions on window, that's where global variables be (#6170)\\n\\t\\t\\t\\tif ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {\\n\\n\\t\\t\\t\\t\\t// Don't re-trigger an onFOO event when we call its FOO() method\\n\\t\\t\\t\\t\\ttmp = elem[ ontype ];\\n\\n\\t\\t\\t\\t\\tif ( tmp ) {\\n\\t\\t\\t\\t\\t\\telem[ ontype ] = null;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Prevent re-triggering of the same event, since we already bubbled it above\\n\\t\\t\\t\\t\\tjQuery.event.triggered = type;\\n\\n\\t\\t\\t\\t\\tif ( event.isPropagationStopped() ) {\\n\\t\\t\\t\\t\\t\\tlastElement.addEventListener( type, stopPropagationCallback );\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\telem[ type ]();\\n\\n\\t\\t\\t\\t\\tif ( event.isPropagationStopped() ) {\\n\\t\\t\\t\\t\\t\\tlastElement.removeEventListener( type, stopPropagationCallback );\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tjQuery.event.triggered = undefined;\\n\\n\\t\\t\\t\\t\\tif ( tmp ) {\\n\\t\\t\\t\\t\\t\\telem[ ontype ] = tmp;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn event.result;\\n\\t},\\n\\n\\t// Piggyback on a donor event to simulate a different one\\n\\t// Used only for `focus(in | out)` events\\n\\tsimulate: function( type, elem, event ) {\\n\\t\\tvar e = jQuery.extend(\\n\\t\\t\\tnew jQuery.Event(),\\n\\t\\t\\tevent,\\n\\t\\t\\t{\\n\\t\\t\\t\\ttype: type,\\n\\t\\t\\t\\tisSimulated: true\\n\\t\\t\\t}\\n\\t\\t);\\n\\n\\t\\tjQuery.event.trigger( e, null, elem );\\n\\t}\\n\\n} );\\n\\njQuery.fn.extend( {\\n\\n\\ttrigger: function( type, data ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tjQuery.event.trigger( type, data, this );\\n\\t\\t} );\\n\\t},\\n\\ttriggerHandler: function( type, data ) {\\n\\t\\tvar elem = this[ 0 ];\\n\\t\\tif ( elem ) {\\n\\t\\t\\treturn jQuery.event.trigger( type, data, elem, true );\\n\\t\\t}\\n\\t}\\n} );\\n\\n\\n// Support: Firefox <=44\\n// Firefox doesn't have focus(in | out) events\\n// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\\n//\\n// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\\n// focus(in | out) events fire after focus & blur events,\\n// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\\n// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\\nif ( !support.focusin ) {\\n\\tjQuery.each( { focus: \\\"focusin\\\", blur: \\\"focusout\\\" }, function( orig, fix ) {\\n\\n\\t\\t// Attach a single capturing handler on the document while someone wants focusin/focusout\\n\\t\\tvar handler = function( event ) {\\n\\t\\t\\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\\n\\t\\t};\\n\\n\\t\\tjQuery.event.special[ fix ] = {\\n\\t\\t\\tsetup: function() {\\n\\t\\t\\t\\tvar doc = this.ownerDocument || this,\\n\\t\\t\\t\\t\\tattaches = dataPriv.access( doc, fix );\\n\\n\\t\\t\\t\\tif ( !attaches ) {\\n\\t\\t\\t\\t\\tdoc.addEventListener( orig, handler, true );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\\n\\t\\t\\t},\\n\\t\\t\\tteardown: function() {\\n\\t\\t\\t\\tvar doc = this.ownerDocument || this,\\n\\t\\t\\t\\t\\tattaches = dataPriv.access( doc, fix ) - 1;\\n\\n\\t\\t\\t\\tif ( !attaches ) {\\n\\t\\t\\t\\t\\tdoc.removeEventListener( orig, handler, true );\\n\\t\\t\\t\\t\\tdataPriv.remove( doc, fix );\\n\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdataPriv.access( doc, fix, attaches );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t} );\\n}\\nvar location = window.location;\\n\\nvar nonce = Date.now();\\n\\nvar rquery = ( /\\\\?/ );\\n\\n\\n\\n// Cross-browser xml parsing\\njQuery.parseXML = function( data ) {\\n\\tvar xml;\\n\\tif ( !data || typeof data !== \\\"string\\\" ) {\\n\\t\\treturn null;\\n\\t}\\n\\n\\t// Support: IE 9 - 11 only\\n\\t// IE throws on parseFromString with invalid input.\\n\\ttry {\\n\\t\\txml = ( new window.DOMParser() ).parseFromString( data, \\\"text/xml\\\" );\\n\\t} catch ( e ) {\\n\\t\\txml = undefined;\\n\\t}\\n\\n\\tif ( !xml || xml.getElementsByTagName( \\\"parsererror\\\" ).length ) {\\n\\t\\tjQuery.error( \\\"Invalid XML: \\\" + data );\\n\\t}\\n\\treturn xml;\\n};\\n\\n\\nvar\\n\\trbracket = /\\\\[\\\\]$/,\\n\\trCRLF = /\\\\r?\\\\n/g,\\n\\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\\n\\trsubmittable = /^(?:input|select|textarea|keygen)/i;\\n\\nfunction buildParams( prefix, obj, traditional, add ) {\\n\\tvar name;\\n\\n\\tif ( Array.isArray( obj ) ) {\\n\\n\\t\\t// Serialize array item.\\n\\t\\tjQuery.each( obj, function( i, v ) {\\n\\t\\t\\tif ( traditional || rbracket.test( prefix ) ) {\\n\\n\\t\\t\\t\\t// Treat each array item as a scalar.\\n\\t\\t\\t\\tadd( prefix, v );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// Item is non-scalar (array or object), encode its numeric index.\\n\\t\\t\\t\\tbuildParams(\\n\\t\\t\\t\\t\\tprefix + \\\"[\\\" + ( typeof v === \\\"object\\\" && v != null ? i : \\\"\\\" ) + \\\"]\\\",\\n\\t\\t\\t\\t\\tv,\\n\\t\\t\\t\\t\\ttraditional,\\n\\t\\t\\t\\t\\tadd\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t} );\\n\\n\\t} else if ( !traditional && toType( obj ) === \\\"object\\\" ) {\\n\\n\\t\\t// Serialize object item.\\n\\t\\tfor ( name in obj ) {\\n\\t\\t\\tbuildParams( prefix + \\\"[\\\" + name + \\\"]\\\", obj[ name ], traditional, add );\\n\\t\\t}\\n\\n\\t} else {\\n\\n\\t\\t// Serialize scalar item.\\n\\t\\tadd( prefix, obj );\\n\\t}\\n}\\n\\n// Serialize an array of form elements or a set of\\n// key/values into a query string\\njQuery.param = function( a, traditional ) {\\n\\tvar prefix,\\n\\t\\ts = [],\\n\\t\\tadd = function( key, valueOrFunction ) {\\n\\n\\t\\t\\t// If value is a function, invoke it and use its return value\\n\\t\\t\\tvar value = isFunction( valueOrFunction ) ?\\n\\t\\t\\t\\tvalueOrFunction() :\\n\\t\\t\\t\\tvalueOrFunction;\\n\\n\\t\\t\\ts[ s.length ] = encodeURIComponent( key ) + \\\"=\\\" +\\n\\t\\t\\t\\tencodeURIComponent( value == null ? \\\"\\\" : value );\\n\\t\\t};\\n\\n\\t// If an array was passed in, assume that it is an array of form elements.\\n\\tif ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\\n\\n\\t\\t// Serialize the form elements\\n\\t\\tjQuery.each( a, function() {\\n\\t\\t\\tadd( this.name, this.value );\\n\\t\\t} );\\n\\n\\t} else {\\n\\n\\t\\t// If traditional, encode the \\\"old\\\" way (the way 1.3.2 or older\\n\\t\\t// did it), otherwise encode params recursively.\\n\\t\\tfor ( prefix in a ) {\\n\\t\\t\\tbuildParams( prefix, a[ prefix ], traditional, add );\\n\\t\\t}\\n\\t}\\n\\n\\t// Return the resulting serialization\\n\\treturn s.join( \\\"&\\\" );\\n};\\n\\njQuery.fn.extend( {\\n\\tserialize: function() {\\n\\t\\treturn jQuery.param( this.serializeArray() );\\n\\t},\\n\\tserializeArray: function() {\\n\\t\\treturn this.map( function() {\\n\\n\\t\\t\\t// Can add propHook for \\\"elements\\\" to filter or add form elements\\n\\t\\t\\tvar elements = jQuery.prop( this, \\\"elements\\\" );\\n\\t\\t\\treturn elements ? jQuery.makeArray( elements ) : this;\\n\\t\\t} )\\n\\t\\t.filter( function() {\\n\\t\\t\\tvar type = this.type;\\n\\n\\t\\t\\t// Use .is( \\\":disabled\\\" ) so that fieldset[disabled] works\\n\\t\\t\\treturn this.name && !jQuery( this ).is( \\\":disabled\\\" ) &&\\n\\t\\t\\t\\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\\n\\t\\t\\t\\t( this.checked || !rcheckableType.test( type ) );\\n\\t\\t} )\\n\\t\\t.map( function( i, elem ) {\\n\\t\\t\\tvar val = jQuery( this ).val();\\n\\n\\t\\t\\tif ( val == null ) {\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( Array.isArray( val ) ) {\\n\\t\\t\\t\\treturn jQuery.map( val, function( val ) {\\n\\t\\t\\t\\t\\treturn { name: elem.name, value: val.replace( rCRLF, \\\"\\\\r\\\\n\\\" ) };\\n\\t\\t\\t\\t} );\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn { name: elem.name, value: val.replace( rCRLF, \\\"\\\\r\\\\n\\\" ) };\\n\\t\\t} ).get();\\n\\t}\\n} );\\n\\n\\nvar\\n\\tr20 = /%20/g,\\n\\trhash = /#.*$/,\\n\\trantiCache = /([?&])_=[^&]*/,\\n\\trheaders = /^(.*?):[ \\\\t]*([^\\\\r\\\\n]*)$/mg,\\n\\n\\t// #7653, #8125, #8152: local protocol detection\\n\\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\\n\\trnoContent = /^(?:GET|HEAD)$/,\\n\\trprotocol = /^\\\\/\\\\//,\\n\\n\\t/* Prefilters\\n\\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\\n\\t * 2) These are called:\\n\\t *    - BEFORE asking for a transport\\n\\t *    - AFTER param serialization (s.data is a string if s.processData is true)\\n\\t * 3) key is the dataType\\n\\t * 4) the catchall symbol \\\"*\\\" can be used\\n\\t * 5) execution will start with transport dataType and THEN continue down to \\\"*\\\" if needed\\n\\t */\\n\\tprefilters = {},\\n\\n\\t/* Transports bindings\\n\\t * 1) key is the dataType\\n\\t * 2) the catchall symbol \\\"*\\\" can be used\\n\\t * 3) selection will start with transport dataType and THEN go to \\\"*\\\" if needed\\n\\t */\\n\\ttransports = {},\\n\\n\\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\\n\\tallTypes = \\\"*/\\\".concat( \\\"*\\\" ),\\n\\n\\t// Anchor tag for parsing the document origin\\n\\toriginAnchor = document.createElement( \\\"a\\\" );\\n\\toriginAnchor.href = location.href;\\n\\n// Base \\\"constructor\\\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\\nfunction addToPrefiltersOrTransports( structure ) {\\n\\n\\t// dataTypeExpression is optional and defaults to \\\"*\\\"\\n\\treturn function( dataTypeExpression, func ) {\\n\\n\\t\\tif ( typeof dataTypeExpression !== \\\"string\\\" ) {\\n\\t\\t\\tfunc = dataTypeExpression;\\n\\t\\t\\tdataTypeExpression = \\\"*\\\";\\n\\t\\t}\\n\\n\\t\\tvar dataType,\\n\\t\\t\\ti = 0,\\n\\t\\t\\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\\n\\n\\t\\tif ( isFunction( func ) ) {\\n\\n\\t\\t\\t// For each dataType in the dataTypeExpression\\n\\t\\t\\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\\n\\n\\t\\t\\t\\t// Prepend if requested\\n\\t\\t\\t\\tif ( dataType[ 0 ] === \\\"+\\\" ) {\\n\\t\\t\\t\\t\\tdataType = dataType.slice( 1 ) || \\\"*\\\";\\n\\t\\t\\t\\t\\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\\n\\n\\t\\t\\t\\t// Otherwise append\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n}\\n\\n// Base inspection function for prefilters and transports\\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\\n\\n\\tvar inspected = {},\\n\\t\\tseekingTransport = ( structure === transports );\\n\\n\\tfunction inspect( dataType ) {\\n\\t\\tvar selected;\\n\\t\\tinspected[ dataType ] = true;\\n\\t\\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\\n\\t\\t\\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\\n\\t\\t\\tif ( typeof dataTypeOrTransport === \\\"string\\\" &&\\n\\t\\t\\t\\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\\n\\n\\t\\t\\t\\toptions.dataTypes.unshift( dataTypeOrTransport );\\n\\t\\t\\t\\tinspect( dataTypeOrTransport );\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t} else if ( seekingTransport ) {\\n\\t\\t\\t\\treturn !( selected = dataTypeOrTransport );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t\\treturn selected;\\n\\t}\\n\\n\\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \\\"*\\\" ] && inspect( \\\"*\\\" );\\n}\\n\\n// A special extend for ajax options\\n// that takes \\\"flat\\\" options (not to be deep extended)\\n// Fixes #9887\\nfunction ajaxExtend( target, src ) {\\n\\tvar key, deep,\\n\\t\\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\\n\\n\\tfor ( key in src ) {\\n\\t\\tif ( src[ key ] !== undefined ) {\\n\\t\\t\\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\\n\\t\\t}\\n\\t}\\n\\tif ( deep ) {\\n\\t\\tjQuery.extend( true, target, deep );\\n\\t}\\n\\n\\treturn target;\\n}\\n\\n/* Handles responses to an ajax request:\\n * - finds the right dataType (mediates between content-type and expected dataType)\\n * - returns the corresponding response\\n */\\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\\n\\n\\tvar ct, type, finalDataType, firstDataType,\\n\\t\\tcontents = s.contents,\\n\\t\\tdataTypes = s.dataTypes;\\n\\n\\t// Remove auto dataType and get content-type in the process\\n\\twhile ( dataTypes[ 0 ] === \\\"*\\\" ) {\\n\\t\\tdataTypes.shift();\\n\\t\\tif ( ct === undefined ) {\\n\\t\\t\\tct = s.mimeType || jqXHR.getResponseHeader( \\\"Content-Type\\\" );\\n\\t\\t}\\n\\t}\\n\\n\\t// Check if we're dealing with a known content-type\\n\\tif ( ct ) {\\n\\t\\tfor ( type in contents ) {\\n\\t\\t\\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\\n\\t\\t\\t\\tdataTypes.unshift( type );\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Check to see if we have a response for the expected dataType\\n\\tif ( dataTypes[ 0 ] in responses ) {\\n\\t\\tfinalDataType = dataTypes[ 0 ];\\n\\t} else {\\n\\n\\t\\t// Try convertible dataTypes\\n\\t\\tfor ( type in responses ) {\\n\\t\\t\\tif ( !dataTypes[ 0 ] || s.converters[ type + \\\" \\\" + dataTypes[ 0 ] ] ) {\\n\\t\\t\\t\\tfinalDataType = type;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif ( !firstDataType ) {\\n\\t\\t\\t\\tfirstDataType = type;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Or just use first one\\n\\t\\tfinalDataType = finalDataType || firstDataType;\\n\\t}\\n\\n\\t// If we found a dataType\\n\\t// We add the dataType to the list if needed\\n\\t// and return the corresponding response\\n\\tif ( finalDataType ) {\\n\\t\\tif ( finalDataType !== dataTypes[ 0 ] ) {\\n\\t\\t\\tdataTypes.unshift( finalDataType );\\n\\t\\t}\\n\\t\\treturn responses[ finalDataType ];\\n\\t}\\n}\\n\\n/* Chain conversions given the request and the original response\\n * Also sets the responseXXX fields on the jqXHR instance\\n */\\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\\n\\tvar conv2, current, conv, tmp, prev,\\n\\t\\tconverters = {},\\n\\n\\t\\t// Work with a copy of dataTypes in case we need to modify it for conversion\\n\\t\\tdataTypes = s.dataTypes.slice();\\n\\n\\t// Create converters map with lowercased keys\\n\\tif ( dataTypes[ 1 ] ) {\\n\\t\\tfor ( conv in s.converters ) {\\n\\t\\t\\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\\n\\t\\t}\\n\\t}\\n\\n\\tcurrent = dataTypes.shift();\\n\\n\\t// Convert to each sequential dataType\\n\\twhile ( current ) {\\n\\n\\t\\tif ( s.responseFields[ current ] ) {\\n\\t\\t\\tjqXHR[ s.responseFields[ current ] ] = response;\\n\\t\\t}\\n\\n\\t\\t// Apply the dataFilter if provided\\n\\t\\tif ( !prev && isSuccess && s.dataFilter ) {\\n\\t\\t\\tresponse = s.dataFilter( response, s.dataType );\\n\\t\\t}\\n\\n\\t\\tprev = current;\\n\\t\\tcurrent = dataTypes.shift();\\n\\n\\t\\tif ( current ) {\\n\\n\\t\\t\\t// There's only work to do if current dataType is non-auto\\n\\t\\t\\tif ( current === \\\"*\\\" ) {\\n\\n\\t\\t\\t\\tcurrent = prev;\\n\\n\\t\\t\\t// Convert response if prev dataType is non-auto and differs from current\\n\\t\\t\\t} else if ( prev !== \\\"*\\\" && prev !== current ) {\\n\\n\\t\\t\\t\\t// Seek a direct converter\\n\\t\\t\\t\\tconv = converters[ prev + \\\" \\\" + current ] || converters[ \\\"* \\\" + current ];\\n\\n\\t\\t\\t\\t// If none found, seek a pair\\n\\t\\t\\t\\tif ( !conv ) {\\n\\t\\t\\t\\t\\tfor ( conv2 in converters ) {\\n\\n\\t\\t\\t\\t\\t\\t// If conv2 outputs current\\n\\t\\t\\t\\t\\t\\ttmp = conv2.split( \\\" \\\" );\\n\\t\\t\\t\\t\\t\\tif ( tmp[ 1 ] === current ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// If prev can be converted to accepted input\\n\\t\\t\\t\\t\\t\\t\\tconv = converters[ prev + \\\" \\\" + tmp[ 0 ] ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\tconverters[ \\\"* \\\" + tmp[ 0 ] ];\\n\\t\\t\\t\\t\\t\\t\\tif ( conv ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Condense equivalence converters\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( conv === true ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tconv = converters[ conv2 ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Otherwise, insert the intermediate dataType\\n\\t\\t\\t\\t\\t\\t\\t\\t} else if ( converters[ conv2 ] !== true ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcurrent = tmp[ 0 ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tdataTypes.unshift( tmp[ 1 ] );\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Apply converter (if not an equivalence)\\n\\t\\t\\t\\tif ( conv !== true ) {\\n\\n\\t\\t\\t\\t\\t// Unless errors are allowed to bubble, catch and return them\\n\\t\\t\\t\\t\\tif ( conv && s.throws ) {\\n\\t\\t\\t\\t\\t\\tresponse = conv( response );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\t\\tresponse = conv( response );\\n\\t\\t\\t\\t\\t\\t} catch ( e ) {\\n\\t\\t\\t\\t\\t\\t\\treturn {\\n\\t\\t\\t\\t\\t\\t\\t\\tstate: \\\"parsererror\\\",\\n\\t\\t\\t\\t\\t\\t\\t\\terror: conv ? e : \\\"No conversion from \\\" + prev + \\\" to \\\" + current\\n\\t\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn { state: \\\"success\\\", data: response };\\n}\\n\\njQuery.extend( {\\n\\n\\t// Counter for holding the number of active queries\\n\\tactive: 0,\\n\\n\\t// Last-Modified header cache for next request\\n\\tlastModified: {},\\n\\tetag: {},\\n\\n\\tajaxSettings: {\\n\\t\\turl: location.href,\\n\\t\\ttype: \\\"GET\\\",\\n\\t\\tisLocal: rlocalProtocol.test( location.protocol ),\\n\\t\\tglobal: true,\\n\\t\\tprocessData: true,\\n\\t\\tasync: true,\\n\\t\\tcontentType: \\\"application/x-www-form-urlencoded; charset=UTF-8\\\",\\n\\n\\t\\t/*\\n\\t\\ttimeout: 0,\\n\\t\\tdata: null,\\n\\t\\tdataType: null,\\n\\t\\tusername: null,\\n\\t\\tpassword: null,\\n\\t\\tcache: null,\\n\\t\\tthrows: false,\\n\\t\\ttraditional: false,\\n\\t\\theaders: {},\\n\\t\\t*/\\n\\n\\t\\taccepts: {\\n\\t\\t\\t\\\"*\\\": allTypes,\\n\\t\\t\\ttext: \\\"text/plain\\\",\\n\\t\\t\\thtml: \\\"text/html\\\",\\n\\t\\t\\txml: \\\"application/xml, text/xml\\\",\\n\\t\\t\\tjson: \\\"application/json, text/javascript\\\"\\n\\t\\t},\\n\\n\\t\\tcontents: {\\n\\t\\t\\txml: /\\\\bxml\\\\b/,\\n\\t\\t\\thtml: /\\\\bhtml/,\\n\\t\\t\\tjson: /\\\\bjson\\\\b/\\n\\t\\t},\\n\\n\\t\\tresponseFields: {\\n\\t\\t\\txml: \\\"responseXML\\\",\\n\\t\\t\\ttext: \\\"responseText\\\",\\n\\t\\t\\tjson: \\\"responseJSON\\\"\\n\\t\\t},\\n\\n\\t\\t// Data converters\\n\\t\\t// Keys separate source (or catchall \\\"*\\\") and destination types with a single space\\n\\t\\tconverters: {\\n\\n\\t\\t\\t// Convert anything to text\\n\\t\\t\\t\\\"* text\\\": String,\\n\\n\\t\\t\\t// Text to html (true = no transformation)\\n\\t\\t\\t\\\"text html\\\": true,\\n\\n\\t\\t\\t// Evaluate text as a json expression\\n\\t\\t\\t\\\"text json\\\": JSON.parse,\\n\\n\\t\\t\\t// Parse text as xml\\n\\t\\t\\t\\\"text xml\\\": jQuery.parseXML\\n\\t\\t},\\n\\n\\t\\t// For options that shouldn't be deep extended:\\n\\t\\t// you can add your own custom options here if\\n\\t\\t// and when you create one that shouldn't be\\n\\t\\t// deep extended (see ajaxExtend)\\n\\t\\tflatOptions: {\\n\\t\\t\\turl: true,\\n\\t\\t\\tcontext: true\\n\\t\\t}\\n\\t},\\n\\n\\t// Creates a full fledged settings object into target\\n\\t// with both ajaxSettings and settings fields.\\n\\t// If target is omitted, writes into ajaxSettings.\\n\\tajaxSetup: function( target, settings ) {\\n\\t\\treturn settings ?\\n\\n\\t\\t\\t// Building a settings object\\n\\t\\t\\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\\n\\n\\t\\t\\t// Extending ajaxSettings\\n\\t\\t\\tajaxExtend( jQuery.ajaxSettings, target );\\n\\t},\\n\\n\\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\\n\\tajaxTransport: addToPrefiltersOrTransports( transports ),\\n\\n\\t// Main method\\n\\tajax: function( url, options ) {\\n\\n\\t\\t// If url is an object, simulate pre-1.5 signature\\n\\t\\tif ( typeof url === \\\"object\\\" ) {\\n\\t\\t\\toptions = url;\\n\\t\\t\\turl = undefined;\\n\\t\\t}\\n\\n\\t\\t// Force options to be an object\\n\\t\\toptions = options || {};\\n\\n\\t\\tvar transport,\\n\\n\\t\\t\\t// URL without anti-cache param\\n\\t\\t\\tcacheURL,\\n\\n\\t\\t\\t// Response headers\\n\\t\\t\\tresponseHeadersString,\\n\\t\\t\\tresponseHeaders,\\n\\n\\t\\t\\t// timeout handle\\n\\t\\t\\ttimeoutTimer,\\n\\n\\t\\t\\t// Url cleanup var\\n\\t\\t\\turlAnchor,\\n\\n\\t\\t\\t// Request state (becomes false upon send and true upon completion)\\n\\t\\t\\tcompleted,\\n\\n\\t\\t\\t// To know if global events are to be dispatched\\n\\t\\t\\tfireGlobals,\\n\\n\\t\\t\\t// Loop variable\\n\\t\\t\\ti,\\n\\n\\t\\t\\t// uncached part of the url\\n\\t\\t\\tuncached,\\n\\n\\t\\t\\t// Create the final options object\\n\\t\\t\\ts = jQuery.ajaxSetup( {}, options ),\\n\\n\\t\\t\\t// Callbacks context\\n\\t\\t\\tcallbackContext = s.context || s,\\n\\n\\t\\t\\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\\n\\t\\t\\tglobalEventContext = s.context &&\\n\\t\\t\\t\\t( callbackContext.nodeType || callbackContext.jquery ) ?\\n\\t\\t\\t\\t\\tjQuery( callbackContext ) :\\n\\t\\t\\t\\t\\tjQuery.event,\\n\\n\\t\\t\\t// Deferreds\\n\\t\\t\\tdeferred = jQuery.Deferred(),\\n\\t\\t\\tcompleteDeferred = jQuery.Callbacks( \\\"once memory\\\" ),\\n\\n\\t\\t\\t// Status-dependent callbacks\\n\\t\\t\\tstatusCode = s.statusCode || {},\\n\\n\\t\\t\\t// Headers (they are sent all at once)\\n\\t\\t\\trequestHeaders = {},\\n\\t\\t\\trequestHeadersNames = {},\\n\\n\\t\\t\\t// Default abort message\\n\\t\\t\\tstrAbort = \\\"canceled\\\",\\n\\n\\t\\t\\t// Fake xhr\\n\\t\\t\\tjqXHR = {\\n\\t\\t\\t\\treadyState: 0,\\n\\n\\t\\t\\t\\t// Builds headers hashtable if needed\\n\\t\\t\\t\\tgetResponseHeader: function( key ) {\\n\\t\\t\\t\\t\\tvar match;\\n\\t\\t\\t\\t\\tif ( completed ) {\\n\\t\\t\\t\\t\\t\\tif ( !responseHeaders ) {\\n\\t\\t\\t\\t\\t\\t\\tresponseHeaders = {};\\n\\t\\t\\t\\t\\t\\t\\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tresponseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tmatch = responseHeaders[ key.toLowerCase() ];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn match == null ? null : match;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Raw string\\n\\t\\t\\t\\tgetAllResponseHeaders: function() {\\n\\t\\t\\t\\t\\treturn completed ? responseHeadersString : null;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Caches the header\\n\\t\\t\\t\\tsetRequestHeader: function( name, value ) {\\n\\t\\t\\t\\t\\tif ( completed == null ) {\\n\\t\\t\\t\\t\\t\\tname = requestHeadersNames[ name.toLowerCase() ] =\\n\\t\\t\\t\\t\\t\\t\\trequestHeadersNames[ name.toLowerCase() ] || name;\\n\\t\\t\\t\\t\\t\\trequestHeaders[ name ] = value;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Overrides response content-type header\\n\\t\\t\\t\\toverrideMimeType: function( type ) {\\n\\t\\t\\t\\t\\tif ( completed == null ) {\\n\\t\\t\\t\\t\\t\\ts.mimeType = type;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Status-dependent callbacks\\n\\t\\t\\t\\tstatusCode: function( map ) {\\n\\t\\t\\t\\t\\tvar code;\\n\\t\\t\\t\\t\\tif ( map ) {\\n\\t\\t\\t\\t\\t\\tif ( completed ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Execute the appropriate callbacks\\n\\t\\t\\t\\t\\t\\t\\tjqXHR.always( map[ jqXHR.status ] );\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Lazy-add the new callbacks in a way that preserves old ones\\n\\t\\t\\t\\t\\t\\t\\tfor ( code in map ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Cancel the request\\n\\t\\t\\t\\tabort: function( statusText ) {\\n\\t\\t\\t\\t\\tvar finalText = statusText || strAbort;\\n\\t\\t\\t\\t\\tif ( transport ) {\\n\\t\\t\\t\\t\\t\\ttransport.abort( finalText );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tdone( 0, finalText );\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\n\\t\\t// Attach deferreds\\n\\t\\tdeferred.promise( jqXHR );\\n\\n\\t\\t// Add protocol if not provided (prefilters might expect it)\\n\\t\\t// Handle falsy url in the settings object (#10093: consistency with old signature)\\n\\t\\t// We also use the url parameter if available\\n\\t\\ts.url = ( ( url || s.url || location.href ) + \\\"\\\" )\\n\\t\\t\\t.replace( rprotocol, location.protocol + \\\"//\\\" );\\n\\n\\t\\t// Alias method option to type as per ticket #12004\\n\\t\\ts.type = options.method || options.type || s.method || s.type;\\n\\n\\t\\t// Extract dataTypes list\\n\\t\\ts.dataTypes = ( s.dataType || \\\"*\\\" ).toLowerCase().match( rnothtmlwhite ) || [ \\\"\\\" ];\\n\\n\\t\\t// A cross-domain request is in order when the origin doesn't match the current origin.\\n\\t\\tif ( s.crossDomain == null ) {\\n\\t\\t\\turlAnchor = document.createElement( \\\"a\\\" );\\n\\n\\t\\t\\t// Support: IE <=8 - 11, Edge 12 - 15\\n\\t\\t\\t// IE throws exception on accessing the href property if url is malformed,\\n\\t\\t\\t// e.g. http://example.com:80x/\\n\\t\\t\\ttry {\\n\\t\\t\\t\\turlAnchor.href = s.url;\\n\\n\\t\\t\\t\\t// Support: IE <=8 - 11 only\\n\\t\\t\\t\\t// Anchor's host property isn't correctly set when s.url is relative\\n\\t\\t\\t\\turlAnchor.href = urlAnchor.href;\\n\\t\\t\\t\\ts.crossDomain = originAnchor.protocol + \\\"//\\\" + originAnchor.host !==\\n\\t\\t\\t\\t\\turlAnchor.protocol + \\\"//\\\" + urlAnchor.host;\\n\\t\\t\\t} catch ( e ) {\\n\\n\\t\\t\\t\\t// If there is an error parsing the URL, assume it is crossDomain,\\n\\t\\t\\t\\t// it can be rejected by the transport if it is invalid\\n\\t\\t\\t\\ts.crossDomain = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Convert data if not already a string\\n\\t\\tif ( s.data && s.processData && typeof s.data !== \\\"string\\\" ) {\\n\\t\\t\\ts.data = jQuery.param( s.data, s.traditional );\\n\\t\\t}\\n\\n\\t\\t// Apply prefilters\\n\\t\\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\\n\\n\\t\\t// If request was aborted inside a prefilter, stop there\\n\\t\\tif ( completed ) {\\n\\t\\t\\treturn jqXHR;\\n\\t\\t}\\n\\n\\t\\t// We can fire global events as of now if asked to\\n\\t\\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\\n\\t\\tfireGlobals = jQuery.event && s.global;\\n\\n\\t\\t// Watch for a new set of requests\\n\\t\\tif ( fireGlobals && jQuery.active++ === 0 ) {\\n\\t\\t\\tjQuery.event.trigger( \\\"ajaxStart\\\" );\\n\\t\\t}\\n\\n\\t\\t// Uppercase the type\\n\\t\\ts.type = s.type.toUpperCase();\\n\\n\\t\\t// Determine if request has content\\n\\t\\ts.hasContent = !rnoContent.test( s.type );\\n\\n\\t\\t// Save the URL in case we're toying with the If-Modified-Since\\n\\t\\t// and/or If-None-Match header later on\\n\\t\\t// Remove hash to simplify url manipulation\\n\\t\\tcacheURL = s.url.replace( rhash, \\\"\\\" );\\n\\n\\t\\t// More options handling for requests with no content\\n\\t\\tif ( !s.hasContent ) {\\n\\n\\t\\t\\t// Remember the hash so we can put it back\\n\\t\\t\\tuncached = s.url.slice( cacheURL.length );\\n\\n\\t\\t\\t// If data is available and should be processed, append data to url\\n\\t\\t\\tif ( s.data && ( s.processData || typeof s.data === \\\"string\\\" ) ) {\\n\\t\\t\\t\\tcacheURL += ( rquery.test( cacheURL ) ? \\\"&\\\" : \\\"?\\\" ) + s.data;\\n\\n\\t\\t\\t\\t// #9682: remove data so that it's not used in an eventual retry\\n\\t\\t\\t\\tdelete s.data;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Add or update anti-cache param if needed\\n\\t\\t\\tif ( s.cache === false ) {\\n\\t\\t\\t\\tcacheURL = cacheURL.replace( rantiCache, \\\"$1\\\" );\\n\\t\\t\\t\\tuncached = ( rquery.test( cacheURL ) ? \\\"&\\\" : \\\"?\\\" ) + \\\"_=\\\" + ( nonce++ ) + uncached;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\\n\\t\\t\\ts.url = cacheURL + uncached;\\n\\n\\t\\t// Change '%20' to '+' if this is encoded form body content (gh-2658)\\n\\t\\t} else if ( s.data && s.processData &&\\n\\t\\t\\t( s.contentType || \\\"\\\" ).indexOf( \\\"application/x-www-form-urlencoded\\\" ) === 0 ) {\\n\\t\\t\\ts.data = s.data.replace( r20, \\\"+\\\" );\\n\\t\\t}\\n\\n\\t\\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\\n\\t\\tif ( s.ifModified ) {\\n\\t\\t\\tif ( jQuery.lastModified[ cacheURL ] ) {\\n\\t\\t\\t\\tjqXHR.setRequestHeader( \\\"If-Modified-Since\\\", jQuery.lastModified[ cacheURL ] );\\n\\t\\t\\t}\\n\\t\\t\\tif ( jQuery.etag[ cacheURL ] ) {\\n\\t\\t\\t\\tjqXHR.setRequestHeader( \\\"If-None-Match\\\", jQuery.etag[ cacheURL ] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Set the correct header, if data is being sent\\n\\t\\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\\n\\t\\t\\tjqXHR.setRequestHeader( \\\"Content-Type\\\", s.contentType );\\n\\t\\t}\\n\\n\\t\\t// Set the Accepts header for the server, depending on the dataType\\n\\t\\tjqXHR.setRequestHeader(\\n\\t\\t\\t\\\"Accept\\\",\\n\\t\\t\\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\\n\\t\\t\\t\\ts.accepts[ s.dataTypes[ 0 ] ] +\\n\\t\\t\\t\\t\\t( s.dataTypes[ 0 ] !== \\\"*\\\" ? \\\", \\\" + allTypes + \\\"; q=0.01\\\" : \\\"\\\" ) :\\n\\t\\t\\t\\ts.accepts[ \\\"*\\\" ]\\n\\t\\t);\\n\\n\\t\\t// Check for headers option\\n\\t\\tfor ( i in s.headers ) {\\n\\t\\t\\tjqXHR.setRequestHeader( i, s.headers[ i ] );\\n\\t\\t}\\n\\n\\t\\t// Allow custom headers/mimetypes and early abort\\n\\t\\tif ( s.beforeSend &&\\n\\t\\t\\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\\n\\n\\t\\t\\t// Abort if not done already and return\\n\\t\\t\\treturn jqXHR.abort();\\n\\t\\t}\\n\\n\\t\\t// Aborting is no longer a cancellation\\n\\t\\tstrAbort = \\\"abort\\\";\\n\\n\\t\\t// Install callbacks on deferreds\\n\\t\\tcompleteDeferred.add( s.complete );\\n\\t\\tjqXHR.done( s.success );\\n\\t\\tjqXHR.fail( s.error );\\n\\n\\t\\t// Get transport\\n\\t\\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\\n\\n\\t\\t// If no transport, we auto-abort\\n\\t\\tif ( !transport ) {\\n\\t\\t\\tdone( -1, \\\"No Transport\\\" );\\n\\t\\t} else {\\n\\t\\t\\tjqXHR.readyState = 1;\\n\\n\\t\\t\\t// Send global event\\n\\t\\t\\tif ( fireGlobals ) {\\n\\t\\t\\t\\tglobalEventContext.trigger( \\\"ajaxSend\\\", [ jqXHR, s ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If request was aborted inside ajaxSend, stop there\\n\\t\\t\\tif ( completed ) {\\n\\t\\t\\t\\treturn jqXHR;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Timeout\\n\\t\\t\\tif ( s.async && s.timeout > 0 ) {\\n\\t\\t\\t\\ttimeoutTimer = window.setTimeout( function() {\\n\\t\\t\\t\\t\\tjqXHR.abort( \\\"timeout\\\" );\\n\\t\\t\\t\\t}, s.timeout );\\n\\t\\t\\t}\\n\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tcompleted = false;\\n\\t\\t\\t\\ttransport.send( requestHeaders, done );\\n\\t\\t\\t} catch ( e ) {\\n\\n\\t\\t\\t\\t// Rethrow post-completion exceptions\\n\\t\\t\\t\\tif ( completed ) {\\n\\t\\t\\t\\t\\tthrow e;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Propagate others as results\\n\\t\\t\\t\\tdone( -1, e );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Callback for when everything is done\\n\\t\\tfunction done( status, nativeStatusText, responses, headers ) {\\n\\t\\t\\tvar isSuccess, success, error, response, modified,\\n\\t\\t\\t\\tstatusText = nativeStatusText;\\n\\n\\t\\t\\t// Ignore repeat invocations\\n\\t\\t\\tif ( completed ) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tcompleted = true;\\n\\n\\t\\t\\t// Clear timeout if it exists\\n\\t\\t\\tif ( timeoutTimer ) {\\n\\t\\t\\t\\twindow.clearTimeout( timeoutTimer );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Dereference transport for early garbage collection\\n\\t\\t\\t// (no matter how long the jqXHR object will be used)\\n\\t\\t\\ttransport = undefined;\\n\\n\\t\\t\\t// Cache response headers\\n\\t\\t\\tresponseHeadersString = headers || \\\"\\\";\\n\\n\\t\\t\\t// Set readyState\\n\\t\\t\\tjqXHR.readyState = status > 0 ? 4 : 0;\\n\\n\\t\\t\\t// Determine if successful\\n\\t\\t\\tisSuccess = status >= 200 && status < 300 || status === 304;\\n\\n\\t\\t\\t// Get response data\\n\\t\\t\\tif ( responses ) {\\n\\t\\t\\t\\tresponse = ajaxHandleResponses( s, jqXHR, responses );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Convert no matter what (that way responseXXX fields are always set)\\n\\t\\t\\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\\n\\n\\t\\t\\t// If successful, handle type chaining\\n\\t\\t\\tif ( isSuccess ) {\\n\\n\\t\\t\\t\\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\\n\\t\\t\\t\\tif ( s.ifModified ) {\\n\\t\\t\\t\\t\\tmodified = jqXHR.getResponseHeader( \\\"Last-Modified\\\" );\\n\\t\\t\\t\\t\\tif ( modified ) {\\n\\t\\t\\t\\t\\t\\tjQuery.lastModified[ cacheURL ] = modified;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tmodified = jqXHR.getResponseHeader( \\\"etag\\\" );\\n\\t\\t\\t\\t\\tif ( modified ) {\\n\\t\\t\\t\\t\\t\\tjQuery.etag[ cacheURL ] = modified;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// if no content\\n\\t\\t\\t\\tif ( status === 204 || s.type === \\\"HEAD\\\" ) {\\n\\t\\t\\t\\t\\tstatusText = \\\"nocontent\\\";\\n\\n\\t\\t\\t\\t// if not modified\\n\\t\\t\\t\\t} else if ( status === 304 ) {\\n\\t\\t\\t\\t\\tstatusText = \\\"notmodified\\\";\\n\\n\\t\\t\\t\\t// If we have data, let's convert it\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tstatusText = response.state;\\n\\t\\t\\t\\t\\tsuccess = response.data;\\n\\t\\t\\t\\t\\terror = response.error;\\n\\t\\t\\t\\t\\tisSuccess = !error;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// Extract error from statusText and normalize for non-aborts\\n\\t\\t\\t\\terror = statusText;\\n\\t\\t\\t\\tif ( status || !statusText ) {\\n\\t\\t\\t\\t\\tstatusText = \\\"error\\\";\\n\\t\\t\\t\\t\\tif ( status < 0 ) {\\n\\t\\t\\t\\t\\t\\tstatus = 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Set data for the fake xhr object\\n\\t\\t\\tjqXHR.status = status;\\n\\t\\t\\tjqXHR.statusText = ( nativeStatusText || statusText ) + \\\"\\\";\\n\\n\\t\\t\\t// Success/Error\\n\\t\\t\\tif ( isSuccess ) {\\n\\t\\t\\t\\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Status-dependent callbacks\\n\\t\\t\\tjqXHR.statusCode( statusCode );\\n\\t\\t\\tstatusCode = undefined;\\n\\n\\t\\t\\tif ( fireGlobals ) {\\n\\t\\t\\t\\tglobalEventContext.trigger( isSuccess ? \\\"ajaxSuccess\\\" : \\\"ajaxError\\\",\\n\\t\\t\\t\\t\\t[ jqXHR, s, isSuccess ? success : error ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Complete\\n\\t\\t\\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\\n\\n\\t\\t\\tif ( fireGlobals ) {\\n\\t\\t\\t\\tglobalEventContext.trigger( \\\"ajaxComplete\\\", [ jqXHR, s ] );\\n\\n\\t\\t\\t\\t// Handle the global AJAX counter\\n\\t\\t\\t\\tif ( !( --jQuery.active ) ) {\\n\\t\\t\\t\\t\\tjQuery.event.trigger( \\\"ajaxStop\\\" );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn jqXHR;\\n\\t},\\n\\n\\tgetJSON: function( url, data, callback ) {\\n\\t\\treturn jQuery.get( url, data, callback, \\\"json\\\" );\\n\\t},\\n\\n\\tgetScript: function( url, callback ) {\\n\\t\\treturn jQuery.get( url, undefined, callback, \\\"script\\\" );\\n\\t}\\n} );\\n\\njQuery.each( [ \\\"get\\\", \\\"post\\\" ], function( i, method ) {\\n\\tjQuery[ method ] = function( url, data, callback, type ) {\\n\\n\\t\\t// Shift arguments if data argument was omitted\\n\\t\\tif ( isFunction( data ) ) {\\n\\t\\t\\ttype = type || callback;\\n\\t\\t\\tcallback = data;\\n\\t\\t\\tdata = undefined;\\n\\t\\t}\\n\\n\\t\\t// The url can be an options object (which then must have .url)\\n\\t\\treturn jQuery.ajax( jQuery.extend( {\\n\\t\\t\\turl: url,\\n\\t\\t\\ttype: method,\\n\\t\\t\\tdataType: type,\\n\\t\\t\\tdata: data,\\n\\t\\t\\tsuccess: callback\\n\\t\\t}, jQuery.isPlainObject( url ) && url ) );\\n\\t};\\n} );\\n\\n\\njQuery._evalUrl = function( url ) {\\n\\treturn jQuery.ajax( {\\n\\t\\turl: url,\\n\\n\\t\\t// Make this explicit, since user can override this through ajaxSetup (#11264)\\n\\t\\ttype: \\\"GET\\\",\\n\\t\\tdataType: \\\"script\\\",\\n\\t\\tcache: true,\\n\\t\\tasync: false,\\n\\t\\tglobal: false,\\n\\t\\t\\\"throws\\\": true\\n\\t} );\\n};\\n\\n\\njQuery.fn.extend( {\\n\\twrapAll: function( html ) {\\n\\t\\tvar wrap;\\n\\n\\t\\tif ( this[ 0 ] ) {\\n\\t\\t\\tif ( isFunction( html ) ) {\\n\\t\\t\\t\\thtml = html.call( this[ 0 ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// The elements to wrap the target around\\n\\t\\t\\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\\n\\n\\t\\t\\tif ( this[ 0 ].parentNode ) {\\n\\t\\t\\t\\twrap.insertBefore( this[ 0 ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\twrap.map( function() {\\n\\t\\t\\t\\tvar elem = this;\\n\\n\\t\\t\\t\\twhile ( elem.firstElementChild ) {\\n\\t\\t\\t\\t\\telem = elem.firstElementChild;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn elem;\\n\\t\\t\\t} ).append( this );\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\twrapInner: function( html ) {\\n\\t\\tif ( isFunction( html ) ) {\\n\\t\\t\\treturn this.each( function( i ) {\\n\\t\\t\\t\\tjQuery( this ).wrapInner( html.call( this, i ) );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tvar self = jQuery( this ),\\n\\t\\t\\t\\tcontents = self.contents();\\n\\n\\t\\t\\tif ( contents.length ) {\\n\\t\\t\\t\\tcontents.wrapAll( html );\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tself.append( html );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\twrap: function( html ) {\\n\\t\\tvar htmlIsFunction = isFunction( html );\\n\\n\\t\\treturn this.each( function( i ) {\\n\\t\\t\\tjQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );\\n\\t\\t} );\\n\\t},\\n\\n\\tunwrap: function( selector ) {\\n\\t\\tthis.parent( selector ).not( \\\"body\\\" ).each( function() {\\n\\t\\t\\tjQuery( this ).replaceWith( this.childNodes );\\n\\t\\t} );\\n\\t\\treturn this;\\n\\t}\\n} );\\n\\n\\njQuery.expr.pseudos.hidden = function( elem ) {\\n\\treturn !jQuery.expr.pseudos.visible( elem );\\n};\\njQuery.expr.pseudos.visible = function( elem ) {\\n\\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\\n};\\n\\n\\n\\n\\njQuery.ajaxSettings.xhr = function() {\\n\\ttry {\\n\\t\\treturn new window.XMLHttpRequest();\\n\\t} catch ( e ) {}\\n};\\n\\nvar xhrSuccessStatus = {\\n\\n\\t\\t// File protocol always yields status code 0, assume 200\\n\\t\\t0: 200,\\n\\n\\t\\t// Support: IE <=9 only\\n\\t\\t// #1450: sometimes IE returns 1223 when it should be 204\\n\\t\\t1223: 204\\n\\t},\\n\\txhrSupported = jQuery.ajaxSettings.xhr();\\n\\nsupport.cors = !!xhrSupported && ( \\\"withCredentials\\\" in xhrSupported );\\nsupport.ajax = xhrSupported = !!xhrSupported;\\n\\njQuery.ajaxTransport( function( options ) {\\n\\tvar callback, errorCallback;\\n\\n\\t// Cross domain only allowed if supported through XMLHttpRequest\\n\\tif ( support.cors || xhrSupported && !options.crossDomain ) {\\n\\t\\treturn {\\n\\t\\t\\tsend: function( headers, complete ) {\\n\\t\\t\\t\\tvar i,\\n\\t\\t\\t\\t\\txhr = options.xhr();\\n\\n\\t\\t\\t\\txhr.open(\\n\\t\\t\\t\\t\\toptions.type,\\n\\t\\t\\t\\t\\toptions.url,\\n\\t\\t\\t\\t\\toptions.async,\\n\\t\\t\\t\\t\\toptions.username,\\n\\t\\t\\t\\t\\toptions.password\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t// Apply custom fields if provided\\n\\t\\t\\t\\tif ( options.xhrFields ) {\\n\\t\\t\\t\\t\\tfor ( i in options.xhrFields ) {\\n\\t\\t\\t\\t\\t\\txhr[ i ] = options.xhrFields[ i ];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Override mime type if needed\\n\\t\\t\\t\\tif ( options.mimeType && xhr.overrideMimeType ) {\\n\\t\\t\\t\\t\\txhr.overrideMimeType( options.mimeType );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// X-Requested-With header\\n\\t\\t\\t\\t// For cross-domain requests, seeing as conditions for a preflight are\\n\\t\\t\\t\\t// akin to a jigsaw puzzle, we simply never set it to be sure.\\n\\t\\t\\t\\t// (it can always be set on a per-request basis or even using ajaxSetup)\\n\\t\\t\\t\\t// For same-domain requests, won't change header if already provided.\\n\\t\\t\\t\\tif ( !options.crossDomain && !headers[ \\\"X-Requested-With\\\" ] ) {\\n\\t\\t\\t\\t\\theaders[ \\\"X-Requested-With\\\" ] = \\\"XMLHttpRequest\\\";\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Set headers\\n\\t\\t\\t\\tfor ( i in headers ) {\\n\\t\\t\\t\\t\\txhr.setRequestHeader( i, headers[ i ] );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Callback\\n\\t\\t\\t\\tcallback = function( type ) {\\n\\t\\t\\t\\t\\treturn function() {\\n\\t\\t\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\t\\t\\tcallback = errorCallback = xhr.onload =\\n\\t\\t\\t\\t\\t\\t\\t\\txhr.onerror = xhr.onabort = xhr.ontimeout =\\n\\t\\t\\t\\t\\t\\t\\t\\t\\txhr.onreadystatechange = null;\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( type === \\\"abort\\\" ) {\\n\\t\\t\\t\\t\\t\\t\\t\\txhr.abort();\\n\\t\\t\\t\\t\\t\\t\\t} else if ( type === \\\"error\\\" ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Support: IE <=9 only\\n\\t\\t\\t\\t\\t\\t\\t\\t// On a manual native abort, IE9 throws\\n\\t\\t\\t\\t\\t\\t\\t\\t// errors on any property access that is not readyState\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( typeof xhr.status !== \\\"number\\\" ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcomplete( 0, \\\"error\\\" );\\n\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcomplete(\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// File: protocol always yields status 0; see #8605, #14207\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\txhr.status,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\txhr.statusText\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tcomplete(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\txhrSuccessStatus[ xhr.status ] || xhr.status,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\txhr.statusText,\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: IE <=9 only\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// IE9 has no XHR2 but throws on binary (trac-11426)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// For XHR2 non-text, let the caller handle it (gh-2498)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t( xhr.responseType || \\\"text\\\" ) !== \\\"text\\\"  ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\ttypeof xhr.responseText !== \\\"string\\\" ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{ binary: xhr.response } :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{ text: xhr.responseText },\\n\\t\\t\\t\\t\\t\\t\\t\\t\\txhr.getAllResponseHeaders()\\n\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t// Listen to events\\n\\t\\t\\t\\txhr.onload = callback();\\n\\t\\t\\t\\terrorCallback = xhr.onerror = xhr.ontimeout = callback( \\\"error\\\" );\\n\\n\\t\\t\\t\\t// Support: IE 9 only\\n\\t\\t\\t\\t// Use onreadystatechange to replace onabort\\n\\t\\t\\t\\t// to handle uncaught aborts\\n\\t\\t\\t\\tif ( xhr.onabort !== undefined ) {\\n\\t\\t\\t\\t\\txhr.onabort = errorCallback;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\txhr.onreadystatechange = function() {\\n\\n\\t\\t\\t\\t\\t\\t// Check readyState before timeout as it changes\\n\\t\\t\\t\\t\\t\\tif ( xhr.readyState === 4 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Allow onerror to be called first,\\n\\t\\t\\t\\t\\t\\t\\t// but that will not handle a native abort\\n\\t\\t\\t\\t\\t\\t\\t// Also, save errorCallback to a variable\\n\\t\\t\\t\\t\\t\\t\\t// as xhr.onerror cannot be accessed\\n\\t\\t\\t\\t\\t\\t\\twindow.setTimeout( function() {\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\terrorCallback();\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Create the abort callback\\n\\t\\t\\t\\tcallback = callback( \\\"abort\\\" );\\n\\n\\t\\t\\t\\ttry {\\n\\n\\t\\t\\t\\t\\t// Do send the request (this may raise an exception)\\n\\t\\t\\t\\t\\txhr.send( options.hasContent && options.data || null );\\n\\t\\t\\t\\t} catch ( e ) {\\n\\n\\t\\t\\t\\t\\t// #14683: Only rethrow if this hasn't been notified as an error yet\\n\\t\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\t\\tthrow e;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\n\\t\\t\\tabort: function() {\\n\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\tcallback();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n} );\\n\\n\\n\\n\\n// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\\njQuery.ajaxPrefilter( function( s ) {\\n\\tif ( s.crossDomain ) {\\n\\t\\ts.contents.script = false;\\n\\t}\\n} );\\n\\n// Install script dataType\\njQuery.ajaxSetup( {\\n\\taccepts: {\\n\\t\\tscript: \\\"text/javascript, application/javascript, \\\" +\\n\\t\\t\\t\\\"application/ecmascript, application/x-ecmascript\\\"\\n\\t},\\n\\tcontents: {\\n\\t\\tscript: /\\\\b(?:java|ecma)script\\\\b/\\n\\t},\\n\\tconverters: {\\n\\t\\t\\\"text script\\\": function( text ) {\\n\\t\\t\\tjQuery.globalEval( text );\\n\\t\\t\\treturn text;\\n\\t\\t}\\n\\t}\\n} );\\n\\n// Handle cache's special case and crossDomain\\njQuery.ajaxPrefilter( \\\"script\\\", function( s ) {\\n\\tif ( s.cache === undefined ) {\\n\\t\\ts.cache = false;\\n\\t}\\n\\tif ( s.crossDomain ) {\\n\\t\\ts.type = \\\"GET\\\";\\n\\t}\\n} );\\n\\n// Bind script tag hack transport\\njQuery.ajaxTransport( \\\"script\\\", function( s ) {\\n\\n\\t// This transport only deals with cross domain requests\\n\\tif ( s.crossDomain ) {\\n\\t\\tvar script, callback;\\n\\t\\treturn {\\n\\t\\t\\tsend: function( _, complete ) {\\n\\t\\t\\t\\tscript = jQuery( \\\"<script>\\\" ).prop( {\\n\\t\\t\\t\\t\\tcharset: s.scriptCharset,\\n\\t\\t\\t\\t\\tsrc: s.url\\n\\t\\t\\t\\t} ).on(\\n\\t\\t\\t\\t\\t\\\"load error\\\",\\n\\t\\t\\t\\t\\tcallback = function( evt ) {\\n\\t\\t\\t\\t\\t\\tscript.remove();\\n\\t\\t\\t\\t\\t\\tcallback = null;\\n\\t\\t\\t\\t\\t\\tif ( evt ) {\\n\\t\\t\\t\\t\\t\\t\\tcomplete( evt.type === \\\"error\\\" ? 404 : 200, evt.type );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t// Use native DOM manipulation to avoid our domManip AJAX trickery\\n\\t\\t\\t\\tdocument.head.appendChild( script[ 0 ] );\\n\\t\\t\\t},\\n\\t\\t\\tabort: function() {\\n\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\tcallback();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n} );\\n\\n\\n\\n\\nvar oldCallbacks = [],\\n\\trjsonp = /(=)\\\\?(?=&|$)|\\\\?\\\\?/;\\n\\n// Default jsonp settings\\njQuery.ajaxSetup( {\\n\\tjsonp: \\\"callback\\\",\\n\\tjsonpCallback: function() {\\n\\t\\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \\\"_\\\" + ( nonce++ ) );\\n\\t\\tthis[ callback ] = true;\\n\\t\\treturn callback;\\n\\t}\\n} );\\n\\n// Detect, normalize options and install callbacks for jsonp requests\\njQuery.ajaxPrefilter( \\\"json jsonp\\\", function( s, originalSettings, jqXHR ) {\\n\\n\\tvar callbackName, overwritten, responseContainer,\\n\\t\\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\\n\\t\\t\\t\\\"url\\\" :\\n\\t\\t\\ttypeof s.data === \\\"string\\\" &&\\n\\t\\t\\t\\t( s.contentType || \\\"\\\" )\\n\\t\\t\\t\\t\\t.indexOf( \\\"application/x-www-form-urlencoded\\\" ) === 0 &&\\n\\t\\t\\t\\trjsonp.test( s.data ) && \\\"data\\\"\\n\\t\\t);\\n\\n\\t// Handle iff the expected data type is \\\"jsonp\\\" or we have a parameter to set\\n\\tif ( jsonProp || s.dataTypes[ 0 ] === \\\"jsonp\\\" ) {\\n\\n\\t\\t// Get callback name, remembering preexisting value associated with it\\n\\t\\tcallbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?\\n\\t\\t\\ts.jsonpCallback() :\\n\\t\\t\\ts.jsonpCallback;\\n\\n\\t\\t// Insert callback into url or form data\\n\\t\\tif ( jsonProp ) {\\n\\t\\t\\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \\\"$1\\\" + callbackName );\\n\\t\\t} else if ( s.jsonp !== false ) {\\n\\t\\t\\ts.url += ( rquery.test( s.url ) ? \\\"&\\\" : \\\"?\\\" ) + s.jsonp + \\\"=\\\" + callbackName;\\n\\t\\t}\\n\\n\\t\\t// Use data converter to retrieve json after script execution\\n\\t\\ts.converters[ \\\"script json\\\" ] = function() {\\n\\t\\t\\tif ( !responseContainer ) {\\n\\t\\t\\t\\tjQuery.error( callbackName + \\\" was not called\\\" );\\n\\t\\t\\t}\\n\\t\\t\\treturn responseContainer[ 0 ];\\n\\t\\t};\\n\\n\\t\\t// Force json dataType\\n\\t\\ts.dataTypes[ 0 ] = \\\"json\\\";\\n\\n\\t\\t// Install callback\\n\\t\\toverwritten = window[ callbackName ];\\n\\t\\twindow[ callbackName ] = function() {\\n\\t\\t\\tresponseContainer = arguments;\\n\\t\\t};\\n\\n\\t\\t// Clean-up function (fires after converters)\\n\\t\\tjqXHR.always( function() {\\n\\n\\t\\t\\t// If previous value didn't exist - remove it\\n\\t\\t\\tif ( overwritten === undefined ) {\\n\\t\\t\\t\\tjQuery( window ).removeProp( callbackName );\\n\\n\\t\\t\\t// Otherwise restore preexisting value\\n\\t\\t\\t} else {\\n\\t\\t\\t\\twindow[ callbackName ] = overwritten;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Save back as free\\n\\t\\t\\tif ( s[ callbackName ] ) {\\n\\n\\t\\t\\t\\t// Make sure that re-using the options doesn't screw things around\\n\\t\\t\\t\\ts.jsonpCallback = originalSettings.jsonpCallback;\\n\\n\\t\\t\\t\\t// Save the callback name for future use\\n\\t\\t\\t\\toldCallbacks.push( callbackName );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Call if it was a function and we have a response\\n\\t\\t\\tif ( responseContainer && isFunction( overwritten ) ) {\\n\\t\\t\\t\\toverwritten( responseContainer[ 0 ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\tresponseContainer = overwritten = undefined;\\n\\t\\t} );\\n\\n\\t\\t// Delegate to script\\n\\t\\treturn \\\"script\\\";\\n\\t}\\n} );\\n\\n\\n\\n\\n// Support: Safari 8 only\\n// In Safari 8 documents created via document.implementation.createHTMLDocument\\n// collapse sibling forms: the second one becomes a child of the first one.\\n// Because of that, this security measure has to be disabled in Safari 8.\\n// https://bugs.webkit.org/show_bug.cgi?id=137337\\nsupport.createHTMLDocument = ( function() {\\n\\tvar body = document.implementation.createHTMLDocument( \\\"\\\" ).body;\\n\\tbody.innerHTML = \\\"<form></form><form></form>\\\";\\n\\treturn body.childNodes.length === 2;\\n} )();\\n\\n\\n// Argument \\\"data\\\" should be string of html\\n// context (optional): If specified, the fragment will be created in this context,\\n// defaults to document\\n// keepScripts (optional): If true, will include scripts passed in the html string\\njQuery.parseHTML = function( data, context, keepScripts ) {\\n\\tif ( typeof data !== \\\"string\\\" ) {\\n\\t\\treturn [];\\n\\t}\\n\\tif ( typeof context === \\\"boolean\\\" ) {\\n\\t\\tkeepScripts = context;\\n\\t\\tcontext = false;\\n\\t}\\n\\n\\tvar base, parsed, scripts;\\n\\n\\tif ( !context ) {\\n\\n\\t\\t// Stop scripts or inline event handlers from being executed immediately\\n\\t\\t// by using document.implementation\\n\\t\\tif ( support.createHTMLDocument ) {\\n\\t\\t\\tcontext = document.implementation.createHTMLDocument( \\\"\\\" );\\n\\n\\t\\t\\t// Set the base href for the created document\\n\\t\\t\\t// so any parsed elements with URLs\\n\\t\\t\\t// are based on the document's URL (gh-2965)\\n\\t\\t\\tbase = context.createElement( \\\"base\\\" );\\n\\t\\t\\tbase.href = document.location.href;\\n\\t\\t\\tcontext.head.appendChild( base );\\n\\t\\t} else {\\n\\t\\t\\tcontext = document;\\n\\t\\t}\\n\\t}\\n\\n\\tparsed = rsingleTag.exec( data );\\n\\tscripts = !keepScripts && [];\\n\\n\\t// Single tag\\n\\tif ( parsed ) {\\n\\t\\treturn [ context.createElement( parsed[ 1 ] ) ];\\n\\t}\\n\\n\\tparsed = buildFragment( [ data ], context, scripts );\\n\\n\\tif ( scripts && scripts.length ) {\\n\\t\\tjQuery( scripts ).remove();\\n\\t}\\n\\n\\treturn jQuery.merge( [], parsed.childNodes );\\n};\\n\\n\\n/**\\n * Load a url into a page\\n */\\njQuery.fn.load = function( url, params, callback ) {\\n\\tvar selector, type, response,\\n\\t\\tself = this,\\n\\t\\toff = url.indexOf( \\\" \\\" );\\n\\n\\tif ( off > -1 ) {\\n\\t\\tselector = stripAndCollapse( url.slice( off ) );\\n\\t\\turl = url.slice( 0, off );\\n\\t}\\n\\n\\t// If it's a function\\n\\tif ( isFunction( params ) ) {\\n\\n\\t\\t// We assume that it's the callback\\n\\t\\tcallback = params;\\n\\t\\tparams = undefined;\\n\\n\\t// Otherwise, build a param string\\n\\t} else if ( params && typeof params === \\\"object\\\" ) {\\n\\t\\ttype = \\\"POST\\\";\\n\\t}\\n\\n\\t// If we have elements to modify, make the request\\n\\tif ( self.length > 0 ) {\\n\\t\\tjQuery.ajax( {\\n\\t\\t\\turl: url,\\n\\n\\t\\t\\t// If \\\"type\\\" variable is undefined, then \\\"GET\\\" method will be used.\\n\\t\\t\\t// Make value of this field explicit since\\n\\t\\t\\t// user can override it through ajaxSetup method\\n\\t\\t\\ttype: type || \\\"GET\\\",\\n\\t\\t\\tdataType: \\\"html\\\",\\n\\t\\t\\tdata: params\\n\\t\\t} ).done( function( responseText ) {\\n\\n\\t\\t\\t// Save response for use in complete callback\\n\\t\\t\\tresponse = arguments;\\n\\n\\t\\t\\tself.html( selector ?\\n\\n\\t\\t\\t\\t// If a selector was specified, locate the right elements in a dummy div\\n\\t\\t\\t\\t// Exclude scripts to avoid IE 'Permission Denied' errors\\n\\t\\t\\t\\tjQuery( \\\"<div>\\\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\\n\\n\\t\\t\\t\\t// Otherwise use the full result\\n\\t\\t\\t\\tresponseText );\\n\\n\\t\\t// If the request succeeds, this function gets \\\"data\\\", \\\"status\\\", \\\"jqXHR\\\"\\n\\t\\t// but they are ignored because response was set above.\\n\\t\\t// If it fails, this function gets \\\"jqXHR\\\", \\\"status\\\", \\\"error\\\"\\n\\t\\t} ).always( callback && function( jqXHR, status ) {\\n\\t\\t\\tself.each( function() {\\n\\t\\t\\t\\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\\n\\t\\t\\t} );\\n\\t\\t} );\\n\\t}\\n\\n\\treturn this;\\n};\\n\\n\\n\\n\\n// Attach a bunch of functions for handling common AJAX events\\njQuery.each( [\\n\\t\\\"ajaxStart\\\",\\n\\t\\\"ajaxStop\\\",\\n\\t\\\"ajaxComplete\\\",\\n\\t\\\"ajaxError\\\",\\n\\t\\\"ajaxSuccess\\\",\\n\\t\\\"ajaxSend\\\"\\n], function( i, type ) {\\n\\tjQuery.fn[ type ] = function( fn ) {\\n\\t\\treturn this.on( type, fn );\\n\\t};\\n} );\\n\\n\\n\\n\\njQuery.expr.pseudos.animated = function( elem ) {\\n\\treturn jQuery.grep( jQuery.timers, function( fn ) {\\n\\t\\treturn elem === fn.elem;\\n\\t} ).length;\\n};\\n\\n\\n\\n\\njQuery.offset = {\\n\\tsetOffset: function( elem, options, i ) {\\n\\t\\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\\n\\t\\t\\tposition = jQuery.css( elem, \\\"position\\\" ),\\n\\t\\t\\tcurElem = jQuery( elem ),\\n\\t\\t\\tprops = {};\\n\\n\\t\\t// Set position first, in-case top/left are set even on static elem\\n\\t\\tif ( position === \\\"static\\\" ) {\\n\\t\\t\\telem.style.position = \\\"relative\\\";\\n\\t\\t}\\n\\n\\t\\tcurOffset = curElem.offset();\\n\\t\\tcurCSSTop = jQuery.css( elem, \\\"top\\\" );\\n\\t\\tcurCSSLeft = jQuery.css( elem, \\\"left\\\" );\\n\\t\\tcalculatePosition = ( position === \\\"absolute\\\" || position === \\\"fixed\\\" ) &&\\n\\t\\t\\t( curCSSTop + curCSSLeft ).indexOf( \\\"auto\\\" ) > -1;\\n\\n\\t\\t// Need to be able to calculate position if either\\n\\t\\t// top or left is auto and position is either absolute or fixed\\n\\t\\tif ( calculatePosition ) {\\n\\t\\t\\tcurPosition = curElem.position();\\n\\t\\t\\tcurTop = curPosition.top;\\n\\t\\t\\tcurLeft = curPosition.left;\\n\\n\\t\\t} else {\\n\\t\\t\\tcurTop = parseFloat( curCSSTop ) || 0;\\n\\t\\t\\tcurLeft = parseFloat( curCSSLeft ) || 0;\\n\\t\\t}\\n\\n\\t\\tif ( isFunction( options ) ) {\\n\\n\\t\\t\\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\\n\\t\\t\\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\\n\\t\\t}\\n\\n\\t\\tif ( options.top != null ) {\\n\\t\\t\\tprops.top = ( options.top - curOffset.top ) + curTop;\\n\\t\\t}\\n\\t\\tif ( options.left != null ) {\\n\\t\\t\\tprops.left = ( options.left - curOffset.left ) + curLeft;\\n\\t\\t}\\n\\n\\t\\tif ( \\\"using\\\" in options ) {\\n\\t\\t\\toptions.using.call( elem, props );\\n\\n\\t\\t} else {\\n\\t\\t\\tcurElem.css( props );\\n\\t\\t}\\n\\t}\\n};\\n\\njQuery.fn.extend( {\\n\\n\\t// offset() relates an element's border box to the document origin\\n\\toffset: function( options ) {\\n\\n\\t\\t// Preserve chaining for setter\\n\\t\\tif ( arguments.length ) {\\n\\t\\t\\treturn options === undefined ?\\n\\t\\t\\t\\tthis :\\n\\t\\t\\t\\tthis.each( function( i ) {\\n\\t\\t\\t\\t\\tjQuery.offset.setOffset( this, options, i );\\n\\t\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\tvar rect, win,\\n\\t\\t\\telem = this[ 0 ];\\n\\n\\t\\tif ( !elem ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Return zeros for disconnected and hidden (display: none) elements (gh-2310)\\n\\t\\t// Support: IE <=11 only\\n\\t\\t// Running getBoundingClientRect on a\\n\\t\\t// disconnected node in IE throws an error\\n\\t\\tif ( !elem.getClientRects().length ) {\\n\\t\\t\\treturn { top: 0, left: 0 };\\n\\t\\t}\\n\\n\\t\\t// Get document-relative position by adding viewport scroll to viewport-relative gBCR\\n\\t\\trect = elem.getBoundingClientRect();\\n\\t\\twin = elem.ownerDocument.defaultView;\\n\\t\\treturn {\\n\\t\\t\\ttop: rect.top + win.pageYOffset,\\n\\t\\t\\tleft: rect.left + win.pageXOffset\\n\\t\\t};\\n\\t},\\n\\n\\t// position() relates an element's margin box to its offset parent's padding box\\n\\t// This corresponds to the behavior of CSS absolute positioning\\n\\tposition: function() {\\n\\t\\tif ( !this[ 0 ] ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tvar offsetParent, offset, doc,\\n\\t\\t\\telem = this[ 0 ],\\n\\t\\t\\tparentOffset = { top: 0, left: 0 };\\n\\n\\t\\t// position:fixed elements are offset from the viewport, which itself always has zero offset\\n\\t\\tif ( jQuery.css( elem, \\\"position\\\" ) === \\\"fixed\\\" ) {\\n\\n\\t\\t\\t// Assume position:fixed implies availability of getBoundingClientRect\\n\\t\\t\\toffset = elem.getBoundingClientRect();\\n\\n\\t\\t} else {\\n\\t\\t\\toffset = this.offset();\\n\\n\\t\\t\\t// Account for the *real* offset parent, which can be the document or its root element\\n\\t\\t\\t// when a statically positioned element is identified\\n\\t\\t\\tdoc = elem.ownerDocument;\\n\\t\\t\\toffsetParent = elem.offsetParent || doc.documentElement;\\n\\t\\t\\twhile ( offsetParent &&\\n\\t\\t\\t\\t( offsetParent === doc.body || offsetParent === doc.documentElement ) &&\\n\\t\\t\\t\\tjQuery.css( offsetParent, \\\"position\\\" ) === \\\"static\\\" ) {\\n\\n\\t\\t\\t\\toffsetParent = offsetParent.parentNode;\\n\\t\\t\\t}\\n\\t\\t\\tif ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {\\n\\n\\t\\t\\t\\t// Incorporate borders into its offset, since they are outside its content origin\\n\\t\\t\\t\\tparentOffset = jQuery( offsetParent ).offset();\\n\\t\\t\\t\\tparentOffset.top += jQuery.css( offsetParent, \\\"borderTopWidth\\\", true );\\n\\t\\t\\t\\tparentOffset.left += jQuery.css( offsetParent, \\\"borderLeftWidth\\\", true );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Subtract parent offsets and element margins\\n\\t\\treturn {\\n\\t\\t\\ttop: offset.top - parentOffset.top - jQuery.css( elem, \\\"marginTop\\\", true ),\\n\\t\\t\\tleft: offset.left - parentOffset.left - jQuery.css( elem, \\\"marginLeft\\\", true )\\n\\t\\t};\\n\\t},\\n\\n\\t// This method will return documentElement in the following cases:\\n\\t// 1) For the element inside the iframe without offsetParent, this method will return\\n\\t//    documentElement of the parent window\\n\\t// 2) For the hidden or detached element\\n\\t// 3) For body or html element, i.e. in case of the html node - it will return itself\\n\\t//\\n\\t// but those exceptions were never presented as a real life use-cases\\n\\t// and might be considered as more preferable results.\\n\\t//\\n\\t// This logic, however, is not guaranteed and can change at any point in the future\\n\\toffsetParent: function() {\\n\\t\\treturn this.map( function() {\\n\\t\\t\\tvar offsetParent = this.offsetParent;\\n\\n\\t\\t\\twhile ( offsetParent && jQuery.css( offsetParent, \\\"position\\\" ) === \\\"static\\\" ) {\\n\\t\\t\\t\\toffsetParent = offsetParent.offsetParent;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn offsetParent || documentElement;\\n\\t\\t} );\\n\\t}\\n} );\\n\\n// Create scrollLeft and scrollTop methods\\njQuery.each( { scrollLeft: \\\"pageXOffset\\\", scrollTop: \\\"pageYOffset\\\" }, function( method, prop ) {\\n\\tvar top = \\\"pageYOffset\\\" === prop;\\n\\n\\tjQuery.fn[ method ] = function( val ) {\\n\\t\\treturn access( this, function( elem, method, val ) {\\n\\n\\t\\t\\t// Coalesce documents and windows\\n\\t\\t\\tvar win;\\n\\t\\t\\tif ( isWindow( elem ) ) {\\n\\t\\t\\t\\twin = elem;\\n\\t\\t\\t} else if ( elem.nodeType === 9 ) {\\n\\t\\t\\t\\twin = elem.defaultView;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( val === undefined ) {\\n\\t\\t\\t\\treturn win ? win[ prop ] : elem[ method ];\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( win ) {\\n\\t\\t\\t\\twin.scrollTo(\\n\\t\\t\\t\\t\\t!top ? val : win.pageXOffset,\\n\\t\\t\\t\\t\\ttop ? val : win.pageYOffset\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\telem[ method ] = val;\\n\\t\\t\\t}\\n\\t\\t}, method, val, arguments.length );\\n\\t};\\n} );\\n\\n// Support: Safari <=7 - 9.1, Chrome <=37 - 49\\n// Add the top/left cssHooks using jQuery.fn.position\\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\\n// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\\n// getComputedStyle returns percent when specified for top/left/bottom/right;\\n// rather than make the css module depend on the offset module, just check for it here\\njQuery.each( [ \\\"top\\\", \\\"left\\\" ], function( i, prop ) {\\n\\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\\n\\t\\tfunction( elem, computed ) {\\n\\t\\t\\tif ( computed ) {\\n\\t\\t\\t\\tcomputed = curCSS( elem, prop );\\n\\n\\t\\t\\t\\t// If curCSS returns percentage, fallback to offset\\n\\t\\t\\t\\treturn rnumnonpx.test( computed ) ?\\n\\t\\t\\t\\t\\tjQuery( elem ).position()[ prop ] + \\\"px\\\" :\\n\\t\\t\\t\\t\\tcomputed;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t);\\n} );\\n\\n\\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\\njQuery.each( { Height: \\\"height\\\", Width: \\\"width\\\" }, function( name, type ) {\\n\\tjQuery.each( { padding: \\\"inner\\\" + name, content: type, \\\"\\\": \\\"outer\\\" + name },\\n\\t\\tfunction( defaultExtra, funcName ) {\\n\\n\\t\\t// Margin is only for outerHeight, outerWidth\\n\\t\\tjQuery.fn[ funcName ] = function( margin, value ) {\\n\\t\\t\\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \\\"boolean\\\" ),\\n\\t\\t\\t\\textra = defaultExtra || ( margin === true || value === true ? \\\"margin\\\" : \\\"border\\\" );\\n\\n\\t\\t\\treturn access( this, function( elem, type, value ) {\\n\\t\\t\\t\\tvar doc;\\n\\n\\t\\t\\t\\tif ( isWindow( elem ) ) {\\n\\n\\t\\t\\t\\t\\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\\n\\t\\t\\t\\t\\treturn funcName.indexOf( \\\"outer\\\" ) === 0 ?\\n\\t\\t\\t\\t\\t\\telem[ \\\"inner\\\" + name ] :\\n\\t\\t\\t\\t\\t\\telem.document.documentElement[ \\\"client\\\" + name ];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Get document width or height\\n\\t\\t\\t\\tif ( elem.nodeType === 9 ) {\\n\\t\\t\\t\\t\\tdoc = elem.documentElement;\\n\\n\\t\\t\\t\\t\\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\\n\\t\\t\\t\\t\\t// whichever is greatest\\n\\t\\t\\t\\t\\treturn Math.max(\\n\\t\\t\\t\\t\\t\\telem.body[ \\\"scroll\\\" + name ], doc[ \\\"scroll\\\" + name ],\\n\\t\\t\\t\\t\\t\\telem.body[ \\\"offset\\\" + name ], doc[ \\\"offset\\\" + name ],\\n\\t\\t\\t\\t\\t\\tdoc[ \\\"client\\\" + name ]\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn value === undefined ?\\n\\n\\t\\t\\t\\t\\t// Get width or height on the element, requesting but not forcing parseFloat\\n\\t\\t\\t\\t\\tjQuery.css( elem, type, extra ) :\\n\\n\\t\\t\\t\\t\\t// Set width or height on the element\\n\\t\\t\\t\\t\\tjQuery.style( elem, type, value, extra );\\n\\t\\t\\t}, type, chainable ? margin : undefined, chainable );\\n\\t\\t};\\n\\t} );\\n} );\\n\\n\\njQuery.each( ( \\\"blur focus focusin focusout resize scroll click dblclick \\\" +\\n\\t\\\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \\\" +\\n\\t\\\"change select submit keydown keypress keyup contextmenu\\\" ).split( \\\" \\\" ),\\n\\tfunction( i, name ) {\\n\\n\\t// Handle event binding\\n\\tjQuery.fn[ name ] = function( data, fn ) {\\n\\t\\treturn arguments.length > 0 ?\\n\\t\\t\\tthis.on( name, null, data, fn ) :\\n\\t\\t\\tthis.trigger( name );\\n\\t};\\n} );\\n\\njQuery.fn.extend( {\\n\\thover: function( fnOver, fnOut ) {\\n\\t\\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\\n\\t}\\n} );\\n\\n\\n\\n\\njQuery.fn.extend( {\\n\\n\\tbind: function( types, data, fn ) {\\n\\t\\treturn this.on( types, null, data, fn );\\n\\t},\\n\\tunbind: function( types, fn ) {\\n\\t\\treturn this.off( types, null, fn );\\n\\t},\\n\\n\\tdelegate: function( selector, types, data, fn ) {\\n\\t\\treturn this.on( types, selector, data, fn );\\n\\t},\\n\\tundelegate: function( selector, types, fn ) {\\n\\n\\t\\t// ( namespace ) or ( selector, types [, fn] )\\n\\t\\treturn arguments.length === 1 ?\\n\\t\\t\\tthis.off( selector, \\\"**\\\" ) :\\n\\t\\t\\tthis.off( types, selector || \\\"**\\\", fn );\\n\\t}\\n} );\\n\\n// Bind a function to a context, optionally partially applying any\\n// arguments.\\n// jQuery.proxy is deprecated to promote standards (specifically Function#bind)\\n// However, it is not slated for removal any time soon\\njQuery.proxy = function( fn, context ) {\\n\\tvar tmp, args, proxy;\\n\\n\\tif ( typeof context === \\\"string\\\" ) {\\n\\t\\ttmp = fn[ context ];\\n\\t\\tcontext = fn;\\n\\t\\tfn = tmp;\\n\\t}\\n\\n\\t// Quick check to determine if target is callable, in the spec\\n\\t// this throws a TypeError, but we will just return undefined.\\n\\tif ( !isFunction( fn ) ) {\\n\\t\\treturn undefined;\\n\\t}\\n\\n\\t// Simulated bind\\n\\targs = slice.call( arguments, 2 );\\n\\tproxy = function() {\\n\\t\\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\\n\\t};\\n\\n\\t// Set the guid of unique handler to the same of original handler, so it can be removed\\n\\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\\n\\n\\treturn proxy;\\n};\\n\\njQuery.holdReady = function( hold ) {\\n\\tif ( hold ) {\\n\\t\\tjQuery.readyWait++;\\n\\t} else {\\n\\t\\tjQuery.ready( true );\\n\\t}\\n};\\njQuery.isArray = Array.isArray;\\njQuery.parseJSON = JSON.parse;\\njQuery.nodeName = nodeName;\\njQuery.isFunction = isFunction;\\njQuery.isWindow = isWindow;\\njQuery.camelCase = camelCase;\\njQuery.type = toType;\\n\\njQuery.now = Date.now;\\n\\njQuery.isNumeric = function( obj ) {\\n\\n\\t// As of jQuery 3.0, isNumeric is limited to\\n\\t// strings and numbers (primitives or objects)\\n\\t// that can be coerced to finite numbers (gh-2662)\\n\\tvar type = jQuery.type( obj );\\n\\treturn ( type === \\\"number\\\" || type === \\\"string\\\" ) &&\\n\\n\\t\\t// parseFloat NaNs numeric-cast false positives (\\\"\\\")\\n\\t\\t// ...but misinterprets leading-number strings, particularly hex literals (\\\"0x...\\\")\\n\\t\\t// subtraction forces infinities to NaN\\n\\t\\t!isNaN( obj - parseFloat( obj ) );\\n};\\n\\n\\n\\n\\n// Register as a named AMD module, since jQuery can be concatenated with other\\n// files that may use define, but not via a proper concatenation script that\\n// understands anonymous AMD modules. A named AMD is safest and most robust\\n// way to register. Lowercase jquery is used because AMD module names are\\n// derived from file names, and jQuery is normally delivered in a lowercase\\n// file name. Do this after creating the global so that if an AMD module wants\\n// to call noConflict to hide this version of jQuery, it will work.\\n\\n// Note that for maximum portability, libraries that are not jQuery should\\n// declare themselves as anonymous modules, and avoid setting a global if an\\n// AMD loader is present. jQuery is a special case. For more information, see\\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\\n\\nif ( true ) {\\n\\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {\\n\\t\\treturn jQuery;\\n\\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\\n}\\n\\n\\n\\n\\nvar\\n\\n\\t// Map over jQuery in case of overwrite\\n\\t_jQuery = window.jQuery,\\n\\n\\t// Map over the $ in case of overwrite\\n\\t_$ = window.$;\\n\\njQuery.noConflict = function( deep ) {\\n\\tif ( window.$ === jQuery ) {\\n\\t\\twindow.$ = _$;\\n\\t}\\n\\n\\tif ( deep && window.jQuery === jQuery ) {\\n\\t\\twindow.jQuery = _jQuery;\\n\\t}\\n\\n\\treturn jQuery;\\n};\\n\\n// Expose jQuery and $ identifiers, even in AMD\\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\\n// and CommonJS for browser emulators (#13566)\\nif ( !noGlobal ) {\\n\\twindow.jQuery = window.$ = jQuery;\\n}\\n\\n\\n\\n\\nreturn jQuery;\\n} );\\n\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/jquery/dist/jquery.js\\n// module id = 1\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/jquery/dist/jquery.js?\");\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\n\\n/**\\n * Copyright (c) 2013-present, Facebook, Inc.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n *\\n * \\n */\\n\\nfunction makeEmptyFunction(arg) {\\n  return function () {\\n    return arg;\\n  };\\n}\\n\\n/**\\n * This function accepts and discards inputs; it has no side effects. This is\\n * primarily useful idiomatically for overridable function endpoints which\\n * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\\n */\\nvar emptyFunction = function emptyFunction() {};\\n\\nemptyFunction.thatReturns = makeEmptyFunction;\\nemptyFunction.thatReturnsFalse = makeEmptyFunction(false);\\nemptyFunction.thatReturnsTrue = makeEmptyFunction(true);\\nemptyFunction.thatReturnsNull = makeEmptyFunction(null);\\nemptyFunction.thatReturnsThis = function () {\\n  return this;\\n};\\nemptyFunction.thatReturnsArgument = function (arg) {\\n  return arg;\\n};\\n\\nmodule.exports = emptyFunction;\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/fbjs/lib/emptyFunction.js\\n// module id = 2\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/fbjs/lib/emptyFunction.js?\");\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"/* WEBPACK VAR INJECTION */(function(process) {/**\\n * Copyright (c) 2013-present, Facebook, Inc.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n *\\n */\\n\\n\\n\\n/**\\n * Use invariant() to assert state which your program assumes to be true.\\n *\\n * Provide sprintf-style format (only %s is supported) and arguments\\n * to provide information about what broke and what you were\\n * expecting.\\n *\\n * The invariant message will be stripped in production, but the invariant\\n * will remain to ensure logic does not differ in production.\\n */\\n\\nvar validateFormat = function validateFormat(format) {};\\n\\nif (process.env.NODE_ENV !== 'production') {\\n  validateFormat = function validateFormat(format) {\\n    if (format === undefined) {\\n      throw new Error('invariant requires an error message argument');\\n    }\\n  };\\n}\\n\\nfunction invariant(condition, format, a, b, c, d, e, f) {\\n  validateFormat(format);\\n\\n  if (!condition) {\\n    var error;\\n    if (format === undefined) {\\n      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\\n    } else {\\n      var args = [a, b, c, d, e, f];\\n      var argIndex = 0;\\n      error = new Error(format.replace(/%s/g, function () {\\n        return args[argIndex++];\\n      }));\\n      error.name = 'Invariant Violation';\\n    }\\n\\n    error.framesToPop = 1; // we don't care about invariant's own frame\\n    throw error;\\n  }\\n}\\n\\nmodule.exports = invariant;\\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/fbjs/lib/invariant.js\\n// module id = 3\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/fbjs/lib/invariant.js?\");\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"/**\\n * Copyright (c) 2013-present, Facebook, Inc.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n */\\n\\n\\n\\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\\n\\nmodule.exports = ReactPropTypesSecret;\\n\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/prop-types/lib/ReactPropTypesSecret.js\\n// module id = 4\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/prop-types/lib/ReactPropTypesSecret.js?\");\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\neval(\"/*\\n\\tMIT License http://www.opensource.org/licenses/mit-license.php\\n\\tAuthor Tobias Koppers @sokra\\n*/\\n// css base code, injected by the css-loader\\nmodule.exports = function(useSourceMap) {\\n\\tvar list = [];\\n\\n\\t// return the list of modules as css string\\n\\tlist.toString = function toString() {\\n\\t\\treturn this.map(function (item) {\\n\\t\\t\\tvar content = cssWithMappingToString(item, useSourceMap);\\n\\t\\t\\tif(item[2]) {\\n\\t\\t\\t\\treturn \\\"@media \\\" + item[2] + \\\"{\\\" + content + \\\"}\\\";\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn content;\\n\\t\\t\\t}\\n\\t\\t}).join(\\\"\\\");\\n\\t};\\n\\n\\t// import a list of modules into the list\\n\\tlist.i = function(modules, mediaQuery) {\\n\\t\\tif(typeof modules === \\\"string\\\")\\n\\t\\t\\tmodules = [[null, modules, \\\"\\\"]];\\n\\t\\tvar alreadyImportedModules = {};\\n\\t\\tfor(var i = 0; i < this.length; i++) {\\n\\t\\t\\tvar id = this[i][0];\\n\\t\\t\\tif(typeof id === \\\"number\\\")\\n\\t\\t\\t\\talreadyImportedModules[id] = true;\\n\\t\\t}\\n\\t\\tfor(i = 0; i < modules.length; i++) {\\n\\t\\t\\tvar item = modules[i];\\n\\t\\t\\t// skip already imported module\\n\\t\\t\\t// this implementation is not 100% perfect for weird media query combinations\\n\\t\\t\\t//  when a module is imported multiple times with different media queries.\\n\\t\\t\\t//  I hope this will never occur (Hey this way we have smaller bundles)\\n\\t\\t\\tif(typeof item[0] !== \\\"number\\\" || !alreadyImportedModules[item[0]]) {\\n\\t\\t\\t\\tif(mediaQuery && !item[2]) {\\n\\t\\t\\t\\t\\titem[2] = mediaQuery;\\n\\t\\t\\t\\t} else if(mediaQuery) {\\n\\t\\t\\t\\t\\titem[2] = \\\"(\\\" + item[2] + \\\") and (\\\" + mediaQuery + \\\")\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlist.push(item);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\treturn list;\\n};\\n\\nfunction cssWithMappingToString(item, useSourceMap) {\\n\\tvar content = item[1] || '';\\n\\tvar cssMapping = item[3];\\n\\tif (!cssMapping) {\\n\\t\\treturn content;\\n\\t}\\n\\n\\tif (useSourceMap && typeof btoa === 'function') {\\n\\t\\tvar sourceMapping = toComment(cssMapping);\\n\\t\\tvar sourceURLs = cssMapping.sources.map(function (source) {\\n\\t\\t\\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\\n\\t\\t});\\n\\n\\t\\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\\\n');\\n\\t}\\n\\n\\treturn [content].join('\\\\n');\\n}\\n\\n// Adapted from convert-source-map (MIT)\\nfunction toComment(sourceMap) {\\n\\t// eslint-disable-next-line no-undef\\n\\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\\n\\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\\n\\n\\treturn '/*# ' + data + ' */';\\n}\\n\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/css-loader/lib/css-base.js\\n// module id = 5\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/css-loader/lib/css-base.js?\");\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"/* WEBPACK VAR INJECTION */(function(process) {/**\\n * Copyright (c) 2014-present, Facebook, Inc.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n *\\n */\\n\\n\\n\\nvar emptyFunction = __webpack_require__(2);\\n\\n/**\\n * Similar to invariant but only logs a warning if the condition is not met.\\n * This can be used to log issues in development environments in critical\\n * paths. Removing the logging code for production environments will keep the\\n * same logic and follow the same code paths.\\n */\\n\\nvar warning = emptyFunction;\\n\\nif (process.env.NODE_ENV !== 'production') {\\n  var printWarning = function printWarning(format) {\\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\\n      args[_key - 1] = arguments[_key];\\n    }\\n\\n    var argIndex = 0;\\n    var message = 'Warning: ' + format.replace(/%s/g, function () {\\n      return args[argIndex++];\\n    });\\n    if (typeof console !== 'undefined') {\\n      console.error(message);\\n    }\\n    try {\\n      // --- Welcome to debugging React ---\\n      // This error was thrown as a convenience so that you can use this stack\\n      // to find the callsite that caused this warning to fire.\\n      throw new Error(message);\\n    } catch (x) {}\\n  };\\n\\n  warning = function warning(condition, format) {\\n    if (format === undefined) {\\n      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\\n    }\\n\\n    if (format.indexOf('Failed Composite propType: ') === 0) {\\n      return; // Ignore CompositeComponent proptype check.\\n    }\\n\\n    if (!condition) {\\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\\n        args[_key2 - 2] = arguments[_key2];\\n      }\\n\\n      printWarning.apply(undefined, [format].concat(args));\\n    }\\n  };\\n}\\n\\nmodule.exports = warning;\\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/fbjs/lib/warning.js\\n// module id = 6\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/fbjs/lib/warning.js?\");\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"/*\\n\\tMIT License http://www.opensource.org/licenses/mit-license.php\\n\\tAuthor Tobias Koppers @sokra\\n*/\\nvar stylesInDom = {},\\n\\tmemoize = function(fn) {\\n\\t\\tvar memo;\\n\\t\\treturn function () {\\n\\t\\t\\tif (typeof memo === \\\"undefined\\\") memo = fn.apply(this, arguments);\\n\\t\\t\\treturn memo;\\n\\t\\t};\\n\\t},\\n\\tisOldIE = memoize(function() {\\n\\t\\t// Test for IE <= 9 as proposed by Browserhacks\\n\\t\\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\\n\\t\\t// Tests for existence of standard globals is to allow style-loader \\n\\t\\t// to operate correctly into non-standard environments\\n\\t\\t// @see https://github.com/webpack-contrib/style-loader/issues/177\\n\\t\\treturn window && document && document.all && !window.atob;\\n\\t}),\\n\\tgetElement = (function(fn) {\\n\\t\\tvar memo = {};\\n\\t\\treturn function(selector) {\\n\\t\\t\\tif (typeof memo[selector] === \\\"undefined\\\") {\\n\\t\\t\\t\\tmemo[selector] = fn.call(this, selector);\\n\\t\\t\\t}\\n\\t\\t\\treturn memo[selector]\\n\\t\\t};\\n\\t})(function (styleTarget) {\\n\\t\\treturn document.querySelector(styleTarget)\\n\\t}),\\n\\tsingletonElement = null,\\n\\tsingletonCounter = 0,\\n\\tstyleElementsInsertedAtTop = [],\\n\\tfixUrls = __webpack_require__(22);\\n\\nmodule.exports = function(list, options) {\\n\\tif(typeof DEBUG !== \\\"undefined\\\" && DEBUG) {\\n\\t\\tif(typeof document !== \\\"object\\\") throw new Error(\\\"The style-loader cannot be used in a non-browser environment\\\");\\n\\t}\\n\\n\\toptions = options || {};\\n\\toptions.attrs = typeof options.attrs === \\\"object\\\" ? options.attrs : {};\\n\\n\\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\\n\\t// tags it will allow on a page\\n\\tif (typeof options.singleton === \\\"undefined\\\") options.singleton = isOldIE();\\n\\n\\t// By default, add <style> tags to the <head> element\\n\\tif (typeof options.insertInto === \\\"undefined\\\") options.insertInto = \\\"head\\\";\\n\\n\\t// By default, add <style> tags to the bottom of the target\\n\\tif (typeof options.insertAt === \\\"undefined\\\") options.insertAt = \\\"bottom\\\";\\n\\n\\tvar styles = listToStyles(list, options);\\n\\taddStylesToDom(styles, options);\\n\\n\\treturn function update(newList) {\\n\\t\\tvar mayRemove = [];\\n\\t\\tfor(var i = 0; i < styles.length; i++) {\\n\\t\\t\\tvar item = styles[i];\\n\\t\\t\\tvar domStyle = stylesInDom[item.id];\\n\\t\\t\\tdomStyle.refs--;\\n\\t\\t\\tmayRemove.push(domStyle);\\n\\t\\t}\\n\\t\\tif(newList) {\\n\\t\\t\\tvar newStyles = listToStyles(newList, options);\\n\\t\\t\\taddStylesToDom(newStyles, options);\\n\\t\\t}\\n\\t\\tfor(var i = 0; i < mayRemove.length; i++) {\\n\\t\\t\\tvar domStyle = mayRemove[i];\\n\\t\\t\\tif(domStyle.refs === 0) {\\n\\t\\t\\t\\tfor(var j = 0; j < domStyle.parts.length; j++)\\n\\t\\t\\t\\t\\tdomStyle.parts[j]();\\n\\t\\t\\t\\tdelete stylesInDom[domStyle.id];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n};\\n\\nfunction addStylesToDom(styles, options) {\\n\\tfor(var i = 0; i < styles.length; i++) {\\n\\t\\tvar item = styles[i];\\n\\t\\tvar domStyle = stylesInDom[item.id];\\n\\t\\tif(domStyle) {\\n\\t\\t\\tdomStyle.refs++;\\n\\t\\t\\tfor(var j = 0; j < domStyle.parts.length; j++) {\\n\\t\\t\\t\\tdomStyle.parts[j](item.parts[j]);\\n\\t\\t\\t}\\n\\t\\t\\tfor(; j < item.parts.length; j++) {\\n\\t\\t\\t\\tdomStyle.parts.push(addStyle(item.parts[j], options));\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tvar parts = [];\\n\\t\\t\\tfor(var j = 0; j < item.parts.length; j++) {\\n\\t\\t\\t\\tparts.push(addStyle(item.parts[j], options));\\n\\t\\t\\t}\\n\\t\\t\\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction listToStyles(list, options) {\\n\\tvar styles = [];\\n\\tvar newStyles = {};\\n\\tfor(var i = 0; i < list.length; i++) {\\n\\t\\tvar item = list[i];\\n\\t\\tvar id = options.base ? item[0] + options.base : item[0];\\n\\t\\tvar css = item[1];\\n\\t\\tvar media = item[2];\\n\\t\\tvar sourceMap = item[3];\\n\\t\\tvar part = {css: css, media: media, sourceMap: sourceMap};\\n\\t\\tif(!newStyles[id])\\n\\t\\t\\tstyles.push(newStyles[id] = {id: id, parts: [part]});\\n\\t\\telse\\n\\t\\t\\tnewStyles[id].parts.push(part);\\n\\t}\\n\\treturn styles;\\n}\\n\\nfunction insertStyleElement(options, styleElement) {\\n\\tvar styleTarget = getElement(options.insertInto)\\n\\tif (!styleTarget) {\\n\\t\\tthrow new Error(\\\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\\\");\\n\\t}\\n\\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\\n\\tif (options.insertAt === \\\"top\\\") {\\n\\t\\tif(!lastStyleElementInsertedAtTop) {\\n\\t\\t\\tstyleTarget.insertBefore(styleElement, styleTarget.firstChild);\\n\\t\\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\\n\\t\\t\\tstyleTarget.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\\n\\t\\t} else {\\n\\t\\t\\tstyleTarget.appendChild(styleElement);\\n\\t\\t}\\n\\t\\tstyleElementsInsertedAtTop.push(styleElement);\\n\\t} else if (options.insertAt === \\\"bottom\\\") {\\n\\t\\tstyleTarget.appendChild(styleElement);\\n\\t} else {\\n\\t\\tthrow new Error(\\\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\\\");\\n\\t}\\n}\\n\\nfunction removeStyleElement(styleElement) {\\n\\tstyleElement.parentNode.removeChild(styleElement);\\n\\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\\n\\tif(idx >= 0) {\\n\\t\\tstyleElementsInsertedAtTop.splice(idx, 1);\\n\\t}\\n}\\n\\nfunction createStyleElement(options) {\\n\\tvar styleElement = document.createElement(\\\"style\\\");\\n\\toptions.attrs.type = \\\"text/css\\\";\\n\\n\\tattachTagAttrs(styleElement, options.attrs);\\n\\tinsertStyleElement(options, styleElement);\\n\\treturn styleElement;\\n}\\n\\nfunction createLinkElement(options) {\\n\\tvar linkElement = document.createElement(\\\"link\\\");\\n\\toptions.attrs.type = \\\"text/css\\\";\\n\\toptions.attrs.rel = \\\"stylesheet\\\";\\n\\n\\tattachTagAttrs(linkElement, options.attrs);\\n\\tinsertStyleElement(options, linkElement);\\n\\treturn linkElement;\\n}\\n\\nfunction attachTagAttrs(element, attrs) {\\n\\tObject.keys(attrs).forEach(function (key) {\\n\\t\\telement.setAttribute(key, attrs[key]);\\n\\t});\\n}\\n\\nfunction addStyle(obj, options) {\\n\\tvar styleElement, update, remove, transformResult;\\n\\n\\t// If a transform function was defined, run it on the css\\n\\tif (options.transform && obj.css) {\\n\\t    transformResult = options.transform(obj.css);\\n\\t    \\n\\t    if (transformResult) {\\n\\t    \\t// If transform returns a value, use that instead of the original css.\\n\\t    \\t// This allows running runtime transformations on the css.\\n\\t    \\tobj.css = transformResult;\\n\\t    } else {\\n\\t    \\t// If the transform function returns a falsy value, don't add this css. \\n\\t    \\t// This allows conditional loading of css\\n\\t    \\treturn function() {\\n\\t    \\t\\t// noop\\n\\t    \\t};\\n\\t    }\\n\\t}\\n\\n\\tif (options.singleton) {\\n\\t\\tvar styleIndex = singletonCounter++;\\n\\t\\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\\n\\t\\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\\n\\t\\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\\n\\t} else if(obj.sourceMap &&\\n\\t\\ttypeof URL === \\\"function\\\" &&\\n\\t\\ttypeof URL.createObjectURL === \\\"function\\\" &&\\n\\t\\ttypeof URL.revokeObjectURL === \\\"function\\\" &&\\n\\t\\ttypeof Blob === \\\"function\\\" &&\\n\\t\\ttypeof btoa === \\\"function\\\") {\\n\\t\\tstyleElement = createLinkElement(options);\\n\\t\\tupdate = updateLink.bind(null, styleElement, options);\\n\\t\\tremove = function() {\\n\\t\\t\\tremoveStyleElement(styleElement);\\n\\t\\t\\tif(styleElement.href)\\n\\t\\t\\t\\tURL.revokeObjectURL(styleElement.href);\\n\\t\\t};\\n\\t} else {\\n\\t\\tstyleElement = createStyleElement(options);\\n\\t\\tupdate = applyToTag.bind(null, styleElement);\\n\\t\\tremove = function() {\\n\\t\\t\\tremoveStyleElement(styleElement);\\n\\t\\t};\\n\\t}\\n\\n\\tupdate(obj);\\n\\n\\treturn function updateStyle(newObj) {\\n\\t\\tif(newObj) {\\n\\t\\t\\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tupdate(obj = newObj);\\n\\t\\t} else {\\n\\t\\t\\tremove();\\n\\t\\t}\\n\\t};\\n}\\n\\nvar replaceText = (function () {\\n\\tvar textStore = [];\\n\\n\\treturn function (index, replacement) {\\n\\t\\ttextStore[index] = replacement;\\n\\t\\treturn textStore.filter(Boolean).join('\\\\n');\\n\\t};\\n})();\\n\\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\\n\\tvar css = remove ? \\\"\\\" : obj.css;\\n\\n\\tif (styleElement.styleSheet) {\\n\\t\\tstyleElement.styleSheet.cssText = replaceText(index, css);\\n\\t} else {\\n\\t\\tvar cssNode = document.createTextNode(css);\\n\\t\\tvar childNodes = styleElement.childNodes;\\n\\t\\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\\n\\t\\tif (childNodes.length) {\\n\\t\\t\\tstyleElement.insertBefore(cssNode, childNodes[index]);\\n\\t\\t} else {\\n\\t\\t\\tstyleElement.appendChild(cssNode);\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction applyToTag(styleElement, obj) {\\n\\tvar css = obj.css;\\n\\tvar media = obj.media;\\n\\n\\tif(media) {\\n\\t\\tstyleElement.setAttribute(\\\"media\\\", media)\\n\\t}\\n\\n\\tif(styleElement.styleSheet) {\\n\\t\\tstyleElement.styleSheet.cssText = css;\\n\\t} else {\\n\\t\\twhile(styleElement.firstChild) {\\n\\t\\t\\tstyleElement.removeChild(styleElement.firstChild);\\n\\t\\t}\\n\\t\\tstyleElement.appendChild(document.createTextNode(css));\\n\\t}\\n}\\n\\nfunction updateLink(linkElement, options, obj) {\\n\\tvar css = obj.css;\\n\\tvar sourceMap = obj.sourceMap;\\n\\n\\t/* If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\\n\\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\\n\\ton by default.  Otherwise default to the convertToAbsoluteUrls option\\n\\tdirectly\\n\\t*/\\n\\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\\n\\n\\tif (options.convertToAbsoluteUrls || autoFixUrls){\\n\\t\\tcss = fixUrls(css);\\n\\t}\\n\\n\\tif(sourceMap) {\\n\\t\\t// http://stackoverflow.com/a/26603875\\n\\t\\tcss += \\\"\\\\n/*# sourceMappingURL=data:application/json;base64,\\\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \\\" */\\\";\\n\\t}\\n\\n\\tvar blob = new Blob([css], { type: \\\"text/css\\\" });\\n\\n\\tvar oldSrc = linkElement.href;\\n\\n\\tlinkElement.href = URL.createObjectURL(blob);\\n\\n\\tif(oldSrc)\\n\\t\\tURL.revokeObjectURL(oldSrc);\\n}\\n\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/style-loader/addStyles.js\\n// module id = 7\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/style-loader/addStyles.js?\");\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"/* WEBPACK VAR INJECTION */(function(__webpack_provided_window_dot_jQuery, jQuery) {/**\\n * Owl Carousel v2.2.0\\n * Copyright 2013-2016 David Deutsch\\n * Licensed under MIT (https://github.com/OwlCarousel2/OwlCarousel2/blob/master/LICENSE)\\n */\\n/**\\n * Owl carousel\\n * @version 2.1.6\\n * @author Bartosz Wojciechowski\\n * @author David Deutsch\\n * @license The MIT License (MIT)\\n * @todo Lazy Load Icon\\n * @todo prevent animationend bubling\\n * @todo itemsScaleUp\\n * @todo Test Zepto\\n * @todo stagePadding calculate wrong active classes\\n */\\n;(function($, window, document, undefined) {\\n\\n\\t/**\\n\\t * Creates a carousel.\\n\\t * @class The Owl Carousel.\\n\\t * @public\\n\\t * @param {HTMLElement|jQuery} element - The element to create the carousel for.\\n\\t * @param {Object} [options] - The options\\n\\t */\\n\\tfunction Owl(element, options) {\\n\\n\\t\\t/**\\n\\t\\t * Current settings for the carousel.\\n\\t\\t * @public\\n\\t\\t */\\n\\t\\tthis.settings = null;\\n\\n\\t\\t/**\\n\\t\\t * Current options set by the caller including defaults.\\n\\t\\t * @public\\n\\t\\t */\\n\\t\\tthis.options = $.extend({}, Owl.Defaults, options);\\n\\n\\t\\t/**\\n\\t\\t * Plugin element.\\n\\t\\t * @public\\n\\t\\t */\\n\\t\\tthis.$element = $(element);\\n\\n\\t\\t/**\\n\\t\\t * Proxied event handlers.\\n\\t\\t * @protected\\n\\t\\t */\\n\\t\\tthis._handlers = {};\\n\\n\\t\\t/**\\n\\t\\t * References to the running plugins of this carousel.\\n\\t\\t * @protected\\n\\t\\t */\\n\\t\\tthis._plugins = {};\\n\\n\\t\\t/**\\n\\t\\t * Currently suppressed events to prevent them from beeing retriggered.\\n\\t\\t * @protected\\n\\t\\t */\\n\\t\\tthis._supress = {};\\n\\n\\t\\t/**\\n\\t\\t * Absolute current position.\\n\\t\\t * @protected\\n\\t\\t */\\n\\t\\tthis._current = null;\\n\\n\\t\\t/**\\n\\t\\t * Animation speed in milliseconds.\\n\\t\\t * @protected\\n\\t\\t */\\n\\t\\tthis._speed = null;\\n\\n\\t\\t/**\\n\\t\\t * Coordinates of all items in pixel.\\n\\t\\t * @todo The name of this member is missleading.\\n\\t\\t * @protected\\n\\t\\t */\\n\\t\\tthis._coordinates = [];\\n\\n\\t\\t/**\\n\\t\\t * Current breakpoint.\\n\\t\\t * @todo Real media queries would be nice.\\n\\t\\t * @protected\\n\\t\\t */\\n\\t\\tthis._breakpoint = null;\\n\\n\\t\\t/**\\n\\t\\t * Current width of the plugin element.\\n\\t\\t */\\n\\t\\tthis._width = null;\\n\\n\\t\\t/**\\n\\t\\t * All real items.\\n\\t\\t * @protected\\n\\t\\t */\\n\\t\\tthis._items = [];\\n\\n\\t\\t/**\\n\\t\\t * All cloned items.\\n\\t\\t * @protected\\n\\t\\t */\\n\\t\\tthis._clones = [];\\n\\n\\t\\t/**\\n\\t\\t * Merge values of all items.\\n\\t\\t * @todo Maybe this could be part of a plugin.\\n\\t\\t * @protected\\n\\t\\t */\\n\\t\\tthis._mergers = [];\\n\\n\\t\\t/**\\n\\t\\t * Widths of all items.\\n\\t\\t */\\n\\t\\tthis._widths = [];\\n\\n\\t\\t/**\\n\\t\\t * Invalidated parts within the update process.\\n\\t\\t * @protected\\n\\t\\t */\\n\\t\\tthis._invalidated = {};\\n\\n\\t\\t/**\\n\\t\\t * Ordered list of workers for the update process.\\n\\t\\t * @protected\\n\\t\\t */\\n\\t\\tthis._pipe = [];\\n\\n\\t\\t/**\\n\\t\\t * Current state information for the drag operation.\\n\\t\\t * @todo #261\\n\\t\\t * @protected\\n\\t\\t */\\n\\t\\tthis._drag = {\\n\\t\\t\\ttime: null,\\n\\t\\t\\ttarget: null,\\n\\t\\t\\tpointer: null,\\n\\t\\t\\tstage: {\\n\\t\\t\\t\\tstart: null,\\n\\t\\t\\t\\tcurrent: null\\n\\t\\t\\t},\\n\\t\\t\\tdirection: null\\n\\t\\t};\\n\\n\\t\\t/**\\n\\t\\t * Current state information and their tags.\\n\\t\\t * @type {Object}\\n\\t\\t * @protected\\n\\t\\t */\\n\\t\\tthis._states = {\\n\\t\\t\\tcurrent: {},\\n\\t\\t\\ttags: {\\n\\t\\t\\t\\t'initializing': [ 'busy' ],\\n\\t\\t\\t\\t'animating': [ 'busy' ],\\n\\t\\t\\t\\t'dragging': [ 'interacting' ]\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\t\\t$.each([ 'onResize', 'onThrottledResize' ], $.proxy(function(i, handler) {\\n\\t\\t\\tthis._handlers[handler] = $.proxy(this[handler], this);\\n\\t\\t}, this));\\n\\n\\t\\t$.each(Owl.Plugins, $.proxy(function(key, plugin) {\\n\\t\\t\\tthis._plugins[key.charAt(0).toLowerCase() + key.slice(1)]\\n\\t\\t\\t\\t= new plugin(this);\\n\\t\\t}, this));\\n\\n\\t\\t$.each(Owl.Workers, $.proxy(function(priority, worker) {\\n\\t\\t\\tthis._pipe.push({\\n\\t\\t\\t\\t'filter': worker.filter,\\n\\t\\t\\t\\t'run': $.proxy(worker.run, this)\\n\\t\\t\\t});\\n\\t\\t}, this));\\n\\n\\t\\tthis.setup();\\n\\t\\tthis.initialize();\\n\\t}\\n\\n\\t/**\\n\\t * Default options for the carousel.\\n\\t * @public\\n\\t */\\n\\tOwl.Defaults = {\\n\\t\\titems: 3,\\n\\t\\tloop: false,\\n\\t\\tcenter: false,\\n\\t\\trewind: false,\\n\\n\\t\\tmouseDrag: true,\\n\\t\\ttouchDrag: true,\\n\\t\\tpullDrag: true,\\n\\t\\tfreeDrag: false,\\n\\n\\t\\tmargin: 0,\\n\\t\\tstagePadding: 0,\\n\\n\\t\\tmerge: false,\\n\\t\\tmergeFit: true,\\n\\t\\tautoWidth: false,\\n\\n\\t\\tstartPosition: 0,\\n\\t\\trtl: false,\\n\\n\\t\\tsmartSpeed: 250,\\n\\t\\tfluidSpeed: false,\\n\\t\\tdragEndSpeed: false,\\n\\n\\t\\tresponsive: {},\\n\\t\\tresponsiveRefreshRate: 200,\\n\\t\\tresponsiveBaseElement: window,\\n\\n\\t\\tfallbackEasing: 'swing',\\n\\n\\t\\tinfo: false,\\n\\n\\t\\tnestedItemSelector: false,\\n\\t\\titemElement: 'div',\\n\\t\\tstageElement: 'div',\\n\\n\\t\\trefreshClass: 'owl-refresh',\\n\\t\\tloadedClass: 'owl-loaded',\\n\\t\\tloadingClass: 'owl-loading',\\n\\t\\trtlClass: 'owl-rtl',\\n\\t\\tresponsiveClass: 'owl-responsive',\\n\\t\\tdragClass: 'owl-drag',\\n\\t\\titemClass: 'owl-item',\\n\\t\\tstageClass: 'owl-stage',\\n\\t\\tstageOuterClass: 'owl-stage-outer',\\n\\t\\tgrabClass: 'owl-grab'\\n\\t};\\n\\n\\t/**\\n\\t * Enumeration for width.\\n\\t * @public\\n\\t * @readonly\\n\\t * @enum {String}\\n\\t */\\n\\tOwl.Width = {\\n\\t\\tDefault: 'default',\\n\\t\\tInner: 'inner',\\n\\t\\tOuter: 'outer'\\n\\t};\\n\\n\\t/**\\n\\t * Enumeration for types.\\n\\t * @public\\n\\t * @readonly\\n\\t * @enum {String}\\n\\t */\\n\\tOwl.Type = {\\n\\t\\tEvent: 'event',\\n\\t\\tState: 'state'\\n\\t};\\n\\n\\t/**\\n\\t * Contains all registered plugins.\\n\\t * @public\\n\\t */\\n\\tOwl.Plugins = {};\\n\\n\\t/**\\n\\t * List of workers involved in the update process.\\n\\t */\\n\\tOwl.Workers = [ {\\n\\t\\tfilter: [ 'width', 'settings' ],\\n\\t\\trun: function() {\\n\\t\\t\\tthis._width = this.$element.width();\\n\\t\\t}\\n\\t}, {\\n\\t\\tfilter: [ 'width', 'items', 'settings' ],\\n\\t\\trun: function(cache) {\\n\\t\\t\\tcache.current = this._items && this._items[this.relative(this._current)];\\n\\t\\t}\\n\\t}, {\\n\\t\\tfilter: [ 'items', 'settings' ],\\n\\t\\trun: function() {\\n\\t\\t\\tthis.$stage.children('.cloned').remove();\\n\\t\\t}\\n\\t}, {\\n\\t\\tfilter: [ 'width', 'items', 'settings' ],\\n\\t\\trun: function(cache) {\\n\\t\\t\\tvar margin = this.settings.margin || '',\\n\\t\\t\\t\\tgrid = !this.settings.autoWidth,\\n\\t\\t\\t\\trtl = this.settings.rtl,\\n\\t\\t\\t\\tcss = {\\n\\t\\t\\t\\t\\t'width': 'auto',\\n\\t\\t\\t\\t\\t'margin-left': rtl ? margin : '',\\n\\t\\t\\t\\t\\t'margin-right': rtl ? '' : margin\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t!grid && this.$stage.children().css(css);\\n\\n\\t\\t\\tcache.css = css;\\n\\t\\t}\\n\\t}, {\\n\\t\\tfilter: [ 'width', 'items', 'settings' ],\\n\\t\\trun: function(cache) {\\n\\t\\t\\tvar width = (this.width() / this.settings.items).toFixed(3) - this.settings.margin,\\n\\t\\t\\t\\tmerge = null,\\n\\t\\t\\t\\titerator = this._items.length,\\n\\t\\t\\t\\tgrid = !this.settings.autoWidth,\\n\\t\\t\\t\\twidths = [];\\n\\n\\t\\t\\tcache.items = {\\n\\t\\t\\t\\tmerge: false,\\n\\t\\t\\t\\twidth: width\\n\\t\\t\\t};\\n\\n\\t\\t\\twhile (iterator--) {\\n\\t\\t\\t\\tmerge = this._mergers[iterator];\\n\\t\\t\\t\\tmerge = this.settings.mergeFit && Math.min(merge, this.settings.items) || merge;\\n\\n\\t\\t\\t\\tcache.items.merge = merge > 1 || cache.items.merge;\\n\\n\\t\\t\\t\\twidths[iterator] = !grid ? this._items[iterator].width() : width * merge;\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis._widths = widths;\\n\\t\\t}\\n\\t}, {\\n\\t\\tfilter: [ 'items', 'settings' ],\\n\\t\\trun: function() {\\n\\t\\t\\tvar clones = [],\\n\\t\\t\\t\\titems = this._items,\\n\\t\\t\\t\\tsettings = this.settings,\\n\\t\\t\\t\\tview = Math.max(settings.items * 2, 4),\\n\\t\\t\\t\\tsize = Math.ceil(items.length / 2) * 2,\\n\\t\\t\\t\\trepeat = settings.loop && items.length ? settings.rewind ? view : Math.max(view, size) : 0,\\n\\t\\t\\t\\tappend = '',\\n\\t\\t\\t\\tprepend = '';\\n\\n\\t\\t\\trepeat /= 2;\\n\\n\\t\\t\\twhile (repeat--) {\\n\\t\\t\\t\\tclones.push(this.normalize(clones.length / 2, true));\\n\\t\\t\\t\\tappend = append + items[clones[clones.length - 1]][0].outerHTML;\\n\\t\\t\\t\\tclones.push(this.normalize(items.length - 1 - (clones.length - 1) / 2, true));\\n\\t\\t\\t\\tprepend = items[clones[clones.length - 1]][0].outerHTML + prepend;\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis._clones = clones;\\n\\n\\t\\t\\t$(append).addClass('cloned').appendTo(this.$stage);\\n\\t\\t\\t$(prepend).addClass('cloned').prependTo(this.$stage);\\n\\t\\t}\\n\\t}, {\\n\\t\\tfilter: [ 'width', 'items', 'settings' ],\\n\\t\\trun: function() {\\n\\t\\t\\tvar rtl = this.settings.rtl ? 1 : -1,\\n\\t\\t\\t\\tsize = this._clones.length + this._items.length,\\n\\t\\t\\t\\titerator = -1,\\n\\t\\t\\t\\tprevious = 0,\\n\\t\\t\\t\\tcurrent = 0,\\n\\t\\t\\t\\tcoordinates = [];\\n\\n\\t\\t\\twhile (++iterator < size) {\\n\\t\\t\\t\\tprevious = coordinates[iterator - 1] || 0;\\n\\t\\t\\t\\tcurrent = this._widths[this.relative(iterator)] + this.settings.margin;\\n\\t\\t\\t\\tcoordinates.push(previous + current * rtl);\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis._coordinates = coordinates;\\n\\t\\t}\\n\\t}, {\\n\\t\\tfilter: [ 'width', 'items', 'settings' ],\\n\\t\\trun: function() {\\n\\t\\t\\tvar padding = this.settings.stagePadding,\\n\\t\\t\\t\\tcoordinates = this._coordinates,\\n\\t\\t\\t\\tcss = {\\n\\t\\t\\t\\t\\t'width': Math.ceil(Math.abs(coordinates[coordinates.length - 1])) + padding * 2,\\n\\t\\t\\t\\t\\t'padding-left': padding || '',\\n\\t\\t\\t\\t\\t'padding-right': padding || ''\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\tthis.$stage.css(css);\\n\\t\\t}\\n\\t}, {\\n\\t\\tfilter: [ 'width', 'items', 'settings' ],\\n\\t\\trun: function(cache) {\\n\\t\\t\\tvar iterator = this._coordinates.length,\\n\\t\\t\\t\\tgrid = !this.settings.autoWidth,\\n\\t\\t\\t\\titems = this.$stage.children();\\n\\n\\t\\t\\tif (grid && cache.items.merge) {\\n\\t\\t\\t\\twhile (iterator--) {\\n\\t\\t\\t\\t\\tcache.css.width = this._widths[this.relative(iterator)];\\n\\t\\t\\t\\t\\titems.eq(iterator).css(cache.css);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if (grid) {\\n\\t\\t\\t\\tcache.css.width = cache.items.width;\\n\\t\\t\\t\\titems.css(cache.css);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}, {\\n\\t\\tfilter: [ 'items' ],\\n\\t\\trun: function() {\\n\\t\\t\\tthis._coordinates.length < 1 && this.$stage.removeAttr('style');\\n\\t\\t}\\n\\t}, {\\n\\t\\tfilter: [ 'width', 'items', 'settings' ],\\n\\t\\trun: function(cache) {\\n\\t\\t\\tcache.current = cache.current ? this.$stage.children().index(cache.current) : 0;\\n\\t\\t\\tcache.current = Math.max(this.minimum(), Math.min(this.maximum(), cache.current));\\n\\t\\t\\tthis.reset(cache.current);\\n\\t\\t}\\n\\t}, {\\n\\t\\tfilter: [ 'position' ],\\n\\t\\trun: function() {\\n\\t\\t\\tthis.animate(this.coordinates(this._current));\\n\\t\\t}\\n\\t}, {\\n\\t\\tfilter: [ 'width', 'position', 'items', 'settings' ],\\n\\t\\trun: function() {\\n\\t\\t\\tvar rtl = this.settings.rtl ? 1 : -1,\\n\\t\\t\\t\\tpadding = this.settings.stagePadding * 2,\\n\\t\\t\\t\\tbegin = this.coordinates(this.current()) + padding,\\n\\t\\t\\t\\tend = begin + this.width() * rtl,\\n\\t\\t\\t\\tinner, outer, matches = [], i, n;\\n\\n\\t\\t\\tfor (i = 0, n = this._coordinates.length; i < n; i++) {\\n\\t\\t\\t\\tinner = this._coordinates[i - 1] || 0;\\n\\t\\t\\t\\touter = Math.abs(this._coordinates[i]) + padding * rtl;\\n\\n\\t\\t\\t\\tif ((this.op(inner, '<=', begin) && (this.op(inner, '>', end)))\\n\\t\\t\\t\\t\\t|| (this.op(outer, '<', begin) && this.op(outer, '>', end))) {\\n\\t\\t\\t\\t\\tmatches.push(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.$stage.children('.active').removeClass('active');\\n\\t\\t\\tthis.$stage.children(':eq(' + matches.join('), :eq(') + ')').addClass('active');\\n\\n\\t\\t\\tif (this.settings.center) {\\n\\t\\t\\t\\tthis.$stage.children('.center').removeClass('center');\\n\\t\\t\\t\\tthis.$stage.children().eq(this.current()).addClass('center');\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} ];\\n\\n\\t/**\\n\\t * Initializes the carousel.\\n\\t * @protected\\n\\t */\\n\\tOwl.prototype.initialize = function() {\\n\\t\\tthis.enter('initializing');\\n\\t\\tthis.trigger('initialize');\\n\\n\\t\\tthis.$element.toggleClass(this.settings.rtlClass, this.settings.rtl);\\n\\n\\t\\tif (this.settings.autoWidth && !this.is('pre-loading')) {\\n\\t\\t\\tvar imgs, nestedSelector, width;\\n\\t\\t\\timgs = this.$element.find('img');\\n\\t\\t\\tnestedSelector = this.settings.nestedItemSelector ? '.' + this.settings.nestedItemSelector : undefined;\\n\\t\\t\\twidth = this.$element.children(nestedSelector).width();\\n\\n\\t\\t\\tif (imgs.length && width <= 0) {\\n\\t\\t\\t\\tthis.preloadAutoWidthImages(imgs);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tthis.$element.addClass(this.options.loadingClass);\\n\\n\\t\\t// create stage\\n\\t\\tthis.$stage = $('<' + this.settings.stageElement + ' class=\\\"' + this.settings.stageClass + '\\\"/>')\\n\\t\\t\\t.wrap('<div class=\\\"' + this.settings.stageOuterClass + '\\\"/>');\\n\\n\\t\\t// append stage\\n\\t\\tthis.$element.append(this.$stage.parent());\\n\\n\\t\\t// append content\\n\\t\\tthis.replace(this.$element.children().not(this.$stage.parent()));\\n\\n\\t\\t// check visibility\\n\\t\\tif (this.$element.is(':visible')) {\\n\\t\\t\\t// update view\\n\\t\\t\\tthis.refresh();\\n\\t\\t} else {\\n\\t\\t\\t// invalidate width\\n\\t\\t\\tthis.invalidate('width');\\n\\t\\t}\\n\\n\\t\\tthis.$element\\n\\t\\t\\t.removeClass(this.options.loadingClass)\\n\\t\\t\\t.addClass(this.options.loadedClass);\\n\\n\\t\\t// register event handlers\\n\\t\\tthis.registerEventHandlers();\\n\\n\\t\\tthis.leave('initializing');\\n\\t\\tthis.trigger('initialized');\\n\\t};\\n\\n\\t/**\\n\\t * Setups the current settings.\\n\\t * @todo Remove responsive classes. Why should adaptive designs be brought into IE8?\\n\\t * @todo Support for media queries by using `matchMedia` would be nice.\\n\\t * @public\\n\\t */\\n\\tOwl.prototype.setup = function() {\\n\\t\\tvar viewport = this.viewport(),\\n\\t\\t\\toverwrites = this.options.responsive,\\n\\t\\t\\tmatch = -1,\\n\\t\\t\\tsettings = null;\\n\\n\\t\\tif (!overwrites) {\\n\\t\\t\\tsettings = $.extend({}, this.options);\\n\\t\\t} else {\\n\\t\\t\\t$.each(overwrites, function(breakpoint) {\\n\\t\\t\\t\\tif (breakpoint <= viewport && breakpoint > match) {\\n\\t\\t\\t\\t\\tmatch = Number(breakpoint);\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\tsettings = $.extend({}, this.options, overwrites[match]);\\n\\t\\t\\tif (typeof settings.stagePadding === 'function') {\\n\\t\\t\\t\\tsettings.stagePadding = settings.stagePadding();\\n\\t\\t\\t}\\n\\t\\t\\tdelete settings.responsive;\\n\\n\\t\\t\\t// responsive class\\n\\t\\t\\tif (settings.responsiveClass) {\\n\\t\\t\\t\\tthis.$element.attr('class',\\n\\t\\t\\t\\t\\tthis.$element.attr('class').replace(new RegExp('(' + this.options.responsiveClass + '-)\\\\\\\\S+\\\\\\\\s', 'g'), '$1' + match)\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tthis.trigger('change', { property: { name: 'settings', value: settings } });\\n\\t\\tthis._breakpoint = match;\\n\\t\\tthis.settings = settings;\\n\\t\\tthis.invalidate('settings');\\n\\t\\tthis.trigger('changed', { property: { name: 'settings', value: this.settings } });\\n\\t};\\n\\n\\t/**\\n\\t * Updates option logic if necessery.\\n\\t * @protected\\n\\t */\\n\\tOwl.prototype.optionsLogic = function() {\\n\\t\\tif (this.settings.autoWidth) {\\n\\t\\t\\tthis.settings.stagePadding = false;\\n\\t\\t\\tthis.settings.merge = false;\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Prepares an item before add.\\n\\t * @todo Rename event parameter `content` to `item`.\\n\\t * @protected\\n\\t * @returns {jQuery|HTMLElement} - The item container.\\n\\t */\\n\\tOwl.prototype.prepare = function(item) {\\n\\t\\tvar event = this.trigger('prepare', { content: item });\\n\\n\\t\\tif (!event.data) {\\n\\t\\t\\tevent.data = $('<' + this.settings.itemElement + '/>')\\n\\t\\t\\t\\t.addClass(this.options.itemClass).append(item)\\n\\t\\t}\\n\\n\\t\\tthis.trigger('prepared', { content: event.data });\\n\\n\\t\\treturn event.data;\\n\\t};\\n\\n\\t/**\\n\\t * Updates the view.\\n\\t * @public\\n\\t */\\n\\tOwl.prototype.update = function() {\\n\\t\\tvar i = 0,\\n\\t\\t\\tn = this._pipe.length,\\n\\t\\t\\tfilter = $.proxy(function(p) { return this[p] }, this._invalidated),\\n\\t\\t\\tcache = {};\\n\\n\\t\\twhile (i < n) {\\n\\t\\t\\tif (this._invalidated.all || $.grep(this._pipe[i].filter, filter).length > 0) {\\n\\t\\t\\t\\tthis._pipe[i].run(cache);\\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n\\t\\tthis._invalidated = {};\\n\\n\\t\\t!this.is('valid') && this.enter('valid');\\n\\t};\\n\\n\\t/**\\n\\t * Gets the width of the view.\\n\\t * @public\\n\\t * @param {Owl.Width} [dimension=Owl.Width.Default] - The dimension to return.\\n\\t * @returns {Number} - The width of the view in pixel.\\n\\t */\\n\\tOwl.prototype.width = function(dimension) {\\n\\t\\tdimension = dimension || Owl.Width.Default;\\n\\t\\tswitch (dimension) {\\n\\t\\t\\tcase Owl.Width.Inner:\\n\\t\\t\\tcase Owl.Width.Outer:\\n\\t\\t\\t\\treturn this._width;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\treturn this._width - this.settings.stagePadding * 2 + this.settings.margin;\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Refreshes the carousel primarily for adaptive purposes.\\n\\t * @public\\n\\t */\\n\\tOwl.prototype.refresh = function() {\\n\\t\\tthis.enter('refreshing');\\n\\t\\tthis.trigger('refresh');\\n\\n\\t\\tthis.setup();\\n\\n\\t\\tthis.optionsLogic();\\n\\n\\t\\tthis.$element.addClass(this.options.refreshClass);\\n\\n\\t\\tthis.update();\\n\\n\\t\\tthis.$element.removeClass(this.options.refreshClass);\\n\\n\\t\\tthis.leave('refreshing');\\n\\t\\tthis.trigger('refreshed');\\n\\t};\\n\\n\\t/**\\n\\t * Checks window `resize` event.\\n\\t * @protected\\n\\t */\\n\\tOwl.prototype.onThrottledResize = function() {\\n\\t\\twindow.clearTimeout(this.resizeTimer);\\n\\t\\tthis.resizeTimer = window.setTimeout(this._handlers.onResize, this.settings.responsiveRefreshRate);\\n\\t};\\n\\n\\t/**\\n\\t * Checks window `resize` event.\\n\\t * @protected\\n\\t */\\n\\tOwl.prototype.onResize = function() {\\n\\t\\tif (!this._items.length) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tif (this._width === this.$element.width()) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tif (!this.$element.is(':visible')) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tthis.enter('resizing');\\n\\n\\t\\tif (this.trigger('resize').isDefaultPrevented()) {\\n\\t\\t\\tthis.leave('resizing');\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tthis.invalidate('width');\\n\\n\\t\\tthis.refresh();\\n\\n\\t\\tthis.leave('resizing');\\n\\t\\tthis.trigger('resized');\\n\\t};\\n\\n\\t/**\\n\\t * Registers event handlers.\\n\\t * @todo Check `msPointerEnabled`\\n\\t * @todo #261\\n\\t * @protected\\n\\t */\\n\\tOwl.prototype.registerEventHandlers = function() {\\n\\t\\tif ($.support.transition) {\\n\\t\\t\\tthis.$stage.on($.support.transition.end + '.owl.core', $.proxy(this.onTransitionEnd, this));\\n\\t\\t}\\n\\n\\t\\tif (this.settings.responsive !== false) {\\n\\t\\t\\tthis.on(window, 'resize', this._handlers.onThrottledResize);\\n\\t\\t}\\n\\n\\t\\tif (this.settings.mouseDrag) {\\n\\t\\t\\tthis.$element.addClass(this.options.dragClass);\\n\\t\\t\\tthis.$stage.on('mousedown.owl.core', $.proxy(this.onDragStart, this));\\n\\t\\t\\tthis.$stage.on('dragstart.owl.core selectstart.owl.core', function() { return false });\\n\\t\\t}\\n\\n\\t\\tif (this.settings.touchDrag){\\n\\t\\t\\tthis.$stage.on('touchstart.owl.core', $.proxy(this.onDragStart, this));\\n\\t\\t\\tthis.$stage.on('touchcancel.owl.core', $.proxy(this.onDragEnd, this));\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Handles `touchstart` and `mousedown` events.\\n\\t * @todo Horizontal swipe threshold as option\\n\\t * @todo #261\\n\\t * @protected\\n\\t * @param {Event} event - The event arguments.\\n\\t */\\n\\tOwl.prototype.onDragStart = function(event) {\\n\\t\\tvar stage = null;\\n\\n\\t\\tif (event.which === 3) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ($.support.transform) {\\n\\t\\t\\tstage = this.$stage.css('transform').replace(/.*\\\\(|\\\\)| /g, '').split(',');\\n\\t\\t\\tstage = {\\n\\t\\t\\t\\tx: stage[stage.length === 16 ? 12 : 4],\\n\\t\\t\\t\\ty: stage[stage.length === 16 ? 13 : 5]\\n\\t\\t\\t};\\n\\t\\t} else {\\n\\t\\t\\tstage = this.$stage.position();\\n\\t\\t\\tstage = {\\n\\t\\t\\t\\tx: this.settings.rtl ?\\n\\t\\t\\t\\t\\tstage.left + this.$stage.width() - this.width() + this.settings.margin :\\n\\t\\t\\t\\t\\tstage.left,\\n\\t\\t\\t\\ty: stage.top\\n\\t\\t\\t};\\n\\t\\t}\\n\\n\\t\\tif (this.is('animating')) {\\n\\t\\t\\t$.support.transform ? this.animate(stage.x) : this.$stage.stop()\\n\\t\\t\\tthis.invalidate('position');\\n\\t\\t}\\n\\n\\t\\tthis.$element.toggleClass(this.options.grabClass, event.type === 'mousedown');\\n\\n\\t\\tthis.speed(0);\\n\\n\\t\\tthis._drag.time = new Date().getTime();\\n\\t\\tthis._drag.target = $(event.target);\\n\\t\\tthis._drag.stage.start = stage;\\n\\t\\tthis._drag.stage.current = stage;\\n\\t\\tthis._drag.pointer = this.pointer(event);\\n\\n\\t\\t$(document).on('mouseup.owl.core touchend.owl.core', $.proxy(this.onDragEnd, this));\\n\\n\\t\\t$(document).one('mousemove.owl.core touchmove.owl.core', $.proxy(function(event) {\\n\\t\\t\\tvar delta = this.difference(this._drag.pointer, this.pointer(event));\\n\\n\\t\\t\\t$(document).on('mousemove.owl.core touchmove.owl.core', $.proxy(this.onDragMove, this));\\n\\n\\t\\t\\tif (Math.abs(delta.x) < Math.abs(delta.y) && this.is('valid')) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tevent.preventDefault();\\n\\n\\t\\t\\tthis.enter('dragging');\\n\\t\\t\\tthis.trigger('drag');\\n\\t\\t}, this));\\n\\t};\\n\\n\\t/**\\n\\t * Handles the `touchmove` and `mousemove` events.\\n\\t * @todo #261\\n\\t * @protected\\n\\t * @param {Event} event - The event arguments.\\n\\t */\\n\\tOwl.prototype.onDragMove = function(event) {\\n\\t\\tvar minimum = null,\\n\\t\\t\\tmaximum = null,\\n\\t\\t\\tpull = null,\\n\\t\\t\\tdelta = this.difference(this._drag.pointer, this.pointer(event)),\\n\\t\\t\\tstage = this.difference(this._drag.stage.start, delta);\\n\\n\\t\\tif (!this.is('dragging')) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tevent.preventDefault();\\n\\n\\t\\tif (this.settings.loop) {\\n\\t\\t\\tminimum = this.coordinates(this.minimum());\\n\\t\\t\\tmaximum = this.coordinates(this.maximum() + 1) - minimum;\\n\\t\\t\\tstage.x = (((stage.x - minimum) % maximum + maximum) % maximum) + minimum;\\n\\t\\t} else {\\n\\t\\t\\tminimum = this.settings.rtl ? this.coordinates(this.maximum()) : this.coordinates(this.minimum());\\n\\t\\t\\tmaximum = this.settings.rtl ? this.coordinates(this.minimum()) : this.coordinates(this.maximum());\\n\\t\\t\\tpull = this.settings.pullDrag ? -1 * delta.x / 5 : 0;\\n\\t\\t\\tstage.x = Math.max(Math.min(stage.x, minimum + pull), maximum + pull);\\n\\t\\t}\\n\\n\\t\\tthis._drag.stage.current = stage;\\n\\n\\t\\tthis.animate(stage.x);\\n\\t};\\n\\n\\t/**\\n\\t * Handles the `touchend` and `mouseup` events.\\n\\t * @todo #261\\n\\t * @todo Threshold for click event\\n\\t * @protected\\n\\t * @param {Event} event - The event arguments.\\n\\t */\\n\\tOwl.prototype.onDragEnd = function(event) {\\n\\t\\tvar delta = this.difference(this._drag.pointer, this.pointer(event)),\\n\\t\\t\\tstage = this._drag.stage.current,\\n\\t\\t\\tdirection = delta.x > 0 ^ this.settings.rtl ? 'left' : 'right';\\n\\n\\t\\t$(document).off('.owl.core');\\n\\n\\t\\tthis.$element.removeClass(this.options.grabClass);\\n\\n\\t\\tif (delta.x !== 0 && this.is('dragging') || !this.is('valid')) {\\n\\t\\t\\tthis.speed(this.settings.dragEndSpeed || this.settings.smartSpeed);\\n\\t\\t\\tthis.current(this.closest(stage.x, delta.x !== 0 ? direction : this._drag.direction));\\n\\t\\t\\tthis.invalidate('position');\\n\\t\\t\\tthis.update();\\n\\n\\t\\t\\tthis._drag.direction = direction;\\n\\n\\t\\t\\tif (Math.abs(delta.x) > 3 || new Date().getTime() - this._drag.time > 300) {\\n\\t\\t\\t\\tthis._drag.target.one('click.owl.core', function() { return false; });\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (!this.is('dragging')) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tthis.leave('dragging');\\n\\t\\tthis.trigger('dragged');\\n\\t};\\n\\n\\t/**\\n\\t * Gets absolute position of the closest item for a coordinate.\\n\\t * @todo Setting `freeDrag` makes `closest` not reusable. See #165.\\n\\t * @protected\\n\\t * @param {Number} coordinate - The coordinate in pixel.\\n\\t * @param {String} direction - The direction to check for the closest item. Ether `left` or `right`.\\n\\t * @return {Number} - The absolute position of the closest item.\\n\\t */\\n\\tOwl.prototype.closest = function(coordinate, direction) {\\n\\t\\tvar position = -1,\\n\\t\\t\\tpull = 30,\\n\\t\\t\\twidth = this.width(),\\n\\t\\t\\tcoordinates = this.coordinates();\\n\\n\\t\\tif (!this.settings.freeDrag) {\\n\\t\\t\\t// check closest item\\n\\t\\t\\t$.each(coordinates, $.proxy(function(index, value) {\\n\\t\\t\\t\\t// on a left pull, check on current index\\n\\t\\t\\t\\tif (direction === 'left' && coordinate > value - pull && coordinate < value + pull) {\\n\\t\\t\\t\\t\\tposition = index;\\n\\t\\t\\t\\t// on a right pull, check on previous index\\n\\t\\t\\t\\t// to do so, subtract width from value and set position = index + 1\\n\\t\\t\\t\\t} else if (direction === 'right' && coordinate > value - width - pull && coordinate < value - width + pull) {\\n\\t\\t\\t\\t\\tposition = index + 1;\\n\\t\\t\\t\\t} else if (this.op(coordinate, '<', value)\\n\\t\\t\\t\\t\\t&& this.op(coordinate, '>', coordinates[index + 1] || value - width)) {\\n\\t\\t\\t\\t\\tposition = direction === 'left' ? index + 1 : index;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn position === -1;\\n\\t\\t\\t}, this));\\n\\t\\t}\\n\\n\\t\\tif (!this.settings.loop) {\\n\\t\\t\\t// non loop boundries\\n\\t\\t\\tif (this.op(coordinate, '>', coordinates[this.minimum()])) {\\n\\t\\t\\t\\tposition = coordinate = this.minimum();\\n\\t\\t\\t} else if (this.op(coordinate, '<', coordinates[this.maximum()])) {\\n\\t\\t\\t\\tposition = coordinate = this.maximum();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn position;\\n\\t};\\n\\n\\t/**\\n\\t * Animates the stage.\\n\\t * @todo #270\\n\\t * @public\\n\\t * @param {Number} coordinate - The coordinate in pixels.\\n\\t */\\n\\tOwl.prototype.animate = function(coordinate) {\\n\\t\\tvar animate = this.speed() > 0;\\n\\n\\t\\tthis.is('animating') && this.onTransitionEnd();\\n\\n\\t\\tif (animate) {\\n\\t\\t\\tthis.enter('animating');\\n\\t\\t\\tthis.trigger('translate');\\n\\t\\t}\\n\\n\\t\\tif ($.support.transform3d && $.support.transition) {\\n\\t\\t\\tthis.$stage.css({\\n\\t\\t\\t\\ttransform: 'translate3d(' + coordinate + 'px,0px,0px)',\\n\\t\\t\\t\\ttransition: (this.speed() / 1000) + 's'\\n\\t\\t\\t});\\n\\t\\t} else if (animate) {\\n\\t\\t\\tthis.$stage.animate({\\n\\t\\t\\t\\tleft: coordinate + 'px'\\n\\t\\t\\t}, this.speed(), this.settings.fallbackEasing, $.proxy(this.onTransitionEnd, this));\\n\\t\\t} else {\\n\\t\\t\\tthis.$stage.css({\\n\\t\\t\\t\\tleft: coordinate + 'px'\\n\\t\\t\\t});\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Checks whether the carousel is in a specific state or not.\\n\\t * @param {String} state - The state to check.\\n\\t * @returns {Boolean} - The flag which indicates if the carousel is busy.\\n\\t */\\n\\tOwl.prototype.is = function(state) {\\n\\t\\treturn this._states.current[state] && this._states.current[state] > 0;\\n\\t};\\n\\n\\t/**\\n\\t * Sets the absolute position of the current item.\\n\\t * @public\\n\\t * @param {Number} [position] - The new absolute position or nothing to leave it unchanged.\\n\\t * @returns {Number} - The absolute position of the current item.\\n\\t */\\n\\tOwl.prototype.current = function(position) {\\n\\t\\tif (position === undefined) {\\n\\t\\t\\treturn this._current;\\n\\t\\t}\\n\\n\\t\\tif (this._items.length === 0) {\\n\\t\\t\\treturn undefined;\\n\\t\\t}\\n\\n\\t\\tposition = this.normalize(position);\\n\\n\\t\\tif (this._current !== position) {\\n\\t\\t\\tvar event = this.trigger('change', { property: { name: 'position', value: position } });\\n\\n\\t\\t\\tif (event.data !== undefined) {\\n\\t\\t\\t\\tposition = this.normalize(event.data);\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis._current = position;\\n\\n\\t\\t\\tthis.invalidate('position');\\n\\n\\t\\t\\tthis.trigger('changed', { property: { name: 'position', value: this._current } });\\n\\t\\t}\\n\\n\\t\\treturn this._current;\\n\\t};\\n\\n\\t/**\\n\\t * Invalidates the given part of the update routine.\\n\\t * @param {String} [part] - The part to invalidate.\\n\\t * @returns {Array.<String>} - The invalidated parts.\\n\\t */\\n\\tOwl.prototype.invalidate = function(part) {\\n\\t\\tif ($.type(part) === 'string') {\\n\\t\\t\\tthis._invalidated[part] = true;\\n\\t\\t\\tthis.is('valid') && this.leave('valid');\\n\\t\\t}\\n\\t\\treturn $.map(this._invalidated, function(v, i) { return i });\\n\\t};\\n\\n\\t/**\\n\\t * Resets the absolute position of the current item.\\n\\t * @public\\n\\t * @param {Number} position - The absolute position of the new item.\\n\\t */\\n\\tOwl.prototype.reset = function(position) {\\n\\t\\tposition = this.normalize(position);\\n\\n\\t\\tif (position === undefined) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tthis._speed = 0;\\n\\t\\tthis._current = position;\\n\\n\\t\\tthis.suppress([ 'translate', 'translated' ]);\\n\\n\\t\\tthis.animate(this.coordinates(position));\\n\\n\\t\\tthis.release([ 'translate', 'translated' ]);\\n\\t};\\n\\n\\t/**\\n\\t * Normalizes an absolute or a relative position of an item.\\n\\t * @public\\n\\t * @param {Number} position - The absolute or relative position to normalize.\\n\\t * @param {Boolean} [relative=false] - Whether the given position is relative or not.\\n\\t * @returns {Number} - The normalized position.\\n\\t */\\n\\tOwl.prototype.normalize = function(position, relative) {\\n\\t\\tvar n = this._items.length,\\n\\t\\t\\tm = relative ? 0 : this._clones.length;\\n\\n\\t\\tif (!this.isNumeric(position) || n < 1) {\\n\\t\\t\\tposition = undefined;\\n\\t\\t} else if (position < 0 || position >= n + m) {\\n\\t\\t\\tposition = ((position - m / 2) % n + n) % n + m / 2;\\n\\t\\t}\\n\\n\\t\\treturn position;\\n\\t};\\n\\n\\t/**\\n\\t * Converts an absolute position of an item into a relative one.\\n\\t * @public\\n\\t * @param {Number} position - The absolute position to convert.\\n\\t * @returns {Number} - The converted position.\\n\\t */\\n\\tOwl.prototype.relative = function(position) {\\n\\t\\tposition -= this._clones.length / 2;\\n\\t\\treturn this.normalize(position, true);\\n\\t};\\n\\n\\t/**\\n\\t * Gets the maximum position for the current item.\\n\\t * @public\\n\\t * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.\\n\\t * @returns {Number}\\n\\t */\\n\\tOwl.prototype.maximum = function(relative) {\\n\\t\\tvar settings = this.settings,\\n\\t\\t\\tmaximum = this._coordinates.length,\\n\\t\\t\\titerator,\\n\\t\\t\\treciprocalItemsWidth,\\n\\t\\t\\telementWidth;\\n\\n\\t\\tif (settings.loop) {\\n\\t\\t\\tmaximum = this._clones.length / 2 + this._items.length - 1;\\n\\t\\t} else if (settings.autoWidth || settings.merge) {\\n\\t\\t\\titerator = this._items.length;\\n\\t\\t\\treciprocalItemsWidth = this._items[--iterator].width();\\n\\t\\t\\telementWidth = this.$element.width();\\n\\t\\t\\twhile (iterator--) {\\n\\t\\t\\t\\treciprocalItemsWidth += this._items[iterator].width() + this.settings.margin;\\n\\t\\t\\t\\tif (reciprocalItemsWidth > elementWidth) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tmaximum = iterator + 1;\\n\\t\\t} else if (settings.center) {\\n\\t\\t\\tmaximum = this._items.length - 1;\\n\\t\\t} else {\\n\\t\\t\\tmaximum = this._items.length - settings.items;\\n\\t\\t}\\n\\n\\t\\tif (relative) {\\n\\t\\t\\tmaximum -= this._clones.length / 2;\\n\\t\\t}\\n\\n\\t\\treturn Math.max(maximum, 0);\\n\\t};\\n\\n\\t/**\\n\\t * Gets the minimum position for the current item.\\n\\t * @public\\n\\t * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.\\n\\t * @returns {Number}\\n\\t */\\n\\tOwl.prototype.minimum = function(relative) {\\n\\t\\treturn relative ? 0 : this._clones.length / 2;\\n\\t};\\n\\n\\t/**\\n\\t * Gets an item at the specified relative position.\\n\\t * @public\\n\\t * @param {Number} [position] - The relative position of the item.\\n\\t * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.\\n\\t */\\n\\tOwl.prototype.items = function(position) {\\n\\t\\tif (position === undefined) {\\n\\t\\t\\treturn this._items.slice();\\n\\t\\t}\\n\\n\\t\\tposition = this.normalize(position, true);\\n\\t\\treturn this._items[position];\\n\\t};\\n\\n\\t/**\\n\\t * Gets an item at the specified relative position.\\n\\t * @public\\n\\t * @param {Number} [position] - The relative position of the item.\\n\\t * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.\\n\\t */\\n\\tOwl.prototype.mergers = function(position) {\\n\\t\\tif (position === undefined) {\\n\\t\\t\\treturn this._mergers.slice();\\n\\t\\t}\\n\\n\\t\\tposition = this.normalize(position, true);\\n\\t\\treturn this._mergers[position];\\n\\t};\\n\\n\\t/**\\n\\t * Gets the absolute positions of clones for an item.\\n\\t * @public\\n\\t * @param {Number} [position] - The relative position of the item.\\n\\t * @returns {Array.<Number>} - The absolute positions of clones for the item or all if no position was given.\\n\\t */\\n\\tOwl.prototype.clones = function(position) {\\n\\t\\tvar odd = this._clones.length / 2,\\n\\t\\t\\teven = odd + this._items.length,\\n\\t\\t\\tmap = function(index) { return index % 2 === 0 ? even + index / 2 : odd - (index + 1) / 2 };\\n\\n\\t\\tif (position === undefined) {\\n\\t\\t\\treturn $.map(this._clones, function(v, i) { return map(i) });\\n\\t\\t}\\n\\n\\t\\treturn $.map(this._clones, function(v, i) { return v === position ? map(i) : null });\\n\\t};\\n\\n\\t/**\\n\\t * Sets the current animation speed.\\n\\t * @public\\n\\t * @param {Number} [speed] - The animation speed in milliseconds or nothing to leave it unchanged.\\n\\t * @returns {Number} - The current animation speed in milliseconds.\\n\\t */\\n\\tOwl.prototype.speed = function(speed) {\\n\\t\\tif (speed !== undefined) {\\n\\t\\t\\tthis._speed = speed;\\n\\t\\t}\\n\\n\\t\\treturn this._speed;\\n\\t};\\n\\n\\t/**\\n\\t * Gets the coordinate of an item.\\n\\t * @todo The name of this method is missleanding.\\n\\t * @public\\n\\t * @param {Number} position - The absolute position of the item within `minimum()` and `maximum()`.\\n\\t * @returns {Number|Array.<Number>} - The coordinate of the item in pixel or all coordinates.\\n\\t */\\n\\tOwl.prototype.coordinates = function(position) {\\n\\t\\tvar multiplier = 1,\\n\\t\\t\\tnewPosition = position - 1,\\n\\t\\t\\tcoordinate;\\n\\n\\t\\tif (position === undefined) {\\n\\t\\t\\treturn $.map(this._coordinates, $.proxy(function(coordinate, index) {\\n\\t\\t\\t\\treturn this.coordinates(index);\\n\\t\\t\\t}, this));\\n\\t\\t}\\n\\n\\t\\tif (this.settings.center) {\\n\\t\\t\\tif (this.settings.rtl) {\\n\\t\\t\\t\\tmultiplier = -1;\\n\\t\\t\\t\\tnewPosition = position + 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tcoordinate = this._coordinates[position];\\n\\t\\t\\tcoordinate += (this.width() - coordinate + (this._coordinates[newPosition] || 0)) / 2 * multiplier;\\n\\t\\t} else {\\n\\t\\t\\tcoordinate = this._coordinates[newPosition] || 0;\\n\\t\\t}\\n\\n\\t\\tcoordinate = Math.ceil(coordinate);\\n\\n\\t\\treturn coordinate;\\n\\t};\\n\\n\\t/**\\n\\t * Calculates the speed for a translation.\\n\\t * @protected\\n\\t * @param {Number} from - The absolute position of the start item.\\n\\t * @param {Number} to - The absolute position of the target item.\\n\\t * @param {Number} [factor=undefined] - The time factor in milliseconds.\\n\\t * @returns {Number} - The time in milliseconds for the translation.\\n\\t */\\n\\tOwl.prototype.duration = function(from, to, factor) {\\n\\t\\tif (factor === 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\treturn Math.min(Math.max(Math.abs(to - from), 1), 6) * Math.abs((factor || this.settings.smartSpeed));\\n\\t};\\n\\n\\t/**\\n\\t * Slides to the specified item.\\n\\t * @public\\n\\t * @param {Number} position - The position of the item.\\n\\t * @param {Number} [speed] - The time in milliseconds for the transition.\\n\\t */\\n\\tOwl.prototype.to = function(position, speed) {\\n\\t\\tvar current = this.current(),\\n\\t\\t\\trevert = null,\\n\\t\\t\\tdistance = position - this.relative(current),\\n\\t\\t\\tdirection = (distance > 0) - (distance < 0),\\n\\t\\t\\titems = this._items.length,\\n\\t\\t\\tminimum = this.minimum(),\\n\\t\\t\\tmaximum = this.maximum();\\n\\n\\t\\tif (this.settings.loop) {\\n\\t\\t\\tif (!this.settings.rewind && Math.abs(distance) > items / 2) {\\n\\t\\t\\t\\tdistance += direction * -1 * items;\\n\\t\\t\\t}\\n\\n\\t\\t\\tposition = current + distance;\\n\\t\\t\\trevert = ((position - minimum) % items + items) % items + minimum;\\n\\n\\t\\t\\tif (revert !== position && revert - distance <= maximum && revert - distance > 0) {\\n\\t\\t\\t\\tcurrent = revert - distance;\\n\\t\\t\\t\\tposition = revert;\\n\\t\\t\\t\\tthis.reset(current);\\n\\t\\t\\t}\\n\\t\\t} else if (this.settings.rewind) {\\n\\t\\t\\tmaximum += 1;\\n\\t\\t\\tposition = (position % maximum + maximum) % maximum;\\n\\t\\t} else {\\n\\t\\t\\tposition = Math.max(minimum, Math.min(maximum, position));\\n\\t\\t}\\n\\n\\t\\tthis.speed(this.duration(current, position, speed));\\n\\t\\tthis.current(position);\\n\\n\\t\\tif (this.$element.is(':visible')) {\\n\\t\\t\\tthis.update();\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Slides to the next item.\\n\\t * @public\\n\\t * @param {Number} [speed] - The time in milliseconds for the transition.\\n\\t */\\n\\tOwl.prototype.next = function(speed) {\\n\\t\\tspeed = speed || false;\\n\\t\\tthis.to(this.relative(this.current()) + 1, speed);\\n\\t};\\n\\n\\t/**\\n\\t * Slides to the previous item.\\n\\t * @public\\n\\t * @param {Number} [speed] - The time in milliseconds for the transition.\\n\\t */\\n\\tOwl.prototype.prev = function(speed) {\\n\\t\\tspeed = speed || false;\\n\\t\\tthis.to(this.relative(this.current()) - 1, speed);\\n\\t};\\n\\n\\t/**\\n\\t * Handles the end of an animation.\\n\\t * @protected\\n\\t * @param {Event} event - The event arguments.\\n\\t */\\n\\tOwl.prototype.onTransitionEnd = function(event) {\\n\\n\\t\\t// if css2 animation then event object is undefined\\n\\t\\tif (event !== undefined) {\\n\\t\\t\\tevent.stopPropagation();\\n\\n\\t\\t\\t// Catch only owl-stage transitionEnd event\\n\\t\\t\\tif ((event.target || event.srcElement || event.originalTarget) !== this.$stage.get(0)) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tthis.leave('animating');\\n\\t\\tthis.trigger('translated');\\n\\t};\\n\\n\\t/**\\n\\t * Gets viewport width.\\n\\t * @protected\\n\\t * @return {Number} - The width in pixel.\\n\\t */\\n\\tOwl.prototype.viewport = function() {\\n\\t\\tvar width;\\n\\t\\tif (this.options.responsiveBaseElement !== window) {\\n\\t\\t\\twidth = $(this.options.responsiveBaseElement).width();\\n\\t\\t} else if (window.innerWidth) {\\n\\t\\t\\twidth = window.innerWidth;\\n\\t\\t} else if (document.documentElement && document.documentElement.clientWidth) {\\n\\t\\t\\twidth = document.documentElement.clientWidth;\\n\\t\\t} else {\\n\\t\\t\\tthrow 'Can not detect viewport width.';\\n\\t\\t}\\n\\t\\treturn width;\\n\\t};\\n\\n\\t/**\\n\\t * Replaces the current content.\\n\\t * @public\\n\\t * @param {HTMLElement|jQuery|String} content - The new content.\\n\\t */\\n\\tOwl.prototype.replace = function(content) {\\n\\t\\tthis.$stage.empty();\\n\\t\\tthis._items = [];\\n\\n\\t\\tif (content) {\\n\\t\\t\\tcontent = (content instanceof jQuery) ? content : $(content);\\n\\t\\t}\\n\\n\\t\\tif (this.settings.nestedItemSelector) {\\n\\t\\t\\tcontent = content.find('.' + this.settings.nestedItemSelector);\\n\\t\\t}\\n\\n\\t\\tcontent.filter(function() {\\n\\t\\t\\treturn this.nodeType === 1;\\n\\t\\t}).each($.proxy(function(index, item) {\\n\\t\\t\\titem = this.prepare(item);\\n\\t\\t\\tthis.$stage.append(item);\\n\\t\\t\\tthis._items.push(item);\\n\\t\\t\\tthis._mergers.push(item.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);\\n\\t\\t}, this));\\n\\n\\t\\tthis.reset(this.isNumeric(this.settings.startPosition) ? this.settings.startPosition : 0);\\n\\n\\t\\tthis.invalidate('items');\\n\\t};\\n\\n\\t/**\\n\\t * Adds an item.\\n\\t * @todo Use `item` instead of `content` for the event arguments.\\n\\t * @public\\n\\t * @param {HTMLElement|jQuery|String} content - The item content to add.\\n\\t * @param {Number} [position] - The relative position at which to insert the item otherwise the item will be added to the end.\\n\\t */\\n\\tOwl.prototype.add = function(content, position) {\\n\\t\\tvar current = this.relative(this._current);\\n\\n\\t\\tposition = position === undefined ? this._items.length : this.normalize(position, true);\\n\\t\\tcontent = content instanceof jQuery ? content : $(content);\\n\\n\\t\\tthis.trigger('add', { content: content, position: position });\\n\\n\\t\\tcontent = this.prepare(content);\\n\\n\\t\\tif (this._items.length === 0 || position === this._items.length) {\\n\\t\\t\\tthis._items.length === 0 && this.$stage.append(content);\\n\\t\\t\\tthis._items.length !== 0 && this._items[position - 1].after(content);\\n\\t\\t\\tthis._items.push(content);\\n\\t\\t\\tthis._mergers.push(content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);\\n\\t\\t} else {\\n\\t\\t\\tthis._items[position].before(content);\\n\\t\\t\\tthis._items.splice(position, 0, content);\\n\\t\\t\\tthis._mergers.splice(position, 0, content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);\\n\\t\\t}\\n\\n\\t\\tthis._items[current] && this.reset(this._items[current].index());\\n\\n\\t\\tthis.invalidate('items');\\n\\n\\t\\tthis.trigger('added', { content: content, position: position });\\n\\t};\\n\\n\\t/**\\n\\t * Removes an item by its position.\\n\\t * @todo Use `item` instead of `content` for the event arguments.\\n\\t * @public\\n\\t * @param {Number} position - The relative position of the item to remove.\\n\\t */\\n\\tOwl.prototype.remove = function(position) {\\n\\t\\tposition = this.normalize(position, true);\\n\\n\\t\\tif (position === undefined) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tthis.trigger('remove', { content: this._items[position], position: position });\\n\\n\\t\\tthis._items[position].remove();\\n\\t\\tthis._items.splice(position, 1);\\n\\t\\tthis._mergers.splice(position, 1);\\n\\n\\t\\tthis.invalidate('items');\\n\\n\\t\\tthis.trigger('removed', { content: null, position: position });\\n\\t};\\n\\n\\t/**\\n\\t * Preloads images with auto width.\\n\\t * @todo Replace by a more generic approach\\n\\t * @protected\\n\\t */\\n\\tOwl.prototype.preloadAutoWidthImages = function(images) {\\n\\t\\timages.each($.proxy(function(i, element) {\\n\\t\\t\\tthis.enter('pre-loading');\\n\\t\\t\\telement = $(element);\\n\\t\\t\\t$(new Image()).one('load', $.proxy(function(e) {\\n\\t\\t\\t\\telement.attr('src', e.target.src);\\n\\t\\t\\t\\telement.css('opacity', 1);\\n\\t\\t\\t\\tthis.leave('pre-loading');\\n\\t\\t\\t\\t!this.is('pre-loading') && !this.is('initializing') && this.refresh();\\n\\t\\t\\t}, this)).attr('src', element.attr('src') || element.attr('data-src') || element.attr('data-src-retina'));\\n\\t\\t}, this));\\n\\t};\\n\\n\\t/**\\n\\t * Destroys the carousel.\\n\\t * @public\\n\\t */\\n\\tOwl.prototype.destroy = function() {\\n\\n\\t\\tthis.$element.off('.owl.core');\\n\\t\\tthis.$stage.off('.owl.core');\\n\\t\\t$(document).off('.owl.core');\\n\\n\\t\\tif (this.settings.responsive !== false) {\\n\\t\\t\\twindow.clearTimeout(this.resizeTimer);\\n\\t\\t\\tthis.off(window, 'resize', this._handlers.onThrottledResize);\\n\\t\\t}\\n\\n\\t\\tfor (var i in this._plugins) {\\n\\t\\t\\tthis._plugins[i].destroy();\\n\\t\\t}\\n\\n\\t\\tthis.$stage.children('.cloned').remove();\\n\\n\\t\\tthis.$stage.unwrap();\\n\\t\\tthis.$stage.children().contents().unwrap();\\n\\t\\tthis.$stage.children().unwrap();\\n\\n\\t\\tthis.$element\\n\\t\\t\\t.removeClass(this.options.refreshClass)\\n\\t\\t\\t.removeClass(this.options.loadingClass)\\n\\t\\t\\t.removeClass(this.options.loadedClass)\\n\\t\\t\\t.removeClass(this.options.rtlClass)\\n\\t\\t\\t.removeClass(this.options.dragClass)\\n\\t\\t\\t.removeClass(this.options.grabClass)\\n\\t\\t\\t.attr('class', this.$element.attr('class').replace(new RegExp(this.options.responsiveClass + '-\\\\\\\\S+\\\\\\\\s', 'g'), ''))\\n\\t\\t\\t.removeData('owl.carousel');\\n\\t};\\n\\n\\t/**\\n\\t * Operators to calculate right-to-left and left-to-right.\\n\\t * @protected\\n\\t * @param {Number} [a] - The left side operand.\\n\\t * @param {String} [o] - The operator.\\n\\t * @param {Number} [b] - The right side operand.\\n\\t */\\n\\tOwl.prototype.op = function(a, o, b) {\\n\\t\\tvar rtl = this.settings.rtl;\\n\\t\\tswitch (o) {\\n\\t\\t\\tcase '<':\\n\\t\\t\\t\\treturn rtl ? a > b : a < b;\\n\\t\\t\\tcase '>':\\n\\t\\t\\t\\treturn rtl ? a < b : a > b;\\n\\t\\t\\tcase '>=':\\n\\t\\t\\t\\treturn rtl ? a <= b : a >= b;\\n\\t\\t\\tcase '<=':\\n\\t\\t\\t\\treturn rtl ? a >= b : a <= b;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Attaches to an internal event.\\n\\t * @protected\\n\\t * @param {HTMLElement} element - The event source.\\n\\t * @param {String} event - The event name.\\n\\t * @param {Function} listener - The event handler to attach.\\n\\t * @param {Boolean} capture - Wether the event should be handled at the capturing phase or not.\\n\\t */\\n\\tOwl.prototype.on = function(element, event, listener, capture) {\\n\\t\\tif (element.addEventListener) {\\n\\t\\t\\telement.addEventListener(event, listener, capture);\\n\\t\\t} else if (element.attachEvent) {\\n\\t\\t\\telement.attachEvent('on' + event, listener);\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Detaches from an internal event.\\n\\t * @protected\\n\\t * @param {HTMLElement} element - The event source.\\n\\t * @param {String} event - The event name.\\n\\t * @param {Function} listener - The attached event handler to detach.\\n\\t * @param {Boolean} capture - Wether the attached event handler was registered as a capturing listener or not.\\n\\t */\\n\\tOwl.prototype.off = function(element, event, listener, capture) {\\n\\t\\tif (element.removeEventListener) {\\n\\t\\t\\telement.removeEventListener(event, listener, capture);\\n\\t\\t} else if (element.detachEvent) {\\n\\t\\t\\telement.detachEvent('on' + event, listener);\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Triggers a public event.\\n\\t * @todo Remove `status`, `relatedTarget` should be used instead.\\n\\t * @protected\\n\\t * @param {String} name - The event name.\\n\\t * @param {*} [data=null] - The event data.\\n\\t * @param {String} [namespace=carousel] - The event namespace.\\n\\t * @param {String} [state] - The state which is associated with the event.\\n\\t * @param {Boolean} [enter=false] - Indicates if the call enters the specified state or not.\\n\\t * @returns {Event} - The event arguments.\\n\\t */\\n\\tOwl.prototype.trigger = function(name, data, namespace, state, enter) {\\n\\t\\tvar status = {\\n\\t\\t\\titem: { count: this._items.length, index: this.current() }\\n\\t\\t}, handler = $.camelCase(\\n\\t\\t\\t$.grep([ 'on', name, namespace ], function(v) { return v })\\n\\t\\t\\t\\t.join('-').toLowerCase()\\n\\t\\t), event = $.Event(\\n\\t\\t\\t[ name, 'owl', namespace || 'carousel' ].join('.').toLowerCase(),\\n\\t\\t\\t$.extend({ relatedTarget: this }, status, data)\\n\\t\\t);\\n\\n\\t\\tif (!this._supress[name]) {\\n\\t\\t\\t$.each(this._plugins, function(name, plugin) {\\n\\t\\t\\t\\tif (plugin.onTrigger) {\\n\\t\\t\\t\\t\\tplugin.onTrigger(event);\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\tthis.register({ type: Owl.Type.Event, name: name });\\n\\t\\t\\tthis.$element.trigger(event);\\n\\n\\t\\t\\tif (this.settings && typeof this.settings[handler] === 'function') {\\n\\t\\t\\t\\tthis.settings[handler].call(this, event);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn event;\\n\\t};\\n\\n\\t/**\\n\\t * Enters a state.\\n\\t * @param name - The state name.\\n\\t */\\n\\tOwl.prototype.enter = function(name) {\\n\\t\\t$.each([ name ].concat(this._states.tags[name] || []), $.proxy(function(i, name) {\\n\\t\\t\\tif (this._states.current[name] === undefined) {\\n\\t\\t\\t\\tthis._states.current[name] = 0;\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis._states.current[name]++;\\n\\t\\t}, this));\\n\\t};\\n\\n\\t/**\\n\\t * Leaves a state.\\n\\t * @param name - The state name.\\n\\t */\\n\\tOwl.prototype.leave = function(name) {\\n\\t\\t$.each([ name ].concat(this._states.tags[name] || []), $.proxy(function(i, name) {\\n\\t\\t\\tthis._states.current[name]--;\\n\\t\\t}, this));\\n\\t};\\n\\n\\t/**\\n\\t * Registers an event or state.\\n\\t * @public\\n\\t * @param {Object} object - The event or state to register.\\n\\t */\\n\\tOwl.prototype.register = function(object) {\\n\\t\\tif (object.type === Owl.Type.Event) {\\n\\t\\t\\tif (!$.event.special[object.name]) {\\n\\t\\t\\t\\t$.event.special[object.name] = {};\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (!$.event.special[object.name].owl) {\\n\\t\\t\\t\\tvar _default = $.event.special[object.name]._default;\\n\\t\\t\\t\\t$.event.special[object.name]._default = function(e) {\\n\\t\\t\\t\\t\\tif (_default && _default.apply && (!e.namespace || e.namespace.indexOf('owl') === -1)) {\\n\\t\\t\\t\\t\\t\\treturn _default.apply(this, arguments);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn e.namespace && e.namespace.indexOf('owl') > -1;\\n\\t\\t\\t\\t};\\n\\t\\t\\t\\t$.event.special[object.name].owl = true;\\n\\t\\t\\t}\\n\\t\\t} else if (object.type === Owl.Type.State) {\\n\\t\\t\\tif (!this._states.tags[object.name]) {\\n\\t\\t\\t\\tthis._states.tags[object.name] = object.tags;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tthis._states.tags[object.name] = this._states.tags[object.name].concat(object.tags);\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis._states.tags[object.name] = $.grep(this._states.tags[object.name], $.proxy(function(tag, i) {\\n\\t\\t\\t\\treturn $.inArray(tag, this._states.tags[object.name]) === i;\\n\\t\\t\\t}, this));\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Suppresses events.\\n\\t * @protected\\n\\t * @param {Array.<String>} events - The events to suppress.\\n\\t */\\n\\tOwl.prototype.suppress = function(events) {\\n\\t\\t$.each(events, $.proxy(function(index, event) {\\n\\t\\t\\tthis._supress[event] = true;\\n\\t\\t}, this));\\n\\t};\\n\\n\\t/**\\n\\t * Releases suppressed events.\\n\\t * @protected\\n\\t * @param {Array.<String>} events - The events to release.\\n\\t */\\n\\tOwl.prototype.release = function(events) {\\n\\t\\t$.each(events, $.proxy(function(index, event) {\\n\\t\\t\\tdelete this._supress[event];\\n\\t\\t}, this));\\n\\t};\\n\\n\\t/**\\n\\t * Gets unified pointer coordinates from event.\\n\\t * @todo #261\\n\\t * @protected\\n\\t * @param {Event} - The `mousedown` or `touchstart` event.\\n\\t * @returns {Object} - Contains `x` and `y` coordinates of current pointer position.\\n\\t */\\n\\tOwl.prototype.pointer = function(event) {\\n\\t\\tvar result = { x: null, y: null };\\n\\n\\t\\tevent = event.originalEvent || event || window.event;\\n\\n\\t\\tevent = event.touches && event.touches.length ?\\n\\t\\t\\tevent.touches[0] : event.changedTouches && event.changedTouches.length ?\\n\\t\\t\\t\\tevent.changedTouches[0] : event;\\n\\n\\t\\tif (event.pageX) {\\n\\t\\t\\tresult.x = event.pageX;\\n\\t\\t\\tresult.y = event.pageY;\\n\\t\\t} else {\\n\\t\\t\\tresult.x = event.clientX;\\n\\t\\t\\tresult.y = event.clientY;\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t};\\n\\n\\t/**\\n\\t * Determines if the input is a Number or something that can be coerced to a Number\\n\\t * @protected\\n\\t * @param {Number|String|Object|Array|Boolean|RegExp|Function|Symbol} - The input to be tested\\n\\t * @returns {Boolean} - An indication if the input is a Number or can be coerced to a Number\\n\\t */\\n\\tOwl.prototype.isNumeric = function(number) {\\n\\t\\treturn !isNaN(parseFloat(number));\\n\\t};\\n\\n\\t/**\\n\\t * Gets the difference of two vectors.\\n\\t * @todo #261\\n\\t * @protected\\n\\t * @param {Object} - The first vector.\\n\\t * @param {Object} - The second vector.\\n\\t * @returns {Object} - The difference.\\n\\t */\\n\\tOwl.prototype.difference = function(first, second) {\\n\\t\\treturn {\\n\\t\\t\\tx: first.x - second.x,\\n\\t\\t\\ty: first.y - second.y\\n\\t\\t};\\n\\t};\\n\\n\\t/**\\n\\t * The jQuery Plugin for the Owl Carousel\\n\\t * @todo Navigation plugin `next` and `prev`\\n\\t * @public\\n\\t */\\n\\t$.fn.owlCarousel = function(option) {\\n\\t\\tvar args = Array.prototype.slice.call(arguments, 1);\\n\\n\\t\\treturn this.each(function() {\\n\\t\\t\\tvar $this = $(this),\\n\\t\\t\\t\\tdata = $this.data('owl.carousel');\\n\\n\\t\\t\\tif (!data) {\\n\\t\\t\\t\\tdata = new Owl(this, typeof option == 'object' && option);\\n\\t\\t\\t\\t$this.data('owl.carousel', data);\\n\\n\\t\\t\\t\\t$.each([\\n\\t\\t\\t\\t\\t'next', 'prev', 'to', 'destroy', 'refresh', 'replace', 'add', 'remove'\\n\\t\\t\\t\\t], function(i, event) {\\n\\t\\t\\t\\t\\tdata.register({ type: Owl.Type.Event, name: event });\\n\\t\\t\\t\\t\\tdata.$element.on(event + '.owl.carousel.core', $.proxy(function(e) {\\n\\t\\t\\t\\t\\t\\tif (e.namespace && e.relatedTarget !== this) {\\n\\t\\t\\t\\t\\t\\t\\tthis.suppress([ event ]);\\n\\t\\t\\t\\t\\t\\t\\tdata[event].apply(this, [].slice.call(arguments, 1));\\n\\t\\t\\t\\t\\t\\t\\tthis.release([ event ]);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}, data));\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (typeof option == 'string' && option.charAt(0) !== '_') {\\n\\t\\t\\t\\tdata[option].apply(data, args);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t};\\n\\n\\t/**\\n\\t * The constructor for the jQuery Plugin\\n\\t * @public\\n\\t */\\n\\t$.fn.owlCarousel.Constructor = Owl;\\n\\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\\n\\n/**\\n * AutoRefresh Plugin\\n * @version 2.1.0\\n * @author Artus Kolanowski\\n * @author David Deutsch\\n * @license The MIT License (MIT)\\n */\\n;(function($, window, document, undefined) {\\n\\n\\t/**\\n\\t * Creates the auto refresh plugin.\\n\\t * @class The Auto Refresh Plugin\\n\\t * @param {Owl} carousel - The Owl Carousel\\n\\t */\\n\\tvar AutoRefresh = function(carousel) {\\n\\t\\t/**\\n\\t\\t * Reference to the core.\\n\\t\\t * @protected\\n\\t\\t * @type {Owl}\\n\\t\\t */\\n\\t\\tthis._core = carousel;\\n\\n\\t\\t/**\\n\\t\\t * Refresh interval.\\n\\t\\t * @protected\\n\\t\\t * @type {number}\\n\\t\\t */\\n\\t\\tthis._interval = null;\\n\\n\\t\\t/**\\n\\t\\t * Whether the element is currently visible or not.\\n\\t\\t * @protected\\n\\t\\t * @type {Boolean}\\n\\t\\t */\\n\\t\\tthis._visible = null;\\n\\n\\t\\t/**\\n\\t\\t * All event handlers.\\n\\t\\t * @protected\\n\\t\\t * @type {Object}\\n\\t\\t */\\n\\t\\tthis._handlers = {\\n\\t\\t\\t'initialized.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && this._core.settings.autoRefresh) {\\n\\t\\t\\t\\t\\tthis.watch();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this)\\n\\t\\t};\\n\\n\\t\\t// set default options\\n\\t\\tthis._core.options = $.extend({}, AutoRefresh.Defaults, this._core.options);\\n\\n\\t\\t// register event handlers\\n\\t\\tthis._core.$element.on(this._handlers);\\n\\t};\\n\\n\\t/**\\n\\t * Default options.\\n\\t * @public\\n\\t */\\n\\tAutoRefresh.Defaults = {\\n\\t\\tautoRefresh: true,\\n\\t\\tautoRefreshInterval: 500\\n\\t};\\n\\n\\t/**\\n\\t * Watches the element.\\n\\t */\\n\\tAutoRefresh.prototype.watch = function() {\\n\\t\\tif (this._interval) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tthis._visible = this._core.$element.is(':visible');\\n\\t\\tthis._interval = window.setInterval($.proxy(this.refresh, this), this._core.settings.autoRefreshInterval);\\n\\t};\\n\\n\\t/**\\n\\t * Refreshes the element.\\n\\t */\\n\\tAutoRefresh.prototype.refresh = function() {\\n\\t\\tif (this._core.$element.is(':visible') === this._visible) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tthis._visible = !this._visible;\\n\\n\\t\\tthis._core.$element.toggleClass('owl-hidden', !this._visible);\\n\\n\\t\\tthis._visible && (this._core.invalidate('width') && this._core.refresh());\\n\\t};\\n\\n\\t/**\\n\\t * Destroys the plugin.\\n\\t */\\n\\tAutoRefresh.prototype.destroy = function() {\\n\\t\\tvar handler, property;\\n\\n\\t\\twindow.clearInterval(this._interval);\\n\\n\\t\\tfor (handler in this._handlers) {\\n\\t\\t\\tthis._core.$element.off(handler, this._handlers[handler]);\\n\\t\\t}\\n\\t\\tfor (property in Object.getOwnPropertyNames(this)) {\\n\\t\\t\\ttypeof this[property] != 'function' && (this[property] = null);\\n\\t\\t}\\n\\t};\\n\\n\\t$.fn.owlCarousel.Constructor.Plugins.AutoRefresh = AutoRefresh;\\n\\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\\n\\n/**\\n * Lazy Plugin\\n * @version 2.1.0\\n * @author Bartosz Wojciechowski\\n * @author David Deutsch\\n * @license The MIT License (MIT)\\n */\\n;(function($, window, document, undefined) {\\n\\n\\t/**\\n\\t * Creates the lazy plugin.\\n\\t * @class The Lazy Plugin\\n\\t * @param {Owl} carousel - The Owl Carousel\\n\\t */\\n\\tvar Lazy = function(carousel) {\\n\\n\\t\\t/**\\n\\t\\t * Reference to the core.\\n\\t\\t * @protected\\n\\t\\t * @type {Owl}\\n\\t\\t */\\n\\t\\tthis._core = carousel;\\n\\n\\t\\t/**\\n\\t\\t * Already loaded items.\\n\\t\\t * @protected\\n\\t\\t * @type {Array.<jQuery>}\\n\\t\\t */\\n\\t\\tthis._loaded = [];\\n\\n\\t\\t/**\\n\\t\\t * Event handlers.\\n\\t\\t * @protected\\n\\t\\t * @type {Object}\\n\\t\\t */\\n\\t\\tthis._handlers = {\\n\\t\\t\\t'initialized.owl.carousel change.owl.carousel resized.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (!e.namespace) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (!this._core.settings || !this._core.settings.lazyLoad) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ((e.property && e.property.name == 'position') || e.type == 'initialized') {\\n\\t\\t\\t\\t\\tvar settings = this._core.settings,\\n\\t\\t\\t\\t\\t\\tn = (settings.center && Math.ceil(settings.items / 2) || settings.items),\\n\\t\\t\\t\\t\\t\\ti = ((settings.center && n * -1) || 0),\\n\\t\\t\\t\\t\\t\\tposition = (e.property && e.property.value !== undefined ? e.property.value : this._core.current()) + i,\\n\\t\\t\\t\\t\\t\\tclones = this._core.clones().length,\\n\\t\\t\\t\\t\\t\\tload = $.proxy(function(i, v) { this.load(v) }, this);\\n\\n\\t\\t\\t\\t\\twhile (i++ < n) {\\n\\t\\t\\t\\t\\t\\tthis.load(clones / 2 + this._core.relative(position));\\n\\t\\t\\t\\t\\t\\tclones && $.each(this._core.clones(this._core.relative(position)), load);\\n\\t\\t\\t\\t\\t\\tposition++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this)\\n\\t\\t};\\n\\n\\t\\t// set the default options\\n\\t\\tthis._core.options = $.extend({}, Lazy.Defaults, this._core.options);\\n\\n\\t\\t// register event handler\\n\\t\\tthis._core.$element.on(this._handlers);\\n\\t};\\n\\n\\t/**\\n\\t * Default options.\\n\\t * @public\\n\\t */\\n\\tLazy.Defaults = {\\n\\t\\tlazyLoad: false\\n\\t};\\n\\n\\t/**\\n\\t * Loads all resources of an item at the specified position.\\n\\t * @param {Number} position - The absolute position of the item.\\n\\t * @protected\\n\\t */\\n\\tLazy.prototype.load = function(position) {\\n\\t\\tvar $item = this._core.$stage.children().eq(position),\\n\\t\\t\\t$elements = $item && $item.find('.owl-lazy');\\n\\n\\t\\tif (!$elements || $.inArray($item.get(0), this._loaded) > -1) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t$elements.each($.proxy(function(index, element) {\\n\\t\\t\\tvar $element = $(element), image,\\n\\t\\t\\t\\turl = (window.devicePixelRatio > 1 && $element.attr('data-src-retina')) || $element.attr('data-src');\\n\\n\\t\\t\\tthis._core.trigger('load', { element: $element, url: url }, 'lazy');\\n\\n\\t\\t\\tif ($element.is('img')) {\\n\\t\\t\\t\\t$element.one('load.owl.lazy', $.proxy(function() {\\n\\t\\t\\t\\t\\t$element.css('opacity', 1);\\n\\t\\t\\t\\t\\tthis._core.trigger('loaded', { element: $element, url: url }, 'lazy');\\n\\t\\t\\t\\t}, this)).attr('src', url);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\timage = new Image();\\n\\t\\t\\t\\timage.onload = $.proxy(function() {\\n\\t\\t\\t\\t\\t$element.css({\\n\\t\\t\\t\\t\\t\\t'background-image': 'url(' + url + ')',\\n\\t\\t\\t\\t\\t\\t'opacity': '1'\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\tthis._core.trigger('loaded', { element: $element, url: url }, 'lazy');\\n\\t\\t\\t\\t}, this);\\n\\t\\t\\t\\timage.src = url;\\n\\t\\t\\t}\\n\\t\\t}, this));\\n\\n\\t\\tthis._loaded.push($item.get(0));\\n\\t};\\n\\n\\t/**\\n\\t * Destroys the plugin.\\n\\t * @public\\n\\t */\\n\\tLazy.prototype.destroy = function() {\\n\\t\\tvar handler, property;\\n\\n\\t\\tfor (handler in this.handlers) {\\n\\t\\t\\tthis._core.$element.off(handler, this.handlers[handler]);\\n\\t\\t}\\n\\t\\tfor (property in Object.getOwnPropertyNames(this)) {\\n\\t\\t\\ttypeof this[property] != 'function' && (this[property] = null);\\n\\t\\t}\\n\\t};\\n\\n\\t$.fn.owlCarousel.Constructor.Plugins.Lazy = Lazy;\\n\\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\\n\\n/**\\n * AutoHeight Plugin\\n * @version 2.1.0\\n * @author Bartosz Wojciechowski\\n * @author David Deutsch\\n * @license The MIT License (MIT)\\n */\\n;(function($, window, document, undefined) {\\n\\n\\t/**\\n\\t * Creates the auto height plugin.\\n\\t * @class The Auto Height Plugin\\n\\t * @param {Owl} carousel - The Owl Carousel\\n\\t */\\n\\tvar AutoHeight = function(carousel) {\\n\\t\\t/**\\n\\t\\t * Reference to the core.\\n\\t\\t * @protected\\n\\t\\t * @type {Owl}\\n\\t\\t */\\n\\t\\tthis._core = carousel;\\n\\n\\t\\t/**\\n\\t\\t * All event handlers.\\n\\t\\t * @protected\\n\\t\\t * @type {Object}\\n\\t\\t */\\n\\t\\tthis._handlers = {\\n\\t\\t\\t'initialized.owl.carousel refreshed.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && this._core.settings.autoHeight) {\\n\\t\\t\\t\\t\\tthis.update();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'changed.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && this._core.settings.autoHeight && e.property.name == 'position'){\\n\\t\\t\\t\\t\\tthis.update();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'loaded.owl.lazy': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && this._core.settings.autoHeight\\n\\t\\t\\t\\t\\t&& e.element.closest('.' + this._core.settings.itemClass).index() === this._core.current()) {\\n\\t\\t\\t\\t\\tthis.update();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this)\\n\\t\\t};\\n\\n\\t\\t// set default options\\n\\t\\tthis._core.options = $.extend({}, AutoHeight.Defaults, this._core.options);\\n\\n\\t\\t// register event handlers\\n\\t\\tthis._core.$element.on(this._handlers);\\n\\t};\\n\\n\\t/**\\n\\t * Default options.\\n\\t * @public\\n\\t */\\n\\tAutoHeight.Defaults = {\\n\\t\\tautoHeight: false,\\n\\t\\tautoHeightClass: 'owl-height'\\n\\t};\\n\\n\\t/**\\n\\t * Updates the view.\\n\\t */\\n\\tAutoHeight.prototype.update = function() {\\n\\t\\tvar start = this._core._current,\\n\\t\\t\\tend = start + this._core.settings.items,\\n\\t\\t\\tvisible = this._core.$stage.children().toArray().slice(start, end),\\n\\t\\t\\theights = [],\\n\\t\\t\\tmaxheight = 0;\\n\\n\\t\\t$.each(visible, function(index, item) {\\n\\t\\t\\theights.push($(item).height());\\n\\t\\t});\\n\\n\\t\\tmaxheight = Math.max.apply(null, heights);\\n\\n\\t\\tthis._core.$stage.parent()\\n\\t\\t\\t.height(maxheight)\\n\\t\\t\\t.addClass(this._core.settings.autoHeightClass);\\n\\t};\\n\\n\\tAutoHeight.prototype.destroy = function() {\\n\\t\\tvar handler, property;\\n\\n\\t\\tfor (handler in this._handlers) {\\n\\t\\t\\tthis._core.$element.off(handler, this._handlers[handler]);\\n\\t\\t}\\n\\t\\tfor (property in Object.getOwnPropertyNames(this)) {\\n\\t\\t\\ttypeof this[property] != 'function' && (this[property] = null);\\n\\t\\t}\\n\\t};\\n\\n\\t$.fn.owlCarousel.Constructor.Plugins.AutoHeight = AutoHeight;\\n\\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\\n\\n/**\\n * Video Plugin\\n * @version 2.1.0\\n * @author Bartosz Wojciechowski\\n * @author David Deutsch\\n * @license The MIT License (MIT)\\n */\\n;(function($, window, document, undefined) {\\n\\n\\t/**\\n\\t * Creates the video plugin.\\n\\t * @class The Video Plugin\\n\\t * @param {Owl} carousel - The Owl Carousel\\n\\t */\\n\\tvar Video = function(carousel) {\\n\\t\\t/**\\n\\t\\t * Reference to the core.\\n\\t\\t * @protected\\n\\t\\t * @type {Owl}\\n\\t\\t */\\n\\t\\tthis._core = carousel;\\n\\n\\t\\t/**\\n\\t\\t * Cache all video URLs.\\n\\t\\t * @protected\\n\\t\\t * @type {Object}\\n\\t\\t */\\n\\t\\tthis._videos = {};\\n\\n\\t\\t/**\\n\\t\\t * Current playing item.\\n\\t\\t * @protected\\n\\t\\t * @type {jQuery}\\n\\t\\t */\\n\\t\\tthis._playing = null;\\n\\n\\t\\t/**\\n\\t\\t * All event handlers.\\n\\t\\t * @todo The cloned content removale is too late\\n\\t\\t * @protected\\n\\t\\t * @type {Object}\\n\\t\\t */\\n\\t\\tthis._handlers = {\\n\\t\\t\\t'initialized.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace) {\\n\\t\\t\\t\\t\\tthis._core.register({ type: 'state', name: 'playing', tags: [ 'interacting' ] });\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'resize.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && this._core.settings.video && this.isInFullScreen()) {\\n\\t\\t\\t\\t\\te.preventDefault();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'refreshed.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && this._core.is('resizing')) {\\n\\t\\t\\t\\t\\tthis._core.$stage.find('.cloned .owl-video-frame').remove();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'changed.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && e.property.name === 'position' && this._playing) {\\n\\t\\t\\t\\t\\tthis.stop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'prepared.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (!e.namespace) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar $element = $(e.content).find('.owl-video');\\n\\n\\t\\t\\t\\tif ($element.length) {\\n\\t\\t\\t\\t\\t$element.css('display', 'none');\\n\\t\\t\\t\\t\\tthis.fetch($element, $(e.content));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this)\\n\\t\\t};\\n\\n\\t\\t// set default options\\n\\t\\tthis._core.options = $.extend({}, Video.Defaults, this._core.options);\\n\\n\\t\\t// register event handlers\\n\\t\\tthis._core.$element.on(this._handlers);\\n\\n\\t\\tthis._core.$element.on('click.owl.video', '.owl-video-play-icon', $.proxy(function(e) {\\n\\t\\t\\tthis.play(e);\\n\\t\\t}, this));\\n\\t};\\n\\n\\t/**\\n\\t * Default options.\\n\\t * @public\\n\\t */\\n\\tVideo.Defaults = {\\n\\t\\tvideo: false,\\n\\t\\tvideoHeight: false,\\n\\t\\tvideoWidth: false\\n\\t};\\n\\n\\t/**\\n\\t * Gets the video ID and the type (YouTube/Vimeo/vzaar only).\\n\\t * @protected\\n\\t * @param {jQuery} target - The target containing the video data.\\n\\t * @param {jQuery} item - The item containing the video.\\n\\t */\\n\\tVideo.prototype.fetch = function(target, item) {\\n\\t\\t\\tvar type = (function() {\\n\\t\\t\\t\\t\\tif (target.attr('data-vimeo-id')) {\\n\\t\\t\\t\\t\\t\\treturn 'vimeo';\\n\\t\\t\\t\\t\\t} else if (target.attr('data-vzaar-id')) {\\n\\t\\t\\t\\t\\t\\treturn 'vzaar'\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\treturn 'youtube';\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t})(),\\n\\t\\t\\t\\tid = target.attr('data-vimeo-id') || target.attr('data-youtube-id') || target.attr('data-vzaar-id'),\\n\\t\\t\\t\\twidth = target.attr('data-width') || this._core.settings.videoWidth,\\n\\t\\t\\t\\theight = target.attr('data-height') || this._core.settings.videoHeight,\\n\\t\\t\\t\\turl = target.attr('href');\\n\\n\\t\\tif (url) {\\n\\n\\t\\t\\t/*\\n\\t\\t\\t\\t\\tParses the id's out of the following urls (and probably more):\\n\\t\\t\\t\\t\\thttps://www.youtube.com/watch?v=:id\\n\\t\\t\\t\\t\\thttps://youtu.be/:id\\n\\t\\t\\t\\t\\thttps://vimeo.com/:id\\n\\t\\t\\t\\t\\thttps://vimeo.com/channels/:channel/:id\\n\\t\\t\\t\\t\\thttps://vimeo.com/groups/:group/videos/:id\\n\\t\\t\\t\\t\\thttps://app.vzaar.com/videos/:id\\n\\n\\t\\t\\t\\t\\tVisual example: https://regexper.com/#(http%3A%7Chttps%3A%7C)%5C%2F%5C%2F(player.%7Cwww.%7Capp.)%3F(vimeo%5C.com%7Cyoutu(be%5C.com%7C%5C.be%7Cbe%5C.googleapis%5C.com)%7Cvzaar%5C.com)%5C%2F(video%5C%2F%7Cvideos%5C%2F%7Cembed%5C%2F%7Cchannels%5C%2F.%2B%5C%2F%7Cgroups%5C%2F.%2B%5C%2F%7Cwatch%5C%3Fv%3D%7Cv%5C%2F)%3F(%5BA-Za-z0-9._%25-%5D*)(%5C%26%5CS%2B)%3F\\n\\t\\t\\t*/\\n\\n\\t\\t\\tid = url.match(/(http:|https:|)\\\\/\\\\/(player.|www.|app.)?(vimeo\\\\.com|youtu(be\\\\.com|\\\\.be|be\\\\.googleapis\\\\.com)|vzaar\\\\.com)\\\\/(video\\\\/|videos\\\\/|embed\\\\/|channels\\\\/.+\\\\/|groups\\\\/.+\\\\/|watch\\\\?v=|v\\\\/)?([A-Za-z0-9._%-]*)(\\\\&\\\\S+)?/);\\n\\n\\t\\t\\tif (id[3].indexOf('youtu') > -1) {\\n\\t\\t\\t\\ttype = 'youtube';\\n\\t\\t\\t} else if (id[3].indexOf('vimeo') > -1) {\\n\\t\\t\\t\\ttype = 'vimeo';\\n\\t\\t\\t} else if (id[3].indexOf('vzaar') > -1) {\\n\\t\\t\\t\\ttype = 'vzaar';\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tthrow new Error('Video URL not supported.');\\n\\t\\t\\t}\\n\\t\\t\\tid = id[6];\\n\\t\\t} else {\\n\\t\\t\\tthrow new Error('Missing video URL.');\\n\\t\\t}\\n\\n\\t\\tthis._videos[url] = {\\n\\t\\t\\ttype: type,\\n\\t\\t\\tid: id,\\n\\t\\t\\twidth: width,\\n\\t\\t\\theight: height\\n\\t\\t};\\n\\n\\t\\titem.attr('data-video', url);\\n\\n\\t\\tthis.thumbnail(target, this._videos[url]);\\n\\t};\\n\\n\\t/**\\n\\t * Creates video thumbnail.\\n\\t * @protected\\n\\t * @param {jQuery} target - The target containing the video data.\\n\\t * @param {Object} info - The video info object.\\n\\t * @see `fetch`\\n\\t */\\n\\tVideo.prototype.thumbnail = function(target, video) {\\n\\t\\tvar tnLink,\\n\\t\\t\\ticon,\\n\\t\\t\\tpath,\\n\\t\\t\\tdimensions = video.width && video.height ? 'style=\\\"width:' + video.width + 'px;height:' + video.height + 'px;\\\"' : '',\\n\\t\\t\\tcustomTn = target.find('img'),\\n\\t\\t\\tsrcType = 'src',\\n\\t\\t\\tlazyClass = '',\\n\\t\\t\\tsettings = this._core.settings,\\n\\t\\t\\tcreate = function(path) {\\n\\t\\t\\t\\ticon = '<div class=\\\"owl-video-play-icon\\\"></div>';\\n\\n\\t\\t\\t\\tif (settings.lazyLoad) {\\n\\t\\t\\t\\t\\ttnLink = '<div class=\\\"owl-video-tn ' + lazyClass + '\\\" ' + srcType + '=\\\"' + path + '\\\"></div>';\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ttnLink = '<div class=\\\"owl-video-tn\\\" style=\\\"opacity:1;background-image:url(' + path + ')\\\"></div>';\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttarget.after(tnLink);\\n\\t\\t\\t\\ttarget.after(icon);\\n\\t\\t\\t};\\n\\n\\t\\t// wrap video content into owl-video-wrapper div\\n\\t\\ttarget.wrap('<div class=\\\"owl-video-wrapper\\\"' + dimensions + '></div>');\\n\\n\\t\\tif (this._core.settings.lazyLoad) {\\n\\t\\t\\tsrcType = 'data-src';\\n\\t\\t\\tlazyClass = 'owl-lazy';\\n\\t\\t}\\n\\n\\t\\t// custom thumbnail\\n\\t\\tif (customTn.length) {\\n\\t\\t\\tcreate(customTn.attr(srcType));\\n\\t\\t\\tcustomTn.remove();\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tif (video.type === 'youtube') {\\n\\t\\t\\tpath = \\\"//img.youtube.com/vi/\\\" + video.id + \\\"/hqdefault.jpg\\\";\\n\\t\\t\\tcreate(path);\\n\\t\\t} else if (video.type === 'vimeo') {\\n\\t\\t\\t$.ajax({\\n\\t\\t\\t\\ttype: 'GET',\\n\\t\\t\\t\\turl: '//vimeo.com/api/v2/video/' + video.id + '.json',\\n\\t\\t\\t\\tjsonp: 'callback',\\n\\t\\t\\t\\tdataType: 'jsonp',\\n\\t\\t\\t\\tsuccess: function(data) {\\n\\t\\t\\t\\t\\tpath = data[0].thumbnail_large;\\n\\t\\t\\t\\t\\tcreate(path);\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t} else if (video.type === 'vzaar') {\\n\\t\\t\\t$.ajax({\\n\\t\\t\\t\\ttype: 'GET',\\n\\t\\t\\t\\turl: '//vzaar.com/api/videos/' + video.id + '.json',\\n\\t\\t\\t\\tjsonp: 'callback',\\n\\t\\t\\t\\tdataType: 'jsonp',\\n\\t\\t\\t\\tsuccess: function(data) {\\n\\t\\t\\t\\t\\tpath = data.framegrab_url;\\n\\t\\t\\t\\t\\tcreate(path);\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Stops the current video.\\n\\t * @public\\n\\t */\\n\\tVideo.prototype.stop = function() {\\n\\t\\tthis._core.trigger('stop', null, 'video');\\n\\t\\tthis._playing.find('.owl-video-frame').remove();\\n\\t\\tthis._playing.removeClass('owl-video-playing');\\n\\t\\tthis._playing = null;\\n\\t\\tthis._core.leave('playing');\\n\\t\\tthis._core.trigger('stopped', null, 'video');\\n\\t};\\n\\n\\t/**\\n\\t * Starts the current video.\\n\\t * @public\\n\\t * @param {Event} event - The event arguments.\\n\\t */\\n\\tVideo.prototype.play = function(event) {\\n\\t\\tvar target = $(event.target),\\n\\t\\t\\titem = target.closest('.' + this._core.settings.itemClass),\\n\\t\\t\\tvideo = this._videos[item.attr('data-video')],\\n\\t\\t\\twidth = video.width || '100%',\\n\\t\\t\\theight = video.height || this._core.$stage.height(),\\n\\t\\t\\thtml;\\n\\n\\t\\tif (this._playing) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tthis._core.enter('playing');\\n\\t\\tthis._core.trigger('play', null, 'video');\\n\\n\\t\\titem = this._core.items(this._core.relative(item.index()));\\n\\n\\t\\tthis._core.reset(item.index());\\n\\n\\t\\tif (video.type === 'youtube') {\\n\\t\\t\\thtml = '<iframe width=\\\"' + width + '\\\" height=\\\"' + height + '\\\" src=\\\"//www.youtube.com/embed/' +\\n\\t\\t\\t\\tvideo.id + '?autoplay=1&v=' + video.id + '\\\" frameborder=\\\"0\\\" allowfullscreen></iframe>';\\n\\t\\t} else if (video.type === 'vimeo') {\\n\\t\\t\\thtml = '<iframe src=\\\"//player.vimeo.com/video/' + video.id +\\n\\t\\t\\t\\t'?autoplay=1\\\" width=\\\"' + width + '\\\" height=\\\"' + height +\\n\\t\\t\\t\\t'\\\" frameborder=\\\"0\\\" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>';\\n\\t\\t} else if (video.type === 'vzaar') {\\n\\t\\t\\thtml = '<iframe frameborder=\\\"0\\\"' + 'height=\\\"' + height + '\\\"' + 'width=\\\"' + width +\\n\\t\\t\\t\\t'\\\" allowfullscreen mozallowfullscreen webkitAllowFullScreen ' +\\n\\t\\t\\t\\t'src=\\\"//view.vzaar.com/' + video.id + '/player?autoplay=true\\\"></iframe>';\\n\\t\\t}\\n\\n\\t\\t$('<div class=\\\"owl-video-frame\\\">' + html + '</div>').insertAfter(item.find('.owl-video'));\\n\\n\\t\\tthis._playing = item.addClass('owl-video-playing');\\n\\t};\\n\\n\\t/**\\n\\t * Checks whether an video is currently in full screen mode or not.\\n\\t * @todo Bad style because looks like a readonly method but changes members.\\n\\t * @protected\\n\\t * @returns {Boolean}\\n\\t */\\n\\tVideo.prototype.isInFullScreen = function() {\\n\\t\\tvar element = document.fullscreenElement || document.mozFullScreenElement ||\\n\\t\\t\\t\\tdocument.webkitFullscreenElement;\\n\\n\\t\\treturn element && $(element).parent().hasClass('owl-video-frame');\\n\\t};\\n\\n\\t/**\\n\\t * Destroys the plugin.\\n\\t */\\n\\tVideo.prototype.destroy = function() {\\n\\t\\tvar handler, property;\\n\\n\\t\\tthis._core.$element.off('click.owl.video');\\n\\n\\t\\tfor (handler in this._handlers) {\\n\\t\\t\\tthis._core.$element.off(handler, this._handlers[handler]);\\n\\t\\t}\\n\\t\\tfor (property in Object.getOwnPropertyNames(this)) {\\n\\t\\t\\ttypeof this[property] != 'function' && (this[property] = null);\\n\\t\\t}\\n\\t};\\n\\n\\t$.fn.owlCarousel.Constructor.Plugins.Video = Video;\\n\\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\\n\\n/**\\n * Animate Plugin\\n * @version 2.1.0\\n * @author Bartosz Wojciechowski\\n * @author David Deutsch\\n * @license The MIT License (MIT)\\n */\\n;(function($, window, document, undefined) {\\n\\n\\t/**\\n\\t * Creates the animate plugin.\\n\\t * @class The Navigation Plugin\\n\\t * @param {Owl} scope - The Owl Carousel\\n\\t */\\n\\tvar Animate = function(scope) {\\n\\t\\tthis.core = scope;\\n\\t\\tthis.core.options = $.extend({}, Animate.Defaults, this.core.options);\\n\\t\\tthis.swapping = true;\\n\\t\\tthis.previous = undefined;\\n\\t\\tthis.next = undefined;\\n\\n\\t\\tthis.handlers = {\\n\\t\\t\\t'change.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && e.property.name == 'position') {\\n\\t\\t\\t\\t\\tthis.previous = this.core.current();\\n\\t\\t\\t\\t\\tthis.next = e.property.value;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'drag.owl.carousel dragged.owl.carousel translated.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace) {\\n\\t\\t\\t\\t\\tthis.swapping = e.type == 'translated';\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'translate.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && this.swapping && (this.core.options.animateOut || this.core.options.animateIn)) {\\n\\t\\t\\t\\t\\tthis.swap();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this)\\n\\t\\t};\\n\\n\\t\\tthis.core.$element.on(this.handlers);\\n\\t};\\n\\n\\t/**\\n\\t * Default options.\\n\\t * @public\\n\\t */\\n\\tAnimate.Defaults = {\\n\\t\\tanimateOut: false,\\n\\t\\tanimateIn: false\\n\\t};\\n\\n\\t/**\\n\\t * Toggles the animation classes whenever an translations starts.\\n\\t * @protected\\n\\t * @returns {Boolean|undefined}\\n\\t */\\n\\tAnimate.prototype.swap = function() {\\n\\n\\t\\tif (this.core.settings.items !== 1) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif (!$.support.animation || !$.support.transition) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tthis.core.speed(0);\\n\\n\\t\\tvar left,\\n\\t\\t\\tclear = $.proxy(this.clear, this),\\n\\t\\t\\tprevious = this.core.$stage.children().eq(this.previous),\\n\\t\\t\\tnext = this.core.$stage.children().eq(this.next),\\n\\t\\t\\tincoming = this.core.settings.animateIn,\\n\\t\\t\\toutgoing = this.core.settings.animateOut;\\n\\n\\t\\tif (this.core.current() === this.previous) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif (outgoing) {\\n\\t\\t\\tleft = this.core.coordinates(this.previous) - this.core.coordinates(this.next);\\n\\t\\t\\tprevious.one($.support.animation.end, clear)\\n\\t\\t\\t\\t.css( { 'left': left + 'px' } )\\n\\t\\t\\t\\t.addClass('animated owl-animated-out')\\n\\t\\t\\t\\t.addClass(outgoing);\\n\\t\\t}\\n\\n\\t\\tif (incoming) {\\n\\t\\t\\tnext.one($.support.animation.end, clear)\\n\\t\\t\\t\\t.addClass('animated owl-animated-in')\\n\\t\\t\\t\\t.addClass(incoming);\\n\\t\\t}\\n\\t};\\n\\n\\tAnimate.prototype.clear = function(e) {\\n\\t\\t$(e.target).css( { 'left': '' } )\\n\\t\\t\\t.removeClass('animated owl-animated-out owl-animated-in')\\n\\t\\t\\t.removeClass(this.core.settings.animateIn)\\n\\t\\t\\t.removeClass(this.core.settings.animateOut);\\n\\t\\tthis.core.onTransitionEnd();\\n\\t};\\n\\n\\t/**\\n\\t * Destroys the plugin.\\n\\t * @public\\n\\t */\\n\\tAnimate.prototype.destroy = function() {\\n\\t\\tvar handler, property;\\n\\n\\t\\tfor (handler in this.handlers) {\\n\\t\\t\\tthis.core.$element.off(handler, this.handlers[handler]);\\n\\t\\t}\\n\\t\\tfor (property in Object.getOwnPropertyNames(this)) {\\n\\t\\t\\ttypeof this[property] != 'function' && (this[property] = null);\\n\\t\\t}\\n\\t};\\n\\n\\t$.fn.owlCarousel.Constructor.Plugins.Animate = Animate;\\n\\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\\n\\n/**\\n * Autoplay Plugin\\n * @version 2.1.0\\n * @author Bartosz Wojciechowski\\n * @author Artus Kolanowski\\n * @author David Deutsch\\n * @license The MIT License (MIT)\\n */\\n;(function($, window, document, undefined) {\\n\\n\\t/**\\n\\t * Creates the autoplay plugin.\\n\\t * @class The Autoplay Plugin\\n\\t * @param {Owl} scope - The Owl Carousel\\n\\t */\\n\\tvar Autoplay = function(carousel) {\\n\\t\\t/**\\n\\t\\t * Reference to the core.\\n\\t\\t * @protected\\n\\t\\t * @type {Owl}\\n\\t\\t */\\n\\t\\tthis._core = carousel;\\n\\n\\t\\t/**\\n\\t\\t * The autoplay timeout.\\n\\t\\t * @type {Timeout}\\n\\t\\t */\\n\\t\\tthis._timeout = null;\\n\\n\\t\\t/**\\n\\t\\t * Indicates whenever the autoplay is paused.\\n\\t\\t * @type {Boolean}\\n\\t\\t */\\n\\t\\tthis._paused = false;\\n\\n\\t\\t/**\\n\\t\\t * All event handlers.\\n\\t\\t * @protected\\n\\t\\t * @type {Object}\\n\\t\\t */\\n\\t\\tthis._handlers = {\\n\\t\\t\\t'changed.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && e.property.name === 'settings') {\\n\\t\\t\\t\\t\\tif (this._core.settings.autoplay) {\\n\\t\\t\\t\\t\\t\\tthis.play();\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tthis.stop();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else if (e.namespace && e.property.name === 'position') {\\n\\t\\t\\t\\t\\t//console.log('play?', e);\\n\\t\\t\\t\\t\\tif (this._core.settings.autoplay) {\\n\\t\\t\\t\\t\\t\\tthis._setAutoPlayInterval();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'initialized.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && this._core.settings.autoplay) {\\n\\t\\t\\t\\t\\tthis.play();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'play.owl.autoplay': $.proxy(function(e, t, s) {\\n\\t\\t\\t\\tif (e.namespace) {\\n\\t\\t\\t\\t\\tthis.play(t, s);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'stop.owl.autoplay': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace) {\\n\\t\\t\\t\\t\\tthis.stop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'mouseover.owl.autoplay': $.proxy(function() {\\n\\t\\t\\t\\tif (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {\\n\\t\\t\\t\\t\\tthis.pause();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'mouseleave.owl.autoplay': $.proxy(function() {\\n\\t\\t\\t\\tif (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {\\n\\t\\t\\t\\t\\tthis.play();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'touchstart.owl.core': $.proxy(function() {\\n\\t\\t\\t\\tif (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {\\n\\t\\t\\t\\t\\tthis.pause();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'touchend.owl.core': $.proxy(function() {\\n\\t\\t\\t\\tif (this._core.settings.autoplayHoverPause) {\\n\\t\\t\\t\\t\\tthis.play();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this)\\n\\t\\t};\\n\\n\\t\\t// register event handlers\\n\\t\\tthis._core.$element.on(this._handlers);\\n\\n\\t\\t// set default options\\n\\t\\tthis._core.options = $.extend({}, Autoplay.Defaults, this._core.options);\\n\\t};\\n\\n\\t/**\\n\\t * Default options.\\n\\t * @public\\n\\t */\\n\\tAutoplay.Defaults = {\\n\\t\\tautoplay: false,\\n\\t\\tautoplayTimeout: 5000,\\n\\t\\tautoplayHoverPause: false,\\n\\t\\tautoplaySpeed: false\\n\\t};\\n\\n\\t/**\\n\\t * Starts the autoplay.\\n\\t * @public\\n\\t * @param {Number} [timeout] - The interval before the next animation starts.\\n\\t * @param {Number} [speed] - The animation speed for the animations.\\n\\t */\\n\\tAutoplay.prototype.play = function(timeout, speed) {\\n\\t\\tthis._paused = false;\\n\\n\\t\\tif (this._core.is('rotating')) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tthis._core.enter('rotating');\\n\\n\\t\\tthis._setAutoPlayInterval();\\n\\t};\\n\\n\\t/**\\n\\t * Gets a new timeout\\n\\t * @private\\n\\t * @param {Number} [timeout] - The interval before the next animation starts.\\n\\t * @param {Number} [speed] - The animation speed for the animations.\\n\\t * @return {Timeout}\\n\\t */\\n\\tAutoplay.prototype._getNextTimeout = function(timeout, speed) {\\n\\t\\tif ( this._timeout ) {\\n\\t\\t\\twindow.clearTimeout(this._timeout);\\n\\t\\t}\\n\\t\\treturn window.setTimeout($.proxy(function() {\\n\\t\\t\\tif (this._paused || this._core.is('busy') || this._core.is('interacting') || document.hidden) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tthis._core.next(speed || this._core.settings.autoplaySpeed);\\n\\t\\t}, this), timeout || this._core.settings.autoplayTimeout);\\n\\t};\\n\\n\\t/**\\n\\t * Sets autoplay in motion.\\n\\t * @private\\n\\t */\\n\\tAutoplay.prototype._setAutoPlayInterval = function() {\\n\\t\\tthis._timeout = this._getNextTimeout();\\n\\t};\\n\\n\\t/**\\n\\t * Stops the autoplay.\\n\\t * @public\\n\\t */\\n\\tAutoplay.prototype.stop = function() {\\n\\t\\tif (!this._core.is('rotating')) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\twindow.clearTimeout(this._timeout);\\n\\t\\tthis._core.leave('rotating');\\n\\t};\\n\\n\\t/**\\n\\t * Stops the autoplay.\\n\\t * @public\\n\\t */\\n\\tAutoplay.prototype.pause = function() {\\n\\t\\tif (!this._core.is('rotating')) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tthis._paused = true;\\n\\t};\\n\\n\\t/**\\n\\t * Destroys the plugin.\\n\\t */\\n\\tAutoplay.prototype.destroy = function() {\\n\\t\\tvar handler, property;\\n\\n\\t\\tthis.stop();\\n\\n\\t\\tfor (handler in this._handlers) {\\n\\t\\t\\tthis._core.$element.off(handler, this._handlers[handler]);\\n\\t\\t}\\n\\t\\tfor (property in Object.getOwnPropertyNames(this)) {\\n\\t\\t\\ttypeof this[property] != 'function' && (this[property] = null);\\n\\t\\t}\\n\\t};\\n\\n\\t$.fn.owlCarousel.Constructor.Plugins.autoplay = Autoplay;\\n\\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\\n\\n/**\\n * Navigation Plugin\\n * @version 2.1.0\\n * @author Artus Kolanowski\\n * @author David Deutsch\\n * @license The MIT License (MIT)\\n */\\n;(function($, window, document, undefined) {\\n\\t'use strict';\\n\\n\\t/**\\n\\t * Creates the navigation plugin.\\n\\t * @class The Navigation Plugin\\n\\t * @param {Owl} carousel - The Owl Carousel.\\n\\t */\\n\\tvar Navigation = function(carousel) {\\n\\t\\t/**\\n\\t\\t * Reference to the core.\\n\\t\\t * @protected\\n\\t\\t * @type {Owl}\\n\\t\\t */\\n\\t\\tthis._core = carousel;\\n\\n\\t\\t/**\\n\\t\\t * Indicates whether the plugin is initialized or not.\\n\\t\\t * @protected\\n\\t\\t * @type {Boolean}\\n\\t\\t */\\n\\t\\tthis._initialized = false;\\n\\n\\t\\t/**\\n\\t\\t * The current paging indexes.\\n\\t\\t * @protected\\n\\t\\t * @type {Array}\\n\\t\\t */\\n\\t\\tthis._pages = [];\\n\\n\\t\\t/**\\n\\t\\t * All DOM elements of the user interface.\\n\\t\\t * @protected\\n\\t\\t * @type {Object}\\n\\t\\t */\\n\\t\\tthis._controls = {};\\n\\n\\t\\t/**\\n\\t\\t * Markup for an indicator.\\n\\t\\t * @protected\\n\\t\\t * @type {Array.<String>}\\n\\t\\t */\\n\\t\\tthis._templates = [];\\n\\n\\t\\t/**\\n\\t\\t * The carousel element.\\n\\t\\t * @type {jQuery}\\n\\t\\t */\\n\\t\\tthis.$element = this._core.$element;\\n\\n\\t\\t/**\\n\\t\\t * Overridden methods of the carousel.\\n\\t\\t * @protected\\n\\t\\t * @type {Object}\\n\\t\\t */\\n\\t\\tthis._overrides = {\\n\\t\\t\\tnext: this._core.next,\\n\\t\\t\\tprev: this._core.prev,\\n\\t\\t\\tto: this._core.to\\n\\t\\t};\\n\\n\\t\\t/**\\n\\t\\t * All event handlers.\\n\\t\\t * @protected\\n\\t\\t * @type {Object}\\n\\t\\t */\\n\\t\\tthis._handlers = {\\n\\t\\t\\t'prepared.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && this._core.settings.dotsData) {\\n\\t\\t\\t\\t\\tthis._templates.push('<div class=\\\"' + this._core.settings.dotClass + '\\\">' +\\n\\t\\t\\t\\t\\t\\t$(e.content).find('[data-dot]').addBack('[data-dot]').attr('data-dot') + '</div>');\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'added.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && this._core.settings.dotsData) {\\n\\t\\t\\t\\t\\tthis._templates.splice(e.position, 0, this._templates.pop());\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'remove.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && this._core.settings.dotsData) {\\n\\t\\t\\t\\t\\tthis._templates.splice(e.position, 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'changed.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && e.property.name == 'position') {\\n\\t\\t\\t\\t\\tthis.draw();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'initialized.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && !this._initialized) {\\n\\t\\t\\t\\t\\tthis._core.trigger('initialize', null, 'navigation');\\n\\t\\t\\t\\t\\tthis.initialize();\\n\\t\\t\\t\\t\\tthis.update();\\n\\t\\t\\t\\t\\tthis.draw();\\n\\t\\t\\t\\t\\tthis._initialized = true;\\n\\t\\t\\t\\t\\tthis._core.trigger('initialized', null, 'navigation');\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'refreshed.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && this._initialized) {\\n\\t\\t\\t\\t\\tthis._core.trigger('refresh', null, 'navigation');\\n\\t\\t\\t\\t\\tthis.update();\\n\\t\\t\\t\\t\\tthis.draw();\\n\\t\\t\\t\\t\\tthis._core.trigger('refreshed', null, 'navigation');\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this)\\n\\t\\t};\\n\\n\\t\\t// set default options\\n\\t\\tthis._core.options = $.extend({}, Navigation.Defaults, this._core.options);\\n\\n\\t\\t// register event handlers\\n\\t\\tthis.$element.on(this._handlers);\\n\\t};\\n\\n\\t/**\\n\\t * Default options.\\n\\t * @public\\n\\t * @todo Rename `slideBy` to `navBy`\\n\\t */\\n\\tNavigation.Defaults = {\\n\\t\\tnav: false,\\n\\t\\tnavText: [ 'prev', 'next' ],\\n\\t\\tnavSpeed: false,\\n\\t\\tnavElement: 'div',\\n\\t\\tnavContainer: false,\\n\\t\\tnavContainerClass: 'owl-nav',\\n\\t\\tnavClass: [ 'owl-prev', 'owl-next' ],\\n\\t\\tslideBy: 1,\\n\\t\\tdotClass: 'owl-dot',\\n\\t\\tdotsClass: 'owl-dots',\\n\\t\\tdots: true,\\n\\t\\tdotsEach: false,\\n\\t\\tdotsData: false,\\n\\t\\tdotsSpeed: false,\\n\\t\\tdotsContainer: false\\n\\t};\\n\\n\\t/**\\n\\t * Initializes the layout of the plugin and extends the carousel.\\n\\t * @protected\\n\\t */\\n\\tNavigation.prototype.initialize = function() {\\n\\t\\tvar override,\\n\\t\\t\\tsettings = this._core.settings;\\n\\n\\t\\t// create DOM structure for relative navigation\\n\\t\\tthis._controls.$relative = (settings.navContainer ? $(settings.navContainer)\\n\\t\\t\\t: $('<div>').addClass(settings.navContainerClass).appendTo(this.$element)).addClass('disabled');\\n\\n\\t\\tthis._controls.$previous = $('<' + settings.navElement + '>')\\n\\t\\t\\t.addClass(settings.navClass[0])\\n\\t\\t\\t.html(settings.navText[0])\\n\\t\\t\\t.prependTo(this._controls.$relative)\\n\\t\\t\\t.on('click', $.proxy(function(e) {\\n\\t\\t\\t\\tthis.prev(settings.navSpeed);\\n\\t\\t\\t}, this));\\n\\t\\tthis._controls.$next = $('<' + settings.navElement + '>')\\n\\t\\t\\t.addClass(settings.navClass[1])\\n\\t\\t\\t.html(settings.navText[1])\\n\\t\\t\\t.appendTo(this._controls.$relative)\\n\\t\\t\\t.on('click', $.proxy(function(e) {\\n\\t\\t\\t\\tthis.next(settings.navSpeed);\\n\\t\\t\\t}, this));\\n\\n\\t\\t// create DOM structure for absolute navigation\\n\\t\\tif (!settings.dotsData) {\\n\\t\\t\\tthis._templates = [ $('<div>')\\n\\t\\t\\t\\t.addClass(settings.dotClass)\\n\\t\\t\\t\\t.append($('<span>'))\\n\\t\\t\\t\\t.prop('outerHTML') ];\\n\\t\\t}\\n\\n\\t\\tthis._controls.$absolute = (settings.dotsContainer ? $(settings.dotsContainer)\\n\\t\\t\\t: $('<div>').addClass(settings.dotsClass).appendTo(this.$element)).addClass('disabled');\\n\\n\\t\\tthis._controls.$absolute.on('click', 'div', $.proxy(function(e) {\\n\\t\\t\\tvar index = $(e.target).parent().is(this._controls.$absolute)\\n\\t\\t\\t\\t? $(e.target).index() : $(e.target).parent().index();\\n\\n\\t\\t\\te.preventDefault();\\n\\n\\t\\t\\tthis.to(index, settings.dotsSpeed);\\n\\t\\t}, this));\\n\\n\\t\\t// override public methods of the carousel\\n\\t\\tfor (override in this._overrides) {\\n\\t\\t\\tthis._core[override] = $.proxy(this[override], this);\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Destroys the plugin.\\n\\t * @protected\\n\\t */\\n\\tNavigation.prototype.destroy = function() {\\n\\t\\tvar handler, control, property, override;\\n\\n\\t\\tfor (handler in this._handlers) {\\n\\t\\t\\tthis.$element.off(handler, this._handlers[handler]);\\n\\t\\t}\\n\\t\\tfor (control in this._controls) {\\n\\t\\t\\tthis._controls[control].remove();\\n\\t\\t}\\n\\t\\tfor (override in this.overides) {\\n\\t\\t\\tthis._core[override] = this._overrides[override];\\n\\t\\t}\\n\\t\\tfor (property in Object.getOwnPropertyNames(this)) {\\n\\t\\t\\ttypeof this[property] != 'function' && (this[property] = null);\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Updates the internal state.\\n\\t * @protected\\n\\t */\\n\\tNavigation.prototype.update = function() {\\n\\t\\tvar i, j, k,\\n\\t\\t\\tlower = this._core.clones().length / 2,\\n\\t\\t\\tupper = lower + this._core.items().length,\\n\\t\\t\\tmaximum = this._core.maximum(true),\\n\\t\\t\\tsettings = this._core.settings,\\n\\t\\t\\tsize = settings.center || settings.autoWidth || settings.dotsData\\n\\t\\t\\t\\t? 1 : settings.dotsEach || settings.items;\\n\\n\\t\\tif (settings.slideBy !== 'page') {\\n\\t\\t\\tsettings.slideBy = Math.min(settings.slideBy, settings.items);\\n\\t\\t}\\n\\n\\t\\tif (settings.dots || settings.slideBy == 'page') {\\n\\t\\t\\tthis._pages = [];\\n\\n\\t\\t\\tfor (i = lower, j = 0, k = 0; i < upper; i++) {\\n\\t\\t\\t\\tif (j >= size || j === 0) {\\n\\t\\t\\t\\t\\tthis._pages.push({\\n\\t\\t\\t\\t\\t\\tstart: Math.min(maximum, i - lower),\\n\\t\\t\\t\\t\\t\\tend: i - lower + size - 1\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\tif (Math.min(maximum, i - lower) === maximum) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tj = 0, ++k;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tj += this._core.mergers(this._core.relative(i));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Draws the user interface.\\n\\t * @todo The option `dotsData` wont work.\\n\\t * @protected\\n\\t */\\n\\tNavigation.prototype.draw = function() {\\n\\t\\tvar difference,\\n\\t\\t\\tsettings = this._core.settings,\\n\\t\\t\\tdisabled = this._core.items().length <= settings.items,\\n\\t\\t\\tindex = this._core.relative(this._core.current()),\\n\\t\\t\\tloop = settings.loop || settings.rewind;\\n\\n\\t\\tthis._controls.$relative.toggleClass('disabled', !settings.nav || disabled);\\n\\n\\t\\tif (settings.nav) {\\n\\t\\t\\tthis._controls.$previous.toggleClass('disabled', !loop && index <= this._core.minimum(true));\\n\\t\\t\\tthis._controls.$next.toggleClass('disabled', !loop && index >= this._core.maximum(true));\\n\\t\\t}\\n\\n\\t\\tthis._controls.$absolute.toggleClass('disabled', !settings.dots || disabled);\\n\\n\\t\\tif (settings.dots) {\\n\\t\\t\\tdifference = this._pages.length - this._controls.$absolute.children().length;\\n\\n\\t\\t\\tif (settings.dotsData && difference !== 0) {\\n\\t\\t\\t\\tthis._controls.$absolute.html(this._templates.join(''));\\n\\t\\t\\t} else if (difference > 0) {\\n\\t\\t\\t\\tthis._controls.$absolute.append(new Array(difference + 1).join(this._templates[0]));\\n\\t\\t\\t} else if (difference < 0) {\\n\\t\\t\\t\\tthis._controls.$absolute.children().slice(difference).remove();\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis._controls.$absolute.find('.active').removeClass('active');\\n\\t\\t\\tthis._controls.$absolute.children().eq($.inArray(this.current(), this._pages)).addClass('active');\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Extends event data.\\n\\t * @protected\\n\\t * @param {Event} event - The event object which gets thrown.\\n\\t */\\n\\tNavigation.prototype.onTrigger = function(event) {\\n\\t\\tvar settings = this._core.settings;\\n\\n\\t\\tevent.page = {\\n\\t\\t\\tindex: $.inArray(this.current(), this._pages),\\n\\t\\t\\tcount: this._pages.length,\\n\\t\\t\\tsize: settings && (settings.center || settings.autoWidth || settings.dotsData\\n\\t\\t\\t\\t? 1 : settings.dotsEach || settings.items)\\n\\t\\t};\\n\\t};\\n\\n\\t/**\\n\\t * Gets the current page position of the carousel.\\n\\t * @protected\\n\\t * @returns {Number}\\n\\t */\\n\\tNavigation.prototype.current = function() {\\n\\t\\tvar current = this._core.relative(this._core.current());\\n\\t\\treturn $.grep(this._pages, $.proxy(function(page, index) {\\n\\t\\t\\treturn page.start <= current && page.end >= current;\\n\\t\\t}, this)).pop();\\n\\t};\\n\\n\\t/**\\n\\t * Gets the current succesor/predecessor position.\\n\\t * @protected\\n\\t * @returns {Number}\\n\\t */\\n\\tNavigation.prototype.getPosition = function(successor) {\\n\\t\\tvar position, length,\\n\\t\\t\\tsettings = this._core.settings;\\n\\n\\t\\tif (settings.slideBy == 'page') {\\n\\t\\t\\tposition = $.inArray(this.current(), this._pages);\\n\\t\\t\\tlength = this._pages.length;\\n\\t\\t\\tsuccessor ? ++position : --position;\\n\\t\\t\\tposition = this._pages[((position % length) + length) % length].start;\\n\\t\\t} else {\\n\\t\\t\\tposition = this._core.relative(this._core.current());\\n\\t\\t\\tlength = this._core.items().length;\\n\\t\\t\\tsuccessor ? position += settings.slideBy : position -= settings.slideBy;\\n\\t\\t}\\n\\n\\t\\treturn position;\\n\\t};\\n\\n\\t/**\\n\\t * Slides to the next item or page.\\n\\t * @public\\n\\t * @param {Number} [speed=false] - The time in milliseconds for the transition.\\n\\t */\\n\\tNavigation.prototype.next = function(speed) {\\n\\t\\t$.proxy(this._overrides.to, this._core)(this.getPosition(true), speed);\\n\\t};\\n\\n\\t/**\\n\\t * Slides to the previous item or page.\\n\\t * @public\\n\\t * @param {Number} [speed=false] - The time in milliseconds for the transition.\\n\\t */\\n\\tNavigation.prototype.prev = function(speed) {\\n\\t\\t$.proxy(this._overrides.to, this._core)(this.getPosition(false), speed);\\n\\t};\\n\\n\\t/**\\n\\t * Slides to the specified item or page.\\n\\t * @public\\n\\t * @param {Number} position - The position of the item or page.\\n\\t * @param {Number} [speed] - The time in milliseconds for the transition.\\n\\t * @param {Boolean} [standard=false] - Whether to use the standard behaviour or not.\\n\\t */\\n\\tNavigation.prototype.to = function(position, speed, standard) {\\n\\t\\tvar length;\\n\\n\\t\\tif (!standard && this._pages.length) {\\n\\t\\t\\tlength = this._pages.length;\\n\\t\\t\\t$.proxy(this._overrides.to, this._core)(this._pages[((position % length) + length) % length].start, speed);\\n\\t\\t} else {\\n\\t\\t\\t$.proxy(this._overrides.to, this._core)(position, speed);\\n\\t\\t}\\n\\t};\\n\\n\\t$.fn.owlCarousel.Constructor.Plugins.Navigation = Navigation;\\n\\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\\n\\n/**\\n * Hash Plugin\\n * @version 2.1.0\\n * @author Artus Kolanowski\\n * @author David Deutsch\\n * @license The MIT License (MIT)\\n */\\n;(function($, window, document, undefined) {\\n\\t'use strict';\\n\\n\\t/**\\n\\t * Creates the hash plugin.\\n\\t * @class The Hash Plugin\\n\\t * @param {Owl} carousel - The Owl Carousel\\n\\t */\\n\\tvar Hash = function(carousel) {\\n\\t\\t/**\\n\\t\\t * Reference to the core.\\n\\t\\t * @protected\\n\\t\\t * @type {Owl}\\n\\t\\t */\\n\\t\\tthis._core = carousel;\\n\\n\\t\\t/**\\n\\t\\t * Hash index for the items.\\n\\t\\t * @protected\\n\\t\\t * @type {Object}\\n\\t\\t */\\n\\t\\tthis._hashes = {};\\n\\n\\t\\t/**\\n\\t\\t * The carousel element.\\n\\t\\t * @type {jQuery}\\n\\t\\t */\\n\\t\\tthis.$element = this._core.$element;\\n\\n\\t\\t/**\\n\\t\\t * All event handlers.\\n\\t\\t * @protected\\n\\t\\t * @type {Object}\\n\\t\\t */\\n\\t\\tthis._handlers = {\\n\\t\\t\\t'initialized.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && this._core.settings.startPosition === 'URLHash') {\\n\\t\\t\\t\\t\\t$(window).trigger('hashchange.owl.navigation');\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'prepared.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace) {\\n\\t\\t\\t\\t\\tvar hash = $(e.content).find('[data-hash]').addBack('[data-hash]').attr('data-hash');\\n\\n\\t\\t\\t\\t\\tif (!hash) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tthis._hashes[hash] = e.content;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this),\\n\\t\\t\\t'changed.owl.carousel': $.proxy(function(e) {\\n\\t\\t\\t\\tif (e.namespace && e.property.name === 'position') {\\n\\t\\t\\t\\t\\tvar current = this._core.items(this._core.relative(this._core.current())),\\n\\t\\t\\t\\t\\t\\thash = $.map(this._hashes, function(item, hash) {\\n\\t\\t\\t\\t\\t\\t\\treturn item === current ? hash : null;\\n\\t\\t\\t\\t\\t\\t}).join();\\n\\n\\t\\t\\t\\t\\tif (!hash || window.location.hash.slice(1) === hash) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\twindow.location.hash = hash;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this)\\n\\t\\t};\\n\\n\\t\\t// set default options\\n\\t\\tthis._core.options = $.extend({}, Hash.Defaults, this._core.options);\\n\\n\\t\\t// register the event handlers\\n\\t\\tthis.$element.on(this._handlers);\\n\\n\\t\\t// register event listener for hash navigation\\n\\t\\t$(window).on('hashchange.owl.navigation', $.proxy(function(e) {\\n\\t\\t\\tvar hash = window.location.hash.substring(1),\\n\\t\\t\\t\\titems = this._core.$stage.children(),\\n\\t\\t\\t\\tposition = this._hashes[hash] && items.index(this._hashes[hash]);\\n\\n\\t\\t\\tif (position === undefined || position === this._core.current()) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis._core.to(this._core.relative(position), false, true);\\n\\t\\t}, this));\\n\\t};\\n\\n\\t/**\\n\\t * Default options.\\n\\t * @public\\n\\t */\\n\\tHash.Defaults = {\\n\\t\\tURLhashListener: false\\n\\t};\\n\\n\\t/**\\n\\t * Destroys the plugin.\\n\\t * @public\\n\\t */\\n\\tHash.prototype.destroy = function() {\\n\\t\\tvar handler, property;\\n\\n\\t\\t$(window).off('hashchange.owl.navigation');\\n\\n\\t\\tfor (handler in this._handlers) {\\n\\t\\t\\tthis._core.$element.off(handler, this._handlers[handler]);\\n\\t\\t}\\n\\t\\tfor (property in Object.getOwnPropertyNames(this)) {\\n\\t\\t\\ttypeof this[property] != 'function' && (this[property] = null);\\n\\t\\t}\\n\\t};\\n\\n\\t$.fn.owlCarousel.Constructor.Plugins.Hash = Hash;\\n\\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\\n\\n/**\\n * Support Plugin\\n *\\n * @version 2.1.0\\n * @author Vivid Planet Software GmbH\\n * @author Artus Kolanowski\\n * @author David Deutsch\\n * @license The MIT License (MIT)\\n */\\n;(function($, window, document, undefined) {\\n\\n\\tvar style = $('<support>').get(0).style,\\n\\t\\tprefixes = 'Webkit Moz O ms'.split(' '),\\n\\t\\tevents = {\\n\\t\\t\\ttransition: {\\n\\t\\t\\t\\tend: {\\n\\t\\t\\t\\t\\tWebkitTransition: 'webkitTransitionEnd',\\n\\t\\t\\t\\t\\tMozTransition: 'transitionend',\\n\\t\\t\\t\\t\\tOTransition: 'oTransitionEnd',\\n\\t\\t\\t\\t\\ttransition: 'transitionend'\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tanimation: {\\n\\t\\t\\t\\tend: {\\n\\t\\t\\t\\t\\tWebkitAnimation: 'webkitAnimationEnd',\\n\\t\\t\\t\\t\\tMozAnimation: 'animationend',\\n\\t\\t\\t\\t\\tOAnimation: 'oAnimationEnd',\\n\\t\\t\\t\\t\\tanimation: 'animationend'\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\ttests = {\\n\\t\\t\\tcsstransforms: function() {\\n\\t\\t\\t\\treturn !!test('transform');\\n\\t\\t\\t},\\n\\t\\t\\tcsstransforms3d: function() {\\n\\t\\t\\t\\treturn !!test('perspective');\\n\\t\\t\\t},\\n\\t\\t\\tcsstransitions: function() {\\n\\t\\t\\t\\treturn !!test('transition');\\n\\t\\t\\t},\\n\\t\\t\\tcssanimations: function() {\\n\\t\\t\\t\\treturn !!test('animation');\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\tfunction test(property, prefixed) {\\n\\t\\tvar result = false,\\n\\t\\t\\tupper = property.charAt(0).toUpperCase() + property.slice(1);\\n\\n\\t\\t$.each((property + ' ' + prefixes.join(upper + ' ') + upper).split(' '), function(i, property) {\\n\\t\\t\\tif (style[property] !== undefined) {\\n\\t\\t\\t\\tresult = prefixed ? property : true;\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\treturn result;\\n\\t}\\n\\n\\tfunction prefixed(property) {\\n\\t\\treturn test(property, true);\\n\\t}\\n\\n\\tif (tests.csstransitions()) {\\n\\t\\t/* jshint -W053 */\\n\\t\\t$.support.transition = new String(prefixed('transition'))\\n\\t\\t$.support.transition.end = events.transition.end[ $.support.transition ];\\n\\t}\\n\\n\\tif (tests.cssanimations()) {\\n\\t\\t/* jshint -W053 */\\n\\t\\t$.support.animation = new String(prefixed('animation'))\\n\\t\\t$.support.animation.end = events.animation.end[ $.support.animation ];\\n\\t}\\n\\n\\tif (tests.csstransforms()) {\\n\\t\\t/* jshint -W053 */\\n\\t\\t$.support.transform = new String(prefixed('transform'));\\n\\t\\t$.support.transform3d = tests.csstransforms3d();\\n\\t}\\n\\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\\n\\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(1)))\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/owl.carousel/dist/owl.carousel.js\\n// module id = 8\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/owl.carousel/dist/owl.carousel.js?\");\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"/* WEBPACK VAR INJECTION */(function(process) {/**\\n * Copyright (c) 2013-present, Facebook, Inc.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n */\\n\\nif (process.env.NODE_ENV !== 'production') {\\n  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&\\n    Symbol.for &&\\n    Symbol.for('react.element')) ||\\n    0xeac7;\\n\\n  var isValidElement = function(object) {\\n    return typeof object === 'object' &&\\n      object !== null &&\\n      object.$$typeof === REACT_ELEMENT_TYPE;\\n  };\\n\\n  // By explicitly using `prop-types` you are opting into new development behavior.\\n  // http://fb.me/prop-types-in-prod\\n  var throwOnDirectAccess = true;\\n  module.exports = __webpack_require__(21)(isValidElement, throwOnDirectAccess);\\n} else {\\n  // By explicitly using `prop-types` you are opting into new production behavior.\\n  // http://fb.me/prop-types-in-prod\\n  module.exports = __webpack_require__(20)();\\n}\\n\\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/prop-types/index.js\\n// module id = 9\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/prop-types/index.js?\");\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"// style-loader: Adds some css to the DOM by adding a <style> tag\\n\\n// load the styles\\nvar content = __webpack_require__(14);\\nif(typeof content === 'string') content = [[module.i, content, '']];\\n// Prepare cssTransformation\\nvar transform;\\n\\nvar options = {}\\noptions.transform = transform\\n// add the styles to the DOM\\nvar update = __webpack_require__(7)(content, options);\\nif(content.locals) module.exports = content.locals;\\n// Hot Module Replacement\\nif(false) {\\n\\t// When the styles change, update the <style> tags\\n\\tif(!content.locals) {\\n\\t\\tmodule.hot.accept(\\\"!!../../../css-loader/index.js!./owl.carousel.min.css\\\", function() {\\n\\t\\t\\tvar newContent = require(\\\"!!../../../css-loader/index.js!./owl.carousel.min.css\\\");\\n\\t\\t\\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\\n\\t\\t\\tupdate(newContent);\\n\\t\\t});\\n\\t}\\n\\t// When the module is disposed, remove the <style> tags\\n\\tmodule.hot.dispose(function() { update(); });\\n}\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/owl.carousel/dist/assets/owl.carousel.min.css\\n// module id = 10\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/owl.carousel/dist/assets/owl.carousel.min.css?\");\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"// style-loader: Adds some css to the DOM by adding a <style> tag\\n\\n// load the styles\\nvar content = __webpack_require__(15);\\nif(typeof content === 'string') content = [[module.i, content, '']];\\n// Prepare cssTransformation\\nvar transform;\\n\\nvar options = {}\\noptions.transform = transform\\n// add the styles to the DOM\\nvar update = __webpack_require__(7)(content, options);\\nif(content.locals) module.exports = content.locals;\\n// Hot Module Replacement\\nif(false) {\\n\\t// When the styles change, update the <style> tags\\n\\tif(!content.locals) {\\n\\t\\tmodule.hot.accept(\\\"!!../../../css-loader/index.js!./owl.theme.default.min.css\\\", function() {\\n\\t\\t\\tvar newContent = require(\\\"!!../../../css-loader/index.js!./owl.theme.default.min.css\\\");\\n\\t\\t\\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\\n\\t\\t\\tupdate(newContent);\\n\\t\\t});\\n\\t}\\n\\t// When the module is disposed, remove the <style> tags\\n\\tmodule.hot.dispose(function() { update(); });\\n}\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/owl.carousel/dist/assets/owl.theme.default.min.css\\n// module id = 11\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/owl.carousel/dist/assets/owl.theme.default.min.css?\");\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\neval(\"module.exports = __WEBPACK_EXTERNAL_MODULE_12__;\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// external {\\\"root\\\":\\\"React\\\",\\\"commonjs2\\\":\\\"react\\\",\\\"commonjs\\\":\\\"react\\\",\\\"amd\\\":\\\"react\\\"}\\n// module id = 12\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///external_%7B%22root%22:%22React%22,%22commonjs2%22:%22react%22,%22commonjs%22:%22react%22,%22amd%22:%22react%22%7D?\");\n\n/***/ }),\n/* 13 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\neval(\"Object.defineProperty(__webpack_exports__, \\\"__esModule\\\", { value: true });\\n/* WEBPACK VAR INJECTION */(function($) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(12);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(9);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);\\n\\n\\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n\\n\\n\\nvar Owl_Carousel_Options = {\\n\\n    // options\\n    items: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,\\n    margin: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,\\n    loop: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    center: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    mouseDrag: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    touchDrag: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    pullDrag: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    freeDrag: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    stagePadding: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,\\n    merge: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    mergeFit: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    autoWidth: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    startPosition: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string]),\\n    URLhashListener: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    nav: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    rewind: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    navText: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.arrayOf(__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string), __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.arrayOf(__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.element)]),\\n    navElement: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\\n    slideBy: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string]),\\n    dots: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    dotsEach: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\\n    dotData: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    lazyLoad: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    lazyContent: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    autoplay: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    autoplayTimeout: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,\\n    autoplayHoverPause: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    smartSpeed: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,\\n    fluidSpeed: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    autoplaySpeed: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\\n    navSpeed: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\\n    dotsSpeed: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\\n    dragEndSpeed: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\\n    callbacks: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    responsive: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,\\n    responsiveRefreshRate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,\\n    responsiveBaseElement: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.element,\\n    video: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\\n    videoHeight: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\\n    videoWidth: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\\n    animateOut: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\\n    animateIn: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\\n    fallbackEasing: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\\n    info: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\\n    nestedItemSelector: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\\n    itemElement: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\\n    stageElement: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\\n    navContainer: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\\n    dotsContainer: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\\n\\n    // dom class\\n    refreshClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\\n    loadingClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\\n    loadedClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\\n    rtlClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\\n    dragClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\\n    grabClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\\n    stageClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\\n    stageOuterClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\\n    navContainerClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\\n    navClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.arrayOf(__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string),\\n    controlsClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\\n    dotClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\\n    dotsClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\\n    autoHeightClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\\n    responsiveClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\\n\\n    // event\\n    onInitialize: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\\n    onInitialized: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\\n    onResize: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\\n    onResized: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\\n    onRefresh: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\\n    onRefreshed: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\\n    onDrag: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\\n    onDragged: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\\n    onTranslate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\\n    onTranslated: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\\n    onChange: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\\n    onChanged: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\\n    onLoadLazy: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\\n    onLoadedLazy: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\\n    onStopVideo: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\\n    onPlayVideo: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func\\n};\\n\\nvar OwlCarousel = function (_Component) {\\n    _inherits(OwlCarousel, _Component);\\n\\n    function OwlCarousel(props, context) {\\n        _classCallCheck(this, OwlCarousel);\\n\\n        var _this = _possibleConstructorReturn(this, (OwlCarousel.__proto__ || Object.getPrototypeOf(OwlCarousel)).call(this, props, context));\\n\\n        _this.next = _this.next.bind(_this);\\n        _this.prev = _this.prev.bind(_this);\\n        _this.to = _this.to.bind(_this);\\n        _this.create = _this.create.bind(_this);\\n        _this.destory = _this.destory.bind(_this);\\n        _this.play = _this.play.bind(_this);\\n        _this.stop = _this.stop.bind(_this);\\n        return _this;\\n    }\\n\\n    _createClass(OwlCarousel, [{\\n        key: 'componentWillMount',\\n        value: function componentWillMount() {\\n            __webpack_require__(10);\\n            __webpack_require__(11);\\n            __webpack_require__(8);\\n\\n            this._filterProps(this.props);\\n        }\\n    }, {\\n        key: 'componentDidMount',\\n        value: function componentDidMount() {\\n            this.owlCarousel = $(this.inst);\\n            this.owlCarousel.owlCarousel(this.options);\\n        }\\n    }, {\\n        key: 'componentWillReceiveProps',\\n        value: function componentWillReceiveProps(nextProps) {\\n            this._filterProps(nextProps);\\n            this.destory();\\n        }\\n    }, {\\n        key: 'componentDidUpdate',\\n        value: function componentDidUpdate() {\\n            this.owlCarousel = $(this.inst);\\n            this.owlCarousel.owlCarousel(this.options);\\n        }\\n    }, {\\n        key: 'componentWillUnmount',\\n        value: function componentWillUnmount() {\\n            this.destory();\\n        }\\n    }, {\\n        key: 'next',\\n        value: function next(speed) {\\n            if (typeof speed == 'number') {\\n                this.owlCarousel.trigger('next.owl.carousel', [speed]);\\n            } else {\\n                this.owlCarousel.trigger('next.owl.carousel');\\n            }\\n        }\\n    }, {\\n        key: 'prev',\\n        value: function prev(speed) {\\n            if (typeof speed == 'number') {\\n                this.owlCarousel.trigger('prev.owl.carousel', [speed]);\\n            } else {\\n                this.owlCarousel.trigger('prev.owl.carousel');\\n            }\\n        }\\n\\n        // refresh(event, speed) {\\n        // }\\n\\n    }, {\\n        key: 'to',\\n        value: function to(position, speed) {\\n            if (typeof position == 'number' && typeof speed == 'number') {\\n                this.owlCarousel.trigger('to.owl.carousel', [position, speed]);\\n            } else {\\n                this.owlCarousel.trigger('to.owl.carousel');\\n            }\\n        }\\n    }, {\\n        key: 'create',\\n        value: function create() {\\n            this.owlCarousel.owlCarousel(this.options);\\n        }\\n    }, {\\n        key: 'destory',\\n        value: function destory() {\\n            this.owlCarousel.trigger('destroy.owl.carousel');\\n        }\\n\\n        // replace(data) {\\n\\n        // }\\n\\n        // add(data, position) {\\n\\n        // }\\n\\n        // remove(position) {\\n\\n        // }\\n\\n    }, {\\n        key: 'play',\\n        value: function play(timeout, speed) {\\n            if (typeof timeout == 'number' && typeof speed == 'number') {\\n                this.owlCarousel.trigger('play.owl.autoplay', [timeout, speed]);\\n            } else {\\n                this.owlCarousel.trigger('play.owl.autoplay');\\n            }\\n        }\\n    }, {\\n        key: 'stop',\\n        value: function stop() {\\n            this.owlCarousel.trigger('stop.owl.autoplay');\\n        }\\n    }, {\\n        key: '_filterProps',\\n        value: function _filterProps(props) {\\n            var _this2 = this;\\n\\n            this.options = {};\\n            this.propsWithoutOptions = {};\\n            Object.keys(props).forEach(function (key) {\\n                if (Owl_Carousel_Options.hasOwnProperty(key)) {\\n                    _this2.options[key] = props[key];\\n                } else {\\n                    _this2.propsWithoutOptions[key] = props[key];\\n                }\\n            });\\n        }\\n    }, {\\n        key: 'render',\\n        value: function render() {\\n            var _this3 = this;\\n\\n            var _propsWithoutOptions = this.propsWithoutOptions,\\n                className = _propsWithoutOptions.className,\\n                children = _propsWithoutOptions.children,\\n                props = _objectWithoutProperties(_propsWithoutOptions, ['className', 'children']);\\n\\n            return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\\n                'div',\\n                _extends({\\n                    className: 'owl-carousel ' + className,\\n                    ref: function ref(inst) {\\n                        return _this3.inst = inst;\\n                    }\\n                }, props),\\n                children\\n            );\\n        }\\n    }]);\\n\\n    return OwlCarousel;\\n}(__WEBPACK_IMPORTED_MODULE_0_react__[\\\"Component\\\"]);\\n\\nOwlCarousel.propTypes = Owl_Carousel_Options;\\n\\nOwlCarousel.defaultProps = {\\n    className: ''\\n};\\n\\n/* harmony default export */ __webpack_exports__[\\\"default\\\"] = (OwlCarousel);\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(1)))\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./components/OwlCarousel.jsx\\n// module id = 13\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./components/OwlCarousel.jsx?\");\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"var escape = __webpack_require__(16);\\nexports = module.exports = __webpack_require__(5)(false);\\n// imports\\n\\n\\n// module\\nexports.push([module.i, \\\"/**\\\\n * Owl Carousel v2.2.0\\\\n * Copyright 2013-2016 David Deutsch\\\\n * Licensed under MIT (https://github.com/OwlCarousel2/OwlCarousel2/blob/master/LICENSE)\\\\n */\\\\n.owl-carousel,.owl-carousel .owl-item{-webkit-tap-highlight-color:transparent;position:relative}.owl-carousel{display:none;width:100%;z-index:1}.owl-carousel .owl-stage{position:relative;-ms-touch-action:pan-Y}.owl-carousel .owl-stage:after{content:\\\\\\\".\\\\\\\";display:block;clear:both;visibility:hidden;line-height:0;height:0}.owl-carousel .owl-stage-outer{position:relative;overflow:hidden;-webkit-transform:translate3d(0,0,0)}.owl-carousel .owl-item{min-height:1px;float:left;-webkit-backface-visibility:hidden;-webkit-touch-callout:none}.owl-carousel .owl-item img{display:block;width:100%;-webkit-transform-style:preserve-3d}.owl-carousel .owl-dots.disabled,.owl-carousel .owl-nav.disabled{display:none}.no-js .owl-carousel,.owl-carousel.owl-loaded{display:block}.owl-carousel .owl-dot,.owl-carousel .owl-nav .owl-next,.owl-carousel .owl-nav .owl-prev{cursor:pointer;cursor:hand;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.owl-carousel.owl-loading{opacity:0;display:block}.owl-carousel.owl-hidden{opacity:0}.owl-carousel.owl-refresh .owl-item{visibility:hidden}.owl-carousel.owl-drag .owl-item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.owl-carousel.owl-grab{cursor:move;cursor:grab}.owl-carousel.owl-rtl{direction:rtl}.owl-carousel.owl-rtl .owl-item{float:right}.owl-carousel .animated{-webkit-animation-duration:1s;animation-duration:1s;-webkit-animation-fill-mode:both;animation-fill-mode:both}.owl-carousel .owl-animated-in{z-index:0}.owl-carousel .owl-animated-out{z-index:1}.owl-carousel .fadeOut{-webkit-animation-name:fadeOut;animation-name:fadeOut}@-webkit-keyframes fadeOut{0%{opacity:1}100%{opacity:0}}@keyframes fadeOut{0%{opacity:1}100%{opacity:0}}.owl-height{transition:height .5s ease-in-out}.owl-carousel .owl-item .owl-lazy{opacity:0;transition:opacity .4s ease}.owl-carousel .owl-item img.owl-lazy{-webkit-transform-style:preserve-3d;transform-style:preserve-3d}.owl-carousel .owl-video-wrapper{position:relative;height:100%;background:#000}.owl-carousel .owl-video-play-icon{position:absolute;height:80px;width:80px;left:50%;top:50%;margin-left:-40px;margin-top:-40px;background:url(\\\" + escape(__webpack_require__(17)) + \\\") no-repeat;cursor:pointer;z-index:1;-webkit-backface-visibility:hidden;transition:-webkit-transform .1s ease;transition:transform .1s ease}.owl-carousel .owl-video-play-icon:hover{-webkit-transform:scale(1.3,1.3);-ms-transform:scale(1.3,1.3);transform:scale(1.3,1.3)}.owl-carousel .owl-video-playing .owl-video-play-icon,.owl-carousel .owl-video-playing .owl-video-tn{display:none}.owl-carousel .owl-video-tn{opacity:0;height:100%;background-position:center center;background-repeat:no-repeat;background-size:contain;transition:opacity .4s ease}.owl-carousel .owl-video-frame{position:relative;z-index:1;height:100%;width:100%}\\\", \\\"\\\"]);\\n\\n// exports\\n\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/css-loader!./~/owl.carousel/dist/assets/owl.carousel.min.css\\n// module id = 14\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/owl.carousel/dist/assets/owl.carousel.min.css?./~/css-loader\");\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"exports = module.exports = __webpack_require__(5)(false);\\n// imports\\n\\n\\n// module\\nexports.push([module.i, \\\"/**\\\\n * Owl Carousel v2.2.0\\\\n * Copyright 2013-2016 David Deutsch\\\\n * Licensed under MIT (https://github.com/OwlCarousel2/OwlCarousel2/blob/master/LICENSE)\\\\n */\\\\n.owl-theme .owl-dots,.owl-theme .owl-nav{text-align:center;-webkit-tap-highlight-color:transparent}.owl-theme .owl-nav{margin-top:10px}.owl-theme .owl-nav [class*=owl-]{color:#FFF;font-size:14px;margin:5px;padding:4px 7px;background:#D6D6D6;display:inline-block;cursor:pointer;border-radius:3px}.owl-theme .owl-nav [class*=owl-]:hover{background:#869791;color:#FFF;text-decoration:none}.owl-theme .owl-nav .disabled{opacity:.5;cursor:default}.owl-theme .owl-nav.disabled+.owl-dots{margin-top:10px}.owl-theme .owl-dots .owl-dot{display:inline-block;zoom:1}.owl-theme .owl-dots .owl-dot span{width:10px;height:10px;margin:5px 7px;background:#D6D6D6;display:block;-webkit-backface-visibility:visible;transition:opacity .2s ease;border-radius:30px}.owl-theme .owl-dots .owl-dot.active span,.owl-theme .owl-dots .owl-dot:hover span{background:#869791}\\\", \\\"\\\"]);\\n\\n// exports\\n\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/css-loader!./~/owl.carousel/dist/assets/owl.theme.default.min.css\\n// module id = 15\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/owl.carousel/dist/assets/owl.theme.default.min.css?./~/css-loader\");\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports) {\n\neval(\"module.exports = function escape(url) {\\n    if (typeof url !== 'string') {\\n        return url\\n    }\\n    // If url is already wrapped in quotes, remove them\\n    if (/^['\\\"].*['\\\"]$/.test(url)) {\\n        url = url.slice(1, -1);\\n    }\\n    // Should url be wrapped?\\n    // See https://drafts.csswg.org/css-values-3/#urls\\n    if (/[\\\"'() \\\\t\\\\n]/.test(url)) {\\n        return '\\\"' + url.replace(/\\\"/g, '\\\\\\\\\\\"').replace(/\\\\n/g, '\\\\\\\\n') + '\\\"'\\n    }\\n\\n    return url\\n}\\n\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/css-loader/lib/url/escape.js\\n// module id = 16\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/css-loader/lib/url/escape.js?\");\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"module.exports = __webpack_require__.p + \\\"4a37f8008959c75f619bf0a3a4e2d7a2.png\\\";\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/owl.carousel/dist/assets/owl.video.play.png\\n// module id = 17\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/owl.carousel/dist/assets/owl.video.play.png?\");\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"/*\\nobject-assign\\n(c) Sindre Sorhus\\n@license MIT\\n*/\\n\\n\\n/* eslint-disable no-unused-vars */\\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\\n\\nfunction toObject(val) {\\n\\tif (val === null || val === undefined) {\\n\\t\\tthrow new TypeError('Object.assign cannot be called with null or undefined');\\n\\t}\\n\\n\\treturn Object(val);\\n}\\n\\nfunction shouldUseNative() {\\n\\ttry {\\n\\t\\tif (!Object.assign) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// Detect buggy property enumeration order in older V8 versions.\\n\\n\\t\\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\\n\\t\\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\\n\\t\\ttest1[5] = 'de';\\n\\t\\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\\n\\t\\tvar test2 = {};\\n\\t\\tfor (var i = 0; i < 10; i++) {\\n\\t\\t\\ttest2['_' + String.fromCharCode(i)] = i;\\n\\t\\t}\\n\\t\\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\\n\\t\\t\\treturn test2[n];\\n\\t\\t});\\n\\t\\tif (order2.join('') !== '0123456789') {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\\n\\t\\tvar test3 = {};\\n\\t\\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\\n\\t\\t\\ttest3[letter] = letter;\\n\\t\\t});\\n\\t\\tif (Object.keys(Object.assign({}, test3)).join('') !==\\n\\t\\t\\t\\t'abcdefghijklmnopqrst') {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t} catch (err) {\\n\\t\\t// We don't expect any of the above to throw, but better to be safe.\\n\\t\\treturn false;\\n\\t}\\n}\\n\\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\\n\\tvar from;\\n\\tvar to = toObject(target);\\n\\tvar symbols;\\n\\n\\tfor (var s = 1; s < arguments.length; s++) {\\n\\t\\tfrom = Object(arguments[s]);\\n\\n\\t\\tfor (var key in from) {\\n\\t\\t\\tif (hasOwnProperty.call(from, key)) {\\n\\t\\t\\t\\tto[key] = from[key];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (getOwnPropertySymbols) {\\n\\t\\t\\tsymbols = getOwnPropertySymbols(from);\\n\\t\\t\\tfor (var i = 0; i < symbols.length; i++) {\\n\\t\\t\\t\\tif (propIsEnumerable.call(from, symbols[i])) {\\n\\t\\t\\t\\t\\tto[symbols[i]] = from[symbols[i]];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn to;\\n};\\n\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/object-assign/index.js\\n// module id = 18\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/object-assign/index.js?\");\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"/* WEBPACK VAR INJECTION */(function(process) {/**\\n * Copyright (c) 2013-present, Facebook, Inc.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n */\\n\\n\\n\\nif (process.env.NODE_ENV !== 'production') {\\n  var invariant = __webpack_require__(3);\\n  var warning = __webpack_require__(6);\\n  var ReactPropTypesSecret = __webpack_require__(4);\\n  var loggedTypeFailures = {};\\n}\\n\\n/**\\n * Assert that the values match with the type specs.\\n * Error messages are memorized and will only be shown once.\\n *\\n * @param {object} typeSpecs Map of name to a ReactPropType\\n * @param {object} values Runtime values that need to be type-checked\\n * @param {string} location e.g. \\\"prop\\\", \\\"context\\\", \\\"child context\\\"\\n * @param {string} componentName Name of the component for error messages.\\n * @param {?Function} getStack Returns the component stack.\\n * @private\\n */\\nfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\\n  if (process.env.NODE_ENV !== 'production') {\\n    for (var typeSpecName in typeSpecs) {\\n      if (typeSpecs.hasOwnProperty(typeSpecName)) {\\n        var error;\\n        // Prop type validation may throw. In case they do, we don't want to\\n        // fail the render phase where it didn't fail before. So we log it.\\n        // After these have been cleaned up, we'll let them throw.\\n        try {\\n          // This is intentionally an invariant that gets caught. It's the same\\n          // behavior as without this statement except with a better message.\\n          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);\\n          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\\n        } catch (ex) {\\n          error = ex;\\n        }\\n        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);\\n        if (error instanceof Error && !(error.message in loggedTypeFailures)) {\\n          // Only monitor this failure once because there tends to be a lot of the\\n          // same error.\\n          loggedTypeFailures[error.message] = true;\\n\\n          var stack = getStack ? getStack() : '';\\n\\n          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');\\n        }\\n      }\\n    }\\n  }\\n}\\n\\nmodule.exports = checkPropTypes;\\n\\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/prop-types/checkPropTypes.js\\n// module id = 19\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/prop-types/checkPropTypes.js?\");\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"/**\\n * Copyright (c) 2013-present, Facebook, Inc.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n */\\n\\n\\n\\nvar emptyFunction = __webpack_require__(2);\\nvar invariant = __webpack_require__(3);\\nvar ReactPropTypesSecret = __webpack_require__(4);\\n\\nmodule.exports = function() {\\n  function shim(props, propName, componentName, location, propFullName, secret) {\\n    if (secret === ReactPropTypesSecret) {\\n      // It is still safe when called from React.\\n      return;\\n    }\\n    invariant(\\n      false,\\n      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\\n      'Use PropTypes.checkPropTypes() to call them. ' +\\n      'Read more at http://fb.me/use-check-prop-types'\\n    );\\n  };\\n  shim.isRequired = shim;\\n  function getShim() {\\n    return shim;\\n  };\\n  // Important!\\n  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\\n  var ReactPropTypes = {\\n    array: shim,\\n    bool: shim,\\n    func: shim,\\n    number: shim,\\n    object: shim,\\n    string: shim,\\n    symbol: shim,\\n\\n    any: shim,\\n    arrayOf: getShim,\\n    element: shim,\\n    instanceOf: getShim,\\n    node: shim,\\n    objectOf: getShim,\\n    oneOf: getShim,\\n    oneOfType: getShim,\\n    shape: getShim,\\n    exact: getShim\\n  };\\n\\n  ReactPropTypes.checkPropTypes = emptyFunction;\\n  ReactPropTypes.PropTypes = ReactPropTypes;\\n\\n  return ReactPropTypes;\\n};\\n\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/prop-types/factoryWithThrowingShims.js\\n// module id = 20\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/prop-types/factoryWithThrowingShims.js?\");\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"/* WEBPACK VAR INJECTION */(function(process) {/**\\n * Copyright (c) 2013-present, Facebook, Inc.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n */\\n\\n\\n\\nvar emptyFunction = __webpack_require__(2);\\nvar invariant = __webpack_require__(3);\\nvar warning = __webpack_require__(6);\\nvar assign = __webpack_require__(18);\\n\\nvar ReactPropTypesSecret = __webpack_require__(4);\\nvar checkPropTypes = __webpack_require__(19);\\n\\nmodule.exports = function(isValidElement, throwOnDirectAccess) {\\n  /* global Symbol */\\n  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\\n  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\\n\\n  /**\\n   * Returns the iterator method function contained on the iterable object.\\n   *\\n   * Be sure to invoke the function with the iterable as context:\\n   *\\n   *     var iteratorFn = getIteratorFn(myIterable);\\n   *     if (iteratorFn) {\\n   *       var iterator = iteratorFn.call(myIterable);\\n   *       ...\\n   *     }\\n   *\\n   * @param {?object} maybeIterable\\n   * @return {?function}\\n   */\\n  function getIteratorFn(maybeIterable) {\\n    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\\n    if (typeof iteratorFn === 'function') {\\n      return iteratorFn;\\n    }\\n  }\\n\\n  /**\\n   * Collection of methods that allow declaration and validation of props that are\\n   * supplied to React components. Example usage:\\n   *\\n   *   var Props = require('ReactPropTypes');\\n   *   var MyArticle = React.createClass({\\n   *     propTypes: {\\n   *       // An optional string prop named \\\"description\\\".\\n   *       description: Props.string,\\n   *\\n   *       // A required enum prop named \\\"category\\\".\\n   *       category: Props.oneOf(['News','Photos']).isRequired,\\n   *\\n   *       // A prop named \\\"dialog\\\" that requires an instance of Dialog.\\n   *       dialog: Props.instanceOf(Dialog).isRequired\\n   *     },\\n   *     render: function() { ... }\\n   *   });\\n   *\\n   * A more formal specification of how these methods are used:\\n   *\\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\\n   *   decl := ReactPropTypes.{type}(.isRequired)?\\n   *\\n   * Each and every declaration produces a function with the same signature. This\\n   * allows the creation of custom validation functions. For example:\\n   *\\n   *  var MyLink = React.createClass({\\n   *    propTypes: {\\n   *      // An optional string or URI prop named \\\"href\\\".\\n   *      href: function(props, propName, componentName) {\\n   *        var propValue = props[propName];\\n   *        if (propValue != null && typeof propValue !== 'string' &&\\n   *            !(propValue instanceof URI)) {\\n   *          return new Error(\\n   *            'Expected a string or an URI for ' + propName + ' in ' +\\n   *            componentName\\n   *          );\\n   *        }\\n   *      }\\n   *    },\\n   *    render: function() {...}\\n   *  });\\n   *\\n   * @internal\\n   */\\n\\n  var ANONYMOUS = '<<anonymous>>';\\n\\n  // Important!\\n  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\\n  var ReactPropTypes = {\\n    array: createPrimitiveTypeChecker('array'),\\n    bool: createPrimitiveTypeChecker('boolean'),\\n    func: createPrimitiveTypeChecker('function'),\\n    number: createPrimitiveTypeChecker('number'),\\n    object: createPrimitiveTypeChecker('object'),\\n    string: createPrimitiveTypeChecker('string'),\\n    symbol: createPrimitiveTypeChecker('symbol'),\\n\\n    any: createAnyTypeChecker(),\\n    arrayOf: createArrayOfTypeChecker,\\n    element: createElementTypeChecker(),\\n    instanceOf: createInstanceTypeChecker,\\n    node: createNodeChecker(),\\n    objectOf: createObjectOfTypeChecker,\\n    oneOf: createEnumTypeChecker,\\n    oneOfType: createUnionTypeChecker,\\n    shape: createShapeTypeChecker,\\n    exact: createStrictShapeTypeChecker,\\n  };\\n\\n  /**\\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\\n   */\\n  /*eslint-disable no-self-compare*/\\n  function is(x, y) {\\n    // SameValue algorithm\\n    if (x === y) {\\n      // Steps 1-5, 7-10\\n      // Steps 6.b-6.e: +0 != -0\\n      return x !== 0 || 1 / x === 1 / y;\\n    } else {\\n      // Step 6.a: NaN == NaN\\n      return x !== x && y !== y;\\n    }\\n  }\\n  /*eslint-enable no-self-compare*/\\n\\n  /**\\n   * We use an Error-like object for backward compatibility as people may call\\n   * PropTypes directly and inspect their output. However, we don't use real\\n   * Errors anymore. We don't inspect their stack anyway, and creating them\\n   * is prohibitively expensive if they are created too often, such as what\\n   * happens in oneOfType() for any type before the one that matched.\\n   */\\n  function PropTypeError(message) {\\n    this.message = message;\\n    this.stack = '';\\n  }\\n  // Make `instanceof Error` still work for returned errors.\\n  PropTypeError.prototype = Error.prototype;\\n\\n  function createChainableTypeChecker(validate) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      var manualPropTypeCallCache = {};\\n      var manualPropTypeWarningCount = 0;\\n    }\\n    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\\n      componentName = componentName || ANONYMOUS;\\n      propFullName = propFullName || propName;\\n\\n      if (secret !== ReactPropTypesSecret) {\\n        if (throwOnDirectAccess) {\\n          // New behavior only for users of `prop-types` package\\n          invariant(\\n            false,\\n            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\\n            'Use `PropTypes.checkPropTypes()` to call them. ' +\\n            'Read more at http://fb.me/use-check-prop-types'\\n          );\\n        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {\\n          // Old behavior for people using React.PropTypes\\n          var cacheKey = componentName + ':' + propName;\\n          if (\\n            !manualPropTypeCallCache[cacheKey] &&\\n            // Avoid spamming the console because they are often not actionable except for lib authors\\n            manualPropTypeWarningCount < 3\\n          ) {\\n            warning(\\n              false,\\n              'You are manually calling a React.PropTypes validation ' +\\n              'function for the `%s` prop on `%s`. This is deprecated ' +\\n              'and will throw in the standalone `prop-types` package. ' +\\n              'You may be seeing this warning due to a third-party PropTypes ' +\\n              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',\\n              propFullName,\\n              componentName\\n            );\\n            manualPropTypeCallCache[cacheKey] = true;\\n            manualPropTypeWarningCount++;\\n          }\\n        }\\n      }\\n      if (props[propName] == null) {\\n        if (isRequired) {\\n          if (props[propName] === null) {\\n            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));\\n          }\\n          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));\\n        }\\n        return null;\\n      } else {\\n        return validate(props, propName, componentName, location, propFullName);\\n      }\\n    }\\n\\n    var chainedCheckType = checkType.bind(null, false);\\n    chainedCheckType.isRequired = checkType.bind(null, true);\\n\\n    return chainedCheckType;\\n  }\\n\\n  function createPrimitiveTypeChecker(expectedType) {\\n    function validate(props, propName, componentName, location, propFullName, secret) {\\n      var propValue = props[propName];\\n      var propType = getPropType(propValue);\\n      if (propType !== expectedType) {\\n        // `propValue` being instance of, say, date/regexp, pass the 'object'\\n        // check, but we can offer a more precise error message here rather than\\n        // 'of type `object`'.\\n        var preciseType = getPreciseType(propValue);\\n\\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));\\n      }\\n      return null;\\n    }\\n    return createChainableTypeChecker(validate);\\n  }\\n\\n  function createAnyTypeChecker() {\\n    return createChainableTypeChecker(emptyFunction.thatReturnsNull);\\n  }\\n\\n  function createArrayOfTypeChecker(typeChecker) {\\n    function validate(props, propName, componentName, location, propFullName) {\\n      if (typeof typeChecker !== 'function') {\\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');\\n      }\\n      var propValue = props[propName];\\n      if (!Array.isArray(propValue)) {\\n        var propType = getPropType(propValue);\\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));\\n      }\\n      for (var i = 0; i < propValue.length; i++) {\\n        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);\\n        if (error instanceof Error) {\\n          return error;\\n        }\\n      }\\n      return null;\\n    }\\n    return createChainableTypeChecker(validate);\\n  }\\n\\n  function createElementTypeChecker() {\\n    function validate(props, propName, componentName, location, propFullName) {\\n      var propValue = props[propName];\\n      if (!isValidElement(propValue)) {\\n        var propType = getPropType(propValue);\\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));\\n      }\\n      return null;\\n    }\\n    return createChainableTypeChecker(validate);\\n  }\\n\\n  function createInstanceTypeChecker(expectedClass) {\\n    function validate(props, propName, componentName, location, propFullName) {\\n      if (!(props[propName] instanceof expectedClass)) {\\n        var expectedClassName = expectedClass.name || ANONYMOUS;\\n        var actualClassName = getClassName(props[propName]);\\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));\\n      }\\n      return null;\\n    }\\n    return createChainableTypeChecker(validate);\\n  }\\n\\n  function createEnumTypeChecker(expectedValues) {\\n    if (!Array.isArray(expectedValues)) {\\n      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;\\n      return emptyFunction.thatReturnsNull;\\n    }\\n\\n    function validate(props, propName, componentName, location, propFullName) {\\n      var propValue = props[propName];\\n      for (var i = 0; i < expectedValues.length; i++) {\\n        if (is(propValue, expectedValues[i])) {\\n          return null;\\n        }\\n      }\\n\\n      var valuesString = JSON.stringify(expectedValues);\\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));\\n    }\\n    return createChainableTypeChecker(validate);\\n  }\\n\\n  function createObjectOfTypeChecker(typeChecker) {\\n    function validate(props, propName, componentName, location, propFullName) {\\n      if (typeof typeChecker !== 'function') {\\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');\\n      }\\n      var propValue = props[propName];\\n      var propType = getPropType(propValue);\\n      if (propType !== 'object') {\\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));\\n      }\\n      for (var key in propValue) {\\n        if (propValue.hasOwnProperty(key)) {\\n          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\\n          if (error instanceof Error) {\\n            return error;\\n          }\\n        }\\n      }\\n      return null;\\n    }\\n    return createChainableTypeChecker(validate);\\n  }\\n\\n  function createUnionTypeChecker(arrayOfTypeCheckers) {\\n    if (!Array.isArray(arrayOfTypeCheckers)) {\\n      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;\\n      return emptyFunction.thatReturnsNull;\\n    }\\n\\n    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\\n      var checker = arrayOfTypeCheckers[i];\\n      if (typeof checker !== 'function') {\\n        warning(\\n          false,\\n          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +\\n          'received %s at index %s.',\\n          getPostfixForTypeWarning(checker),\\n          i\\n        );\\n        return emptyFunction.thatReturnsNull;\\n      }\\n    }\\n\\n    function validate(props, propName, componentName, location, propFullName) {\\n      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\\n        var checker = arrayOfTypeCheckers[i];\\n        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {\\n          return null;\\n        }\\n      }\\n\\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));\\n    }\\n    return createChainableTypeChecker(validate);\\n  }\\n\\n  function createNodeChecker() {\\n    function validate(props, propName, componentName, location, propFullName) {\\n      if (!isNode(props[propName])) {\\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));\\n      }\\n      return null;\\n    }\\n    return createChainableTypeChecker(validate);\\n  }\\n\\n  function createShapeTypeChecker(shapeTypes) {\\n    function validate(props, propName, componentName, location, propFullName) {\\n      var propValue = props[propName];\\n      var propType = getPropType(propValue);\\n      if (propType !== 'object') {\\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\\n      }\\n      for (var key in shapeTypes) {\\n        var checker = shapeTypes[key];\\n        if (!checker) {\\n          continue;\\n        }\\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\\n        if (error) {\\n          return error;\\n        }\\n      }\\n      return null;\\n    }\\n    return createChainableTypeChecker(validate);\\n  }\\n\\n  function createStrictShapeTypeChecker(shapeTypes) {\\n    function validate(props, propName, componentName, location, propFullName) {\\n      var propValue = props[propName];\\n      var propType = getPropType(propValue);\\n      if (propType !== 'object') {\\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\\n      }\\n      // We need to check all keys in case some are required but missing from\\n      // props.\\n      var allKeys = assign({}, props[propName], shapeTypes);\\n      for (var key in allKeys) {\\n        var checker = shapeTypes[key];\\n        if (!checker) {\\n          return new PropTypeError(\\n            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +\\n            '\\\\nBad object: ' + JSON.stringify(props[propName], null, '  ') +\\n            '\\\\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')\\n          );\\n        }\\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\\n        if (error) {\\n          return error;\\n        }\\n      }\\n      return null;\\n    }\\n\\n    return createChainableTypeChecker(validate);\\n  }\\n\\n  function isNode(propValue) {\\n    switch (typeof propValue) {\\n      case 'number':\\n      case 'string':\\n      case 'undefined':\\n        return true;\\n      case 'boolean':\\n        return !propValue;\\n      case 'object':\\n        if (Array.isArray(propValue)) {\\n          return propValue.every(isNode);\\n        }\\n        if (propValue === null || isValidElement(propValue)) {\\n          return true;\\n        }\\n\\n        var iteratorFn = getIteratorFn(propValue);\\n        if (iteratorFn) {\\n          var iterator = iteratorFn.call(propValue);\\n          var step;\\n          if (iteratorFn !== propValue.entries) {\\n            while (!(step = iterator.next()).done) {\\n              if (!isNode(step.value)) {\\n                return false;\\n              }\\n            }\\n          } else {\\n            // Iterator will provide entry [k,v] tuples rather than values.\\n            while (!(step = iterator.next()).done) {\\n              var entry = step.value;\\n              if (entry) {\\n                if (!isNode(entry[1])) {\\n                  return false;\\n                }\\n              }\\n            }\\n          }\\n        } else {\\n          return false;\\n        }\\n\\n        return true;\\n      default:\\n        return false;\\n    }\\n  }\\n\\n  function isSymbol(propType, propValue) {\\n    // Native Symbol.\\n    if (propType === 'symbol') {\\n      return true;\\n    }\\n\\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\\n    if (propValue['@@toStringTag'] === 'Symbol') {\\n      return true;\\n    }\\n\\n    // Fallback for non-spec compliant Symbols which are polyfilled.\\n    if (typeof Symbol === 'function' && propValue instanceof Symbol) {\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // Equivalent of `typeof` but with special handling for array and regexp.\\n  function getPropType(propValue) {\\n    var propType = typeof propValue;\\n    if (Array.isArray(propValue)) {\\n      return 'array';\\n    }\\n    if (propValue instanceof RegExp) {\\n      // Old webkits (at least until Android 4.0) return 'function' rather than\\n      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\\n      // passes PropTypes.object.\\n      return 'object';\\n    }\\n    if (isSymbol(propType, propValue)) {\\n      return 'symbol';\\n    }\\n    return propType;\\n  }\\n\\n  // This handles more types than `getPropType`. Only used for error messages.\\n  // See `createPrimitiveTypeChecker`.\\n  function getPreciseType(propValue) {\\n    if (typeof propValue === 'undefined' || propValue === null) {\\n      return '' + propValue;\\n    }\\n    var propType = getPropType(propValue);\\n    if (propType === 'object') {\\n      if (propValue instanceof Date) {\\n        return 'date';\\n      } else if (propValue instanceof RegExp) {\\n        return 'regexp';\\n      }\\n    }\\n    return propType;\\n  }\\n\\n  // Returns a string that is postfixed to a warning about an invalid type.\\n  // For example, \\\"undefined\\\" or \\\"of type array\\\"\\n  function getPostfixForTypeWarning(value) {\\n    var type = getPreciseType(value);\\n    switch (type) {\\n      case 'array':\\n      case 'object':\\n        return 'an ' + type;\\n      case 'boolean':\\n      case 'date':\\n      case 'regexp':\\n        return 'a ' + type;\\n      default:\\n        return type;\\n    }\\n  }\\n\\n  // Returns class name of the object, if any.\\n  function getClassName(propValue) {\\n    if (!propValue.constructor || !propValue.constructor.name) {\\n      return ANONYMOUS;\\n    }\\n    return propValue.constructor.name;\\n  }\\n\\n  ReactPropTypes.checkPropTypes = checkPropTypes;\\n  ReactPropTypes.PropTypes = ReactPropTypes;\\n\\n  return ReactPropTypes;\\n};\\n\\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/prop-types/factoryWithTypeCheckers.js\\n// module id = 21\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/prop-types/factoryWithTypeCheckers.js?\");\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports) {\n\neval(\"\\n/**\\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\\n * embed the css on the page. This breaks all relative urls because now they are relative to a\\n * bundle instead of the current page.\\n *\\n * One solution is to only use full urls, but that may be impossible.\\n *\\n * Instead, this function \\\"fixes\\\" the relative urls to be absolute according to the current page location.\\n *\\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\\n *\\n */\\n\\nmodule.exports = function (css) {\\n  // get current location\\n  var location = typeof window !== \\\"undefined\\\" && window.location;\\n\\n  if (!location) {\\n    throw new Error(\\\"fixUrls requires window.location\\\");\\n  }\\n\\n\\t// blank or null?\\n\\tif (!css || typeof css !== \\\"string\\\") {\\n\\t  return css;\\n  }\\n\\n  var baseUrl = location.protocol + \\\"//\\\" + location.host;\\n  var currentDir = baseUrl + location.pathname.replace(/\\\\/[^\\\\/]*$/, \\\"/\\\");\\n\\n\\t// convert each url(...)\\n\\t/*\\n\\tThis regular expression is just a way to recursively match brackets within\\n\\ta string.\\n\\n\\t /url\\\\s*\\\\(  = Match on the word \\\"url\\\" with any whitespace after it and then a parens\\n\\t   (  = Start a capturing group\\n\\t     (?:  = Start a non-capturing group\\n\\t         [^)(]  = Match anything that isn't a parentheses\\n\\t         |  = OR\\n\\t         \\\\(  = Match a start parentheses\\n\\t             (?:  = Start another non-capturing groups\\n\\t                 [^)(]+  = Match anything that isn't a parentheses\\n\\t                 |  = OR\\n\\t                 \\\\(  = Match a start parentheses\\n\\t                     [^)(]*  = Match anything that isn't a parentheses\\n\\t                 \\\\)  = Match a end parentheses\\n\\t             )  = End Group\\n              *\\\\) = Match anything and then a close parens\\n          )  = Close non-capturing group\\n          *  = Match anything\\n       )  = Close capturing group\\n\\t \\\\)  = Match a close parens\\n\\n\\t /gi  = Get all matches, not the first.  Be case insensitive.\\n\\t */\\n\\tvar fixedCss = css.replace(/url\\\\s*\\\\(((?:[^)(]|\\\\((?:[^)(]+|\\\\([^)(]*\\\\))*\\\\))*)\\\\)/gi, function(fullMatch, origUrl) {\\n\\t\\t// strip quotes (if they exist)\\n\\t\\tvar unquotedOrigUrl = origUrl\\n\\t\\t\\t.trim()\\n\\t\\t\\t.replace(/^\\\"(.*)\\\"$/, function(o, $1){ return $1; })\\n\\t\\t\\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\\n\\n\\t\\t// already a full url? no change\\n\\t\\tif (/^(#|data:|http:\\\\/\\\\/|https:\\\\/\\\\/|file:\\\\/\\\\/\\\\/)/i.test(unquotedOrigUrl)) {\\n\\t\\t  return fullMatch;\\n\\t\\t}\\n\\n\\t\\t// convert the url to a full url\\n\\t\\tvar newUrl;\\n\\n\\t\\tif (unquotedOrigUrl.indexOf(\\\"//\\\") === 0) {\\n\\t\\t  \\t//TODO: should we add protocol?\\n\\t\\t\\tnewUrl = unquotedOrigUrl;\\n\\t\\t} else if (unquotedOrigUrl.indexOf(\\\"/\\\") === 0) {\\n\\t\\t\\t// path should be relative to the base url\\n\\t\\t\\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\\n\\t\\t} else {\\n\\t\\t\\t// path should be relative to current directory\\n\\t\\t\\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\\\.\\\\//, \\\"\\\"); // Strip leading './'\\n\\t\\t}\\n\\n\\t\\t// send back the fixed url(...)\\n\\t\\treturn \\\"url(\\\" + JSON.stringify(newUrl) + \\\")\\\";\\n\\t});\\n\\n\\t// send back the fixed css\\n\\treturn fixedCss;\\n};\\n\\n\\n//////////////////\\n// WEBPACK FOOTER\\n// ./~/style-loader/fixUrls.js\\n// module id = 22\\n// module chunks = 0\\n\\n//# sourceURL=webpack:///./~/style-loader/fixUrls.js?\");\n\n/***/ })\n/******/ ]);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtb3dsLWNhcm91c2VsMy9saWIvT3dsQ2Fyb3VzZWwuanM/NDZjYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLElBQUksSUFBeUQ7QUFDN0QsMkJBQTJCLG1CQUFPLENBQUMsNENBQU87QUFDMUMsTUFBTSxFQUtnRDtBQUN0RCxDQUFDO0FBQ0Qsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsY0FBYztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywwQkFBMEIsRUFBRTtBQUMvRCx5Q0FBeUMsZUFBZTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELCtEQUErRDtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEVBQThFLHNVQUFzVSx5QkFBeUIsaUNBQWlDLHlEQUF5RCxHQUFHLG1DQUFtQywyREFBMkQsR0FBRyxnQkFBZ0IsV0FBVyxpREFBaUQsNENBQTRDLFdBQVcsT0FBTyxrREFBa0QsV0FBVyxPQUFPLFlBQVksOENBQThDLE9BQU8sV0FBVyxtREFBbUQsZ0RBQWdELFdBQVcsT0FBTyx1REFBdUQsV0FBVyxPQUFPLFlBQVksbURBQW1ELE9BQU8sR0FBRyxnQ0FBZ0MsNENBQTRDLHFGQUFxRixPQUFPLHFKQUFxSix3Q0FBd0Msb0NBQW9DLE9BQU8sV0FBVywwSEFBMEgs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RUFBeUUsOEZBQThGLHNDQUFzQyxPQUFPLEtBQUssd0ZBQXdGLGtFQUFrRSx5QkFBeUIsT0FBTyx3Q0FBd0MsS0FBSyxxREFBcUQsOENBQThDLDRCQUE0QixJQUFJLGdDQUFnQzs7QUFFOThuQixPQUFPO0FBQ1A7QUFDQTs7QUFFQSxra0JBQWtrQixpR0FBaUcsc0JBQXNCLDREQUE0RCxLQUFLLG1FQUFtRSxpQkFBaUIsS0FBSywrREFBK0QsK0VBQStFLG9xQ0FBb3FDLHNJQUFzSSxXQUFXLEVBQUUsOENBQThDLFdBQVcsRUFBRSxFQUFFLGdJQUFnSSx5QkFBeUIsT0FBTyx5REFBeUQsb0RBQW9ELDBFQUEwRSxPQUFPLGlEQUFpRCw2RkFBNkYsa0NBQWtDLE9BQU8sOEhBQThILDZCQUE2Qiw4RkFBOEYsS0FBSyxFQUFFLG9EQUFvRCxJQUFJOztBQUVscUcsT0FBTztBQUNQO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9yZWFjdC1vd2wtY2Fyb3VzZWwzL2xpYi9Pd2xDYXJvdXNlbC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcInJlYWN0XCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcInJlYWN0XCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcInJlYWN0LW93bC1jYXJvdXNlbFwiXSA9IGZhY3RvcnkocmVxdWlyZShcInJlYWN0XCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJyZWFjdC1vd2wtY2Fyb3VzZWxcIl0gPSBmYWN0b3J5KHJvb3RbXCJSZWFjdFwiXSk7XG59KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzEyX18pIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbi8qKioqKiovIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbi8qKioqKiovIFx0XHRcdH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxMyk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmV2YWwoXCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XFxuXFxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXFxuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXFxuXFxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XFxudmFyIGNhY2hlZENsZWFyVGltZW91dDtcXG5cXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcXG59XFxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XFxuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XFxufVxcbihmdW5jdGlvbiAoKSB7XFxuICAgIHRyeSB7XFxuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XFxuICAgICAgICB9XFxuICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xcbiAgICB9XFxuICAgIHRyeSB7XFxuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcXG4gICAgICAgIH1cXG4gICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcXG4gICAgfVxcbn0gKCkpXFxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcXG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcXG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcXG4gICAgfVxcbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcXG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcXG4gICAgfVxcbiAgICB0cnkge1xcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcXG4gICAgfSBjYXRjaChlKXtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xcbiAgICAgICAgfSBjYXRjaChlKXtcXG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcXG4gICAgICAgIH1cXG4gICAgfVxcblxcblxcbn1cXG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XFxuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXFxuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XFxuICAgIH1cXG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcXG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcXG4gICAgfVxcbiAgICB0cnkge1xcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xcbiAgICB9IGNhdGNoIChlKXtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xcbiAgICAgICAgfSBjYXRjaCAoZSl7XFxuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXFxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuXFxuXFxufVxcbnZhciBxdWV1ZSA9IFtdO1xcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xcbnZhciBjdXJyZW50UXVldWU7XFxudmFyIHF1ZXVlSW5kZXggPSAtMTtcXG5cXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XFxuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIGRyYWluaW5nID0gZmFsc2U7XFxuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XFxuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xcbiAgICB9XFxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcXG4gICAgICAgIGRyYWluUXVldWUoKTtcXG4gICAgfVxcbn1cXG5cXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xcbiAgICBpZiAoZHJhaW5pbmcpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcXG4gICAgZHJhaW5pbmcgPSB0cnVlO1xcblxcbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xcbiAgICB3aGlsZShsZW4pIHtcXG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xcbiAgICAgICAgcXVldWUgPSBbXTtcXG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcXG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XFxuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XFxuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XFxuICAgIH1cXG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcXG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcXG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xcbn1cXG5cXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XFxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcXG4gICAgfVxcbn07XFxuXFxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xcbiAgICB0aGlzLmZ1biA9IGZ1bjtcXG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xcbn1cXG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XFxuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xcbn07XFxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcXG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xcbnByb2Nlc3MuZW52ID0ge307XFxucHJvY2Vzcy5hcmd2ID0gW107XFxucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXFxucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xcblxcbmZ1bmN0aW9uIG5vb3AoKSB7fVxcblxcbnByb2Nlc3Mub24gPSBub29wO1xcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xcbnByb2Nlc3Mub25jZSA9IG5vb3A7XFxucHJvY2Vzcy5vZmYgPSBub29wO1xcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcXG5wcm9jZXNzLmVtaXQgPSBub29wO1xcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcXG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xcblxcbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cXG5cXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XFxufTtcXG5cXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XFxuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XFxufTtcXG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xcblxcblxcbi8vLy8vLy8vLy8vLy8vLy8vL1xcbi8vIFdFQlBBQ0sgRk9PVEVSXFxuLy8gLi9+L25vZGUtbGlicy1icm93c2VyL34vcHJvY2Vzcy9icm93c2VyLmpzXFxuLy8gbW9kdWxlIGlkID0gMFxcbi8vIG1vZHVsZSBjaHVua3MgPSAwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vfi9ub2RlLWxpYnMtYnJvd3Nlci9+L3Byb2Nlc3MvYnJvd3Nlci5qcz9cIik7XG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwidmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qIVxcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjMuMy4xXFxuICogaHR0cHM6Ly9qcXVlcnkuY29tL1xcbiAqXFxuICogSW5jbHVkZXMgU2l6emxlLmpzXFxuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXFxuICpcXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXFxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXFxuICogaHR0cHM6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gKlxcbiAqIERhdGU6IDIwMTgtMDEtMjBUMTc6MjRaXFxuICovXFxuKCBmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xcblxcblxcdFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG5cXHRpZiAoIHR5cGVvZiBtb2R1bGUgPT09IFxcXCJvYmplY3RcXFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXFxcIm9iamVjdFxcXCIgKSB7XFxuXFxuXFx0XFx0Ly8gRm9yIENvbW1vbkpTIGFuZCBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB3aGVyZSBhIHByb3BlciBgd2luZG93YFxcblxcdFxcdC8vIGlzIHByZXNlbnQsIGV4ZWN1dGUgdGhlIGZhY3RvcnkgYW5kIGdldCBqUXVlcnkuXFxuXFx0XFx0Ly8gRm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBoYXZlIGEgYHdpbmRvd2Agd2l0aCBhIGBkb2N1bWVudGBcXG5cXHRcXHQvLyAoc3VjaCBhcyBOb2RlLmpzKSwgZXhwb3NlIGEgZmFjdG9yeSBhcyBtb2R1bGUuZXhwb3J0cy5cXG5cXHRcXHQvLyBUaGlzIGFjY2VudHVhdGVzIHRoZSBuZWVkIGZvciB0aGUgY3JlYXRpb24gb2YgYSByZWFsIGB3aW5kb3dgLlxcblxcdFxcdC8vIGUuZy4gdmFyIGpRdWVyeSA9IHJlcXVpcmUoXFxcImpxdWVyeVxcXCIpKHdpbmRvdyk7XFxuXFx0XFx0Ly8gU2VlIHRpY2tldCAjMTQ1NDkgZm9yIG1vcmUgaW5mby5cXG5cXHRcXHRtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudCA/XFxuXFx0XFx0XFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxcblxcdFxcdFxcdGZ1bmN0aW9uKCB3ICkge1xcblxcdFxcdFxcdFxcdGlmICggIXcuZG9jdW1lbnQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhyb3cgbmV3IEVycm9yKCBcXFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFxcXCIgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhY3RvcnkoIHcgKTtcXG5cXHRcXHRcXHR9O1xcblxcdH0gZWxzZSB7XFxuXFx0XFx0ZmFjdG9yeSggZ2xvYmFsICk7XFxuXFx0fVxcblxcbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XFxufSApKCB0eXBlb2Ygd2luZG93ICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKCB3aW5kb3csIG5vR2xvYmFsICkge1xcblxcbi8vIEVkZ2UgPD0gMTIgLSAxMyssIEZpcmVmb3ggPD0xOCAtIDQ1KywgSUUgMTAgLSAxMSwgU2FmYXJpIDUuMSAtIDkrLCBpT1MgNiAtIDkuMVxcbi8vIHRocm93IGV4Y2VwdGlvbnMgd2hlbiBub24tc3RyaWN0IGNvZGUgKGUuZy4sIEFTUC5ORVQgNC41KSBhY2Nlc3NlcyBzdHJpY3QgbW9kZVxcbi8vIGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyICh0cmFjLTEzMzM1KS4gQnV0IGFzIG9mIGpRdWVyeSAzLjAgKDIwMTYpLCBzdHJpY3QgbW9kZSBzaG91bGQgYmUgY29tbW9uXFxuLy8gZW5vdWdoIHRoYXQgYWxsIHN1Y2ggYXR0ZW1wdHMgYXJlIGd1YXJkZWQgaW4gYSB0cnkgYmxvY2suXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbnZhciBhcnIgPSBbXTtcXG5cXG52YXIgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XFxuXFxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xcblxcbnZhciBzbGljZSA9IGFyci5zbGljZTtcXG5cXG52YXIgY29uY2F0ID0gYXJyLmNvbmNhdDtcXG5cXG52YXIgcHVzaCA9IGFyci5wdXNoO1xcblxcbnZhciBpbmRleE9mID0gYXJyLmluZGV4T2Y7XFxuXFxudmFyIGNsYXNzMnR5cGUgPSB7fTtcXG5cXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xcblxcbnZhciBoYXNPd24gPSBjbGFzczJ0eXBlLmhhc093blByb3BlcnR5O1xcblxcbnZhciBmblRvU3RyaW5nID0gaGFzT3duLnRvU3RyaW5nO1xcblxcbnZhciBPYmplY3RGdW5jdGlvblN0cmluZyA9IGZuVG9TdHJpbmcuY2FsbCggT2JqZWN0ICk7XFxuXFxudmFyIHN1cHBvcnQgPSB7fTtcXG5cXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzRnVuY3Rpb24oIG9iaiApIHtcXG5cXG4gICAgICAvLyBTdXBwb3J0OiBDaHJvbWUgPD01NywgRmlyZWZveCA8PTUyXFxuICAgICAgLy8gSW4gc29tZSBicm93c2VycywgdHlwZW9mIHJldHVybnMgXFxcImZ1bmN0aW9uXFxcIiBmb3IgSFRNTCA8b2JqZWN0PiBlbGVtZW50c1xcbiAgICAgIC8vIChpLmUuLCBgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFxcXCJvYmplY3RcXFwiICkgPT09IFxcXCJmdW5jdGlvblxcXCJgKS5cXG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGNsYXNzaWZ5ICphbnkqIERPTSBub2RlIGFzIGEgZnVuY3Rpb24uXFxuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIG9iai5ub2RlVHlwZSAhPT0gXFxcIm51bWJlclxcXCI7XFxuICB9O1xcblxcblxcbnZhciBpc1dpbmRvdyA9IGZ1bmN0aW9uIGlzV2luZG93KCBvYmogKSB7XFxuXFx0XFx0cmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PT0gb2JqLndpbmRvdztcXG5cXHR9O1xcblxcblxcblxcblxcblxcdHZhciBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzID0ge1xcblxcdFxcdHR5cGU6IHRydWUsXFxuXFx0XFx0c3JjOiB0cnVlLFxcblxcdFxcdG5vTW9kdWxlOiB0cnVlXFxuXFx0fTtcXG5cXG5cXHRmdW5jdGlvbiBET01FdmFsKCBjb2RlLCBkb2MsIG5vZGUgKSB7XFxuXFx0XFx0ZG9jID0gZG9jIHx8IGRvY3VtZW50O1xcblxcblxcdFxcdHZhciBpLFxcblxcdFxcdFxcdHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KCBcXFwic2NyaXB0XFxcIiApO1xcblxcblxcdFxcdHNjcmlwdC50ZXh0ID0gY29kZTtcXG5cXHRcXHRpZiAoIG5vZGUgKSB7XFxuXFx0XFx0XFx0Zm9yICggaSBpbiBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzICkge1xcblxcdFxcdFxcdFxcdGlmICggbm9kZVsgaSBdICkge1xcblxcdFxcdFxcdFxcdFxcdHNjcmlwdFsgaSBdID0gbm9kZVsgaSBdO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdFxcdGRvYy5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcXG5cXHR9XFxuXFxuXFxuZnVuY3Rpb24gdG9UeXBlKCBvYmogKSB7XFxuXFx0aWYgKCBvYmogPT0gbnVsbCApIHtcXG5cXHRcXHRyZXR1cm4gb2JqICsgXFxcIlxcXCI7XFxuXFx0fVxcblxcblxcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seSAoZnVuY3Rpb25pc2ggUmVnRXhwKVxcblxcdHJldHVybiB0eXBlb2Ygb2JqID09PSBcXFwib2JqZWN0XFxcIiB8fCB0eXBlb2Ygb2JqID09PSBcXFwiZnVuY3Rpb25cXFwiID9cXG5cXHRcXHRjbGFzczJ0eXBlWyB0b1N0cmluZy5jYWxsKCBvYmogKSBdIHx8IFxcXCJvYmplY3RcXFwiIDpcXG5cXHRcXHR0eXBlb2Ygb2JqO1xcbn1cXG4vKiBnbG9iYWwgU3ltYm9sICovXFxuLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmVzbGludHJjLmpzb24gd291bGQgY3JlYXRlIGEgZGFuZ2VyIG9mIHVzaW5nIHRoZSBnbG9iYWxcXG4vLyB1bmd1YXJkZWQgaW4gYW5vdGhlciBwbGFjZSwgaXQgc2VlbXMgc2FmZXIgdG8gZGVmaW5lIGdsb2JhbCBvbmx5IGZvciB0aGlzIG1vZHVsZVxcblxcblxcblxcbnZhclxcblxcdHZlcnNpb24gPSBcXFwiMy4zLjFcXFwiLFxcblxcblxcdC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XFxuXFx0alF1ZXJ5ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xcblxcblxcdFxcdC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xcblxcdFxcdC8vIE5lZWQgaW5pdCBpZiBqUXVlcnkgaXMgY2FsbGVkIChqdXN0IGFsbG93IGVycm9yIHRvIGJlIHRocm93biBpZiBub3QgaW5jbHVkZWQpXFxuXFx0XFx0cmV0dXJuIG5ldyBqUXVlcnkuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKTtcXG5cXHR9LFxcblxcblxcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxcblxcdC8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxcblxcdHJ0cmltID0gL15bXFxcXHNcXFxcdUZFRkZcXFxceEEwXSt8W1xcXFxzXFxcXHVGRUZGXFxcXHhBMF0rJC9nO1xcblxcbmpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XFxuXFxuXFx0Ly8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxcblxcdGpxdWVyeTogdmVyc2lvbixcXG5cXG5cXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxcblxcblxcdC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxcblxcdGxlbmd0aDogMCxcXG5cXG5cXHR0b0FycmF5OiBmdW5jdGlvbigpIHtcXG5cXHRcXHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xcblxcdH0sXFxuXFxuXFx0Ly8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxcblxcdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XFxuXFx0Z2V0OiBmdW5jdGlvbiggbnVtICkge1xcblxcblxcdFxcdC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcXG5cXHRcXHRpZiAoIG51bSA9PSBudWxsICkge1xcblxcdFxcdFxcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFJldHVybiBqdXN0IHRoZSBvbmUgZWxlbWVudCBmcm9tIHRoZSBzZXRcXG5cXHRcXHRyZXR1cm4gbnVtIDwgMCA/IHRoaXNbIG51bSArIHRoaXMubGVuZ3RoIF0gOiB0aGlzWyBudW0gXTtcXG5cXHR9LFxcblxcblxcdC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcXG5cXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcXG5cXHRwdXNoU3RhY2s6IGZ1bmN0aW9uKCBlbGVtcyApIHtcXG5cXG5cXHRcXHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxcblxcdFxcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcXG5cXG5cXHRcXHQvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxcblxcdFxcdHJldC5wcmV2T2JqZWN0ID0gdGhpcztcXG5cXG5cXHRcXHQvLyBSZXR1cm4gdGhlIG5ld2x5LWZvcm1lZCBlbGVtZW50IHNldFxcblxcdFxcdHJldHVybiByZXQ7XFxuXFx0fSxcXG5cXG5cXHQvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxcblxcdGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcXG5cXHRcXHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrICk7XFxuXFx0fSxcXG5cXG5cXHRtYXA6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5tYXAoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xcblxcdFxcdFxcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XFxuXFx0XFx0fSApICk7XFxuXFx0fSxcXG5cXG5cXHRzbGljZTogZnVuY3Rpb24oKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBzbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgKTtcXG5cXHR9LFxcblxcblxcdGZpcnN0OiBmdW5jdGlvbigpIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5lcSggMCApO1xcblxcdH0sXFxuXFxuXFx0bGFzdDogZnVuY3Rpb24oKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XFxuXFx0fSxcXG5cXG5cXHRlcTogZnVuY3Rpb24oIGkgKSB7XFxuXFx0XFx0dmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxcblxcdFxcdFxcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XFxuXFx0XFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1sgaiBdIF0gOiBbXSApO1xcblxcdH0sXFxuXFxuXFx0ZW5kOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IoKTtcXG5cXHR9LFxcblxcblxcdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cXG5cXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cXG5cXHRwdXNoOiBwdXNoLFxcblxcdHNvcnQ6IGFyci5zb3J0LFxcblxcdHNwbGljZTogYXJyLnNwbGljZVxcbn07XFxuXFxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcXG5cXHR2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXFxuXFx0XFx0dGFyZ2V0ID0gYXJndW1lbnRzWyAwIF0gfHwge30sXFxuXFx0XFx0aSA9IDEsXFxuXFx0XFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcXG5cXHRcXHRkZWVwID0gZmFsc2U7XFxuXFxuXFx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxcblxcdGlmICggdHlwZW9mIHRhcmdldCA9PT0gXFxcImJvb2xlYW5cXFwiICkge1xcblxcdFxcdGRlZXAgPSB0YXJnZXQ7XFxuXFxuXFx0XFx0Ly8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxcblxcdFxcdHRhcmdldCA9IGFyZ3VtZW50c1sgaSBdIHx8IHt9O1xcblxcdFxcdGkrKztcXG5cXHR9XFxuXFxuXFx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXFxuXFx0aWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcXFwib2JqZWN0XFxcIiAmJiAhaXNGdW5jdGlvbiggdGFyZ2V0ICkgKSB7XFxuXFx0XFx0dGFyZ2V0ID0ge307XFxuXFx0fVxcblxcblxcdC8vIEV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxcblxcdGlmICggaSA9PT0gbGVuZ3RoICkge1xcblxcdFxcdHRhcmdldCA9IHRoaXM7XFxuXFx0XFx0aS0tO1xcblxcdH1cXG5cXG5cXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcXG5cXG5cXHRcXHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXFxuXFx0XFx0aWYgKCAoIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSApICE9IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxcblxcdFxcdFxcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcXG5cXHRcXHRcXHRcXHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcXG5cXHRcXHRcXHRcXHRjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xcblxcblxcdFxcdFxcdFxcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3BcXG5cXHRcXHRcXHRcXHRpZiAoIHRhcmdldCA9PT0gY29weSApIHtcXG5cXHRcXHRcXHRcXHRcXHRjb250aW51ZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXFxuXFx0XFx0XFx0XFx0aWYgKCBkZWVwICYmIGNvcHkgJiYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29weSApIHx8XFxuXFx0XFx0XFx0XFx0XFx0KCBjb3B5SXNBcnJheSA9IEFycmF5LmlzQXJyYXkoIGNvcHkgKSApICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBjb3B5SXNBcnJheSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjb3B5SXNBcnJheSA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNsb25lID0gc3JjICYmIEFycmF5LmlzQXJyYXkoIHNyYyApID8gc3JjIDogW107XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggc3JjICkgPyBzcmMgOiB7fTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXFxuXFx0XFx0XFx0XFx0XFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xcblxcblxcdFxcdFxcdFxcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGFyZ2V0WyBuYW1lIF0gPSBjb3B5O1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHQvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxcblxcdHJldHVybiB0YXJnZXQ7XFxufTtcXG5cXG5qUXVlcnkuZXh0ZW5kKCB7XFxuXFxuXFx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXFxuXFx0ZXhwYW5kbzogXFxcImpRdWVyeVxcXCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcXFxEL2csIFxcXCJcXFwiICksXFxuXFxuXFx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcXG5cXHRpc1JlYWR5OiB0cnVlLFxcblxcblxcdGVycm9yOiBmdW5jdGlvbiggbXNnICkge1xcblxcdFxcdHRocm93IG5ldyBFcnJvciggbXNnICk7XFxuXFx0fSxcXG5cXG5cXHRub29wOiBmdW5jdGlvbigpIHt9LFxcblxcblxcdGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XFxuXFx0XFx0dmFyIHByb3RvLCBDdG9yO1xcblxcblxcdFxcdC8vIERldGVjdCBvYnZpb3VzIG5lZ2F0aXZlc1xcblxcdFxcdC8vIFVzZSB0b1N0cmluZyBpbnN0ZWFkIG9mIGpRdWVyeS50eXBlIHRvIGNhdGNoIGhvc3Qgb2JqZWN0c1xcblxcdFxcdGlmICggIW9iaiB8fCB0b1N0cmluZy5jYWxsKCBvYmogKSAhPT0gXFxcIltvYmplY3QgT2JqZWN0XVxcXCIgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRwcm90byA9IGdldFByb3RvKCBvYmogKTtcXG5cXG5cXHRcXHQvLyBPYmplY3RzIHdpdGggbm8gcHJvdG90eXBlIChlLmcuLCBgT2JqZWN0LmNyZWF0ZSggbnVsbCApYCkgYXJlIHBsYWluXFxuXFx0XFx0aWYgKCAhcHJvdG8gKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIE9iamVjdHMgd2l0aCBwcm90b3R5cGUgYXJlIHBsYWluIGlmZiB0aGV5IHdlcmUgY29uc3RydWN0ZWQgYnkgYSBnbG9iYWwgT2JqZWN0IGZ1bmN0aW9uXFxuXFx0XFx0Q3RvciA9IGhhc093bi5jYWxsKCBwcm90bywgXFxcImNvbnN0cnVjdG9yXFxcIiApICYmIHByb3RvLmNvbnN0cnVjdG9yO1xcblxcdFxcdHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBmblRvU3RyaW5nLmNhbGwoIEN0b3IgKSA9PT0gT2JqZWN0RnVuY3Rpb25TdHJpbmc7XFxuXFx0fSxcXG5cXG5cXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xcblxcblxcdFxcdC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXFxuXFx0XFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy82MTI1XFxuXFx0XFx0dmFyIG5hbWU7XFxuXFxuXFx0XFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHR9LFxcblxcblxcdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIGdsb2JhbCBjb250ZXh0XFxuXFx0Z2xvYmFsRXZhbDogZnVuY3Rpb24oIGNvZGUgKSB7XFxuXFx0XFx0RE9NRXZhbCggY29kZSApO1xcblxcdH0sXFxuXFxuXFx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2sgKSB7XFxuXFx0XFx0dmFyIGxlbmd0aCwgaSA9IDA7XFxuXFxuXFx0XFx0aWYgKCBpc0FycmF5TGlrZSggb2JqICkgKSB7XFxuXFx0XFx0XFx0bGVuZ3RoID0gb2JqLmxlbmd0aDtcXG5cXHRcXHRcXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcXG5cXHRcXHRcXHRcXHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0Zm9yICggaSBpbiBvYmogKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIG9iajtcXG5cXHR9LFxcblxcblxcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxcblxcdHRyaW06IGZ1bmN0aW9uKCB0ZXh0ICkge1xcblxcdFxcdHJldHVybiB0ZXh0ID09IG51bGwgP1xcblxcdFxcdFxcdFxcXCJcXFwiIDpcXG5cXHRcXHRcXHQoIHRleHQgKyBcXFwiXFxcIiApLnJlcGxhY2UoIHJ0cmltLCBcXFwiXFxcIiApO1xcblxcdH0sXFxuXFxuXFx0Ly8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxcblxcdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcXG5cXHRcXHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcXG5cXG5cXHRcXHRpZiAoIGFyciAhPSBudWxsICkge1xcblxcdFxcdFxcdGlmICggaXNBcnJheUxpa2UoIE9iamVjdCggYXJyICkgKSApIHtcXG5cXHRcXHRcXHRcXHRqUXVlcnkubWVyZ2UoIHJldCxcXG5cXHRcXHRcXHRcXHRcXHR0eXBlb2YgYXJyID09PSBcXFwic3RyaW5nXFxcIiA/XFxuXFx0XFx0XFx0XFx0XFx0WyBhcnIgXSA6IGFyclxcblxcdFxcdFxcdFxcdCk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRwdXNoLmNhbGwoIHJldCwgYXJyICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gcmV0O1xcblxcdH0sXFxuXFxuXFx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcXG5cXHRcXHRyZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XFxuXFx0fSxcXG5cXG5cXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcXG5cXHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XFxuXFx0bWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkge1xcblxcdFxcdHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcXG5cXHRcXHRcXHRqID0gMCxcXG5cXHRcXHRcXHRpID0gZmlyc3QubGVuZ3RoO1xcblxcblxcdFxcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xcblxcdFxcdFxcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaiBdO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRmaXJzdC5sZW5ndGggPSBpO1xcblxcblxcdFxcdHJldHVybiBmaXJzdDtcXG5cXHR9LFxcblxcblxcdGdyZXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGludmVydCApIHtcXG5cXHRcXHR2YXIgY2FsbGJhY2tJbnZlcnNlLFxcblxcdFxcdFxcdG1hdGNoZXMgPSBbXSxcXG5cXHRcXHRcXHRpID0gMCxcXG5cXHRcXHRcXHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXFxuXFx0XFx0XFx0Y2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xcblxcblxcdFxcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcXG5cXHRcXHQvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxcblxcdFxcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xcblxcdFxcdFxcdGNhbGxiYWNrSW52ZXJzZSA9ICFjYWxsYmFjayggZWxlbXNbIGkgXSwgaSApO1xcblxcdFxcdFxcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcXG5cXHRcXHRcXHRcXHRtYXRjaGVzLnB1c2goIGVsZW1zWyBpIF0gKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBtYXRjaGVzO1xcblxcdH0sXFxuXFxuXFx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XFxuXFx0bWFwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBhcmcgKSB7XFxuXFx0XFx0dmFyIGxlbmd0aCwgdmFsdWUsXFxuXFx0XFx0XFx0aSA9IDAsXFxuXFx0XFx0XFx0cmV0ID0gW107XFxuXFxuXFx0XFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIHRyYW5zbGF0aW5nIGVhY2ggb2YgdGhlIGl0ZW1zIHRvIHRoZWlyIG5ldyB2YWx1ZXNcXG5cXHRcXHRpZiAoIGlzQXJyYXlMaWtlKCBlbGVtcyApICkge1xcblxcdFxcdFxcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aDtcXG5cXHRcXHRcXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcXG5cXHRcXHRcXHRcXHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0LnB1c2goIHZhbHVlICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHQvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0Zm9yICggaSBpbiBlbGVtcyApIHtcXG5cXHRcXHRcXHRcXHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0LnB1c2goIHZhbHVlICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xcblxcdFxcdHJldHVybiBjb25jYXQuYXBwbHkoIFtdLCByZXQgKTtcXG5cXHR9LFxcblxcblxcdC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xcblxcdGd1aWQ6IDEsXFxuXFxuXFx0Ly8galF1ZXJ5LnN1cHBvcnQgaXMgbm90IHVzZWQgaW4gQ29yZSBidXQgb3RoZXIgcHJvamVjdHMgYXR0YWNoIHRoZWlyXFxuXFx0Ly8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cXG5cXHRzdXBwb3J0OiBzdXBwb3J0XFxufSApO1xcblxcbmlmICggdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiApIHtcXG5cXHRqUXVlcnkuZm5bIFN5bWJvbC5pdGVyYXRvciBdID0gYXJyWyBTeW1ib2wuaXRlcmF0b3IgXTtcXG59XFxuXFxuLy8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwXFxualF1ZXJ5LmVhY2goIFxcXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFxcXCIuc3BsaXQoIFxcXCIgXFxcIiApLFxcbmZ1bmN0aW9uKCBpLCBuYW1lICkge1xcblxcdGNsYXNzMnR5cGVbIFxcXCJbb2JqZWN0IFxcXCIgKyBuYW1lICsgXFxcIl1cXFwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XFxufSApO1xcblxcbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKCBvYmogKSB7XFxuXFxuXFx0Ly8gU3VwcG9ydDogcmVhbCBpT1MgOC4yIG9ubHkgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxcblxcdC8vIGBpbmAgY2hlY2sgdXNlZCB0byBwcmV2ZW50IEpJVCBlcnJvciAoZ2gtMjE0NSlcXG5cXHQvLyBoYXNPd24gaXNuJ3QgdXNlZCBoZXJlIGR1ZSB0byBmYWxzZSBuZWdhdGl2ZXNcXG5cXHQvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXFxuXFx0dmFyIGxlbmd0aCA9ICEhb2JqICYmIFxcXCJsZW5ndGhcXFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxcblxcdFxcdHR5cGUgPSB0b1R5cGUoIG9iaiApO1xcblxcblxcdGlmICggaXNGdW5jdGlvbiggb2JqICkgfHwgaXNXaW5kb3coIG9iaiApICkge1xcblxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIHR5cGUgPT09IFxcXCJhcnJheVxcXCIgfHwgbGVuZ3RoID09PSAwIHx8XFxuXFx0XFx0dHlwZW9mIGxlbmd0aCA9PT0gXFxcIm51bWJlclxcXCIgJiYgbGVuZ3RoID4gMCAmJiAoIGxlbmd0aCAtIDEgKSBpbiBvYmo7XFxufVxcbnZhciBTaXp6bGUgPVxcbi8qIVxcbiAqIFNpenpsZSBDU1MgU2VsZWN0b3IgRW5naW5lIHYyLjMuM1xcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xcbiAqXFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICpcXG4gKiBEYXRlOiAyMDE2LTA4LTA4XFxuICovXFxuKGZ1bmN0aW9uKCB3aW5kb3cgKSB7XFxuXFxudmFyIGksXFxuXFx0c3VwcG9ydCxcXG5cXHRFeHByLFxcblxcdGdldFRleHQsXFxuXFx0aXNYTUwsXFxuXFx0dG9rZW5pemUsXFxuXFx0Y29tcGlsZSxcXG5cXHRzZWxlY3QsXFxuXFx0b3V0ZXJtb3N0Q29udGV4dCxcXG5cXHRzb3J0SW5wdXQsXFxuXFx0aGFzRHVwbGljYXRlLFxcblxcblxcdC8vIExvY2FsIGRvY3VtZW50IHZhcnNcXG5cXHRzZXREb2N1bWVudCxcXG5cXHRkb2N1bWVudCxcXG5cXHRkb2NFbGVtLFxcblxcdGRvY3VtZW50SXNIVE1MLFxcblxcdHJidWdneVFTQSxcXG5cXHRyYnVnZ3lNYXRjaGVzLFxcblxcdG1hdGNoZXMsXFxuXFx0Y29udGFpbnMsXFxuXFxuXFx0Ly8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxcblxcdGV4cGFuZG8gPSBcXFwic2l6emxlXFxcIiArIDEgKiBuZXcgRGF0ZSgpLFxcblxcdHByZWZlcnJlZERvYyA9IHdpbmRvdy5kb2N1bWVudCxcXG5cXHRkaXJydW5zID0gMCxcXG5cXHRkb25lID0gMCxcXG5cXHRjbGFzc0NhY2hlID0gY3JlYXRlQ2FjaGUoKSxcXG5cXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcXG5cXHRjb21waWxlckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcXG5cXHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcXG5cXHRcXHRpZiAoIGEgPT09IGIgKSB7XFxuXFx0XFx0XFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIDA7XFxuXFx0fSxcXG5cXG5cXHQvLyBJbnN0YW5jZSBtZXRob2RzXFxuXFx0aGFzT3duID0gKHt9KS5oYXNPd25Qcm9wZXJ0eSxcXG5cXHRhcnIgPSBbXSxcXG5cXHRwb3AgPSBhcnIucG9wLFxcblxcdHB1c2hfbmF0aXZlID0gYXJyLnB1c2gsXFxuXFx0cHVzaCA9IGFyci5wdXNoLFxcblxcdHNsaWNlID0gYXJyLnNsaWNlLFxcblxcdC8vIFVzZSBhIHN0cmlwcGVkLWRvd24gaW5kZXhPZiBhcyBpdCdzIGZhc3RlciB0aGFuIG5hdGl2ZVxcblxcdC8vIGh0dHBzOi8vanNwZXJmLmNvbS90aG9yLWluZGV4b2YtdnMtZm9yLzVcXG5cXHRpbmRleE9mID0gZnVuY3Rpb24oIGxpc3QsIGVsZW0gKSB7XFxuXFx0XFx0dmFyIGkgPSAwLFxcblxcdFxcdFxcdGxlbiA9IGxpc3QubGVuZ3RoO1xcblxcdFxcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xcblxcdFxcdFxcdGlmICggbGlzdFtpXSA9PT0gZWxlbSApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gaTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiAtMTtcXG5cXHR9LFxcblxcblxcdGJvb2xlYW5zID0gXFxcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXFxcIixcXG5cXG5cXHQvLyBSZWd1bGFyIGV4cHJlc3Npb25zXFxuXFxuXFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI3doaXRlc3BhY2VcXG5cXHR3aGl0ZXNwYWNlID0gXFxcIltcXFxcXFxcXHgyMFxcXFxcXFxcdFxcXFxcXFxcclxcXFxcXFxcblxcXFxcXFxcZl1cXFwiLFxcblxcblxcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCN2YWx1ZS1kZWYtaWRlbnRpZmllclxcblxcdGlkZW50aWZpZXIgPSBcXFwiKD86XFxcXFxcXFxcXFxcXFxcXC58W1xcXFxcXFxcdy1dfFteXFxcXDAtXFxcXFxcXFx4YTBdKStcXFwiLFxcblxcblxcdC8vIEF0dHJpYnV0ZSBzZWxlY3RvcnM6IGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xcblxcdGF0dHJpYnV0ZXMgPSBcXFwiXFxcXFxcXFxbXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKihcXFwiICsgaWRlbnRpZmllciArIFxcXCIpKD86XFxcIiArIHdoaXRlc3BhY2UgK1xcblxcdFxcdC8vIE9wZXJhdG9yIChjYXB0dXJlIDIpXFxuXFx0XFx0XFxcIiooWypeJHwhfl0/PSlcXFwiICsgd2hpdGVzcGFjZSArXFxuXFx0XFx0Ly8gXFxcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV0gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF1cXFwiXFxuXFx0XFx0XFxcIiooPzonKCg/OlxcXFxcXFxcXFxcXFxcXFwufFteXFxcXFxcXFxcXFxcXFxcXCddKSopJ3xcXFxcXFxcIigoPzpcXFxcXFxcXFxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcIl0pKilcXFxcXFxcInwoXFxcIiArIGlkZW50aWZpZXIgKyBcXFwiKSl8KVxcXCIgKyB3aGl0ZXNwYWNlICtcXG5cXHRcXHRcXFwiKlxcXFxcXFxcXVxcXCIsXFxuXFxuXFx0cHNldWRvcyA9IFxcXCI6KFxcXCIgKyBpZGVudGlmaWVyICsgXFxcIikoPzpcXFxcXFxcXCgoXFxcIiArXFxuXFx0XFx0Ly8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcXG5cXHRcXHQvLyAxLiBxdW90ZWQgKGNhcHR1cmUgMzsgY2FwdHVyZSA0IG9yIGNhcHR1cmUgNSlcXG5cXHRcXHRcXFwiKCcoKD86XFxcXFxcXFxcXFxcXFxcXC58W15cXFxcXFxcXFxcXFxcXFxcJ10pKiknfFxcXFxcXFwiKCg/OlxcXFxcXFxcXFxcXFxcXFwufFteXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFwiXSkqKVxcXFxcXFwiKXxcXFwiICtcXG5cXHRcXHQvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcXG5cXHRcXHRcXFwiKCg/OlxcXFxcXFxcXFxcXFxcXFwufFteXFxcXFxcXFxcXFxcXFxcXCgpW1xcXFxcXFxcXV18XFxcIiArIGF0dHJpYnV0ZXMgKyBcXFwiKSopfFxcXCIgK1xcblxcdFxcdC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcXG5cXHRcXHRcXFwiLipcXFwiICtcXG5cXHRcXHRcXFwiKVxcXFxcXFxcKXwpXFxcIixcXG5cXG5cXHQvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXFxuXFx0cndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXFxcIitcXFwiLCBcXFwiZ1xcXCIgKSxcXG5cXHRydHJpbSA9IG5ldyBSZWdFeHAoIFxcXCJeXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiK3woKD86XnxbXlxcXFxcXFxcXFxcXFxcXFxdKSg/OlxcXFxcXFxcXFxcXFxcXFwuKSopXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKyRcXFwiLCBcXFwiZ1xcXCIgKSxcXG5cXG5cXHRyY29tbWEgPSBuZXcgUmVnRXhwKCBcXFwiXlxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIiosXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKlxcXCIgKSxcXG5cXHRyY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKCBcXFwiXlxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIiooWz4rfl18XFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKVxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIipcXFwiICksXFxuXFxuXFx0cmF0dHJpYnV0ZVF1b3RlcyA9IG5ldyBSZWdFeHAoIFxcXCI9XFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKihbXlxcXFxcXFxcXSdcXFxcXFxcIl0qPylcXFwiICsgd2hpdGVzcGFjZSArIFxcXCIqXFxcXFxcXFxdXFxcIiwgXFxcImdcXFwiICksXFxuXFxuXFx0cnBzZXVkbyA9IG5ldyBSZWdFeHAoIHBzZXVkb3MgKSxcXG5cXHRyaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoIFxcXCJeXFxcIiArIGlkZW50aWZpZXIgKyBcXFwiJFxcXCIgKSxcXG5cXG5cXHRtYXRjaEV4cHIgPSB7XFxuXFx0XFx0XFxcIklEXFxcIjogbmV3IFJlZ0V4cCggXFxcIl4jKFxcXCIgKyBpZGVudGlmaWVyICsgXFxcIilcXFwiICksXFxuXFx0XFx0XFxcIkNMQVNTXFxcIjogbmV3IFJlZ0V4cCggXFxcIl5cXFxcXFxcXC4oXFxcIiArIGlkZW50aWZpZXIgKyBcXFwiKVxcXCIgKSxcXG5cXHRcXHRcXFwiVEFHXFxcIjogbmV3IFJlZ0V4cCggXFxcIl4oXFxcIiArIGlkZW50aWZpZXIgKyBcXFwifFsqXSlcXFwiICksXFxuXFx0XFx0XFxcIkFUVFJcXFwiOiBuZXcgUmVnRXhwKCBcXFwiXlxcXCIgKyBhdHRyaWJ1dGVzICksXFxuXFx0XFx0XFxcIlBTRVVET1xcXCI6IG5ldyBSZWdFeHAoIFxcXCJeXFxcIiArIHBzZXVkb3MgKSxcXG5cXHRcXHRcXFwiQ0hJTERcXFwiOiBuZXcgUmVnRXhwKCBcXFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXFxcXFwoXFxcIiArIHdoaXRlc3BhY2UgK1xcblxcdFxcdFxcdFxcXCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxcXFxcZCopbnwpXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKig/OihbKy1dfClcXFwiICsgd2hpdGVzcGFjZSArXFxuXFx0XFx0XFx0XFxcIiooXFxcXFxcXFxkKyl8KSlcXFwiICsgd2hpdGVzcGFjZSArIFxcXCIqXFxcXFxcXFwpfClcXFwiLCBcXFwiaVxcXCIgKSxcXG5cXHRcXHRcXFwiYm9vbFxcXCI6IG5ldyBSZWdFeHAoIFxcXCJeKD86XFxcIiArIGJvb2xlYW5zICsgXFxcIikkXFxcIiwgXFxcImlcXFwiICksXFxuXFx0XFx0Ly8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXFxuXFx0XFx0Ly8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxcblxcdFxcdFxcXCJuZWVkc0NvbnRleHRcXFwiOiBuZXcgUmVnRXhwKCBcXFwiXlxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFxcXFxcKFxcXCIgK1xcblxcdFxcdFxcdHdoaXRlc3BhY2UgKyBcXFwiKigoPzotXFxcXFxcXFxkKT9cXFxcXFxcXGQqKVxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIipcXFxcXFxcXCl8KSg/PVteLV18JClcXFwiLCBcXFwiaVxcXCIgKVxcblxcdH0sXFxuXFxuXFx0cmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXFxuXFx0cmhlYWRlciA9IC9eaFxcXFxkJC9pLFxcblxcblxcdHJuYXRpdmUgPSAvXltee10rXFxcXHtcXFxccypcXFxcW25hdGl2ZSBcXFxcdy8sXFxuXFxuXFx0Ly8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXFxuXFx0cnF1aWNrRXhwciA9IC9eKD86IyhbXFxcXHctXSspfChcXFxcdyspfFxcXFwuKFtcXFxcdy1dKykpJC8sXFxuXFxuXFx0cnNpYmxpbmcgPSAvWyt+XS8sXFxuXFxuXFx0Ly8gQ1NTIGVzY2FwZXNcXG5cXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjZXNjYXBlZC1jaGFyYWN0ZXJzXFxuXFx0cnVuZXNjYXBlID0gbmV3IFJlZ0V4cCggXFxcIlxcXFxcXFxcXFxcXFxcXFwoW1xcXFxcXFxcZGEtZl17MSw2fVxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIj98KFxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIil8LilcXFwiLCBcXFwiaWdcXFwiICksXFxuXFx0ZnVuZXNjYXBlID0gZnVuY3Rpb24oIF8sIGVzY2FwZWQsIGVzY2FwZWRXaGl0ZXNwYWNlICkge1xcblxcdFxcdHZhciBoaWdoID0gXFxcIjB4XFxcIiArIGVzY2FwZWQgLSAweDEwMDAwO1xcblxcdFxcdC8vIE5hTiBtZWFucyBub24tY29kZXBvaW50XFxuXFx0XFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyNFxcblxcdFxcdC8vIFdvcmthcm91bmQgZXJyb25lb3VzIG51bWVyaWMgaW50ZXJwcmV0YXRpb24gb2YgK1xcXCIweFxcXCJcXG5cXHRcXHRyZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZSA/XFxuXFx0XFx0XFx0ZXNjYXBlZCA6XFxuXFx0XFx0XFx0aGlnaCA8IDAgP1xcblxcdFxcdFxcdFxcdC8vIEJNUCBjb2RlcG9pbnRcXG5cXHRcXHRcXHRcXHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcXG5cXHRcXHRcXHRcXHQvLyBTdXBwbGVtZW50YWwgUGxhbmUgY29kZXBvaW50IChzdXJyb2dhdGUgcGFpcilcXG5cXHRcXHRcXHRcXHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDAgKTtcXG5cXHR9LFxcblxcblxcdC8vIENTUyBzdHJpbmcvaWRlbnRpZmllciBzZXJpYWxpemF0aW9uXFxuXFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNjb21tb24tc2VyaWFsaXppbmctaWRpb21zXFxuXFx0cmNzc2VzY2FwZSA9IC8oW1xcXFwwLVxcXFx4MWZcXFxceDdmXXxeLT9cXFxcZCl8Xi0kfFteXFxcXDAtXFxcXHgxZlxcXFx4N2YtXFxcXHVGRkZGXFxcXHctXS9nLFxcblxcdGZjc3Nlc2NhcGUgPSBmdW5jdGlvbiggY2gsIGFzQ29kZVBvaW50ICkge1xcblxcdFxcdGlmICggYXNDb2RlUG9pbnQgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gVSswMDAwIE5VTEwgYmVjb21lcyBVK0ZGRkQgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXFxuXFx0XFx0XFx0aWYgKCBjaCA9PT0gXFxcIlxcXFwwXFxcIiApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gXFxcIlxcXFx1RkZGRFxcXCI7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIENvbnRyb2wgY2hhcmFjdGVycyBhbmQgKGRlcGVuZGVudCB1cG9uIHBvc2l0aW9uKSBudW1iZXJzIGdldCBlc2NhcGVkIGFzIGNvZGUgcG9pbnRzXFxuXFx0XFx0XFx0cmV0dXJuIGNoLnNsaWNlKCAwLCAtMSApICsgXFxcIlxcXFxcXFxcXFxcIiArIGNoLmNoYXJDb2RlQXQoIGNoLmxlbmd0aCAtIDEgKS50b1N0cmluZyggMTYgKSArIFxcXCIgXFxcIjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gT3RoZXIgcG90ZW50aWFsbHktc3BlY2lhbCBBU0NJSSBjaGFyYWN0ZXJzIGdldCBiYWNrc2xhc2gtZXNjYXBlZFxcblxcdFxcdHJldHVybiBcXFwiXFxcXFxcXFxcXFwiICsgY2g7XFxuXFx0fSxcXG5cXG5cXHQvLyBVc2VkIGZvciBpZnJhbWVzXFxuXFx0Ly8gU2VlIHNldERvY3VtZW50KClcXG5cXHQvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcXFwiUGVybWlzc2lvbiBEZW5pZWRcXFwiXFxuXFx0Ly8gZXJyb3IgaW4gSUVcXG5cXHR1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0c2V0RG9jdW1lbnQoKTtcXG5cXHR9LFxcblxcblxcdGRpc2FibGVkQW5jZXN0b3IgPSBhZGRDb21iaW5hdG9yKFxcblxcdFxcdGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlICYmIChcXFwiZm9ybVxcXCIgaW4gZWxlbSB8fCBcXFwibGFiZWxcXFwiIGluIGVsZW0pO1xcblxcdFxcdH0sXFxuXFx0XFx0eyBkaXI6IFxcXCJwYXJlbnROb2RlXFxcIiwgbmV4dDogXFxcImxlZ2VuZFxcXCIgfVxcblxcdCk7XFxuXFxuLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcXG50cnkge1xcblxcdHB1c2guYXBwbHkoXFxuXFx0XFx0KGFyciA9IHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzICkpLFxcblxcdFxcdHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXFxuXFx0KTtcXG5cXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxcblxcdC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcXG5cXHRhcnJbIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzLmxlbmd0aCBdLm5vZGVUeXBlO1xcbn0gY2F0Y2ggKCBlICkge1xcblxcdHB1c2ggPSB7IGFwcGx5OiBhcnIubGVuZ3RoID9cXG5cXG5cXHRcXHQvLyBMZXZlcmFnZSBzbGljZSBpZiBwb3NzaWJsZVxcblxcdFxcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcXG5cXHRcXHRcXHRwdXNoX25hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKGVscykgKTtcXG5cXHRcXHR9IDpcXG5cXG5cXHRcXHQvLyBTdXBwb3J0OiBJRTw5XFxuXFx0XFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZCBkaXJlY3RseVxcblxcdFxcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcXG5cXHRcXHRcXHR2YXIgaiA9IHRhcmdldC5sZW5ndGgsXFxuXFx0XFx0XFx0XFx0aSA9IDA7XFxuXFx0XFx0XFx0Ly8gQ2FuJ3QgdHJ1c3QgTm9kZUxpc3QubGVuZ3RoXFxuXFx0XFx0XFx0d2hpbGUgKCAodGFyZ2V0W2orK10gPSBlbHNbaSsrXSkgKSB7fVxcblxcdFxcdFxcdHRhcmdldC5sZW5ndGggPSBqIC0gMTtcXG5cXHRcXHR9XFxuXFx0fTtcXG59XFxuXFxuZnVuY3Rpb24gU2l6emxlKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcXG5cXHR2YXIgbSwgaSwgZWxlbSwgbmlkLCBtYXRjaCwgZ3JvdXBzLCBuZXdTZWxlY3RvcixcXG5cXHRcXHRuZXdDb250ZXh0ID0gY29udGV4dCAmJiBjb250ZXh0Lm93bmVyRG9jdW1lbnQsXFxuXFxuXFx0XFx0Ly8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxcblxcdFxcdG5vZGVUeXBlID0gY29udGV4dCA/IGNvbnRleHQubm9kZVR5cGUgOiA5O1xcblxcblxcdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xcblxcblxcdC8vIFJldHVybiBlYXJseSBmcm9tIGNhbGxzIHdpdGggaW52YWxpZCBzZWxlY3RvciBvciBjb250ZXh0XFxuXFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFxcXCJzdHJpbmdcXFwiIHx8ICFzZWxlY3RvciB8fFxcblxcdFxcdG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSApIHtcXG5cXG5cXHRcXHRyZXR1cm4gcmVzdWx0cztcXG5cXHR9XFxuXFxuXFx0Ly8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXJzKSBpbiBIVE1MIGRvY3VtZW50c1xcblxcdGlmICggIXNlZWQgKSB7XFxuXFxuXFx0XFx0aWYgKCAoIGNvbnRleHQgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IHByZWZlcnJlZERvYyApICE9PSBkb2N1bWVudCApIHtcXG5cXHRcXHRcXHRzZXREb2N1bWVudCggY29udGV4dCApO1xcblxcdFxcdH1cXG5cXHRcXHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcXG5cXG5cXHRcXHRpZiAoIGRvY3VtZW50SXNIVE1MICkge1xcblxcblxcdFxcdFxcdC8vIElmIHRoZSBzZWxlY3RvciBpcyBzdWZmaWNpZW50bHkgc2ltcGxlLCB0cnkgdXNpbmcgYSBcXFwiZ2V0KkJ5KlxcXCIgRE9NIG1ldGhvZFxcblxcdFxcdFxcdC8vIChleGNlcHRpbmcgRG9jdW1lbnRGcmFnbWVudCBjb250ZXh0LCB3aGVyZSB0aGUgbWV0aG9kcyBkb24ndCBleGlzdClcXG5cXHRcXHRcXHRpZiAoIG5vZGVUeXBlICE9PSAxMSAmJiAobWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICkpICkge1xcblxcblxcdFxcdFxcdFxcdC8vIElEIHNlbGVjdG9yXFxuXFx0XFx0XFx0XFx0aWYgKCAobSA9IG1hdGNoWzFdKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBEb2N1bWVudCBjb250ZXh0XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBub2RlVHlwZSA9PT0gOSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIChlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggZWxlbS5pZCA9PT0gbSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gcmVzdWx0cztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gcmVzdWx0cztcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gRWxlbWVudCBjb250ZXh0XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggbmV3Q29udGV4dCAmJiAoZWxlbSA9IG5ld0NvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgJiZcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjb250YWlucyggY29udGV4dCwgZWxlbSApICYmXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZWxlbS5pZCA9PT0gbSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gcmVzdWx0cztcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFR5cGUgc2VsZWN0b3JcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBtYXRjaFsyXSApIHtcXG5cXHRcXHRcXHRcXHRcXHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdHM7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ2xhc3Mgc2VsZWN0b3JcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCAobSA9IG1hdGNoWzNdKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiZcXG5cXHRcXHRcXHRcXHRcXHRjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBtICkgKTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gcmVzdWx0cztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFRha2UgYWR2YW50YWdlIG9mIHF1ZXJ5U2VsZWN0b3JBbGxcXG5cXHRcXHRcXHRpZiAoIHN1cHBvcnQucXNhICYmXFxuXFx0XFx0XFx0XFx0IWNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXFxcIiBcXFwiIF0gJiZcXG5cXHRcXHRcXHRcXHQoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIHNlbGVjdG9yICkpICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggbm9kZVR5cGUgIT09IDEgKSB7XFxuXFx0XFx0XFx0XFx0XFx0bmV3Q29udGV4dCA9IGNvbnRleHQ7XFxuXFx0XFx0XFx0XFx0XFx0bmV3U2VsZWN0b3IgPSBzZWxlY3RvcjtcXG5cXG5cXHRcXHRcXHRcXHQvLyBxU0EgbG9va3Mgb3V0c2lkZSBFbGVtZW50IGNvbnRleHQsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnRcXG5cXHRcXHRcXHRcXHQvLyBUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhpcyB3b3JrYXJvdW5kIHRlY2huaXF1ZVxcblxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFIDw9OFxcblxcdFxcdFxcdFxcdC8vIEV4Y2x1ZGUgb2JqZWN0IGVsZW1lbnRzXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcXFwib2JqZWN0XFxcIiApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBDYXB0dXJlIHRoZSBjb250ZXh0IElELCBzZXR0aW5nIGl0IGZpcnN0IGlmIG5lY2Vzc2FyeVxcblxcdFxcdFxcdFxcdFxcdGlmICggKG5pZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKCBcXFwiaWRcXFwiICkpICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdG5pZCA9IG5pZC5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjb250ZXh0LnNldEF0dHJpYnV0ZSggXFxcImlkXFxcIiwgKG5pZCA9IGV4cGFuZG8pICk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIFByZWZpeCBldmVyeSBzZWxlY3RvciBpbiB0aGUgbGlzdFxcblxcdFxcdFxcdFxcdFxcdGdyb3VwcyA9IHRva2VuaXplKCBzZWxlY3RvciApO1xcblxcdFxcdFxcdFxcdFxcdGkgPSBncm91cHMubGVuZ3RoO1xcblxcdFxcdFxcdFxcdFxcdHdoaWxlICggaS0tICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGdyb3Vwc1tpXSA9IFxcXCIjXFxcIiArIG5pZCArIFxcXCIgXFxcIiArIHRvU2VsZWN0b3IoIGdyb3Vwc1tpXSApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKCBcXFwiLFxcXCIgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBFeHBhbmQgY29udGV4dCBmb3Igc2libGluZyBzZWxlY3RvcnNcXG5cXHRcXHRcXHRcXHRcXHRuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcXG5cXHRcXHRcXHRcXHRcXHRcXHRjb250ZXh0O1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG5ld1NlbGVjdG9yICkge1xcblxcdFxcdFxcdFxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cHVzaC5hcHBseSggcmVzdWx0cyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIG5ld1NlbGVjdG9yIClcXG5cXHRcXHRcXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiByZXN1bHRzO1xcblxcdFxcdFxcdFxcdFxcdH0gY2F0Y2ggKCBxc2FFcnJvciApIHtcXG5cXHRcXHRcXHRcXHRcXHR9IGZpbmFsbHkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggbmlkID09PSBleHBhbmRvICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbnRleHQucmVtb3ZlQXR0cmlidXRlKCBcXFwiaWRcXFwiICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0Ly8gQWxsIG90aGVyc1xcblxcdHJldHVybiBzZWxlY3QoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcXFwiJDFcXFwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcXG59XFxuXFxuLyoqXFxuICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXFxuICogQHJldHVybnMge2Z1bmN0aW9uKHN0cmluZywgb2JqZWN0KX0gUmV0dXJucyB0aGUgT2JqZWN0IGRhdGEgYWZ0ZXIgc3RvcmluZyBpdCBvbiBpdHNlbGYgd2l0aFxcbiAqXFx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcXG4gKlxcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcXG4gKi9cXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcXG5cXHR2YXIga2V5cyA9IFtdO1xcblxcblxcdGZ1bmN0aW9uIGNhY2hlKCBrZXksIHZhbHVlICkge1xcblxcdFxcdC8vIFVzZSAoa2V5ICsgXFxcIiBcXFwiKSB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBuYXRpdmUgcHJvdG90eXBlIHByb3BlcnRpZXMgKHNlZSBJc3N1ZSAjMTU3KVxcblxcdFxcdGlmICgga2V5cy5wdXNoKCBrZXkgKyBcXFwiIFxcXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XFxuXFx0XFx0XFx0Ly8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXFxuXFx0XFx0XFx0ZGVsZXRlIGNhY2hlWyBrZXlzLnNoaWZ0KCkgXTtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIChjYWNoZVsga2V5ICsgXFxcIiBcXFwiIF0gPSB2YWx1ZSk7XFxuXFx0fVxcblxcdHJldHVybiBjYWNoZTtcXG59XFxuXFxuLyoqXFxuICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBTaXp6bGVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xcbiAqL1xcbmZ1bmN0aW9uIG1hcmtGdW5jdGlvbiggZm4gKSB7XFxuXFx0Zm5bIGV4cGFuZG8gXSA9IHRydWU7XFxuXFx0cmV0dXJuIGZuO1xcbn1cXG5cXG4vKipcXG4gKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBlbGVtZW50IGFuZCByZXR1cm5zIGEgYm9vbGVhbiByZXN1bHRcXG4gKi9cXG5mdW5jdGlvbiBhc3NlcnQoIGZuICkge1xcblxcdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcImZpZWxkc2V0XFxcIik7XFxuXFxuXFx0dHJ5IHtcXG5cXHRcXHRyZXR1cm4gISFmbiggZWwgKTtcXG5cXHR9IGNhdGNoIChlKSB7XFxuXFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdH0gZmluYWxseSB7XFxuXFx0XFx0Ly8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0XFxuXFx0XFx0aWYgKCBlbC5wYXJlbnROb2RlICkge1xcblxcdFxcdFxcdGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsICk7XFxuXFx0XFx0fVxcblxcdFxcdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXFxuXFx0XFx0ZWwgPSBudWxsO1xcblxcdH1cXG59XFxuXFxuLyoqXFxuICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGFwcGxpZWRcXG4gKi9cXG5mdW5jdGlvbiBhZGRIYW5kbGUoIGF0dHJzLCBoYW5kbGVyICkge1xcblxcdHZhciBhcnIgPSBhdHRycy5zcGxpdChcXFwifFxcXCIpLFxcblxcdFxcdGkgPSBhcnIubGVuZ3RoO1xcblxcblxcdHdoaWxlICggaS0tICkge1xcblxcdFxcdEV4cHIuYXR0ckhhbmRsZVsgYXJyW2ldIF0gPSBoYW5kbGVyO1xcblxcdH1cXG59XFxuXFxuLyoqXFxuICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xcbiAqIEBwYXJhbSB7RWxlbWVudH0gYVxcbiAqIEBwYXJhbSB7RWxlbWVudH0gYlxcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxcbiAqL1xcbmZ1bmN0aW9uIHNpYmxpbmdDaGVjayggYSwgYiApIHtcXG5cXHR2YXIgY3VyID0gYiAmJiBhLFxcblxcdFxcdGRpZmYgPSBjdXIgJiYgYS5ub2RlVHlwZSA9PT0gMSAmJiBiLm5vZGVUeXBlID09PSAxICYmXFxuXFx0XFx0XFx0YS5zb3VyY2VJbmRleCAtIGIuc291cmNlSW5kZXg7XFxuXFxuXFx0Ly8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXFxuXFx0aWYgKCBkaWZmICkge1xcblxcdFxcdHJldHVybiBkaWZmO1xcblxcdH1cXG5cXG5cXHQvLyBDaGVjayBpZiBiIGZvbGxvd3MgYVxcblxcdGlmICggY3VyICkge1xcblxcdFxcdHdoaWxlICggKGN1ciA9IGN1ci5uZXh0U2libGluZykgKSB7XFxuXFx0XFx0XFx0aWYgKCBjdXIgPT09IGIgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIC0xO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdHJldHVybiBhID8gMSA6IC0xO1xcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcXG4gKi9cXG5mdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyggdHlwZSApIHtcXG5cXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XFxuXFx0XFx0cmV0dXJuIG5hbWUgPT09IFxcXCJpbnB1dFxcXCIgJiYgZWxlbS50eXBlID09PSB0eXBlO1xcblxcdH07XFxufVxcblxcbi8qKlxcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXFxuICovXFxuZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkge1xcblxcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcXG5cXHRcXHRyZXR1cm4gKG5hbWUgPT09IFxcXCJpbnB1dFxcXCIgfHwgbmFtZSA9PT0gXFxcImJ1dHRvblxcXCIpICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcXG5cXHR9O1xcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIDplbmFibGVkLzpkaXNhYmxlZFxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzYWJsZWQgdHJ1ZSBmb3IgOmRpc2FibGVkOyBmYWxzZSBmb3IgOmVuYWJsZWRcXG4gKi9cXG5mdW5jdGlvbiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZGlzYWJsZWQgKSB7XFxuXFxuXFx0Ly8gS25vd24gOmRpc2FibGVkIGZhbHNlIHBvc2l0aXZlczogZmllbGRzZXRbZGlzYWJsZWRdID4gbGVnZW5kOm50aC1vZi10eXBlKG4rMikgOmNhbi1kaXNhYmxlXFxuXFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xcblxcblxcdFxcdC8vIE9ubHkgY2VydGFpbiBlbGVtZW50cyBjYW4gbWF0Y2ggOmVuYWJsZWQgb3IgOmRpc2FibGVkXFxuXFx0XFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZW5hYmxlZFxcblxcdFxcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWRpc2FibGVkXFxuXFx0XFx0aWYgKCBcXFwiZm9ybVxcXCIgaW4gZWxlbSApIHtcXG5cXG5cXHRcXHRcXHQvLyBDaGVjayBmb3IgaW5oZXJpdGVkIGRpc2FibGVkbmVzcyBvbiByZWxldmFudCBub24tZGlzYWJsZWQgZWxlbWVudHM6XFxuXFx0XFx0XFx0Ly8gKiBsaXN0ZWQgZm9ybS1hc3NvY2lhdGVkIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgZmllbGRzZXRcXG5cXHRcXHRcXHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGlzdGVkXFxuXFx0XFx0XFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtZmUtZGlzYWJsZWRcXG5cXHRcXHRcXHQvLyAqIG9wdGlvbiBlbGVtZW50cyBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXFxuXFx0XFx0XFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtb3B0aW9uLWRpc2FibGVkXFxuXFx0XFx0XFx0Ly8gQWxsIHN1Y2ggZWxlbWVudHMgaGF2ZSBhIFxcXCJmb3JtXFxcIiBwcm9wZXJ0eS5cXG5cXHRcXHRcXHRpZiAoIGVsZW0ucGFyZW50Tm9kZSAmJiBlbGVtLmRpc2FibGVkID09PSBmYWxzZSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBPcHRpb24gZWxlbWVudHMgZGVmZXIgdG8gYSBwYXJlbnQgb3B0Z3JvdXAgaWYgcHJlc2VudFxcblxcdFxcdFxcdFxcdGlmICggXFxcImxhYmVsXFxcIiBpbiBlbGVtICkge1xcblxcdFxcdFxcdFxcdFxcdGlmICggXFxcImxhYmVsXFxcIiBpbiBlbGVtLnBhcmVudE5vZGUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGVsZW0ucGFyZW50Tm9kZS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSA2IC0gMTFcXG5cXHRcXHRcXHRcXHQvLyBVc2UgdGhlIGlzRGlzYWJsZWQgc2hvcnRjdXQgcHJvcGVydHkgdG8gY2hlY2sgZm9yIGRpc2FibGVkIGZpZWxkc2V0IGFuY2VzdG9yc1xcblxcdFxcdFxcdFxcdHJldHVybiBlbGVtLmlzRGlzYWJsZWQgPT09IGRpc2FibGVkIHx8XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gV2hlcmUgdGhlcmUgaXMgbm8gaXNEaXNhYmxlZCwgY2hlY2sgbWFudWFsbHlcXG5cXHRcXHRcXHRcXHRcXHQvKiBqc2hpbnQgLVcwMTggKi9cXG5cXHRcXHRcXHRcXHRcXHRlbGVtLmlzRGlzYWJsZWQgIT09ICFkaXNhYmxlZCAmJlxcblxcdFxcdFxcdFxcdFxcdFxcdGRpc2FibGVkQW5jZXN0b3IoIGVsZW0gKSA9PT0gZGlzYWJsZWQ7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcXG5cXG5cXHRcXHQvLyBUcnkgdG8gd2lubm93IG91dCBlbGVtZW50cyB0aGF0IGNhbid0IGJlIGRpc2FibGVkIGJlZm9yZSB0cnVzdGluZyB0aGUgZGlzYWJsZWQgcHJvcGVydHkuXFxuXFx0XFx0Ly8gU29tZSB2aWN0aW1zIGdldCBjYXVnaHQgaW4gb3VyIG5ldCAobGFiZWwsIGxlZ2VuZCwgbWVudSwgdHJhY2spLCBidXQgaXQgc2hvdWxkbid0XFxuXFx0XFx0Ly8gZXZlbiBleGlzdCBvbiB0aGVtLCBsZXQgYWxvbmUgaGF2ZSBhIGJvb2xlYW4gdmFsdWUuXFxuXFx0XFx0fSBlbHNlIGlmICggXFxcImxhYmVsXFxcIiBpbiBlbGVtICkge1xcblxcdFxcdFxcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gUmVtYWluaW5nIGVsZW1lbnRzIGFyZSBuZWl0aGVyIDplbmFibGVkIG5vciA6ZGlzYWJsZWRcXG5cXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0fTtcXG59XFxuXFxuLyoqXFxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICovXFxuZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZm4gKSB7XFxuXFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7XFxuXFx0XFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XFxuXFx0XFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcXG5cXHRcXHRcXHR2YXIgaixcXG5cXHRcXHRcXHRcXHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxcblxcdFxcdFxcdFxcdGkgPSBtYXRjaEluZGV4ZXMubGVuZ3RoO1xcblxcblxcdFxcdFxcdC8vIE1hdGNoIGVsZW1lbnRzIGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlc1xcblxcdFxcdFxcdHdoaWxlICggaS0tICkge1xcblxcdFxcdFxcdFxcdGlmICggc2VlZFsgKGogPSBtYXRjaEluZGV4ZXNbaV0pIF0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0c2VlZFtqXSA9ICEobWF0Y2hlc1tqXSA9IHNlZWRbal0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSk7XFxuXFx0fSk7XFxufVxcblxcbi8qKlxcbiAqIENoZWNrcyBhIG5vZGUgZm9yIHZhbGlkaXR5IGFzIGEgU2l6emxlIGNvbnRleHRcXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxcbiAqL1xcbmZ1bmN0aW9uIHRlc3RDb250ZXh0KCBjb250ZXh0ICkge1xcblxcdHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmJiBjb250ZXh0O1xcbn1cXG5cXG4vLyBFeHBvc2Ugc3VwcG9ydCB2YXJzIGZvciBjb252ZW5pZW5jZVxcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xcblxcbi8qKlxcbiAqIERldGVjdHMgWE1MIG5vZGVzXFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbSBBbiBlbGVtZW50IG9yIGEgZG9jdW1lbnRcXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZmYgZWxlbSBpcyBhIG5vbi1IVE1MIFhNTCBub2RlXFxuICovXFxuaXNYTUwgPSBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHQvLyBkb2N1bWVudEVsZW1lbnQgaXMgdmVyaWZpZWQgZm9yIGNhc2VzIHdoZXJlIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XFxuXFx0Ly8gKHN1Y2ggYXMgbG9hZGluZyBpZnJhbWVzIGluIElFIC0gIzQ4MzMpXFxuXFx0dmFyIGRvY3VtZW50RWxlbWVudCA9IGVsZW0gJiYgKGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtKS5kb2N1bWVudEVsZW1lbnQ7XFxuXFx0cmV0dXJuIGRvY3VtZW50RWxlbWVudCA/IGRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXFxcIkhUTUxcXFwiIDogZmFsc2U7XFxufTtcXG5cXG4vKipcXG4gKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGN1cnJlbnQgZG9jdW1lbnRcXG4gKi9cXG5zZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKCBub2RlICkge1xcblxcdHZhciBoYXNDb21wYXJlLCBzdWJXaW5kb3csXFxuXFx0XFx0ZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xcblxcblxcdC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXFxuXFx0aWYgKCBkb2MgPT09IGRvY3VtZW50IHx8IGRvYy5ub2RlVHlwZSAhPT0gOSB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCApIHtcXG5cXHRcXHRyZXR1cm4gZG9jdW1lbnQ7XFxuXFx0fVxcblxcblxcdC8vIFVwZGF0ZSBnbG9iYWwgdmFyaWFibGVzXFxuXFx0ZG9jdW1lbnQgPSBkb2M7XFxuXFx0ZG9jRWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcXG5cXHRkb2N1bWVudElzSFRNTCA9ICFpc1hNTCggZG9jdW1lbnQgKTtcXG5cXG5cXHQvLyBTdXBwb3J0OiBJRSA5LTExLCBFZGdlXFxuXFx0Ly8gQWNjZXNzaW5nIGlmcmFtZSBkb2N1bWVudHMgYWZ0ZXIgdW5sb2FkIHRocm93cyBcXFwicGVybWlzc2lvbiBkZW5pZWRcXFwiIGVycm9ycyAoalF1ZXJ5ICMxMzkzNilcXG5cXHRpZiAoIHByZWZlcnJlZERvYyAhPT0gZG9jdW1lbnQgJiZcXG5cXHRcXHQoc3ViV2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcpICYmIHN1YldpbmRvdy50b3AgIT09IHN1YldpbmRvdyApIHtcXG5cXG5cXHRcXHQvLyBTdXBwb3J0OiBJRSAxMSwgRWRnZVxcblxcdFxcdGlmICggc3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIgKSB7XFxuXFx0XFx0XFx0c3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFxcXCJ1bmxvYWRcXFwiLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSApO1xcblxcblxcdFxcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMCBvbmx5XFxuXFx0XFx0fSBlbHNlIGlmICggc3ViV2luZG93LmF0dGFjaEV2ZW50ICkge1xcblxcdFxcdFxcdHN1YldpbmRvdy5hdHRhY2hFdmVudCggXFxcIm9udW5sb2FkXFxcIiwgdW5sb2FkSGFuZGxlciApO1xcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0LyogQXR0cmlidXRlc1xcblxcdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cXG5cXG5cXHQvLyBTdXBwb3J0OiBJRTw4XFxuXFx0Ly8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzXFxuXFx0Ly8gKGV4Y2VwdGluZyBJRTggYm9vbGVhbnMpXFxuXFx0c3VwcG9ydC5hdHRyaWJ1dGVzID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcXG5cXHRcXHRlbC5jbGFzc05hbWUgPSBcXFwiaVxcXCI7XFxuXFx0XFx0cmV0dXJuICFlbC5nZXRBdHRyaWJ1dGUoXFxcImNsYXNzTmFtZVxcXCIpO1xcblxcdH0pO1xcblxcblxcdC8qIGdldEVsZW1lbnQocylCeSpcXG5cXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXFxuXFxuXFx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXFxcIipcXFwiKSByZXR1cm5zIG9ubHkgZWxlbWVudHNcXG5cXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcXG5cXHRcXHRlbC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlQ29tbWVudChcXFwiXFxcIikgKTtcXG5cXHRcXHRyZXR1cm4gIWVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKFxcXCIqXFxcIikubGVuZ3RoO1xcblxcdH0pO1xcblxcblxcdC8vIFN1cHBvcnQ6IElFPDlcXG5cXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKTtcXG5cXG5cXHQvLyBTdXBwb3J0OiBJRTwxMFxcblxcdC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxcblxcdC8vIFRoZSBicm9rZW4gZ2V0RWxlbWVudEJ5SWQgbWV0aG9kcyBkb24ndCBwaWNrIHVwIHByb2dyYW1tYXRpY2FsbHktc2V0IG5hbWVzLFxcblxcdC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxcblxcdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XFxuXFx0XFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pZCA9IGV4cGFuZG87XFxuXFx0XFx0cmV0dXJuICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoIGV4cGFuZG8gKS5sZW5ndGg7XFxuXFx0fSk7XFxuXFxuXFx0Ly8gSUQgZmlsdGVyIGFuZCBmaW5kXFxuXFx0aWYgKCBzdXBwb3J0LmdldEJ5SWQgKSB7XFxuXFx0XFx0RXhwci5maWx0ZXJbXFxcIklEXFxcIl0gPSBmdW5jdGlvbiggaWQgKSB7XFxuXFx0XFx0XFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdFxcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcXFwiaWRcXFwiKSA9PT0gYXR0cklkO1xcblxcdFxcdFxcdH07XFxuXFx0XFx0fTtcXG5cXHRcXHRFeHByLmZpbmRbXFxcIklEXFxcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XFxuXFx0XFx0XFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xcblxcdFxcdFxcdFxcdHJldHVybiBlbGVtID8gWyBlbGVtIF0gOiBbXTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXHR9IGVsc2Uge1xcblxcdFxcdEV4cHIuZmlsdGVyW1xcXCJJRFxcXCJdID0gIGZ1bmN0aW9uKCBpZCApIHtcXG5cXHRcXHRcXHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0XFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmJlxcblxcdFxcdFxcdFxcdFxcdGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcXFwiaWRcXFwiKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIFN1cHBvcnQ6IElFIDYgLSA3IG9ubHlcXG5cXHRcXHQvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XFxuXFx0XFx0RXhwci5maW5kW1xcXCJJRFxcXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xcblxcdFxcdFxcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFxcXCJ1bmRlZmluZWRcXFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xcblxcdFxcdFxcdFxcdHZhciBub2RlLCBpLCBlbGVtcyxcXG5cXHRcXHRcXHRcXHRcXHRlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGVsZW0gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gVmVyaWZ5IHRoZSBpZCBhdHRyaWJ1dGVcXG5cXHRcXHRcXHRcXHRcXHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFxcXCJpZFxcXCIpO1xcblxcdFxcdFxcdFxcdFxcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gWyBlbGVtIF07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIEZhbGwgYmFjayBvbiBnZXRFbGVtZW50c0J5TmFtZVxcblxcdFxcdFxcdFxcdFxcdGVsZW1zID0gY29udGV4dC5nZXRFbGVtZW50c0J5TmFtZSggaWQgKTtcXG5cXHRcXHRcXHRcXHRcXHRpID0gMDtcXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAoIChlbGVtID0gZWxlbXNbaSsrXSkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcXFwiaWRcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIFsgZWxlbSBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJldHVybiBbXTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXHR9XFxuXFxuXFx0Ly8gVGFnXFxuXFx0RXhwci5maW5kW1xcXCJUQUdcXFwiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgP1xcblxcdFxcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XFxuXFx0XFx0XFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXFxcInVuZGVmaW5lZFxcXCIgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xcblxcblxcdFxcdFxcdC8vIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgZG9uJ3QgaGF2ZSBnRUJUTlxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIHN1cHBvcnQucXNhICkge1xcblxcdFxcdFxcdFxcdHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9IDpcXG5cXG5cXHRcXHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xcblxcdFxcdFxcdHZhciBlbGVtLFxcblxcdFxcdFxcdFxcdHRtcCA9IFtdLFxcblxcdFxcdFxcdFxcdGkgPSAwLFxcblxcdFxcdFxcdFxcdC8vIEJ5IGhhcHB5IGNvaW5jaWRlbmNlLCBhIChicm9rZW4pIGdFQlROIGFwcGVhcnMgb24gRG9jdW1lbnRGcmFnbWVudCBub2RlcyB0b29cXG5cXHRcXHRcXHRcXHRyZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XFxuXFxuXFx0XFx0XFx0Ly8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xcblxcdFxcdFxcdGlmICggdGFnID09PSBcXFwiKlxcXCIgKSB7XFxuXFx0XFx0XFx0XFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRtcC5wdXNoKCBlbGVtICk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdG1wO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gcmVzdWx0cztcXG5cXHRcXHR9O1xcblxcblxcdC8vIENsYXNzXFxuXFx0RXhwci5maW5kW1xcXCJDTEFTU1xcXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQgKSB7XFxuXFx0XFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcXG5cXHRcXHRcXHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBjbGFzc05hbWUgKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXFxuXFx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xcblxcblxcdC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcXG5cXG5cXHQvLyBtYXRjaGVzU2VsZWN0b3IoOmFjdGl2ZSkgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKElFOS9PcGVyYSAxMS41KVxcblxcdHJidWdneU1hdGNoZXMgPSBbXTtcXG5cXG5cXHQvLyBxU2EoOmZvY3VzKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoQ2hyb21lIDIxKVxcblxcdC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxcblxcdC8vIHdoZW5ldmVyIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBhY2Nlc3NlZCBvbiBhbiBpZnJhbWVcXG5cXHQvLyBTbywgd2UgYWxsb3cgOmZvY3VzIHRvIHBhc3MgdGhyb3VnaCBRU0EgYWxsIHRoZSB0aW1lIHRvIGF2b2lkIHRoZSBJRSBlcnJvclxcblxcdC8vIFNlZSBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcXG5cXHRyYnVnZ3lRU0EgPSBbXTtcXG5cXG5cXHRpZiAoIChzdXBwb3J0LnFzYSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCApKSApIHtcXG5cXHRcXHQvLyBCdWlsZCBRU0EgcmVnZXhcXG5cXHRcXHQvLyBSZWdleCBzdHJhdGVneSBhZG9wdGVkIGZyb20gRGllZ28gUGVyaW5pXFxuXFx0XFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcXG5cXHRcXHRcXHQvLyBTZWxlY3QgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXFxuXFx0XFx0XFx0Ly8gVGhpcyBpcyB0byB0ZXN0IElFJ3MgdHJlYXRtZW50IG9mIG5vdCBleHBsaWNpdGx5XFxuXFx0XFx0XFx0Ly8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXFxuXFx0XFx0XFx0Ly8gc2luY2UgaXRzIHByZXNlbmNlIHNob3VsZCBiZSBlbm91Z2hcXG5cXHRcXHRcXHQvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcXG5cXHRcXHRcXHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlubmVySFRNTCA9IFxcXCI8YSBpZD0nXFxcIiArIGV4cGFuZG8gKyBcXFwiJz48L2E+XFxcIiArXFxuXFx0XFx0XFx0XFx0XFxcIjxzZWxlY3QgaWQ9J1xcXCIgKyBleHBhbmRvICsgXFxcIi1cXFxcclxcXFxcXFxcJyBtc2FsbG93Y2FwdHVyZT0nJz5cXFwiICtcXG5cXHRcXHRcXHRcXHRcXFwiPG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cXFwiO1xcblxcblxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcXG5cXHRcXHRcXHQvLyBOb3RoaW5nIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIGVtcHR5IHN0cmluZ3MgZm9sbG93IF49IG9yICQ9IG9yICo9XFxuXFx0XFx0XFx0Ly8gVGhlIHRlc3QgYXR0cmlidXRlIG11c3QgYmUgdW5rbm93biBpbiBPcGVyYSBidXQgXFxcInNhZmVcXFwiIGZvciBXaW5SVFxcblxcdFxcdFxcdC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvaGg0NjUzODguYXNweCNhdHRyaWJ1dGVfc2VjdGlvblxcblxcdFxcdFxcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcXFwiW21zYWxsb3djYXB0dXJlXj0nJ11cXFwiKS5sZW5ndGggKSB7XFxuXFx0XFx0XFx0XFx0cmJ1Z2d5UVNBLnB1c2goIFxcXCJbKl4kXT1cXFwiICsgd2hpdGVzcGFjZSArIFxcXCIqKD86Jyd8XFxcXFxcXCJcXFxcXFxcIilcXFwiICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFOFxcblxcdFxcdFxcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXFxcInZhbHVlXFxcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5XFxuXFx0XFx0XFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbChcXFwiW3NlbGVjdGVkXVxcXCIpLmxlbmd0aCApIHtcXG5cXHRcXHRcXHRcXHRyYnVnZ3lRU0EucHVzaCggXFxcIlxcXFxcXFxcW1xcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIiooPzp2YWx1ZXxcXFwiICsgYm9vbGVhbnMgKyBcXFwiKVxcXCIgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU3VwcG9ydDogQ2hyb21lPDI5LCBBbmRyb2lkPDQuNCwgU2FmYXJpPDcuMCssIGlPUzw3LjArLCBQaGFudG9tSlM8MS45LjgrXFxuXFx0XFx0XFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXFxcIltpZH49XFxcIiArIGV4cGFuZG8gKyBcXFwiLV1cXFwiICkubGVuZ3RoICkge1xcblxcdFxcdFxcdFxcdHJidWdneVFTQS5wdXNoKFxcXCJ+PVxcXCIpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBXZWJraXQvT3BlcmEgLSA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIHNlbGVjdGVkIG9wdGlvbiBlbGVtZW50c1xcblxcdFxcdFxcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXFxuXFx0XFx0XFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcXG5cXHRcXHRcXHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCI6Y2hlY2tlZFxcXCIpLmxlbmd0aCApIHtcXG5cXHRcXHRcXHRcXHRyYnVnZ3lRU0EucHVzaChcXFwiOmNoZWNrZWRcXFwiKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcXG5cXHRcXHRcXHQvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXFxuXFx0XFx0XFx0Ly8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2libGluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xcblxcdFxcdFxcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFxcXCJhI1xcXCIgKyBleHBhbmRvICsgXFxcIisqXFxcIiApLmxlbmd0aCApIHtcXG5cXHRcXHRcXHRcXHRyYnVnZ3lRU0EucHVzaChcXFwiLiMuK1srfl1cXFwiKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSk7XFxuXFxuXFx0XFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcXG5cXHRcXHRcXHRlbC5pbm5lckhUTUwgPSBcXFwiPGEgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT5cXFwiICtcXG5cXHRcXHRcXHRcXHRcXFwiPHNlbGVjdCBkaXNhYmxlZD0nZGlzYWJsZWQnPjxvcHRpb24vPjwvc2VsZWN0PlxcXCI7XFxuXFxuXFx0XFx0XFx0Ly8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXFxuXFx0XFx0XFx0Ly8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XFxuXFx0XFx0XFx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwiaW5wdXRcXFwiKTtcXG5cXHRcXHRcXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFxcXCJ0eXBlXFxcIiwgXFxcImhpZGRlblxcXCIgKTtcXG5cXHRcXHRcXHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFxcXCJuYW1lXFxcIiwgXFxcIkRcXFwiICk7XFxuXFxuXFx0XFx0XFx0Ly8gU3VwcG9ydDogSUU4XFxuXFx0XFx0XFx0Ly8gRW5mb3JjZSBjYXNlLXNlbnNpdGl2aXR5IG9mIG5hbWUgYXR0cmlidXRlXFxuXFx0XFx0XFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCJbbmFtZT1kXVxcXCIpLmxlbmd0aCApIHtcXG5cXHRcXHRcXHRcXHRyYnVnZ3lRU0EucHVzaCggXFxcIm5hbWVcXFwiICsgd2hpdGVzcGFjZSArIFxcXCIqWypeJHwhfl0/PVxcXCIgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcXG5cXHRcXHRcXHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xcblxcdFxcdFxcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcXFwiOmVuYWJsZWRcXFwiKS5sZW5ndGggIT09IDIgKSB7XFxuXFx0XFx0XFx0XFx0cmJ1Z2d5UVNBLnB1c2goIFxcXCI6ZW5hYmxlZFxcXCIsIFxcXCI6ZGlzYWJsZWRcXFwiICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFOS0xMStcXG5cXHRcXHRcXHQvLyBJRSdzIDpkaXNhYmxlZCBzZWxlY3RvciBkb2VzIG5vdCBwaWNrIHVwIHRoZSBjaGlsZHJlbiBvZiBkaXNhYmxlZCBmaWVsZHNldHNcXG5cXHRcXHRcXHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmRpc2FibGVkID0gdHJ1ZTtcXG5cXHRcXHRcXHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIjpkaXNhYmxlZFxcXCIpLmxlbmd0aCAhPT0gMiApIHtcXG5cXHRcXHRcXHRcXHRyYnVnZ3lRU0EucHVzaCggXFxcIjplbmFibGVkXFxcIiwgXFxcIjpkaXNhYmxlZFxcXCIgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gT3BlcmEgMTAtMTEgZG9lcyBub3QgdGhyb3cgb24gcG9zdC1jb21tYSBpbnZhbGlkIHBzZXVkb3NcXG5cXHRcXHRcXHRlbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCIqLDp4XFxcIik7XFxuXFx0XFx0XFx0cmJ1Z2d5UVNBLnB1c2goXFxcIiwuKjpcXFwiKTtcXG5cXHRcXHR9KTtcXG5cXHR9XFxuXFxuXFx0aWYgKCAoc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgPSBybmF0aXZlLnRlc3QoIChtYXRjaGVzID0gZG9jRWxlbS5tYXRjaGVzIHx8XFxuXFx0XFx0ZG9jRWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcXG5cXHRcXHRkb2NFbGVtLm1vek1hdGNoZXNTZWxlY3RvciB8fFxcblxcdFxcdGRvY0VsZW0ub01hdGNoZXNTZWxlY3RvciB8fFxcblxcdFxcdGRvY0VsZW0ubXNNYXRjaGVzU2VsZWN0b3IpICkpICkge1xcblxcblxcdFxcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XFxuXFx0XFx0XFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXFxuXFx0XFx0XFx0Ly8gb24gYSBkaXNjb25uZWN0ZWQgbm9kZSAoSUUgOSlcXG5cXHRcXHRcXHRzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKCBlbCwgXFxcIipcXFwiICk7XFxuXFxuXFx0XFx0XFx0Ly8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxcblxcdFxcdFxcdC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcXG5cXHRcXHRcXHRtYXRjaGVzLmNhbGwoIGVsLCBcXFwiW3MhPScnXTp4XFxcIiApO1xcblxcdFxcdFxcdHJidWdneU1hdGNoZXMucHVzaCggXFxcIiE9XFxcIiwgcHNldWRvcyApO1xcblxcdFxcdH0pO1xcblxcdH1cXG5cXG5cXHRyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKFxcXCJ8XFxcIikgKTtcXG5cXHRyYnVnZ3lNYXRjaGVzID0gcmJ1Z2d5TWF0Y2hlcy5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5TWF0Y2hlcy5qb2luKFxcXCJ8XFxcIikgKTtcXG5cXG5cXHQvKiBDb250YWluc1xcblxcdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cXG5cXHRoYXNDb21wYXJlID0gcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICk7XFxuXFxuXFx0Ly8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXFxuXFx0Ly8gUHVycG9zZWZ1bGx5IHNlbGYtZXhjbHVzaXZlXFxuXFx0Ly8gQXMgaW4sIGFuIGVsZW1lbnQgZG9lcyBub3QgY29udGFpbiBpdHNlbGZcXG5cXHRjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xcblxcdFxcdGZ1bmN0aW9uKCBhLCBiICkge1xcblxcdFxcdFxcdHZhciBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXFxuXFx0XFx0XFx0XFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XFxuXFx0XFx0XFx0cmV0dXJuIGEgPT09IGJ1cCB8fCAhISggYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiAoXFxuXFx0XFx0XFx0XFx0YWRvd24uY29udGFpbnMgP1xcblxcdFxcdFxcdFxcdFxcdGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XFxuXFx0XFx0XFx0XFx0XFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XFxuXFx0XFx0XFx0KSk7XFxuXFx0XFx0fSA6XFxuXFx0XFx0ZnVuY3Rpb24oIGEsIGIgKSB7XFxuXFx0XFx0XFx0aWYgKCBiICkge1xcblxcdFxcdFxcdFxcdHdoaWxlICggKGIgPSBiLnBhcmVudE5vZGUpICkge1xcblxcdFxcdFxcdFxcdFxcdGlmICggYiA9PT0gYSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0fTtcXG5cXG5cXHQvKiBTb3J0aW5nXFxuXFx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xcblxcblxcdC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcXG5cXHRzb3J0T3JkZXIgPSBoYXNDb21wYXJlID9cXG5cXHRmdW5jdGlvbiggYSwgYiApIHtcXG5cXG5cXHRcXHQvLyBGbGFnIGZvciBkdXBsaWNhdGUgcmVtb3ZhbFxcblxcdFxcdGlmICggYSA9PT0gYiApIHtcXG5cXHRcXHRcXHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xcblxcdFxcdFxcdHJldHVybiAwO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBTb3J0IG9uIG1ldGhvZCBleGlzdGVuY2UgaWYgb25seSBvbmUgaW5wdXQgaGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXFxuXFx0XFx0dmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xcblxcdFxcdGlmICggY29tcGFyZSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gY29tcGFyZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxcblxcdFxcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XFxuXFx0XFx0XFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYiApIDpcXG5cXG5cXHRcXHRcXHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcXG5cXHRcXHRcXHQxO1xcblxcblxcdFxcdC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xcblxcdFxcdGlmICggY29tcGFyZSAmIDEgfHxcXG5cXHRcXHRcXHQoIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSkgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XFxuXFx0XFx0XFx0aWYgKCBhID09PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpICkge1xcblxcdFxcdFxcdFxcdHJldHVybiAtMTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCBiID09PSBkb2N1bWVudCB8fCBiLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGIpICkge1xcblxcdFxcdFxcdFxcdHJldHVybiAxO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxcblxcdFxcdFxcdHJldHVybiBzb3J0SW5wdXQgP1xcblxcdFxcdFxcdFxcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcXG5cXHRcXHRcXHRcXHQwO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XFxuXFx0fSA6XFxuXFx0ZnVuY3Rpb24oIGEsIGIgKSB7XFxuXFx0XFx0Ly8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxcblxcdFxcdGlmICggYSA9PT0gYiApIHtcXG5cXHRcXHRcXHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xcblxcdFxcdFxcdHJldHVybiAwO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR2YXIgY3VyLFxcblxcdFxcdFxcdGkgPSAwLFxcblxcdFxcdFxcdGF1cCA9IGEucGFyZW50Tm9kZSxcXG5cXHRcXHRcXHRidXAgPSBiLnBhcmVudE5vZGUsXFxuXFx0XFx0XFx0YXAgPSBbIGEgXSxcXG5cXHRcXHRcXHRicCA9IFsgYiBdO1xcblxcblxcdFxcdC8vIFBhcmVudGxlc3Mgbm9kZXMgYXJlIGVpdGhlciBkb2N1bWVudHMgb3IgZGlzY29ubmVjdGVkXFxuXFx0XFx0aWYgKCAhYXVwIHx8ICFidXAgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGEgPT09IGRvY3VtZW50ID8gLTEgOlxcblxcdFxcdFxcdFxcdGIgPT09IGRvY3VtZW50ID8gMSA6XFxuXFx0XFx0XFx0XFx0YXVwID8gLTEgOlxcblxcdFxcdFxcdFxcdGJ1cCA/IDEgOlxcblxcdFxcdFxcdFxcdHNvcnRJbnB1dCA/XFxuXFx0XFx0XFx0XFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxcblxcdFxcdFxcdFxcdDA7XFxuXFxuXFx0XFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcXG5cXHRcXHR9IGVsc2UgaWYgKCBhdXAgPT09IGJ1cCApIHtcXG5cXHRcXHRcXHRyZXR1cm4gc2libGluZ0NoZWNrKCBhLCBiICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIE90aGVyd2lzZSB3ZSBuZWVkIGZ1bGwgbGlzdHMgb2YgdGhlaXIgYW5jZXN0b3JzIGZvciBjb21wYXJpc29uXFxuXFx0XFx0Y3VyID0gYTtcXG5cXHRcXHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XFxuXFx0XFx0XFx0YXAudW5zaGlmdCggY3VyICk7XFxuXFx0XFx0fVxcblxcdFxcdGN1ciA9IGI7XFxuXFx0XFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xcblxcdFxcdFxcdGJwLnVuc2hpZnQoIGN1ciApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBXYWxrIGRvd24gdGhlIHRyZWUgbG9va2luZyBmb3IgYSBkaXNjcmVwYW5jeVxcblxcdFxcdHdoaWxlICggYXBbaV0gPT09IGJwW2ldICkge1xcblxcdFxcdFxcdGkrKztcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIGkgP1xcblxcdFxcdFxcdC8vIERvIGEgc2libGluZyBjaGVjayBpZiB0aGUgbm9kZXMgaGF2ZSBhIGNvbW1vbiBhbmNlc3RvclxcblxcdFxcdFxcdHNpYmxpbmdDaGVjayggYXBbaV0sIGJwW2ldICkgOlxcblxcblxcdFxcdFxcdC8vIE90aGVyd2lzZSBub2RlcyBpbiBvdXIgZG9jdW1lbnQgc29ydCBmaXJzdFxcblxcdFxcdFxcdGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XFxuXFx0XFx0XFx0YnBbaV0gPT09IHByZWZlcnJlZERvYyA/IDEgOlxcblxcdFxcdFxcdDA7XFxuXFx0fTtcXG5cXG5cXHRyZXR1cm4gZG9jdW1lbnQ7XFxufTtcXG5cXG5TaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHtcXG5cXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xcbn07XFxuXFxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xcblxcdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxcblxcdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcXG5cXHRcXHRzZXREb2N1bWVudCggZWxlbSApO1xcblxcdH1cXG5cXG5cXHQvLyBNYWtlIHN1cmUgdGhhdCBhdHRyaWJ1dGUgc2VsZWN0b3JzIGFyZSBxdW90ZWRcXG5cXHRleHByID0gZXhwci5yZXBsYWNlKCByYXR0cmlidXRlUXVvdGVzLCBcXFwiPSckMSddXFxcIiApO1xcblxcblxcdGlmICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgJiYgZG9jdW1lbnRJc0hUTUwgJiZcXG5cXHRcXHQhY29tcGlsZXJDYWNoZVsgZXhwciArIFxcXCIgXFxcIiBdICYmXFxuXFx0XFx0KCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxcblxcdFxcdCggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcXG5cXG5cXHRcXHR0cnkge1xcblxcdFxcdFxcdHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcXG5cXG5cXHRcXHRcXHQvLyBJRSA5J3MgbWF0Y2hlc1NlbGVjdG9yIHJldHVybnMgZmFsc2Ugb24gZGlzY29ubmVjdGVkIG5vZGVzXFxuXFx0XFx0XFx0aWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxcblxcdFxcdFxcdFxcdFxcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XFxuXFx0XFx0XFx0XFx0XFx0Ly8gZnJhZ21lbnQgaW4gSUUgOVxcblxcdFxcdFxcdFxcdFxcdGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJldDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSBjYXRjaCAoZSkge31cXG5cXHR9XFxuXFxuXFx0cmV0dXJuIFNpenpsZSggZXhwciwgZG9jdW1lbnQsIG51bGwsIFsgZWxlbSBdICkubGVuZ3RoID4gMDtcXG59O1xcblxcblNpenpsZS5jb250YWlucyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVtICkge1xcblxcdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxcblxcdGlmICggKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCApICE9PSBkb2N1bWVudCApIHtcXG5cXHRcXHRzZXREb2N1bWVudCggY29udGV4dCApO1xcblxcdH1cXG5cXHRyZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcXG59O1xcblxcblNpenpsZS5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XFxuXFx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXFxuXFx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xcblxcdFxcdHNldERvY3VtZW50KCBlbGVtICk7XFxuXFx0fVxcblxcblxcdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXFxuXFx0XFx0Ly8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXFxuXFx0XFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xcblxcdFxcdFxcdGZuKCBlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwgKSA6XFxuXFx0XFx0XFx0dW5kZWZpbmVkO1xcblxcblxcdHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/XFxuXFx0XFx0dmFsIDpcXG5cXHRcXHRzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWRvY3VtZW50SXNIVE1MID9cXG5cXHRcXHRcXHRlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcXG5cXHRcXHRcXHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpKSAmJiB2YWwuc3BlY2lmaWVkID9cXG5cXHRcXHRcXHRcXHR2YWwudmFsdWUgOlxcblxcdFxcdFxcdFxcdG51bGw7XFxufTtcXG5cXG5TaXp6bGUuZXNjYXBlID0gZnVuY3Rpb24oIHNlbCApIHtcXG5cXHRyZXR1cm4gKHNlbCArIFxcXCJcXFwiKS5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XFxufTtcXG5cXG5TaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xcblxcdHRocm93IG5ldyBFcnJvciggXFxcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFxcXCIgKyBtc2cgKTtcXG59O1xcblxcbi8qKlxcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcXG4gKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xcbiAqL1xcblNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XFxuXFx0dmFyIGVsZW0sXFxuXFx0XFx0ZHVwbGljYXRlcyA9IFtdLFxcblxcdFxcdGogPSAwLFxcblxcdFxcdGkgPSAwO1xcblxcblxcdC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2VcXG5cXHRoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzO1xcblxcdHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSggMCApO1xcblxcdHJlc3VsdHMuc29ydCggc29ydE9yZGVyICk7XFxuXFxuXFx0aWYgKCBoYXNEdXBsaWNhdGUgKSB7XFxuXFx0XFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XFxuXFx0XFx0XFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XFxuXFx0XFx0XFx0XFx0aiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0XFx0d2hpbGUgKCBqLS0gKSB7XFxuXFx0XFx0XFx0cmVzdWx0cy5zcGxpY2UoIGR1cGxpY2F0ZXNbIGogXSwgMSApO1xcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0Ly8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcXG5cXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcXG5cXHRzb3J0SW5wdXQgPSBudWxsO1xcblxcblxcdHJldHVybiByZXN1bHRzO1xcbn07XFxuXFxuLyoqXFxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcXG4gKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cXG4gKi9cXG5nZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHR2YXIgbm9kZSxcXG5cXHRcXHRyZXQgPSBcXFwiXFxcIixcXG5cXHRcXHRpID0gMCxcXG5cXHRcXHRub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XFxuXFxuXFx0aWYgKCAhbm9kZVR5cGUgKSB7XFxuXFx0XFx0Ly8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcXG5cXHRcXHR3aGlsZSAoIChub2RlID0gZWxlbVtpKytdKSApIHtcXG5cXHRcXHRcXHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xcblxcdFxcdFxcdHJldCArPSBnZXRUZXh0KCBub2RlICk7XFxuXFx0XFx0fVxcblxcdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcXG5cXHRcXHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXFxuXFx0XFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1MylcXG5cXHRcXHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcXFwic3RyaW5nXFxcIiApIHtcXG5cXHRcXHRcXHRyZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxcblxcdFxcdFxcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xcblxcdFxcdFxcdFxcdHJldCArPSBnZXRUZXh0KCBlbGVtICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcXG5cXHRcXHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XFxuXFx0fVxcblxcdC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xcblxcblxcdHJldHVybiByZXQ7XFxufTtcXG5cXG5FeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcXG5cXG5cXHQvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXJcXG5cXHRjYWNoZUxlbmd0aDogNTAsXFxuXFxuXFx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXFxuXFxuXFx0bWF0Y2g6IG1hdGNoRXhwcixcXG5cXG5cXHRhdHRySGFuZGxlOiB7fSxcXG5cXG5cXHRmaW5kOiB7fSxcXG5cXG5cXHRyZWxhdGl2ZToge1xcblxcdFxcdFxcXCI+XFxcIjogeyBkaXI6IFxcXCJwYXJlbnROb2RlXFxcIiwgZmlyc3Q6IHRydWUgfSxcXG5cXHRcXHRcXFwiIFxcXCI6IHsgZGlyOiBcXFwicGFyZW50Tm9kZVxcXCIgfSxcXG5cXHRcXHRcXFwiK1xcXCI6IHsgZGlyOiBcXFwicHJldmlvdXNTaWJsaW5nXFxcIiwgZmlyc3Q6IHRydWUgfSxcXG5cXHRcXHRcXFwiflxcXCI6IHsgZGlyOiBcXFwicHJldmlvdXNTaWJsaW5nXFxcIiB9XFxuXFx0fSxcXG5cXG5cXHRwcmVGaWx0ZXI6IHtcXG5cXHRcXHRcXFwiQVRUUlxcXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcXG5cXHRcXHRcXHRtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XFxuXFxuXFx0XFx0XFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcXG5cXHRcXHRcXHRtYXRjaFszXSA9ICggbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXFxcIlxcXCIgKS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xcblxcblxcdFxcdFxcdGlmICggbWF0Y2hbMl0gPT09IFxcXCJ+PVxcXCIgKSB7XFxuXFx0XFx0XFx0XFx0bWF0Y2hbM10gPSBcXFwiIFxcXCIgKyBtYXRjaFszXSArIFxcXCIgXFxcIjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCA0ICk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRcXFwiQ0hJTERcXFwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XFxuXFx0XFx0XFx0LyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwcltcXFwiQ0hJTERcXFwiXVxcblxcdFxcdFxcdFxcdDEgdHlwZSAob25seXxudGh8Li4uKVxcblxcdFxcdFxcdFxcdDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcXG5cXHRcXHRcXHRcXHQzIGFyZ3VtZW50IChldmVufG9kZHxcXFxcZCp8XFxcXGQqbihbKy1dXFxcXGQrKT98Li4uKVxcblxcdFxcdFxcdFxcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxcXGQqbnwpXFxuXFx0XFx0XFx0XFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxcblxcdFxcdFxcdFxcdDYgeCBvZiB4bi1jb21wb25lbnRcXG5cXHRcXHRcXHRcXHQ3IHNpZ24gb2YgeS1jb21wb25lbnRcXG5cXHRcXHRcXHRcXHQ4IHkgb2YgeS1jb21wb25lbnRcXG5cXHRcXHRcXHQqL1xcblxcdFxcdFxcdG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcXG5cXG5cXHRcXHRcXHRpZiAoIG1hdGNoWzFdLnNsaWNlKCAwLCAzICkgPT09IFxcXCJudGhcXFwiICkge1xcblxcdFxcdFxcdFxcdC8vIG50aC0qIHJlcXVpcmVzIGFyZ3VtZW50XFxuXFx0XFx0XFx0XFx0aWYgKCAhbWF0Y2hbM10gKSB7XFxuXFx0XFx0XFx0XFx0XFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBudW1lcmljIHggYW5kIHkgcGFyYW1ldGVycyBmb3IgRXhwci5maWx0ZXIuQ0hJTERcXG5cXHRcXHRcXHRcXHQvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xXFxuXFx0XFx0XFx0XFx0bWF0Y2hbNF0gPSArKCBtYXRjaFs0XSA/IG1hdGNoWzVdICsgKG1hdGNoWzZdIHx8IDEpIDogMiAqICggbWF0Y2hbM10gPT09IFxcXCJldmVuXFxcIiB8fCBtYXRjaFszXSA9PT0gXFxcIm9kZFxcXCIgKSApO1xcblxcdFxcdFxcdFxcdG1hdGNoWzVdID0gKyggKCBtYXRjaFs3XSArIG1hdGNoWzhdICkgfHwgbWF0Y2hbM10gPT09IFxcXCJvZGRcXFwiICk7XFxuXFxuXFx0XFx0XFx0Ly8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggbWF0Y2hbM10gKSB7XFxuXFx0XFx0XFx0XFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gbWF0Y2g7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRcXFwiUFNFVURPXFxcIjogZnVuY3Rpb24oIG1hdGNoICkge1xcblxcdFxcdFxcdHZhciBleGNlc3MsXFxuXFx0XFx0XFx0XFx0dW5xdW90ZWQgPSAhbWF0Y2hbNl0gJiYgbWF0Y2hbMl07XFxuXFxuXFx0XFx0XFx0aWYgKCBtYXRjaEV4cHJbXFxcIkNISUxEXFxcIl0udGVzdCggbWF0Y2hbMF0gKSApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gbnVsbDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcXG5cXHRcXHRcXHRpZiAoIG1hdGNoWzNdICkge1xcblxcdFxcdFxcdFxcdG1hdGNoWzJdID0gbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXFxcIlxcXCI7XFxuXFxuXFx0XFx0XFx0Ly8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcXG5cXHRcXHRcXHRcXHQvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxcblxcdFxcdFxcdFxcdChleGNlc3MgPSB0b2tlbml6ZSggdW5xdW90ZWQsIHRydWUgKSkgJiZcXG5cXHRcXHRcXHRcXHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcXG5cXHRcXHRcXHRcXHQoZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZiggXFxcIilcXFwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcXG5cXHRcXHRcXHRcXHRtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwLCBleGNlc3MgKTtcXG5cXHRcXHRcXHRcXHRtYXRjaFsyXSA9IHVucXVvdGVkLnNsaWNlKCAwLCBleGNlc3MgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gUmV0dXJuIG9ubHkgY2FwdHVyZXMgbmVlZGVkIGJ5IHRoZSBwc2V1ZG8gZmlsdGVyIG1ldGhvZCAodHlwZSBhbmQgYXJndW1lbnQpXFxuXFx0XFx0XFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7XFxuXFx0XFx0fVxcblxcdH0sXFxuXFxuXFx0ZmlsdGVyOiB7XFxuXFxuXFx0XFx0XFxcIlRBR1xcXCI6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xcblxcdFxcdFxcdHZhciBub2RlTmFtZSA9IG5vZGVOYW1lU2VsZWN0b3IucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xcblxcdFxcdFxcdHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcXFwiKlxcXCIgP1xcblxcdFxcdFxcdFxcdGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSA6XFxuXFx0XFx0XFx0XFx0ZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZTtcXG5cXHRcXHRcXHRcXHR9O1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0XFxcIkNMQVNTXFxcIjogZnVuY3Rpb24oIGNsYXNzTmFtZSApIHtcXG5cXHRcXHRcXHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFxcXCIgXFxcIiBdO1xcblxcblxcdFxcdFxcdHJldHVybiBwYXR0ZXJuIHx8XFxuXFx0XFx0XFx0XFx0KHBhdHRlcm4gPSBuZXcgUmVnRXhwKCBcXFwiKF58XFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKVxcXCIgKyBjbGFzc05hbWUgKyBcXFwiKFxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcInwkKVxcXCIgKSkgJiZcXG5cXHRcXHRcXHRcXHRjbGFzc0NhY2hlKCBjbGFzc05hbWUsIGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBwYXR0ZXJuLnRlc3QoIHR5cGVvZiBlbGVtLmNsYXNzTmFtZSA9PT0gXFxcInN0cmluZ1xcXCIgJiYgZWxlbS5jbGFzc05hbWUgfHwgdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmJiBlbGVtLmdldEF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiKSB8fCBcXFwiXFxcIiApO1xcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0XFxcIkFUVFJcXFwiOiBmdW5jdGlvbiggbmFtZSwgb3BlcmF0b3IsIGNoZWNrICkge1xcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRcXHR2YXIgcmVzdWx0ID0gU2l6emxlLmF0dHIoIGVsZW0sIG5hbWUgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHJlc3VsdCA9PSBudWxsICkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBvcGVyYXRvciA9PT0gXFxcIiE9XFxcIjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKCAhb3BlcmF0b3IgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJlc3VsdCArPSBcXFwiXFxcIjtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gb3BlcmF0b3IgPT09IFxcXCI9XFxcIiA/IHJlc3VsdCA9PT0gY2hlY2sgOlxcblxcdFxcdFxcdFxcdFxcdG9wZXJhdG9yID09PSBcXFwiIT1cXFwiID8gcmVzdWx0ICE9PSBjaGVjayA6XFxuXFx0XFx0XFx0XFx0XFx0b3BlcmF0b3IgPT09IFxcXCJePVxcXCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XFxuXFx0XFx0XFx0XFx0XFx0b3BlcmF0b3IgPT09IFxcXCIqPVxcXCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcXG5cXHRcXHRcXHRcXHRcXHRvcGVyYXRvciA9PT0gXFxcIiQ9XFxcIiA/IGNoZWNrICYmIHJlc3VsdC5zbGljZSggLWNoZWNrLmxlbmd0aCApID09PSBjaGVjayA6XFxuXFx0XFx0XFx0XFx0XFx0b3BlcmF0b3IgPT09IFxcXCJ+PVxcXCIgPyAoIFxcXCIgXFxcIiArIHJlc3VsdC5yZXBsYWNlKCByd2hpdGVzcGFjZSwgXFxcIiBcXFwiICkgKyBcXFwiIFxcXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxcblxcdFxcdFxcdFxcdFxcdG9wZXJhdG9yID09PSBcXFwifD1cXFwiID8gcmVzdWx0ID09PSBjaGVjayB8fCByZXN1bHQuc2xpY2UoIDAsIGNoZWNrLmxlbmd0aCArIDEgKSA9PT0gY2hlY2sgKyBcXFwiLVxcXCIgOlxcblxcdFxcdFxcdFxcdFxcdGZhbHNlO1xcblxcdFxcdFxcdH07XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRcXFwiQ0hJTERcXFwiOiBmdW5jdGlvbiggdHlwZSwgd2hhdCwgYXJndW1lbnQsIGZpcnN0LCBsYXN0ICkge1xcblxcdFxcdFxcdHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFxcXCJudGhcXFwiLFxcblxcdFxcdFxcdFxcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcXFwibGFzdFxcXCIsXFxuXFx0XFx0XFx0XFx0b2ZUeXBlID0gd2hhdCA9PT0gXFxcIm9mLXR5cGVcXFwiO1xcblxcblxcdFxcdFxcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cXG5cXG5cXHRcXHRcXHRcXHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXFxuXFx0XFx0XFx0XFx0ZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xcblxcdFxcdFxcdFxcdH0gOlxcblxcblxcdFxcdFxcdFxcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGNhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSwgbm9kZSwgbm9kZUluZGV4LCBzdGFydCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcXFwibmV4dFNpYmxpbmdcXFwiIDogXFxcInByZXZpb3VzU2libGluZ1xcXCIsXFxuXFx0XFx0XFx0XFx0XFx0XFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxcblxcdFxcdFxcdFxcdFxcdFxcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxcblxcdFxcdFxcdFxcdFxcdFxcdHVzZUNhY2hlID0gIXhtbCAmJiAhb2ZUeXBlLFxcblxcdFxcdFxcdFxcdFxcdFxcdGRpZmYgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHBhcmVudCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBzaW1wbGUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0d2hpbGUgKCBkaXIgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9kZSA9IGVsZW07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0d2hpbGUgKCAobm9kZSA9IG5vZGVbIGRpciBdKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIG9mVHlwZSA/XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRub2RlLm5vZGVUeXBlID09PSAxICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFJldmVyc2UgZGlyZWN0aW9uIGZvciA6b25seS0qIChpZiB3ZSBoYXZlbid0IHlldCBkb25lIHNvKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXFxcIm9ubHlcXFwiICYmICFzdGFydCAmJiBcXFwibmV4dFNpYmxpbmdcXFwiO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0c3RhcnQgPSBbIGZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGQgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggZm9yd2FyZCAmJiB1c2VDYWNoZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9kZSA9IHBhcmVudDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRpZmYgPSBub2RlSW5kZXggJiYgY2FjaGVbIDIgXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRub2RlID0gbm9kZUluZGV4ICYmIHBhcmVudC5jaGlsZE5vZGVzWyBub2RlSW5kZXggXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgbm9kZUluZGV4LCBkaWZmIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggdXNlQ2FjaGUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vZGUgPSBlbGVtO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGlmZiA9IG5vZGVJbmRleDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8geG1sIDpudGgtY2hpbGQoLi4uKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGRpZmYgPT09IGZhbHNlICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoICggb2ZUeXBlID9cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vZGUubm9kZVR5cGUgPT09IDEgKSAmJlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdCsrZGlmZiApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB1c2VDYWNoZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggbm9kZSA9PT0gZWxlbSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGlmZiAtPSBsYXN0O1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9O1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0XFxcIlBTRVVET1xcXCI6IGZ1bmN0aW9uKCBwc2V1ZG8sIGFyZ3VtZW50ICkge1xcblxcdFxcdFxcdC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxcblxcdFxcdFxcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcXG5cXHRcXHRcXHQvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xcblxcdFxcdFxcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3NcXG5cXHRcXHRcXHR2YXIgYXJncyxcXG5cXHRcXHRcXHRcXHRmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XFxuXFx0XFx0XFx0XFx0XFx0U2l6emxlLmVycm9yKCBcXFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcXFwiICsgcHNldWRvICk7XFxuXFxuXFx0XFx0XFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxcblxcdFxcdFxcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXFxuXFx0XFx0XFx0Ly8ganVzdCBhcyBTaXp6bGUgZG9lc1xcblxcdFxcdFxcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZm4oIGFyZ3VtZW50ICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEJ1dCBtYWludGFpbiBzdXBwb3J0IGZvciBvbGQgc2lnbmF0dXJlc1xcblxcdFxcdFxcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcXG5cXHRcXHRcXHRcXHRhcmdzID0gWyBwc2V1ZG8sIHBzZXVkbywgXFxcIlxcXCIsIGFyZ3VtZW50IF07XFxuXFx0XFx0XFx0XFx0cmV0dXJuIEV4cHIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eSggcHNldWRvLnRvTG93ZXJDYXNlKCkgKSA/XFxuXFx0XFx0XFx0XFx0XFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBpZHgsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bWF0Y2hlZCA9IGZuKCBzZWVkLCBhcmd1bWVudCApLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGkgPSBtYXRjaGVkLmxlbmd0aDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR3aGlsZSAoIGktLSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZHggPSBpbmRleE9mKCBzZWVkLCBtYXRjaGVkW2ldICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbaV0gKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fSkgOlxcblxcdFxcdFxcdFxcdFxcdGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBmbiggZWxlbSwgMCwgYXJncyApO1xcblxcdFxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBmbjtcXG5cXHRcXHR9XFxuXFx0fSxcXG5cXG5cXHRwc2V1ZG9zOiB7XFxuXFx0XFx0Ly8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXFxuXFx0XFx0XFxcIm5vdFxcXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XFxuXFx0XFx0XFx0Ly8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcXG5cXHRcXHRcXHQvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xcblxcdFxcdFxcdC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xcblxcdFxcdFxcdHZhciBpbnB1dCA9IFtdLFxcblxcdFxcdFxcdFxcdHJlc3VsdHMgPSBbXSxcXG5cXHRcXHRcXHRcXHRtYXRjaGVyID0gY29tcGlsZSggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFxcXCIkMVxcXCIgKSApO1xcblxcblxcdFxcdFxcdHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xcblxcdFxcdFxcdFxcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgY29udGV4dCwgeG1sICkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBlbGVtLFxcblxcdFxcdFxcdFxcdFxcdFxcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRpID0gc2VlZC5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxcblxcdFxcdFxcdFxcdFxcdHdoaWxlICggaS0tICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNlZWRbaV0gPSAhKG1hdGNoZXNbaV0gPSBlbGVtKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0pIDpcXG5cXHRcXHRcXHRcXHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xcblxcdFxcdFxcdFxcdFxcdGlucHV0WzBdID0gZWxlbTtcXG5cXHRcXHRcXHRcXHRcXHRtYXRjaGVyKCBpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzICk7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gRG9uJ3Qga2VlcCB0aGUgZWxlbWVudCAoaXNzdWUgIzI5OSlcXG5cXHRcXHRcXHRcXHRcXHRpbnB1dFswXSA9IG51bGw7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuICFyZXN1bHRzLnBvcCgpO1xcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0fSksXFxuXFxuXFx0XFx0XFxcImhhc1xcXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdFxcdHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcXG5cXHRcXHRcXHR9O1xcblxcdFxcdH0pLFxcblxcblxcdFxcdFxcXCJjb250YWluc1xcXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggdGV4dCApIHtcXG5cXHRcXHRcXHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGVsZW0uaW5uZXJUZXh0IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xcblxcdFxcdFxcdH07XFxuXFx0XFx0fSksXFxuXFxuXFx0XFx0Ly8gXFxcIldoZXRoZXIgYW4gZWxlbWVudCBpcyByZXByZXNlbnRlZCBieSBhIDpsYW5nKCkgc2VsZWN0b3JcXG5cXHRcXHQvLyBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZVxcblxcdFxcdC8vIGJlaW5nIGVxdWFsIHRvIHRoZSBpZGVudGlmaWVyIEMsXFxuXFx0XFx0Ly8gb3IgYmVnaW5uaW5nIHdpdGggdGhlIGlkZW50aWZpZXIgQyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBcXFwiLVxcXCIuXFxuXFx0XFx0Ly8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXFxuXFx0XFx0Ly8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cXFwiXFxuXFx0XFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNsYW5nLXBzZXVkb1xcblxcdFxcdFxcXCJsYW5nXFxcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggbGFuZyApIHtcXG5cXHRcXHRcXHQvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXFxuXFx0XFx0XFx0aWYgKCAhcmlkZW50aWZpZXIudGVzdChsYW5nIHx8IFxcXCJcXFwiKSApIHtcXG5cXHRcXHRcXHRcXHRTaXp6bGUuZXJyb3IoIFxcXCJ1bnN1cHBvcnRlZCBsYW5nOiBcXFwiICsgbGFuZyApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRsYW5nID0gbGFuZy5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdFxcdHZhciBlbGVtTGFuZztcXG5cXHRcXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCAoZWxlbUxhbmcgPSBkb2N1bWVudElzSFRNTCA/XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxlbS5sYW5nIDpcXG5cXHRcXHRcXHRcXHRcXHRcXHRlbGVtLmdldEF0dHJpYnV0ZShcXFwieG1sOmxhbmdcXFwiKSB8fCBlbGVtLmdldEF0dHJpYnV0ZShcXFwibGFuZ1xcXCIpKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8IGVsZW1MYW5nLmluZGV4T2YoIGxhbmcgKyBcXFwiLVxcXCIgKSA9PT0gMDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSB3aGlsZSAoIChlbGVtID0gZWxlbS5wYXJlbnROb2RlKSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH07XFxuXFx0XFx0fSksXFxuXFxuXFx0XFx0Ly8gTWlzY2VsbGFuZW91c1xcblxcdFxcdFxcXCJ0YXJnZXRcXFwiOiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHR2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcXG5cXHRcXHRcXHRyZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRcXFwicm9vdFxcXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdHJldHVybiBlbGVtID09PSBkb2NFbGVtO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0XFxcImZvY3VzXFxcIjogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKCFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpKSAmJiAhIShlbGVtLnR5cGUgfHwgZWxlbS5ocmVmIHx8IH5lbGVtLnRhYkluZGV4KTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIEJvb2xlYW4gcHJvcGVydGllc1xcblxcdFxcdFxcXCJlbmFibGVkXFxcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGZhbHNlICksXFxuXFx0XFx0XFxcImRpc2FibGVkXFxcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIHRydWUgKSxcXG5cXG5cXHRcXHRcXFwiY2hlY2tlZFxcXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xcblxcdFxcdFxcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXFxuXFx0XFx0XFx0dmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xcblxcdFxcdFxcdHJldHVybiAobm9kZU5hbWUgPT09IFxcXCJpbnB1dFxcXCIgJiYgISFlbGVtLmNoZWNrZWQpIHx8IChub2RlTmFtZSA9PT0gXFxcIm9wdGlvblxcXCIgJiYgISFlbGVtLnNlbGVjdGVkKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdFxcXCJzZWxlY3RlZFxcXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcXG5cXHRcXHRcXHQvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XFxuXFx0XFx0XFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XFxuXFx0XFx0XFx0XFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gQ29udGVudHNcXG5cXHRcXHRcXFwiZW1wdHlcXFwiOiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xcblxcdFxcdFxcdC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcXG5cXHRcXHRcXHQvLyAgIGJ1dCBub3QgYnkgb3RoZXJzIChjb21tZW50OiA4OyBwcm9jZXNzaW5nIGluc3RydWN0aW9uOiA3OyBldGMuKVxcblxcdFxcdFxcdC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cXG5cXHRcXHRcXHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcXG5cXHRcXHRcXHRcXHRpZiAoIGVsZW0ubm9kZVR5cGUgPCA2ICkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0XFxcInBhcmVudFxcXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdHJldHVybiAhRXhwci5wc2V1ZG9zW1xcXCJlbXB0eVxcXCJdKCBlbGVtICk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBFbGVtZW50L2lucHV0IHR5cGVzXFxuXFx0XFx0XFxcImhlYWRlclxcXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdHJldHVybiByaGVhZGVyLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdFxcXCJpbnB1dFxcXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdHJldHVybiByaW5wdXRzLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdFxcXCJidXR0b25cXFwiOiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcXG5cXHRcXHRcXHRyZXR1cm4gbmFtZSA9PT0gXFxcImlucHV0XFxcIiAmJiBlbGVtLnR5cGUgPT09IFxcXCJidXR0b25cXFwiIHx8IG5hbWUgPT09IFxcXCJidXR0b25cXFwiO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0XFxcInRleHRcXFwiOiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHR2YXIgYXR0cjtcXG5cXHRcXHRcXHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcXFwiaW5wdXRcXFwiICYmXFxuXFx0XFx0XFx0XFx0ZWxlbS50eXBlID09PSBcXFwidGV4dFxcXCIgJiZcXG5cXG5cXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBJRTw4XFxuXFx0XFx0XFx0XFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFxcXCJzZWFyY2hcXFwiKSBhcHBlYXIgd2l0aCBlbGVtLnR5cGUgPT09IFxcXCJ0ZXh0XFxcIlxcblxcdFxcdFxcdFxcdCggKGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZShcXFwidHlwZVxcXCIpKSA9PSBudWxsIHx8IGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gXFxcInRleHRcXFwiICk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBQb3NpdGlvbi1pbi1jb2xsZWN0aW9uXFxuXFx0XFx0XFxcImZpcnN0XFxcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRyZXR1cm4gWyAwIF07XFxuXFx0XFx0fSksXFxuXFxuXFx0XFx0XFxcImxhc3RcXFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcXG5cXHRcXHRcXHRyZXR1cm4gWyBsZW5ndGggLSAxIF07XFxuXFx0XFx0fSksXFxuXFxuXFx0XFx0XFxcImVxXFxcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xcblxcdFxcdFxcdHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcXG5cXHRcXHR9KSxcXG5cXG5cXHRcXHRcXFwiZXZlblxcXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xcblxcdFxcdFxcdHZhciBpID0gMDtcXG5cXHRcXHRcXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcXG5cXHRcXHRcXHRcXHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xcblxcdFxcdH0pLFxcblxcblxcdFxcdFxcXCJvZGRcXFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcXG5cXHRcXHRcXHR2YXIgaSA9IDE7XFxuXFx0XFx0XFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XFxuXFx0XFx0XFx0XFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcXG5cXHRcXHR9KSxcXG5cXG5cXHRcXHRcXFwibHRcXFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XFxuXFx0XFx0XFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xcblxcdFxcdFxcdGZvciAoIDsgLS1pID49IDA7ICkge1xcblxcdFxcdFxcdFxcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBtYXRjaEluZGV4ZXM7XFxuXFx0XFx0fSksXFxuXFxuXFx0XFx0XFxcImd0XFxcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xcblxcdFxcdFxcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcXG5cXHRcXHRcXHRmb3IgKCA7ICsraSA8IGxlbmd0aDsgKSB7XFxuXFx0XFx0XFx0XFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcXG5cXHRcXHR9KVxcblxcdH1cXG59O1xcblxcbkV4cHIucHNldWRvc1tcXFwibnRoXFxcIl0gPSBFeHByLnBzZXVkb3NbXFxcImVxXFxcIl07XFxuXFxuLy8gQWRkIGJ1dHRvbi9pbnB1dCB0eXBlIHBzZXVkb3NcXG5mb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcXG5cXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XFxufVxcbmZvciAoIGkgaW4geyBzdWJtaXQ6IHRydWUsIHJlc2V0OiB0cnVlIH0gKSB7XFxuXFx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcXG59XFxuXFxuLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXFxuZnVuY3Rpb24gc2V0RmlsdGVycygpIHt9XFxuc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XFxuRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcXG5cXG50b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xcblxcdHZhciBtYXRjaGVkLCBtYXRjaCwgdG9rZW5zLCB0eXBlLFxcblxcdFxcdHNvRmFyLCBncm91cHMsIHByZUZpbHRlcnMsXFxuXFx0XFx0Y2FjaGVkID0gdG9rZW5DYWNoZVsgc2VsZWN0b3IgKyBcXFwiIFxcXCIgXTtcXG5cXG5cXHRpZiAoIGNhY2hlZCApIHtcXG5cXHRcXHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xcblxcdH1cXG5cXG5cXHRzb0ZhciA9IHNlbGVjdG9yO1xcblxcdGdyb3VwcyA9IFtdO1xcblxcdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcXG5cXG5cXHR3aGlsZSAoIHNvRmFyICkge1xcblxcblxcdFxcdC8vIENvbW1hIGFuZCBmaXJzdCBydW5cXG5cXHRcXHRpZiAoICFtYXRjaGVkIHx8IChtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApKSApIHtcXG5cXHRcXHRcXHRpZiAoIG1hdGNoICkge1xcblxcdFxcdFxcdFxcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXFxuXFx0XFx0XFx0XFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbMF0ubGVuZ3RoICkgfHwgc29GYXI7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGdyb3Vwcy5wdXNoKCAodG9rZW5zID0gW10pICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdG1hdGNoZWQgPSBmYWxzZTtcXG5cXG5cXHRcXHQvLyBDb21iaW5hdG9yc1xcblxcdFxcdGlmICggKG1hdGNoID0gcmNvbWJpbmF0b3JzLmV4ZWMoIHNvRmFyICkpICkge1xcblxcdFxcdFxcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xcblxcdFxcdFxcdHRva2Vucy5wdXNoKHtcXG5cXHRcXHRcXHRcXHR2YWx1ZTogbWF0Y2hlZCxcXG5cXHRcXHRcXHRcXHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2VcXG5cXHRcXHRcXHRcXHR0eXBlOiBtYXRjaFswXS5yZXBsYWNlKCBydHJpbSwgXFxcIiBcXFwiIClcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBGaWx0ZXJzXFxuXFx0XFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcXG5cXHRcXHRcXHRpZiAoIChtYXRjaCA9IG1hdGNoRXhwclsgdHlwZSBdLmV4ZWMoIHNvRmFyICkpICYmICghcHJlRmlsdGVyc1sgdHlwZSBdIHx8XFxuXFx0XFx0XFx0XFx0KG1hdGNoID0gcHJlRmlsdGVyc1sgdHlwZSBdKCBtYXRjaCApKSkgKSB7XFxuXFx0XFx0XFx0XFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XFxuXFx0XFx0XFx0XFx0dG9rZW5zLnB1c2goe1xcblxcdFxcdFxcdFxcdFxcdHZhbHVlOiBtYXRjaGVkLFxcblxcdFxcdFxcdFxcdFxcdHR5cGU6IHR5cGUsXFxuXFx0XFx0XFx0XFx0XFx0bWF0Y2hlczogbWF0Y2hcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCAhbWF0Y2hlZCApIHtcXG5cXHRcXHRcXHRicmVhaztcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdC8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnZhbGlkIGV4Y2Vzc1xcblxcdC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xcblxcdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xcblxcdHJldHVybiBwYXJzZU9ubHkgP1xcblxcdFxcdHNvRmFyLmxlbmd0aCA6XFxuXFx0XFx0c29GYXIgP1xcblxcdFxcdFxcdFNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6XFxuXFx0XFx0XFx0Ly8gQ2FjaGUgdGhlIHRva2Vuc1xcblxcdFxcdFxcdHRva2VuQ2FjaGUoIHNlbGVjdG9yLCBncm91cHMgKS5zbGljZSggMCApO1xcbn07XFxuXFxuZnVuY3Rpb24gdG9TZWxlY3RvciggdG9rZW5zICkge1xcblxcdHZhciBpID0gMCxcXG5cXHRcXHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxcblxcdFxcdHNlbGVjdG9yID0gXFxcIlxcXCI7XFxuXFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XFxuXFx0XFx0c2VsZWN0b3IgKz0gdG9rZW5zW2ldLnZhbHVlO1xcblxcdH1cXG5cXHRyZXR1cm4gc2VsZWN0b3I7XFxufVxcblxcbmZ1bmN0aW9uIGFkZENvbWJpbmF0b3IoIG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UgKSB7XFxuXFx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxcblxcdFxcdHNraXAgPSBjb21iaW5hdG9yLm5leHQsXFxuXFx0XFx0a2V5ID0gc2tpcCB8fCBkaXIsXFxuXFx0XFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcXFwicGFyZW50Tm9kZVxcXCIsXFxuXFx0XFx0ZG9uZU5hbWUgPSBkb25lKys7XFxuXFxuXFx0cmV0dXJuIGNvbWJpbmF0b3IuZmlyc3QgP1xcblxcdFxcdC8vIENoZWNrIGFnYWluc3QgY2xvc2VzdCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudFxcblxcdFxcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XFxuXFx0XFx0XFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcXG5cXHRcXHRcXHRcXHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0fSA6XFxuXFxuXFx0XFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXFxuXFx0XFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcXG5cXHRcXHRcXHR2YXIgb2xkQ2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLFxcblxcdFxcdFxcdFxcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xcblxcblxcdFxcdFxcdC8vIFdlIGNhbid0IHNldCBhcmJpdHJhcnkgZGF0YSBvbiBYTUwgbm9kZXMsIHNvIHRoZXkgZG9uJ3QgYmVuZWZpdCBmcm9tIGNvbWJpbmF0b3IgY2FjaGluZ1xcblxcdFxcdFxcdGlmICggeG1sICkge1xcblxcdFxcdFxcdFxcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcXG5cXHRcXHRcXHRcXHRcXHRcXHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSB8fCAob3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdID0ge30pO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggc2tpcCAmJiBza2lwID09PSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZWxlbSA9IGVsZW1bIGRpciBdIHx8IGVsZW07XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmICggKG9sZENhY2hlID0gdW5pcXVlQ2FjaGVbIGtleSBdKSAmJlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG9sZENhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbIDEgXSA9PT0gZG9uZU5hbWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gKG5ld0NhY2hlWyAyIF0gPSBvbGRDYWNoZVsgMiBdKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFJldXNlIG5ld2NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR1bmlxdWVDYWNoZVsga2V5IF0gPSBuZXdDYWNoZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIChuZXdDYWNoZVsgMiBdID0gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkpICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdH07XFxufVxcblxcbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcXG5cXHRyZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMSA/XFxuXFx0XFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcXG5cXHRcXHRcXHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcXG5cXHRcXHRcXHR3aGlsZSAoIGktLSApIHtcXG5cXHRcXHRcXHRcXHRpZiAoICFtYXRjaGVyc1tpXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0fSA6XFxuXFx0XFx0bWF0Y2hlcnNbMF07XFxufVxcblxcbmZ1bmN0aW9uIG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cyApIHtcXG5cXHR2YXIgaSA9IDAsXFxuXFx0XFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xcblxcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xcblxcdFxcdFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHRzW2ldLCByZXN1bHRzICk7XFxuXFx0fVxcblxcdHJldHVybiByZXN1bHRzO1xcbn1cXG5cXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xcblxcdHZhciBlbGVtLFxcblxcdFxcdG5ld1VubWF0Y2hlZCA9IFtdLFxcblxcdFxcdGkgPSAwLFxcblxcdFxcdGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXFxuXFx0XFx0bWFwcGVkID0gbWFwICE9IG51bGw7XFxuXFxuXFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XFxuXFx0XFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XFxuXFx0XFx0XFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XFxuXFx0XFx0XFx0XFx0bmV3VW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcXG5cXHRcXHRcXHRcXHRpZiAoIG1hcHBlZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRtYXAucHVzaCggaSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xcbn1cXG5cXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XFxuXFx0aWYgKCBwb3N0RmlsdGVyICYmICFwb3N0RmlsdGVyWyBleHBhbmRvIF0gKSB7XFxuXFx0XFx0cG9zdEZpbHRlciA9IHNldE1hdGNoZXIoIHBvc3RGaWx0ZXIgKTtcXG5cXHR9XFxuXFx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XFxuXFx0XFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xcblxcdH1cXG5cXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwgKSB7XFxuXFx0XFx0dmFyIHRlbXAsIGksIGVsZW0sXFxuXFx0XFx0XFx0cHJlTWFwID0gW10sXFxuXFx0XFx0XFx0cG9zdE1hcCA9IFtdLFxcblxcdFxcdFxcdHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXFxuXFxuXFx0XFx0XFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcXG5cXHRcXHRcXHRlbGVtcyA9IHNlZWQgfHwgbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IgfHwgXFxcIipcXFwiLCBjb250ZXh0Lm5vZGVUeXBlID8gWyBjb250ZXh0IF0gOiBjb250ZXh0LCBbXSApLFxcblxcblxcdFxcdFxcdC8vIFByZWZpbHRlciB0byBnZXQgbWF0Y2hlciBpbnB1dCwgcHJlc2VydmluZyBhIG1hcCBmb3Igc2VlZC1yZXN1bHRzIHN5bmNocm9uaXphdGlvblxcblxcdFxcdFxcdG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoIHNlZWQgfHwgIXNlbGVjdG9yICkgP1xcblxcdFxcdFxcdFxcdGNvbmRlbnNlKCBlbGVtcywgcHJlTWFwLCBwcmVGaWx0ZXIsIGNvbnRleHQsIHhtbCApIDpcXG5cXHRcXHRcXHRcXHRlbGVtcyxcXG5cXG5cXHRcXHRcXHRtYXRjaGVyT3V0ID0gbWF0Y2hlciA/XFxuXFx0XFx0XFx0XFx0Ly8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXIgb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcXG5cXHRcXHRcXHRcXHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XFxuXFx0XFx0XFx0XFx0XFx0W10gOlxcblxcblxcdFxcdFxcdFxcdFxcdC8vIC4uLm90aGVyd2lzZSB1c2UgcmVzdWx0cyBkaXJlY3RseVxcblxcdFxcdFxcdFxcdFxcdHJlc3VsdHMgOlxcblxcdFxcdFxcdFxcdG1hdGNoZXJJbjtcXG5cXG5cXHRcXHQvLyBGaW5kIHByaW1hcnkgbWF0Y2hlc1xcblxcdFxcdGlmICggbWF0Y2hlciApIHtcXG5cXHRcXHRcXHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBBcHBseSBwb3N0RmlsdGVyXFxuXFx0XFx0aWYgKCBwb3N0RmlsdGVyICkge1xcblxcdFxcdFxcdHRlbXAgPSBjb25kZW5zZSggbWF0Y2hlck91dCwgcG9zdE1hcCApO1xcblxcdFxcdFxcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcXG5cXG5cXHRcXHRcXHQvLyBVbi1tYXRjaCBmYWlsaW5nIGVsZW1lbnRzIGJ5IG1vdmluZyB0aGVtIGJhY2sgdG8gbWF0Y2hlckluXFxuXFx0XFx0XFx0aSA9IHRlbXAubGVuZ3RoO1xcblxcdFxcdFxcdHdoaWxlICggaS0tICkge1xcblxcdFxcdFxcdFxcdGlmICggKGVsZW0gPSB0ZW1wW2ldKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBzZWVkICkge1xcblxcdFxcdFxcdGlmICggcG9zdEZpbmRlciB8fCBwcmVGaWx0ZXIgKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCBwb3N0RmluZGVyICkge1xcblxcdFxcdFxcdFxcdFxcdC8vIEdldCB0aGUgZmluYWwgbWF0Y2hlck91dCBieSBjb25kZW5zaW5nIHRoaXMgaW50ZXJtZWRpYXRlIGludG8gcG9zdEZpbmRlciBjb250ZXh0c1xcblxcdFxcdFxcdFxcdFxcdHRlbXAgPSBbXTtcXG5cXHRcXHRcXHRcXHRcXHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKCBpLS0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGVtcC5wdXNoKCAobWF0Y2hlckluW2ldID0gZWxlbSkgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHBvc3RGaW5kZXIoIG51bGwsIChtYXRjaGVyT3V0ID0gW10pLCB0ZW1wLCB4bWwgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcXG5cXHRcXHRcXHRcXHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XFxuXFx0XFx0XFx0XFx0d2hpbGUgKCBpLS0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICYmXFxuXFx0XFx0XFx0XFx0XFx0XFx0KHRlbXAgPSBwb3N0RmluZGVyID8gaW5kZXhPZiggc2VlZCwgZWxlbSApIDogcHJlTWFwW2ldKSA+IC0xICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHNlZWRbdGVtcF0gPSAhKHJlc3VsdHNbdGVtcF0gPSBlbGVtKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHQvLyBBZGQgZWxlbWVudHMgdG8gcmVzdWx0cywgdGhyb3VnaCBwb3N0RmluZGVyIGlmIGRlZmluZWRcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcXG5cXHRcXHRcXHRcXHRtYXRjaGVyT3V0ID09PSByZXN1bHRzID9cXG5cXHRcXHRcXHRcXHRcXHRtYXRjaGVyT3V0LnNwbGljZSggcHJlZXhpc3RpbmcsIG1hdGNoZXJPdXQubGVuZ3RoICkgOlxcblxcdFxcdFxcdFxcdFxcdG1hdGNoZXJPdXRcXG5cXHRcXHRcXHQpO1xcblxcdFxcdFxcdGlmICggcG9zdEZpbmRlciApIHtcXG5cXHRcXHRcXHRcXHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH0pO1xcbn1cXG5cXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xcblxcdHZhciBjaGVja0NvbnRleHQsIG1hdGNoZXIsIGosXFxuXFx0XFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcXG5cXHRcXHRsZWFkaW5nUmVsYXRpdmUgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMF0udHlwZSBdLFxcblxcdFxcdGltcGxpY2l0UmVsYXRpdmUgPSBsZWFkaW5nUmVsYXRpdmUgfHwgRXhwci5yZWxhdGl2ZVtcXFwiIFxcXCJdLFxcblxcdFxcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcXG5cXG5cXHRcXHQvLyBUaGUgZm91bmRhdGlvbmFsIG1hdGNoZXIgZW5zdXJlcyB0aGF0IGVsZW1lbnRzIGFyZSByZWFjaGFibGUgZnJvbSB0b3AtbGV2ZWwgY29udGV4dChzKVxcblxcdFxcdG1hdGNoQ29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdHJldHVybiBlbGVtID09PSBjaGVja0NvbnRleHQ7XFxuXFx0XFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxcblxcdFxcdG1hdGNoQW55Q29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xcblxcdFxcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcXG5cXHRcXHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcXG5cXHRcXHRcXHR2YXIgcmV0ID0gKCAhbGVhZGluZ1JlbGF0aXZlICYmICggeG1sIHx8IGNvbnRleHQgIT09IG91dGVybW9zdENvbnRleHQgKSApIHx8IChcXG5cXHRcXHRcXHRcXHQoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgP1xcblxcdFxcdFxcdFxcdFxcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxcblxcdFxcdFxcdFxcdFxcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcXG5cXHRcXHRcXHQvLyBBdm9pZCBoYW5naW5nIG9udG8gZWxlbWVudCAoaXNzdWUgIzI5OSlcXG5cXHRcXHRcXHRjaGVja0NvbnRleHQgPSBudWxsO1xcblxcdFxcdFxcdHJldHVybiByZXQ7XFxuXFx0XFx0fSBdO1xcblxcblxcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xcblxcdFxcdGlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHtcXG5cXHRcXHRcXHRtYXRjaGVycyA9IFsgYWRkQ29tYmluYXRvcihlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSwgbWF0Y2hlcikgXTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdG1hdGNoZXIgPSBFeHByLmZpbHRlclsgdG9rZW5zW2ldLnR5cGUgXS5hcHBseSggbnVsbCwgdG9rZW5zW2ldLm1hdGNoZXMgKTtcXG5cXG5cXHRcXHRcXHQvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxcblxcdFxcdFxcdGlmICggbWF0Y2hlclsgZXhwYW5kbyBdICkge1xcblxcdFxcdFxcdFxcdC8vIEZpbmQgdGhlIG5leHQgcmVsYXRpdmUgb3BlcmF0b3IgKGlmIGFueSkgZm9yIHByb3BlciBoYW5kbGluZ1xcblxcdFxcdFxcdFxcdGogPSArK2k7XFxuXFx0XFx0XFx0XFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBFeHByLnJlbGF0aXZlWyB0b2tlbnNbal0udHlwZSBdICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHNldE1hdGNoZXIoXFxuXFx0XFx0XFx0XFx0XFx0aSA+IDEgJiYgZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksXFxuXFx0XFx0XFx0XFx0XFx0aSA+IDEgJiYgdG9TZWxlY3RvcihcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBJZiB0aGUgcHJlY2VkaW5nIHRva2VuIHdhcyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciwgaW5zZXJ0IGFuIGltcGxpY2l0IGFueS1lbGVtZW50IGAqYFxcblxcdFxcdFxcdFxcdFxcdFxcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFxcXCIgXFxcIiA/IFxcXCIqXFxcIiA6IFxcXCJcXFwiIH0pXFxuXFx0XFx0XFx0XFx0XFx0KS5yZXBsYWNlKCBydHJpbSwgXFxcIiQxXFxcIiApLFxcblxcdFxcdFxcdFxcdFxcdG1hdGNoZXIsXFxuXFx0XFx0XFx0XFx0XFx0aSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnMoIHRva2Vucy5zbGljZSggaSwgaiApICksXFxuXFx0XFx0XFx0XFx0XFx0aiA8IGxlbiAmJiBtYXRjaGVyRnJvbVRva2VucyggKHRva2VucyA9IHRva2Vucy5zbGljZSggaiApKSApLFxcblxcdFxcdFxcdFxcdFxcdGogPCBsZW4gJiYgdG9TZWxlY3RvciggdG9rZW5zIClcXG5cXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRtYXRjaGVycy5wdXNoKCBtYXRjaGVyICk7XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRyZXR1cm4gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICk7XFxufVxcblxcbmZ1bmN0aW9uIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApIHtcXG5cXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxcblxcdFxcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxcblxcdFxcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcXG5cXHRcXHRcXHR2YXIgZWxlbSwgaiwgbWF0Y2hlcixcXG5cXHRcXHRcXHRcXHRtYXRjaGVkQ291bnQgPSAwLFxcblxcdFxcdFxcdFxcdGkgPSBcXFwiMFxcXCIsXFxuXFx0XFx0XFx0XFx0dW5tYXRjaGVkID0gc2VlZCAmJiBbXSxcXG5cXHRcXHRcXHRcXHRzZXRNYXRjaGVkID0gW10sXFxuXFx0XFx0XFx0XFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXFxuXFx0XFx0XFx0XFx0Ly8gV2UgbXVzdCBhbHdheXMgaGF2ZSBlaXRoZXIgc2VlZCBlbGVtZW50cyBvciBvdXRlcm1vc3QgY29udGV4dFxcblxcdFxcdFxcdFxcdGVsZW1zID0gc2VlZCB8fCBieUVsZW1lbnQgJiYgRXhwci5maW5kW1xcXCJUQUdcXFwiXSggXFxcIipcXFwiLCBvdXRlcm1vc3QgKSxcXG5cXHRcXHRcXHRcXHQvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxcblxcdFxcdFxcdFxcdGRpcnJ1bnNVbmlxdWUgPSAoZGlycnVucyArPSBjb250ZXh0QmFja3VwID09IG51bGwgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAwLjEpLFxcblxcdFxcdFxcdFxcdGxlbiA9IGVsZW1zLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHRpZiAoIG91dGVybW9zdCApIHtcXG5cXHRcXHRcXHRcXHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCA9PT0gZG9jdW1lbnQgfHwgY29udGV4dCB8fCBvdXRlcm1vc3Q7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEFkZCBlbGVtZW50cyBwYXNzaW5nIGVsZW1lbnRNYXRjaGVycyBkaXJlY3RseSB0byByZXN1bHRzXFxuXFx0XFx0XFx0Ly8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXFxuXFx0XFx0XFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFxcXCJsZW5ndGhcXFwiOyBTYWZhcmk6IDxudW1iZXI+KSBtYXRjaGluZyBlbGVtZW50cyBieSBpZFxcblxcdFxcdFxcdGZvciAoIDsgaSAhPT0gbGVuICYmIChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcXG5cXHRcXHRcXHRcXHRpZiAoIGJ5RWxlbWVudCAmJiBlbGVtICkge1xcblxcdFxcdFxcdFxcdFxcdGogPSAwO1xcblxcdFxcdFxcdFxcdFxcdGlmICggIWNvbnRleHQgJiYgZWxlbS5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzZXREb2N1bWVudCggZWxlbSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKCAobWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1tqKytdKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQgfHwgZG9jdW1lbnQsIHhtbCkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIG91dGVybW9zdCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcXG5cXHRcXHRcXHRcXHRpZiAoIGJ5U2V0ICkge1xcblxcdFxcdFxcdFxcdFxcdC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIChlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bWF0Y2hlZENvdW50LS07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIExlbmd0aGVuIHRoZSBhcnJheSBmb3IgZXZlcnkgZWxlbWVudCwgbWF0Y2hlZCBvciBub3RcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHNlZWQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBgaWAgaXMgbm93IHRoZSBjb3VudCBvZiBlbGVtZW50cyB2aXNpdGVkIGFib3ZlLCBhbmQgYWRkaW5nIGl0IHRvIGBtYXRjaGVkQ291bnRgXFxuXFx0XFx0XFx0Ly8gbWFrZXMgdGhlIGxhdHRlciBub25uZWdhdGl2ZS5cXG5cXHRcXHRcXHRtYXRjaGVkQ291bnQgKz0gaTtcXG5cXG5cXHRcXHRcXHQvLyBBcHBseSBzZXQgZmlsdGVycyB0byB1bm1hdGNoZWQgZWxlbWVudHNcXG5cXHRcXHRcXHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXFxuXFx0XFx0XFx0Ly8gZXF1YWxzIGBpYCksIHVubGVzcyB3ZSBkaWRuJ3QgdmlzaXQgX2FueV8gZWxlbWVudHMgaW4gdGhlIGFib3ZlIGxvb3AgYmVjYXVzZSB3ZSBoYXZlXFxuXFx0XFx0XFx0Ly8gbm8gZWxlbWVudCBtYXRjaGVycyBhbmQgbm8gc2VlZC5cXG5cXHRcXHRcXHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcXFwiMFxcXCIgYGlgIGFsbG93cyBgaWAgdG8gcmVtYWluIGEgc3RyaW5nIG9ubHkgaW4gdGhhdFxcblxcdFxcdFxcdC8vIGNhc2UsIHdoaWNoIHdpbGwgcmVzdWx0IGluIGEgXFxcIjAwXFxcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cXG5cXHRcXHRcXHQvLyBudW1lcmljYWxseSB6ZXJvLlxcblxcdFxcdFxcdGlmICggYnlTZXQgJiYgaSAhPT0gbWF0Y2hlZENvdW50ICkge1xcblxcdFxcdFxcdFxcdGogPSAwO1xcblxcdFxcdFxcdFxcdHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHNlZWQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gUmVpbnRlZ3JhdGUgZWxlbWVudCBtYXRjaGVzIHRvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3Igc29ydGluZ1xcblxcdFxcdFxcdFxcdFxcdGlmICggbWF0Y2hlZENvdW50ID4gMCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR3aGlsZSAoIGktLSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoICEodW5tYXRjaGVkW2ldIHx8IHNldE1hdGNoZWRbaV0pICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHNldE1hdGNoZWRbaV0gPSBwb3AuY2FsbCggcmVzdWx0cyApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXFxuXFx0XFx0XFx0XFx0XFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHNcXG5cXHRcXHRcXHRcXHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZXRNYXRjaGVkICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU2VlZGxlc3Mgc2V0IG1hdGNoZXMgc3VjY2VlZGluZyBtdWx0aXBsZSBzdWNjZXNzZnVsIG1hdGNoZXJzIHN0aXB1bGF0ZSBzb3J0aW5nXFxuXFx0XFx0XFx0XFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXFxuXFx0XFx0XFx0XFx0XFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0U2l6emxlLnVuaXF1ZVNvcnQoIHJlc3VsdHMgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xcblxcdFxcdFxcdGlmICggb3V0ZXJtb3N0ICkge1xcblxcdFxcdFxcdFxcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xcblxcdFxcdFxcdFxcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdW5tYXRjaGVkO1xcblxcdFxcdH07XFxuXFxuXFx0cmV0dXJuIGJ5U2V0ID9cXG5cXHRcXHRtYXJrRnVuY3Rpb24oIHN1cGVyTWF0Y2hlciApIDpcXG5cXHRcXHRzdXBlck1hdGNoZXI7XFxufVxcblxcbmNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XFxuXFx0dmFyIGksXFxuXFx0XFx0c2V0TWF0Y2hlcnMgPSBbXSxcXG5cXHRcXHRlbGVtZW50TWF0Y2hlcnMgPSBbXSxcXG5cXHRcXHRjYWNoZWQgPSBjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFxcXCIgXFxcIiBdO1xcblxcblxcdGlmICggIWNhY2hlZCApIHtcXG5cXHRcXHQvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcXG5cXHRcXHRpZiAoICFtYXRjaCApIHtcXG5cXHRcXHRcXHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xcblxcdFxcdH1cXG5cXHRcXHRpID0gbWF0Y2gubGVuZ3RoO1xcblxcdFxcdHdoaWxlICggaS0tICkge1xcblxcdFxcdFxcdGNhY2hlZCA9IG1hdGNoZXJGcm9tVG9rZW5zKCBtYXRjaFtpXSApO1xcblxcdFxcdFxcdGlmICggY2FjaGVkWyBleHBhbmRvIF0gKSB7XFxuXFx0XFx0XFx0XFx0c2V0TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRlbGVtZW50TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cXG5cXHRcXHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcXG5cXG5cXHRcXHQvLyBTYXZlIHNlbGVjdG9yIGFuZCB0b2tlbml6YXRpb25cXG5cXHRcXHRjYWNoZWQuc2VsZWN0b3IgPSBzZWxlY3RvcjtcXG5cXHR9XFxuXFx0cmV0dXJuIGNhY2hlZDtcXG59O1xcblxcbi8qKlxcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb25zXFxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGV4dFxcbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxcbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XFxuICovXFxuc2VsZWN0ID0gU2l6emxlLnNlbGVjdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcXG5cXHR2YXIgaSwgdG9rZW5zLCB0b2tlbiwgdHlwZSwgZmluZCxcXG5cXHRcXHRjb21waWxlZCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBzZWxlY3RvcixcXG5cXHRcXHRtYXRjaCA9ICFzZWVkICYmIHRva2VuaXplKCAoc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3RvcikgKTtcXG5cXG5cXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcXG5cXG5cXHQvLyBUcnkgdG8gbWluaW1pemUgb3BlcmF0aW9ucyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBzZWxlY3RvciBpbiB0aGUgbGlzdCBhbmQgbm8gc2VlZFxcblxcdC8vICh0aGUgbGF0dGVyIG9mIHdoaWNoIGd1YXJhbnRlZXMgdXMgY29udGV4dClcXG5cXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcXG5cXG5cXHRcXHQvLyBSZWR1Y2UgY29udGV4dCBpZiB0aGUgbGVhZGluZyBjb21wb3VuZCBzZWxlY3RvciBpcyBhbiBJRFxcblxcdFxcdHRva2VucyA9IG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAgKTtcXG5cXHRcXHRpZiAoIHRva2Vucy5sZW5ndGggPiAyICYmICh0b2tlbiA9IHRva2Vuc1swXSkudHlwZSA9PT0gXFxcIklEXFxcIiAmJlxcblxcdFxcdFxcdFxcdGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiYgRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzFdLnR5cGUgXSApIHtcXG5cXG5cXHRcXHRcXHRjb250ZXh0ID0gKCBFeHByLmZpbmRbXFxcIklEXFxcIl0oIHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSksIGNvbnRleHQgKSB8fCBbXSApWzBdO1xcblxcdFxcdFxcdGlmICggIWNvbnRleHQgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdHM7XFxuXFxuXFx0XFx0XFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIGNvbXBpbGVkICkge1xcblxcdFxcdFxcdFxcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXFxuXFx0XFx0aSA9IG1hdGNoRXhwcltcXFwibmVlZHNDb250ZXh0XFxcIl0udGVzdCggc2VsZWN0b3IgKSA/IDAgOiB0b2tlbnMubGVuZ3RoO1xcblxcdFxcdHdoaWxlICggaS0tICkge1xcblxcdFxcdFxcdHRva2VuID0gdG9rZW5zW2ldO1xcblxcblxcdFxcdFxcdC8vIEFib3J0IGlmIHdlIGhpdCBhIGNvbWJpbmF0b3JcXG5cXHRcXHRcXHRpZiAoIEV4cHIucmVsYXRpdmVbICh0eXBlID0gdG9rZW4udHlwZSkgXSApIHtcXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCAoZmluZCA9IEV4cHIuZmluZFsgdHlwZSBdKSApIHtcXG5cXHRcXHRcXHRcXHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcXG5cXHRcXHRcXHRcXHRpZiAoIChzZWVkID0gZmluZChcXG5cXHRcXHRcXHRcXHRcXHR0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksXFxuXFx0XFx0XFx0XFx0XFx0cnNpYmxpbmcudGVzdCggdG9rZW5zWzBdLnR5cGUgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxcblxcdFxcdFxcdFxcdCkpICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxcblxcdFxcdFxcdFxcdFxcdHRva2Vucy5zcGxpY2UoIGksIDEgKTtcXG5cXHRcXHRcXHRcXHRcXHRzZWxlY3RvciA9IHNlZWQubGVuZ3RoICYmIHRvU2VsZWN0b3IoIHRva2VucyApO1xcblxcdFxcdFxcdFxcdFxcdGlmICggIXNlbGVjdG9yICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gcmVzdWx0cztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxcblxcdC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcXG5cXHQoIGNvbXBpbGVkIHx8IGNvbXBpbGUoIHNlbGVjdG9yLCBtYXRjaCApICkoXFxuXFx0XFx0c2VlZCxcXG5cXHRcXHRjb250ZXh0LFxcblxcdFxcdCFkb2N1bWVudElzSFRNTCxcXG5cXHRcXHRyZXN1bHRzLFxcblxcdFxcdCFjb250ZXh0IHx8IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcXG5cXHQpO1xcblxcdHJldHVybiByZXN1bHRzO1xcbn07XFxuXFxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcXG5cXG4vLyBTb3J0IHN0YWJpbGl0eVxcbnN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoXFxcIlxcXCIpLnNvcnQoIHNvcnRPcmRlciApLmpvaW4oXFxcIlxcXCIpID09PSBleHBhbmRvO1xcblxcbi8vIFN1cHBvcnQ6IENocm9tZSAxNC0zNStcXG4vLyBBbHdheXMgYXNzdW1lIGR1cGxpY2F0ZXMgaWYgdGhleSBhcmVuJ3QgcGFzc2VkIHRvIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXFxuc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XFxuXFxuLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XFxuc2V0RG9jdW1lbnQoKTtcXG5cXG4vLyBTdXBwb3J0OiBXZWJraXQ8NTM3LjMyIC0gU2FmYXJpIDYuMC4zL0Nocm9tZSAyNSAoZml4ZWQgaW4gQ2hyb21lIDI3KVxcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxcbnN1cHBvcnQuc29ydERldGFjaGVkID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcXG5cXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcXG5cXHRyZXR1cm4gZWwuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcImZpZWxkc2V0XFxcIikgKSAmIDE7XFxufSk7XFxuXFxuLy8gU3VwcG9ydDogSUU8OFxcbi8vIFByZXZlbnQgYXR0cmlidXRlL3Byb3BlcnR5IFxcXCJpbnRlcnBvbGF0aW9uXFxcIlxcbi8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XFxuaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcXG5cXHRlbC5pbm5lckhUTUwgPSBcXFwiPGEgaHJlZj0nIyc+PC9hPlxcXCI7XFxuXFx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFxcXCJocmVmXFxcIikgPT09IFxcXCIjXFxcIiA7XFxufSkgKSB7XFxuXFx0YWRkSGFuZGxlKCBcXFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFxcXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcXG5cXHRcXHRpZiAoICFpc1hNTCApIHtcXG5cXHRcXHRcXHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXFxcInR5cGVcXFwiID8gMSA6IDIgKTtcXG5cXHRcXHR9XFxuXFx0fSk7XFxufVxcblxcbi8vIFN1cHBvcnQ6IElFPDlcXG4vLyBVc2UgZGVmYXVsdFZhbHVlIGluIHBsYWNlIG9mIGdldEF0dHJpYnV0ZShcXFwidmFsdWVcXFwiKVxcbmlmICggIXN1cHBvcnQuYXR0cmlidXRlcyB8fCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcXG5cXHRlbC5pbm5lckhUTUwgPSBcXFwiPGlucHV0Lz5cXFwiO1xcblxcdGVsLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcXFwidmFsdWVcXFwiLCBcXFwiXFxcIiApO1xcblxcdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggXFxcInZhbHVlXFxcIiApID09PSBcXFwiXFxcIjtcXG59KSApIHtcXG5cXHRhZGRIYW5kbGUoIFxcXCJ2YWx1ZVxcXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcXG5cXHRcXHRpZiAoICFpc1hNTCAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFxcXCJpbnB1dFxcXCIgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xcblxcdFxcdH1cXG5cXHR9KTtcXG59XFxuXFxuLy8gU3VwcG9ydDogSUU8OVxcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcXG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xcblxcdHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoXFxcImRpc2FibGVkXFxcIikgPT0gbnVsbDtcXG59KSApIHtcXG5cXHRhZGRIYW5kbGUoIGJvb2xlYW5zLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XFxuXFx0XFx0dmFyIHZhbDtcXG5cXHRcXHRpZiAoICFpc1hNTCApIHtcXG5cXHRcXHRcXHRyZXR1cm4gZWxlbVsgbmFtZSBdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDpcXG5cXHRcXHRcXHRcXHRcXHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkpICYmIHZhbC5zcGVjaWZpZWQgP1xcblxcdFxcdFxcdFxcdFxcdHZhbC52YWx1ZSA6XFxuXFx0XFx0XFx0XFx0bnVsbDtcXG5cXHRcXHR9XFxuXFx0fSk7XFxufVxcblxcbnJldHVybiBTaXp6bGU7XFxuXFxufSkoIHdpbmRvdyApO1xcblxcblxcblxcbmpRdWVyeS5maW5kID0gU2l6emxlO1xcbmpRdWVyeS5leHByID0gU2l6emxlLnNlbGVjdG9ycztcXG5cXG4vLyBEZXByZWNhdGVkXFxualF1ZXJ5LmV4cHJbIFxcXCI6XFxcIiBdID0galF1ZXJ5LmV4cHIucHNldWRvcztcXG5qUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcXG5qUXVlcnkudGV4dCA9IFNpenpsZS5nZXRUZXh0O1xcbmpRdWVyeS5pc1hNTERvYyA9IFNpenpsZS5pc1hNTDtcXG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XFxualF1ZXJ5LmVzY2FwZVNlbGVjdG9yID0gU2l6emxlLmVzY2FwZTtcXG5cXG5cXG5cXG5cXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XFxuXFx0dmFyIG1hdGNoZWQgPSBbXSxcXG5cXHRcXHR0cnVuY2F0ZSA9IHVudGlsICE9PSB1bmRlZmluZWQ7XFxuXFxuXFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICYmIGVsZW0ubm9kZVR5cGUgIT09IDkgKSB7XFxuXFx0XFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xcblxcdFxcdFxcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdG1hdGNoZWQucHVzaCggZWxlbSApO1xcblxcdFxcdH1cXG5cXHR9XFxuXFx0cmV0dXJuIG1hdGNoZWQ7XFxufTtcXG5cXG5cXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcXG5cXHR2YXIgbWF0Y2hlZCA9IFtdO1xcblxcblxcdGZvciAoIDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcgKSB7XFxuXFx0XFx0aWYgKCBuLm5vZGVUeXBlID09PSAxICYmIG4gIT09IGVsZW0gKSB7XFxuXFx0XFx0XFx0bWF0Y2hlZC5wdXNoKCBuICk7XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRyZXR1cm4gbWF0Y2hlZDtcXG59O1xcblxcblxcbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xcblxcblxcblxcbmZ1bmN0aW9uIG5vZGVOYW1lKCBlbGVtLCBuYW1lICkge1xcblxcbiAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XFxuXFxufTtcXG52YXIgcnNpbmdsZVRhZyA9ICggL148KFthLXpdW15cXFxcL1xcXFwwPjpcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdKilbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXSpcXFxcLz8+KD86PFxcXFwvXFxcXDE+fCkkL2kgKTtcXG5cXG5cXG5cXG4vLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxcbmZ1bmN0aW9uIHdpbm5vdyggZWxlbWVudHMsIHF1YWxpZmllciwgbm90ICkge1xcblxcdGlmICggaXNGdW5jdGlvbiggcXVhbGlmaWVyICkgKSB7XFxuXFx0XFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XFxuXFx0XFx0XFx0cmV0dXJuICEhcXVhbGlmaWVyLmNhbGwoIGVsZW0sIGksIGVsZW0gKSAhPT0gbm90O1xcblxcdFxcdH0gKTtcXG5cXHR9XFxuXFxuXFx0Ly8gU2luZ2xlIGVsZW1lbnRcXG5cXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcXG5cXHRcXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSAhPT0gbm90O1xcblxcdFxcdH0gKTtcXG5cXHR9XFxuXFxuXFx0Ly8gQXJyYXlsaWtlIG9mIGVsZW1lbnRzIChqUXVlcnksIGFyZ3VtZW50cywgQXJyYXkpXFxuXFx0aWYgKCB0eXBlb2YgcXVhbGlmaWVyICE9PSBcXFwic3RyaW5nXFxcIiApIHtcXG5cXHRcXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID4gLTEgKSAhPT0gbm90O1xcblxcdFxcdH0gKTtcXG5cXHR9XFxuXFxuXFx0Ly8gRmlsdGVyZWQgZGlyZWN0bHkgZm9yIGJvdGggc2ltcGxlIGFuZCBjb21wbGV4IHNlbGVjdG9yc1xcblxcdHJldHVybiBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzLCBub3QgKTtcXG59XFxuXFxualF1ZXJ5LmZpbHRlciA9IGZ1bmN0aW9uKCBleHByLCBlbGVtcywgbm90ICkge1xcblxcdHZhciBlbGVtID0gZWxlbXNbIDAgXTtcXG5cXG5cXHRpZiAoIG5vdCApIHtcXG5cXHRcXHRleHByID0gXFxcIjpub3QoXFxcIiArIGV4cHIgKyBcXFwiKVxcXCI7XFxuXFx0fVxcblxcblxcdGlmICggZWxlbXMubGVuZ3RoID09PSAxICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XFxuXFx0XFx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZWxlbSwgZXhwciApID8gWyBlbGVtIF0gOiBbXTtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXMoIGV4cHIsIGpRdWVyeS5ncmVwKCBlbGVtcywgZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XFxuXFx0fSApICk7XFxufTtcXG5cXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XFxuXFx0ZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xcblxcdFxcdHZhciBpLCByZXQsXFxuXFx0XFx0XFx0bGVuID0gdGhpcy5sZW5ndGgsXFxuXFx0XFx0XFx0c2VsZiA9IHRoaXM7XFxuXFxuXFx0XFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFxcXCJzdHJpbmdcXFwiICkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlciggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9ICkgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0ID0gdGhpcy5wdXNoU3RhY2soIFtdICk7XFxuXFxuXFx0XFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcXG5cXHRcXHRcXHRqUXVlcnkuZmluZCggc2VsZWN0b3IsIHNlbGZbIGkgXSwgcmV0ICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBsZW4gPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIHJldCApIDogcmV0O1xcblxcdH0sXFxuXFx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSApICk7XFxuXFx0fSxcXG5cXHRub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIHRydWUgKSApO1xcblxcdH0sXFxuXFx0aXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcXG5cXHRcXHRyZXR1cm4gISF3aW5ub3coXFxuXFx0XFx0XFx0dGhpcyxcXG5cXG5cXHRcXHRcXHQvLyBJZiB0aGlzIGlzIGEgcG9zaXRpb25hbC9yZWxhdGl2ZSBzZWxlY3RvciwgY2hlY2sgbWVtYmVyc2hpcCBpbiB0aGUgcmV0dXJuZWQgc2V0XFxuXFx0XFx0XFx0Ly8gc28gJChcXFwicDpmaXJzdFxcXCIpLmlzKFxcXCJwOmxhc3RcXFwiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gXFxcInBcXFwiLlxcblxcdFxcdFxcdHR5cGVvZiBzZWxlY3RvciA9PT0gXFxcInN0cmluZ1xcXCIgJiYgcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApID9cXG5cXHRcXHRcXHRcXHRqUXVlcnkoIHNlbGVjdG9yICkgOlxcblxcdFxcdFxcdFxcdHNlbGVjdG9yIHx8IFtdLFxcblxcdFxcdFxcdGZhbHNlXFxuXFx0XFx0KS5sZW5ndGg7XFxuXFx0fVxcbn0gKTtcXG5cXG5cXG4vLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxcblxcblxcbi8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxcbnZhciByb290alF1ZXJ5LFxcblxcblxcdC8vIEEgc2ltcGxlIHdheSB0byBjaGVjayBmb3IgSFRNTCBzdHJpbmdzXFxuXFx0Ly8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKCM5NTIxKVxcblxcdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxcblxcdC8vIFNob3J0Y3V0IHNpbXBsZSAjaWQgY2FzZSBmb3Igc3BlZWRcXG5cXHRycXVpY2tFeHByID0gL14oPzpcXFxccyooPFtcXFxcd1xcXFxXXSs+KVtePl0qfCMoW1xcXFx3LV0rKSkkLyxcXG5cXG5cXHRpbml0ID0galF1ZXJ5LmZuLmluaXQgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJvb3QgKSB7XFxuXFx0XFx0dmFyIG1hdGNoLCBlbGVtO1xcblxcblxcdFxcdC8vIEhBTkRMRTogJChcXFwiXFxcIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcXG5cXHRcXHRpZiAoICFzZWxlY3RvciApIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gTWV0aG9kIGluaXQoKSBhY2NlcHRzIGFuIGFsdGVybmF0ZSByb290alF1ZXJ5XFxuXFx0XFx0Ly8gc28gbWlncmF0ZSBjYW4gc3VwcG9ydCBqUXVlcnkuc3ViIChnaC0yMTAxKVxcblxcdFxcdHJvb3QgPSByb290IHx8IHJvb3RqUXVlcnk7XFxuXFxuXFx0XFx0Ly8gSGFuZGxlIEhUTUwgc3RyaW5nc1xcblxcdFxcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcXFwic3RyaW5nXFxcIiApIHtcXG5cXHRcXHRcXHRpZiAoIHNlbGVjdG9yWyAwIF0gPT09IFxcXCI8XFxcIiAmJlxcblxcdFxcdFxcdFxcdHNlbGVjdG9yWyBzZWxlY3Rvci5sZW5ndGggLSAxIF0gPT09IFxcXCI+XFxcIiAmJlxcblxcdFxcdFxcdFxcdHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xcblxcblxcdFxcdFxcdFxcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXFxuXFx0XFx0XFx0XFx0bWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxcblxcdFxcdFxcdGlmICggbWF0Y2ggJiYgKCBtYXRjaFsgMSBdIHx8ICFjb250ZXh0ICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXFxuXFx0XFx0XFx0XFx0aWYgKCBtYXRjaFsgMSBdICkge1xcblxcdFxcdFxcdFxcdFxcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFsgMCBdIDogY29udGV4dDtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBPcHRpb24gdG8gcnVuIHNjcmlwdHMgaXMgdHJ1ZSBmb3IgYmFjay1jb21wYXRcXG5cXHRcXHRcXHRcXHRcXHQvLyBJbnRlbnRpb25hbGx5IGxldCB0aGUgZXJyb3IgYmUgdGhyb3duIGlmIHBhcnNlSFRNTCBpcyBub3QgcHJlc2VudFxcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS5tZXJnZSggdGhpcywgalF1ZXJ5LnBhcnNlSFRNTChcXG5cXHRcXHRcXHRcXHRcXHRcXHRtYXRjaFsgMSBdLFxcblxcdFxcdFxcdFxcdFxcdFxcdGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXFxuXFx0XFx0XFx0XFx0XFx0XFx0dHJ1ZVxcblxcdFxcdFxcdFxcdFxcdCkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWyAxIF0gKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIG1hdGNoIGluIGNvbnRleHQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmF0dHIoIG1hdGNoLCBjb250ZXh0WyBtYXRjaCBdICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSEFORExFOiAkKCNpZClcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbIDIgXSApO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggZWxlbSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBJbmplY3QgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW50byB0aGUgalF1ZXJ5IG9iamVjdFxcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXNbIDAgXSA9IGVsZW07XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5sZW5ndGggPSAxO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gSEFORExFOiAkKGV4cHIsICQoLi4uKSlcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gKCBjb250ZXh0IHx8IHJvb3QgKS5maW5kKCBzZWxlY3RvciApO1xcblxcblxcdFxcdFxcdC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxcblxcdFxcdFxcdC8vICh3aGljaCBpcyBqdXN0IGVxdWl2YWxlbnQgdG86ICQoY29udGV4dCkuZmluZChleHByKVxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHQvLyBIQU5ETEU6ICQoRE9NRWxlbWVudClcXG5cXHRcXHR9IGVsc2UgaWYgKCBzZWxlY3Rvci5ub2RlVHlwZSApIHtcXG5cXHRcXHRcXHR0aGlzWyAwIF0gPSBzZWxlY3RvcjtcXG5cXHRcXHRcXHR0aGlzLmxlbmd0aCA9IDE7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0Ly8gSEFORExFOiAkKGZ1bmN0aW9uKVxcblxcdFxcdC8vIFNob3J0Y3V0IGZvciBkb2N1bWVudCByZWFkeVxcblxcdFxcdH0gZWxzZSBpZiAoIGlzRnVuY3Rpb24oIHNlbGVjdG9yICkgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHJvb3QucmVhZHkgIT09IHVuZGVmaW5lZCA/XFxuXFx0XFx0XFx0XFx0cm9vdC5yZWFkeSggc2VsZWN0b3IgKSA6XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRXhlY3V0ZSBpbW1lZGlhdGVseSBpZiByZWFkeSBpcyBub3QgcHJlc2VudFxcblxcdFxcdFxcdFxcdHNlbGVjdG9yKCBqUXVlcnkgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIGpRdWVyeS5tYWtlQXJyYXkoIHNlbGVjdG9yLCB0aGlzICk7XFxuXFx0fTtcXG5cXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXFxuaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XFxuXFxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxcbnJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XFxuXFxuXFxudmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxcblxcblxcdC8vIE1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XFxuXFx0Z3VhcmFudGVlZFVuaXF1ZSA9IHtcXG5cXHRcXHRjaGlsZHJlbjogdHJ1ZSxcXG5cXHRcXHRjb250ZW50czogdHJ1ZSxcXG5cXHRcXHRuZXh0OiB0cnVlLFxcblxcdFxcdHByZXY6IHRydWVcXG5cXHR9O1xcblxcbmpRdWVyeS5mbi5leHRlbmQoIHtcXG5cXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XFxuXFx0XFx0dmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxcblxcdFxcdFxcdGwgPSB0YXJnZXRzLmxlbmd0aDtcXG5cXG5cXHRcXHRyZXR1cm4gdGhpcy5maWx0ZXIoIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHZhciBpID0gMDtcXG5cXHRcXHRcXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHRoaXMsIHRhcmdldHNbIGkgXSApICkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSApO1xcblxcdH0sXFxuXFxuXFx0Y2xvc2VzdDogZnVuY3Rpb24oIHNlbGVjdG9ycywgY29udGV4dCApIHtcXG5cXHRcXHR2YXIgY3VyLFxcblxcdFxcdFxcdGkgPSAwLFxcblxcdFxcdFxcdGwgPSB0aGlzLmxlbmd0aCxcXG5cXHRcXHRcXHRtYXRjaGVkID0gW10sXFxuXFx0XFx0XFx0dGFyZ2V0cyA9IHR5cGVvZiBzZWxlY3RvcnMgIT09IFxcXCJzdHJpbmdcXFwiICYmIGpRdWVyeSggc2VsZWN0b3JzICk7XFxuXFxuXFx0XFx0Ly8gUG9zaXRpb25hbCBzZWxlY3RvcnMgbmV2ZXIgbWF0Y2gsIHNpbmNlIHRoZXJlJ3Mgbm8gX3NlbGVjdGlvbl8gY29udGV4dFxcblxcdFxcdGlmICggIXJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3JzICkgKSB7XFxuXFx0XFx0XFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xcblxcdFxcdFxcdFxcdGZvciAoIGN1ciA9IHRoaXNbIGkgXTsgY3VyICYmIGN1ciAhPT0gY29udGV4dDsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAoIHRhcmdldHMgP1xcblxcdFxcdFxcdFxcdFxcdFxcdHRhcmdldHMuaW5kZXgoIGN1ciApID4gLTEgOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxcblxcdFxcdFxcdFxcdFxcdFxcdGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggY3VyLCBzZWxlY3RvcnMgKSApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdG1hdGNoZWQucHVzaCggY3VyICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcXG5cXHR9LFxcblxcblxcdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW4gdGhlIHNldFxcblxcdGluZGV4OiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXG5cXHRcXHQvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxcblxcdFxcdGlmICggIWVsZW0gKSB7XFxuXFx0XFx0XFx0cmV0dXJuICggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBJbmRleCBpbiBzZWxlY3RvclxcblxcdFxcdGlmICggdHlwZW9mIGVsZW0gPT09IFxcXCJzdHJpbmdcXFwiICkge1xcblxcdFxcdFxcdHJldHVybiBpbmRleE9mLmNhbGwoIGpRdWVyeSggZWxlbSApLCB0aGlzWyAwIF0gKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XFxuXFx0XFx0cmV0dXJuIGluZGV4T2YuY2FsbCggdGhpcyxcXG5cXG5cXHRcXHRcXHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcXG5cXHRcXHRcXHRlbGVtLmpxdWVyeSA/IGVsZW1bIDAgXSA6IGVsZW1cXG5cXHRcXHQpO1xcblxcdH0sXFxuXFxuXFx0YWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKFxcblxcdFxcdFxcdGpRdWVyeS51bmlxdWVTb3J0KFxcblxcdFxcdFxcdFxcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcXG5cXHRcXHRcXHQpXFxuXFx0XFx0KTtcXG5cXHR9LFxcblxcblxcdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xcblxcdFxcdFxcdHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoIHNlbGVjdG9yIClcXG5cXHRcXHQpO1xcblxcdH1cXG59ICk7XFxuXFxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XFxuXFx0d2hpbGUgKCAoIGN1ciA9IGN1clsgZGlyIF0gKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxcblxcdHJldHVybiBjdXI7XFxufVxcblxcbmpRdWVyeS5lYWNoKCB7XFxuXFx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xcblxcdFxcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XFxuXFx0fSxcXG5cXHRwYXJlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRyZXR1cm4gZGlyKCBlbGVtLCBcXFwicGFyZW50Tm9kZVxcXCIgKTtcXG5cXHR9LFxcblxcdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xcblxcdFxcdHJldHVybiBkaXIoIGVsZW0sIFxcXCJwYXJlbnROb2RlXFxcIiwgdW50aWwgKTtcXG5cXHR9LFxcblxcdG5leHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcXFwibmV4dFNpYmxpbmdcXFwiICk7XFxuXFx0fSxcXG5cXHRwcmV2OiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRyZXR1cm4gc2libGluZyggZWxlbSwgXFxcInByZXZpb3VzU2libGluZ1xcXCIgKTtcXG5cXHR9LFxcblxcdG5leHRBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdHJldHVybiBkaXIoIGVsZW0sIFxcXCJuZXh0U2libGluZ1xcXCIgKTtcXG5cXHR9LFxcblxcdHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdHJldHVybiBkaXIoIGVsZW0sIFxcXCJwcmV2aW91c1NpYmxpbmdcXFwiICk7XFxuXFx0fSxcXG5cXHRuZXh0VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcXG5cXHRcXHRyZXR1cm4gZGlyKCBlbGVtLCBcXFwibmV4dFNpYmxpbmdcXFwiLCB1bnRpbCApO1xcblxcdH0sXFxuXFx0cHJldlVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XFxuXFx0XFx0cmV0dXJuIGRpciggZWxlbSwgXFxcInByZXZpb3VzU2libGluZ1xcXCIsIHVudGlsICk7XFxuXFx0fSxcXG5cXHRzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0cmV0dXJuIHNpYmxpbmdzKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcXG5cXHR9LFxcblxcdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRyZXR1cm4gc2libGluZ3MoIGVsZW0uZmlyc3RDaGlsZCApO1xcblxcdH0sXFxuXFx0Y29udGVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xcbiAgICAgICAgaWYgKCBub2RlTmFtZSggZWxlbSwgXFxcImlmcmFtZVxcXCIgKSApIHtcXG4gICAgICAgICAgICByZXR1cm4gZWxlbS5jb250ZW50RG9jdW1lbnQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seSwgaU9TIDcgb25seSwgQW5kcm9pZCBCcm93c2VyIDw9NC4zIG9ubHlcXG4gICAgICAgIC8vIFRyZWF0IHRoZSB0ZW1wbGF0ZSBlbGVtZW50IGFzIGEgcmVndWxhciBvbmUgaW4gYnJvd3NlcnMgdGhhdFxcbiAgICAgICAgLy8gZG9uJ3Qgc3VwcG9ydCBpdC5cXG4gICAgICAgIGlmICggbm9kZU5hbWUoIGVsZW0sIFxcXCJ0ZW1wbGF0ZVxcXCIgKSApIHtcXG4gICAgICAgICAgICBlbGVtID0gZWxlbS5jb250ZW50IHx8IGVsZW07XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgZWxlbS5jaGlsZE5vZGVzICk7XFxuXFx0fVxcbn0sIGZ1bmN0aW9uKCBuYW1lLCBmbiApIHtcXG5cXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XFxuXFx0XFx0dmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcXG5cXG5cXHRcXHRpZiAoIG5hbWUuc2xpY2UoIC01ICkgIT09IFxcXCJVbnRpbFxcXCIgKSB7XFxuXFx0XFx0XFx0c2VsZWN0b3IgPSB1bnRpbDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFxcXCJzdHJpbmdcXFwiICkge1xcblxcdFxcdFxcdG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgbWF0Y2hlZCApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIHRoaXMubGVuZ3RoID4gMSApIHtcXG5cXG5cXHRcXHRcXHQvLyBSZW1vdmUgZHVwbGljYXRlc1xcblxcdFxcdFxcdGlmICggIWd1YXJhbnRlZWRVbmlxdWVbIG5hbWUgXSApIHtcXG5cXHRcXHRcXHRcXHRqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xcblxcdFxcdFxcdGlmICggcnBhcmVudHNwcmV2LnRlc3QoIG5hbWUgKSApIHtcXG5cXHRcXHRcXHRcXHRtYXRjaGVkLnJldmVyc2UoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZCApO1xcblxcdH07XFxufSApO1xcbnZhciBybm90aHRtbHdoaXRlID0gKCAvW15cXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdKy9nICk7XFxuXFxuXFxuXFxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXNcXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xcblxcdHZhciBvYmplY3QgPSB7fTtcXG5cXHRqUXVlcnkuZWFjaCggb3B0aW9ucy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdLCBmdW5jdGlvbiggXywgZmxhZyApIHtcXG5cXHRcXHRvYmplY3RbIGZsYWcgXSA9IHRydWU7XFxuXFx0fSApO1xcblxcdHJldHVybiBvYmplY3Q7XFxufVxcblxcbi8qXFxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XFxuICpcXG4gKlxcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcXG4gKlxcdFxcdFxcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcXG4gKlxcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXFxuICogXFxcImZpcmVkXFxcIiBtdWx0aXBsZSB0aW1lcy5cXG4gKlxcbiAqIFBvc3NpYmxlIG9wdGlvbnM6XFxuICpcXG4gKlxcdG9uY2U6XFx0XFx0XFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxcbiAqXFxuICpcXHRtZW1vcnk6XFx0XFx0XFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxcbiAqXFx0XFx0XFx0XFx0XFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXFxcIm1lbW9yaXplZFxcXCJcXG4gKlxcdFxcdFxcdFxcdFxcdHZhbHVlcyAobGlrZSBhIERlZmVycmVkKVxcbiAqXFxuICpcXHR1bmlxdWU6XFx0XFx0XFx0d2lsbCBlbnN1cmUgYSBjYWxsYmFjayBjYW4gb25seSBiZSBhZGRlZCBvbmNlIChubyBkdXBsaWNhdGUgaW4gdGhlIGxpc3QpXFxuICpcXG4gKlxcdHN0b3BPbkZhbHNlOlxcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxcbiAqXFxuICovXFxualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xcblxcblxcdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcXG5cXHQvLyAod2UgY2hlY2sgaW4gY2FjaGUgZmlyc3QpXFxuXFx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcXFwic3RyaW5nXFxcIiA/XFxuXFx0XFx0Y3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIDpcXG5cXHRcXHRqUXVlcnkuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xcblxcblxcdHZhciAvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXFxuXFx0XFx0ZmlyaW5nLFxcblxcblxcdFxcdC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXFxuXFx0XFx0bWVtb3J5LFxcblxcblxcdFxcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXFxuXFx0XFx0ZmlyZWQsXFxuXFxuXFx0XFx0Ly8gRmxhZyB0byBwcmV2ZW50IGZpcmluZ1xcblxcdFxcdGxvY2tlZCxcXG5cXG5cXHRcXHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxcblxcdFxcdGxpc3QgPSBbXSxcXG5cXG5cXHRcXHQvLyBRdWV1ZSBvZiBleGVjdXRpb24gZGF0YSBmb3IgcmVwZWF0YWJsZSBsaXN0c1xcblxcdFxcdHF1ZXVlID0gW10sXFxuXFxuXFx0XFx0Ly8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgYWRkL3JlbW92ZSBhcyBuZWVkZWQpXFxuXFx0XFx0ZmlyaW5nSW5kZXggPSAtMSxcXG5cXG5cXHRcXHQvLyBGaXJlIGNhbGxiYWNrc1xcblxcdFxcdGZpcmUgPSBmdW5jdGlvbigpIHtcXG5cXG5cXHRcXHRcXHQvLyBFbmZvcmNlIHNpbmdsZS1maXJpbmdcXG5cXHRcXHRcXHRsb2NrZWQgPSBsb2NrZWQgfHwgb3B0aW9ucy5vbmNlO1xcblxcblxcdFxcdFxcdC8vIEV4ZWN1dGUgY2FsbGJhY2tzIGZvciBhbGwgcGVuZGluZyBleGVjdXRpb25zLFxcblxcdFxcdFxcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcXG5cXHRcXHRcXHRmaXJlZCA9IGZpcmluZyA9IHRydWU7XFxuXFx0XFx0XFx0Zm9yICggOyBxdWV1ZS5sZW5ndGg7IGZpcmluZ0luZGV4ID0gLTEgKSB7XFxuXFx0XFx0XFx0XFx0bWVtb3J5ID0gcXVldWUuc2hpZnQoKTtcXG5cXHRcXHRcXHRcXHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBSdW4gY2FsbGJhY2sgYW5kIGNoZWNrIGZvciBlYXJseSB0ZXJtaW5hdGlvblxcblxcdFxcdFxcdFxcdFxcdGlmICggbGlzdFsgZmlyaW5nSW5kZXggXS5hcHBseSggbWVtb3J5WyAwIF0sIG1lbW9yeVsgMSBdICkgPT09IGZhbHNlICYmXFxuXFx0XFx0XFx0XFx0XFx0XFx0b3B0aW9ucy5zdG9wT25GYWxzZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBKdW1wIHRvIGVuZCBhbmQgZm9yZ2V0IHRoZSBkYXRhIHNvIC5hZGQgZG9lc24ndCByZS1maXJlXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtZW1vcnkgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBGb3JnZXQgdGhlIGRhdGEgaWYgd2UncmUgZG9uZSB3aXRoIGl0XFxuXFx0XFx0XFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XFxuXFx0XFx0XFx0XFx0bWVtb3J5ID0gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGZpcmluZyA9IGZhbHNlO1xcblxcblxcdFxcdFxcdC8vIENsZWFuIHVwIGlmIHdlJ3JlIGRvbmUgZmlyaW5nIGZvciBnb29kXFxuXFx0XFx0XFx0aWYgKCBsb2NrZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gS2VlcCBhbiBlbXB0eSBsaXN0IGlmIHdlIGhhdmUgZGF0YSBmb3IgZnV0dXJlIGFkZCBjYWxsc1xcblxcdFxcdFxcdFxcdGlmICggbWVtb3J5ICkge1xcblxcdFxcdFxcdFxcdFxcdGxpc3QgPSBbXTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBPdGhlcndpc2UsIHRoaXMgb2JqZWN0IGlzIHNwZW50XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRsaXN0ID0gXFxcIlxcXCI7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIEFjdHVhbCBDYWxsYmFja3Mgb2JqZWN0XFxuXFx0XFx0c2VsZiA9IHtcXG5cXG5cXHRcXHRcXHQvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XFxuXFx0XFx0XFx0YWRkOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRpZiAoIGxpc3QgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gSWYgd2UgaGF2ZSBtZW1vcnkgZnJvbSBhIHBhc3QgcnVuLCB3ZSBzaG91bGQgZmlyZSBhZnRlciBhZGRpbmdcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xcblxcdFxcdFxcdFxcdFxcdFxcdHF1ZXVlLnB1c2goIG1lbW9yeSApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQoIGZ1bmN0aW9uIGFkZCggYXJncyApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGlzRnVuY3Rpb24oIGFyZyApICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggIW9wdGlvbnMudW5pcXVlIHx8ICFzZWxmLmhhcyggYXJnICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bGlzdC5wdXNoKCBhcmcgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmICggYXJnICYmIGFyZy5sZW5ndGggJiYgdG9UeXBlKCBhcmcgKSAhPT0gXFxcInN0cmluZ1xcXCIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gSW5zcGVjdCByZWN1cnNpdmVseVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGFkZCggYXJnICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH0gKTtcXG5cXHRcXHRcXHRcXHRcXHR9ICkoIGFyZ3VtZW50cyApO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmlyZSgpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHQvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XFxuXFx0XFx0XFx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRqUXVlcnkuZWFjaCggYXJndW1lbnRzLCBmdW5jdGlvbiggXywgYXJnICkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBpbmRleDtcXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAoICggaW5kZXggPSBqUXVlcnkuaW5BcnJheSggYXJnLCBsaXN0LCBpbmRleCApICkgPiAtMSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRsaXN0LnNwbGljZSggaW5kZXgsIDEgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBIYW5kbGUgZmlyaW5nIGluZGV4ZXNcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGluZGV4IDw9IGZpcmluZ0luZGV4ICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZpcmluZ0luZGV4LS07XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9ICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxcblxcdFxcdFxcdC8vIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCByZXR1cm4gd2hldGhlciBvciBub3QgbGlzdCBoYXMgY2FsbGJhY2tzIGF0dGFjaGVkLlxcblxcdFxcdFxcdGhhczogZnVuY3Rpb24oIGZuICkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmbiA/XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmluQXJyYXkoIGZuLCBsaXN0ICkgPiAtMSA6XFxuXFx0XFx0XFx0XFx0XFx0bGlzdC5sZW5ndGggPiAwO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0Ly8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdFxcblxcdFxcdFxcdGVtcHR5OiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRpZiAoIGxpc3QgKSB7XFxuXFx0XFx0XFx0XFx0XFx0bGlzdCA9IFtdO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdC8vIERpc2FibGUgLmZpcmUgYW5kIC5hZGRcXG5cXHRcXHRcXHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcXG5cXHRcXHRcXHQvLyBDbGVhciBhbGwgY2FsbGJhY2tzIGFuZCB2YWx1ZXNcXG5cXHRcXHRcXHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xcblxcdFxcdFxcdFxcdGxpc3QgPSBtZW1vcnkgPSBcXFwiXFxcIjtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdGRpc2FibGVkOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gIWxpc3Q7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHQvLyBEaXNhYmxlIC5maXJlXFxuXFx0XFx0XFx0Ly8gQWxzbyBkaXNhYmxlIC5hZGQgdW5sZXNzIHdlIGhhdmUgbWVtb3J5IChzaW5jZSBpdCB3b3VsZCBoYXZlIG5vIGVmZmVjdClcXG5cXHRcXHRcXHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXFxuXFx0XFx0XFx0bG9jazogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0bG9ja2VkID0gcXVldWUgPSBbXTtcXG5cXHRcXHRcXHRcXHRpZiAoICFtZW1vcnkgJiYgIWZpcmluZyApIHtcXG5cXHRcXHRcXHRcXHRcXHRsaXN0ID0gbWVtb3J5ID0gXFxcIlxcXCI7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gISFsb2NrZWQ7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHQvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXFxuXFx0XFx0XFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xcblxcdFxcdFxcdFxcdGlmICggIWxvY2tlZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRhcmdzID0gYXJncyB8fCBbXTtcXG5cXHRcXHRcXHRcXHRcXHRhcmdzID0gWyBjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJncyBdO1xcblxcdFxcdFxcdFxcdFxcdHF1ZXVlLnB1c2goIGFyZ3MgKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoICFmaXJpbmcgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmlyZSgpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHQvLyBDYWxsIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xcblxcdFxcdFxcdGZpcmU6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdHNlbGYuZmlyZVdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXFxuXFx0XFx0XFx0ZmlyZWQ6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdHJldHVybiAhIWZpcmVkO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcblxcdHJldHVybiBzZWxmO1xcbn07XFxuXFxuXFxuZnVuY3Rpb24gSWRlbnRpdHkoIHYgKSB7XFxuXFx0cmV0dXJuIHY7XFxufVxcbmZ1bmN0aW9uIFRocm93ZXIoIGV4ICkge1xcblxcdHRocm93IGV4O1xcbn1cXG5cXG5mdW5jdGlvbiBhZG9wdFZhbHVlKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0LCBub1ZhbHVlICkge1xcblxcdHZhciBtZXRob2Q7XFxuXFxuXFx0dHJ5IHtcXG5cXG5cXHRcXHQvLyBDaGVjayBmb3IgcHJvbWlzZSBhc3BlY3QgZmlyc3QgdG8gcHJpdmlsZWdlIHN5bmNocm9ub3VzIGJlaGF2aW9yXFxuXFx0XFx0aWYgKCB2YWx1ZSAmJiBpc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnByb21pc2UgKSApICkge1xcblxcdFxcdFxcdG1ldGhvZC5jYWxsKCB2YWx1ZSApLmRvbmUoIHJlc29sdmUgKS5mYWlsKCByZWplY3QgKTtcXG5cXG5cXHRcXHQvLyBPdGhlciB0aGVuYWJsZXNcXG5cXHRcXHR9IGVsc2UgaWYgKCB2YWx1ZSAmJiBpc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnRoZW4gKSApICkge1xcblxcdFxcdFxcdG1ldGhvZC5jYWxsKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0ICk7XFxuXFxuXFx0XFx0Ly8gT3RoZXIgbm9uLXRoZW5hYmxlc1xcblxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0Ly8gQ29udHJvbCBgcmVzb2x2ZWAgYXJndW1lbnRzIGJ5IGxldHRpbmcgQXJyYXkjc2xpY2UgY2FzdCBib29sZWFuIGBub1ZhbHVlYCB0byBpbnRlZ2VyOlxcblxcdFxcdFxcdC8vICogZmFsc2U6IFsgdmFsdWUgXS5zbGljZSggMCApID0+IHJlc29sdmUoIHZhbHVlIClcXG5cXHRcXHRcXHQvLyAqIHRydWU6IFsgdmFsdWUgXS5zbGljZSggMSApID0+IHJlc29sdmUoKVxcblxcdFxcdFxcdHJlc29sdmUuYXBwbHkoIHVuZGVmaW5lZCwgWyB2YWx1ZSBdLnNsaWNlKCBub1ZhbHVlICkgKTtcXG5cXHRcXHR9XFxuXFxuXFx0Ly8gRm9yIFByb21pc2VzL0ErLCBjb252ZXJ0IGV4Y2VwdGlvbnMgaW50byByZWplY3Rpb25zXFxuXFx0Ly8gU2luY2UgalF1ZXJ5LndoZW4gZG9lc24ndCB1bndyYXAgdGhlbmFibGVzLCB3ZSBjYW4gc2tpcCB0aGUgZXh0cmEgY2hlY2tzIGFwcGVhcmluZyBpblxcblxcdC8vIERlZmVycmVkI3RoZW4gdG8gY29uZGl0aW9uYWxseSBzdXBwcmVzcyByZWplY3Rpb24uXFxuXFx0fSBjYXRjaCAoIHZhbHVlICkge1xcblxcblxcdFxcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcXG5cXHRcXHQvLyBTdHJpY3QgbW9kZSBmdW5jdGlvbnMgaW52b2tlZCB3aXRob3V0IC5jYWxsLy5hcHBseSBnZXQgZ2xvYmFsLW9iamVjdCBjb250ZXh0XFxuXFx0XFx0cmVqZWN0LmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXSApO1xcblxcdH1cXG59XFxuXFxualF1ZXJ5LmV4dGVuZCgge1xcblxcblxcdERlZmVycmVkOiBmdW5jdGlvbiggZnVuYyApIHtcXG5cXHRcXHR2YXIgdHVwbGVzID0gW1xcblxcblxcdFxcdFxcdFxcdC8vIGFjdGlvbiwgYWRkIGxpc3RlbmVyLCBjYWxsYmFja3MsXFxuXFx0XFx0XFx0XFx0Ly8gLi4uIC50aGVuIGhhbmRsZXJzLCBhcmd1bWVudCBpbmRleCwgW2ZpbmFsIHN0YXRlXVxcblxcdFxcdFxcdFxcdFsgXFxcIm5vdGlmeVxcXCIsIFxcXCJwcm9ncmVzc1xcXCIsIGpRdWVyeS5DYWxsYmFja3MoIFxcXCJtZW1vcnlcXFwiICksXFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LkNhbGxiYWNrcyggXFxcIm1lbW9yeVxcXCIgKSwgMiBdLFxcblxcdFxcdFxcdFxcdFsgXFxcInJlc29sdmVcXFwiLCBcXFwiZG9uZVxcXCIsIGpRdWVyeS5DYWxsYmFja3MoIFxcXCJvbmNlIG1lbW9yeVxcXCIgKSxcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuQ2FsbGJhY2tzKCBcXFwib25jZSBtZW1vcnlcXFwiICksIDAsIFxcXCJyZXNvbHZlZFxcXCIgXSxcXG5cXHRcXHRcXHRcXHRbIFxcXCJyZWplY3RcXFwiLCBcXFwiZmFpbFxcXCIsIGpRdWVyeS5DYWxsYmFja3MoIFxcXCJvbmNlIG1lbW9yeVxcXCIgKSxcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuQ2FsbGJhY2tzKCBcXFwib25jZSBtZW1vcnlcXFwiICksIDEsIFxcXCJyZWplY3RlZFxcXCIgXVxcblxcdFxcdFxcdF0sXFxuXFx0XFx0XFx0c3RhdGUgPSBcXFwicGVuZGluZ1xcXCIsXFxuXFx0XFx0XFx0cHJvbWlzZSA9IHtcXG5cXHRcXHRcXHRcXHRzdGF0ZTogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHN0YXRlO1xcblxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XFx0YWx3YXlzOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHRkZWZlcnJlZC5kb25lKCBhcmd1bWVudHMgKS5mYWlsKCBhcmd1bWVudHMgKTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdFxcXCJjYXRjaFxcXCI6IGZ1bmN0aW9uKCBmbiApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gcHJvbWlzZS50aGVuKCBudWxsLCBmbiApO1xcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0Ly8gS2VlcCBwaXBlIGZvciBiYWNrLWNvbXBhdFxcblxcdFxcdFxcdFxcdHBpcGU6IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgZm5zID0gYXJndW1lbnRzO1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gTWFwIHR1cGxlcyAocHJvZ3Jlc3MsIGRvbmUsIGZhaWwpIHRvIGFyZ3VtZW50cyAoZG9uZSwgZmFpbCwgcHJvZ3Jlc3MpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGZuID0gaXNGdW5jdGlvbiggZm5zWyB0dXBsZVsgNCBdIF0gKSAmJiBmbnNbIHR1cGxlWyA0IF0gXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBkZWZlcnJlZC5wcm9ncmVzcyhmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5ub3RpZnkgfSlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBkZWZlcnJlZC5kb25lKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlc29sdmUgfSlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBkZWZlcnJlZC5mYWlsKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlamVjdCB9KVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRlZmVycmVkWyB0dXBsZVsgMSBdIF0oIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciByZXR1cm5lZCA9IGZuICYmIGZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHJldHVybmVkICYmIGlzRnVuY3Rpb24oIHJldHVybmVkLnByb21pc2UgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm5lZC5wcm9taXNlKClcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQucHJvZ3Jlc3MoIG5ld0RlZmVyLm5vdGlmeSApXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0LmRvbmUoIG5ld0RlZmVyLnJlc29sdmUgKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5ld0RlZmVyWyB0dXBsZVsgMCBdICsgXFxcIldpdGhcXFwiIF0oXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50c1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9ICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm5zID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHR9ICkucHJvbWlzZSgpO1xcblxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XFx0dGhlbjogZnVuY3Rpb24oIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzICkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBtYXhEZXB0aCA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0ZnVuY3Rpb24gcmVzb2x2ZSggZGVwdGgsIGRlZmVycmVkLCBoYW5kbGVyLCBzcGVjaWFsICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgdGhhdCA9IHRoaXMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YXJncyA9IGFyZ3VtZW50cyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRtaWdodFRocm93ID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIHJldHVybmVkLCB0aGVuO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4zXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBJZ25vcmUgZG91YmxlLXJlc29sdXRpb24gYXR0ZW1wdHNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGRlcHRoIDwgbWF4RGVwdGggKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm5lZCA9IGhhbmRsZXIuYXBwbHkoIHRoYXQsIGFyZ3MgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4xXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNDhcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHJldHVybmVkID09PSBkZWZlcnJlZC5wcm9taXNlKCkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhyb3cgbmV3IFR5cGVFcnJvciggXFxcIlRoZW5hYmxlIHNlbGYtcmVzb2x1dGlvblxcXCIgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbnMgMi4zLjMuMSwgMy41XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC03NVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFJldHJpZXZlIGB0aGVuYCBvbmx5IG9uY2VcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGVuID0gcmV0dXJuZWQgJiZcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy40XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBPbmx5IGNoZWNrIG9iamVjdHMgYW5kIGZ1bmN0aW9ucyBmb3IgdGhlbmFiaWxpdHlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQoIHR5cGVvZiByZXR1cm5lZCA9PT0gXFxcIm9iamVjdFxcXCIgfHxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0eXBlb2YgcmV0dXJuZWQgPT09IFxcXCJmdW5jdGlvblxcXCIgKSAmJlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybmVkLnRoZW47XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gSGFuZGxlIGEgcmV0dXJuZWQgdGhlbmFibGVcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGlzRnVuY3Rpb24oIHRoZW4gKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBTcGVjaWFsIHByb2Nlc3NvcnMgKG5vdGlmeSkganVzdCB3YWl0IGZvciByZXNvbHV0aW9uXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBzcGVjaWFsICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoZW4uY2FsbChcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm5lZCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsIClcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIE5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBhbHNvIGhvb2sgaW50byBwcm9ncmVzc1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gLi4uYW5kIGRpc3JlZ2FyZCBvbGRlciByZXNvbHV0aW9uIHZhbHVlc1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG1heERlcHRoKys7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhlbi5jYWxsKFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybmVkLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRlZmVycmVkLm5vdGlmeVdpdGggKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIEhhbmRsZSBhbGwgb3RoZXIgcmV0dXJuZWQgdmFsdWVzXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBoYW5kbGVyICE9PSBJZGVudGl0eSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGF0ID0gdW5kZWZpbmVkO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGFyZ3MgPSBbIHJldHVybmVkIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFByb2Nlc3MgdGhlIHZhbHVlKHMpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gRGVmYXVsdCBwcm9jZXNzIGlzIHJlc29sdmVcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQoIHNwZWNpYWwgfHwgZGVmZXJyZWQucmVzb2x2ZVdpdGggKSggdGhhdCwgYXJncyApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIE9ubHkgbm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGNhdGNoIGFuZCByZWplY3QgZXhjZXB0aW9uc1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHByb2Nlc3MgPSBzcGVjaWFsID9cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRtaWdodFRocm93IDpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0cnkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG1pZ2h0VGhyb3coKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGNhdGNoICggZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rKCBlLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHByb2Nlc3Muc3RhY2tUcmFjZSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuNC4xXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjFcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBJZ25vcmUgcG9zdC1yZXNvbHV0aW9uIGV4Y2VwdGlvbnNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGRlcHRoICsgMSA+PSBtYXhEZXB0aCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBoYW5kbGVyICE9PSBUaHJvd2VyICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoYXQgPSB1bmRlZmluZWQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YXJncyA9IFsgZSBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkZWZlcnJlZC5yZWplY3RXaXRoKCB0aGF0LCBhcmdzICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4xXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTdcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBSZS1yZXNvbHZlIHByb21pc2VzIGltbWVkaWF0ZWx5IHRvIGRvZGdlIGZhbHNlIHJlamVjdGlvbiBmcm9tXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gc3Vic2VxdWVudCBlcnJvcnNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGRlcHRoICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHByb2Nlc3MoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIENhbGwgYW4gb3B0aW9uYWwgaG9vayB0byByZWNvcmQgdGhlIHN0YWNrLCBpbiBjYXNlIG9mIGV4Y2VwdGlvblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIHNpbmNlIGl0J3Mgb3RoZXJ3aXNlIGxvc3Qgd2hlbiBleGVjdXRpb24gZ29lcyBhc3luY1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggalF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vayApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRwcm9jZXNzLnN0YWNrVHJhY2UgPSBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHdpbmRvdy5zZXRUaW1lb3V0KCBwcm9jZXNzICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBwcm9ncmVzc19oYW5kbGVycy5hZGQoIC4uLiApXFxuXFx0XFx0XFx0XFx0XFx0XFx0dHVwbGVzWyAwIF1bIDMgXS5hZGQoXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVzb2x2ZShcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQwLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5ld0RlZmVyLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlzRnVuY3Rpb24oIG9uUHJvZ3Jlc3MgKSA/XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0b25Qcm9ncmVzcyA6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0SWRlbnRpdHksXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bmV3RGVmZXIubm90aWZ5V2l0aFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdClcXG5cXHRcXHRcXHRcXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5hZGQoIC4uLiApXFxuXFx0XFx0XFx0XFx0XFx0XFx0dHVwbGVzWyAxIF1bIDMgXS5hZGQoXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVzb2x2ZShcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQwLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5ld0RlZmVyLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlzRnVuY3Rpb24oIG9uRnVsZmlsbGVkICkgP1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG9uRnVsZmlsbGVkIDpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRJZGVudGl0eVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdClcXG5cXHRcXHRcXHRcXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmFkZCggLi4uIClcXG5cXHRcXHRcXHRcXHRcXHRcXHR0dXBsZXNbIDIgXVsgMyBdLmFkZChcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXNvbHZlKFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDAsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bmV3RGVmZXIsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aXNGdW5jdGlvbiggb25SZWplY3RlZCApID9cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRvblJlamVjdGVkIDpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRUaHJvd2VyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0KVxcblxcdFxcdFxcdFxcdFxcdFxcdCk7XFxuXFx0XFx0XFx0XFx0XFx0fSApLnByb21pc2UoKTtcXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdC8vIEdldCBhIHByb21pc2UgZm9yIHRoaXMgZGVmZXJyZWRcXG5cXHRcXHRcXHRcXHQvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XFxuXFx0XFx0XFx0XFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0ZGVmZXJyZWQgPSB7fTtcXG5cXG5cXHRcXHQvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXFxuXFx0XFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xcblxcdFxcdFxcdHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcXG5cXHRcXHRcXHRcXHRzdGF0ZVN0cmluZyA9IHR1cGxlWyA1IF07XFxuXFxuXFx0XFx0XFx0Ly8gcHJvbWlzZS5wcm9ncmVzcyA9IGxpc3QuYWRkXFxuXFx0XFx0XFx0Ly8gcHJvbWlzZS5kb25lID0gbGlzdC5hZGRcXG5cXHRcXHRcXHQvLyBwcm9taXNlLmZhaWwgPSBsaXN0LmFkZFxcblxcdFxcdFxcdHByb21pc2VbIHR1cGxlWyAxIF0gXSA9IGxpc3QuYWRkO1xcblxcblxcdFxcdFxcdC8vIEhhbmRsZSBzdGF0ZVxcblxcdFxcdFxcdGlmICggc3RhdGVTdHJpbmcgKSB7XFxuXFx0XFx0XFx0XFx0bGlzdC5hZGQoXFxuXFx0XFx0XFx0XFx0XFx0ZnVuY3Rpb24oKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gc3RhdGUgPSBcXFwicmVzb2x2ZWRcXFwiIChpLmUuLCBmdWxmaWxsZWQpXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gc3RhdGUgPSBcXFwicmVqZWN0ZWRcXFwiXFxuXFx0XFx0XFx0XFx0XFx0XFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcXG5cXHRcXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdFxcdC8vIHJlamVjdGVkX2NhbGxiYWNrcy5kaXNhYmxlXFxuXFx0XFx0XFx0XFx0XFx0Ly8gZnVsZmlsbGVkX2NhbGxiYWNrcy5kaXNhYmxlXFxuXFx0XFx0XFx0XFx0XFx0dHVwbGVzWyAzIC0gaSBdWyAyIF0uZGlzYWJsZSxcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyByZWplY3RlZF9oYW5kbGVycy5kaXNhYmxlXFxuXFx0XFx0XFx0XFx0XFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmRpc2FibGVcXG5cXHRcXHRcXHRcXHRcXHR0dXBsZXNbIDMgLSBpIF1bIDMgXS5kaXNhYmxlLFxcblxcblxcdFxcdFxcdFxcdFxcdC8vIHByb2dyZXNzX2NhbGxiYWNrcy5sb2NrXFxuXFx0XFx0XFx0XFx0XFx0dHVwbGVzWyAwIF1bIDIgXS5sb2NrLFxcblxcblxcdFxcdFxcdFxcdFxcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmxvY2tcXG5cXHRcXHRcXHRcXHRcXHR0dXBsZXNbIDAgXVsgMyBdLmxvY2tcXG5cXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBwcm9ncmVzc19oYW5kbGVycy5maXJlXFxuXFx0XFx0XFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmZpcmVcXG5cXHRcXHRcXHQvLyByZWplY3RlZF9oYW5kbGVycy5maXJlXFxuXFx0XFx0XFx0bGlzdC5hZGQoIHR1cGxlWyAzIF0uZmlyZSApO1xcblxcblxcdFxcdFxcdC8vIGRlZmVycmVkLm5vdGlmeSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5ub3RpZnlXaXRoKC4uLikgfVxcblxcdFxcdFxcdC8vIGRlZmVycmVkLnJlc29sdmUgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVzb2x2ZVdpdGgoLi4uKSB9XFxuXFx0XFx0XFx0Ly8gZGVmZXJyZWQucmVqZWN0ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlamVjdFdpdGgoLi4uKSB9XFxuXFx0XFx0XFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gXSA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXFxcIldpdGhcXFwiIF0oIHRoaXMgPT09IGRlZmVycmVkID8gdW5kZWZpbmVkIDogdGhpcywgYXJndW1lbnRzICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHQvLyBkZWZlcnJlZC5ub3RpZnlXaXRoID0gbGlzdC5maXJlV2l0aFxcblxcdFxcdFxcdC8vIGRlZmVycmVkLnJlc29sdmVXaXRoID0gbGlzdC5maXJlV2l0aFxcblxcdFxcdFxcdC8vIGRlZmVycmVkLnJlamVjdFdpdGggPSBsaXN0LmZpcmVXaXRoXFxuXFx0XFx0XFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcXFwiV2l0aFxcXCIgXSA9IGxpc3QuZmlyZVdpdGg7XFxuXFx0XFx0fSApO1xcblxcblxcdFxcdC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxcblxcdFxcdHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcXG5cXG5cXHRcXHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XFxuXFx0XFx0aWYgKCBmdW5jICkge1xcblxcdFxcdFxcdGZ1bmMuY2FsbCggZGVmZXJyZWQsIGRlZmVycmVkICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEFsbCBkb25lIVxcblxcdFxcdHJldHVybiBkZWZlcnJlZDtcXG5cXHR9LFxcblxcblxcdC8vIERlZmVycmVkIGhlbHBlclxcblxcdHdoZW46IGZ1bmN0aW9uKCBzaW5nbGVWYWx1ZSApIHtcXG5cXHRcXHR2YXJcXG5cXG5cXHRcXHRcXHQvLyBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcXG5cXHRcXHRcXHRyZW1haW5pbmcgPSBhcmd1bWVudHMubGVuZ3RoLFxcblxcblxcdFxcdFxcdC8vIGNvdW50IG9mIHVucHJvY2Vzc2VkIGFyZ3VtZW50c1xcblxcdFxcdFxcdGkgPSByZW1haW5pbmcsXFxuXFxuXFx0XFx0XFx0Ly8gc3Vib3JkaW5hdGUgZnVsZmlsbG1lbnQgZGF0YVxcblxcdFxcdFxcdHJlc29sdmVDb250ZXh0cyA9IEFycmF5KCBpICksXFxuXFx0XFx0XFx0cmVzb2x2ZVZhbHVlcyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxcblxcblxcdFxcdFxcdC8vIHRoZSBtYXN0ZXIgRGVmZXJyZWRcXG5cXHRcXHRcXHRtYXN0ZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcXG5cXG5cXHRcXHRcXHQvLyBzdWJvcmRpbmF0ZSBjYWxsYmFjayBmYWN0b3J5XFxuXFx0XFx0XFx0dXBkYXRlRnVuYyA9IGZ1bmN0aW9uKCBpICkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmVzb2x2ZUNvbnRleHRzWyBpIF0gPSB0aGlzO1xcblxcdFxcdFxcdFxcdFxcdHJlc29sdmVWYWx1ZXNbIGkgXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbCggYXJndW1lbnRzICkgOiB2YWx1ZTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bWFzdGVyLnJlc29sdmVXaXRoKCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdC8vIFNpbmdsZS0gYW5kIGVtcHR5IGFyZ3VtZW50cyBhcmUgYWRvcHRlZCBsaWtlIFByb21pc2UucmVzb2x2ZVxcblxcdFxcdGlmICggcmVtYWluaW5nIDw9IDEgKSB7XFxuXFx0XFx0XFx0YWRvcHRWYWx1ZSggc2luZ2xlVmFsdWUsIG1hc3Rlci5kb25lKCB1cGRhdGVGdW5jKCBpICkgKS5yZXNvbHZlLCBtYXN0ZXIucmVqZWN0LFxcblxcdFxcdFxcdFxcdCFyZW1haW5pbmcgKTtcXG5cXG5cXHRcXHRcXHQvLyBVc2UgLnRoZW4oKSB0byB1bndyYXAgc2Vjb25kYXJ5IHRoZW5hYmxlcyAoY2YuIGdoLTMwMDApXFxuXFx0XFx0XFx0aWYgKCBtYXN0ZXIuc3RhdGUoKSA9PT0gXFxcInBlbmRpbmdcXFwiIHx8XFxuXFx0XFx0XFx0XFx0aXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIHJlc29sdmVWYWx1ZXNbIGkgXS50aGVuICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIG1hc3Rlci50aGVuKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBNdWx0aXBsZSBhcmd1bWVudHMgYXJlIGFnZ3JlZ2F0ZWQgbGlrZSBQcm9taXNlLmFsbCBhcnJheSBlbGVtZW50c1xcblxcdFxcdHdoaWxlICggaS0tICkge1xcblxcdFxcdFxcdGFkb3B0VmFsdWUoIHJlc29sdmVWYWx1ZXNbIGkgXSwgdXBkYXRlRnVuYyggaSApLCBtYXN0ZXIucmVqZWN0ICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBtYXN0ZXIucHJvbWlzZSgpO1xcblxcdH1cXG59ICk7XFxuXFxuXFxuLy8gVGhlc2UgdXN1YWxseSBpbmRpY2F0ZSBhIHByb2dyYW1tZXIgbWlzdGFrZSBkdXJpbmcgZGV2ZWxvcG1lbnQsXFxuLy8gd2FybiBhYm91dCB0aGVtIEFTQVAgcmF0aGVyIHRoYW4gc3dhbGxvd2luZyB0aGVtIGJ5IGRlZmF1bHQuXFxudmFyIHJlcnJvck5hbWVzID0gL14oRXZhbHxJbnRlcm5hbHxSYW5nZXxSZWZlcmVuY2V8U3ludGF4fFR5cGV8VVJJKUVycm9yJC87XFxuXFxualF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgPSBmdW5jdGlvbiggZXJyb3IsIHN0YWNrICkge1xcblxcblxcdC8vIFN1cHBvcnQ6IElFIDggLSA5IG9ubHlcXG5cXHQvLyBDb25zb2xlIGV4aXN0cyB3aGVuIGRldiB0b29scyBhcmUgb3Blbiwgd2hpY2ggY2FuIGhhcHBlbiBhdCBhbnkgdGltZVxcblxcdGlmICggd2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUud2FybiAmJiBlcnJvciAmJiByZXJyb3JOYW1lcy50ZXN0KCBlcnJvci5uYW1lICkgKSB7XFxuXFx0XFx0d2luZG93LmNvbnNvbGUud2FybiggXFxcImpRdWVyeS5EZWZlcnJlZCBleGNlcHRpb246IFxcXCIgKyBlcnJvci5tZXNzYWdlLCBlcnJvci5zdGFjaywgc3RhY2sgKTtcXG5cXHR9XFxufTtcXG5cXG5cXG5cXG5cXG5qUXVlcnkucmVhZHlFeGNlcHRpb24gPSBmdW5jdGlvbiggZXJyb3IgKSB7XFxuXFx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xcblxcdFxcdHRocm93IGVycm9yO1xcblxcdH0gKTtcXG59O1xcblxcblxcblxcblxcbi8vIFRoZSBkZWZlcnJlZCB1c2VkIG9uIERPTSByZWFkeVxcbnZhciByZWFkeUxpc3QgPSBqUXVlcnkuRGVmZXJyZWQoKTtcXG5cXG5qUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XFxuXFxuXFx0cmVhZHlMaXN0XFxuXFx0XFx0LnRoZW4oIGZuIClcXG5cXG5cXHRcXHQvLyBXcmFwIGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiBpbiBhIGZ1bmN0aW9uIHNvIHRoYXQgdGhlIGxvb2t1cFxcblxcdFxcdC8vIGhhcHBlbnMgYXQgdGhlIHRpbWUgb2YgZXJyb3IgaGFuZGxpbmcgaW5zdGVhZCBvZiBjYWxsYmFja1xcblxcdFxcdC8vIHJlZ2lzdHJhdGlvbi5cXG5cXHRcXHQuY2F0Y2goIGZ1bmN0aW9uKCBlcnJvciApIHtcXG5cXHRcXHRcXHRqUXVlcnkucmVhZHlFeGNlcHRpb24oIGVycm9yICk7XFxuXFx0XFx0fSApO1xcblxcblxcdHJldHVybiB0aGlzO1xcbn07XFxuXFxualF1ZXJ5LmV4dGVuZCgge1xcblxcblxcdC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXFxuXFx0aXNSZWFkeTogZmFsc2UsXFxuXFxuXFx0Ly8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxcblxcdC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXFxuXFx0cmVhZHlXYWl0OiAxLFxcblxcblxcdC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcXG5cXHRyZWFkeTogZnVuY3Rpb24oIHdhaXQgKSB7XFxuXFxuXFx0XFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxcblxcdFxcdGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gUmVtZW1iZXIgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XFxuXFx0XFx0alF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xcblxcblxcdFxcdC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXFxuXFx0XFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXFxuXFx0XFx0cmVhZHlMaXN0LnJlc29sdmVXaXRoKCBkb2N1bWVudCwgWyBqUXVlcnkgXSApO1xcblxcdH1cXG59ICk7XFxuXFxualF1ZXJ5LnJlYWR5LnRoZW4gPSByZWFkeUxpc3QudGhlbjtcXG5cXG4vLyBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxcbmZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcXG5cXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcXFwiRE9NQ29udGVudExvYWRlZFxcXCIsIGNvbXBsZXRlZCApO1xcblxcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcXFwibG9hZFxcXCIsIGNvbXBsZXRlZCApO1xcblxcdGpRdWVyeS5yZWFkeSgpO1xcbn1cXG5cXG4vLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZFxcbi8vIGFmdGVyIHRoZSBicm93c2VyIGV2ZW50IGhhcyBhbHJlYWR5IG9jY3VycmVkLlxcbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDEwIG9ubHlcXG4vLyBPbGRlciBJRSBzb21ldGltZXMgc2lnbmFscyBcXFwiaW50ZXJhY3RpdmVcXFwiIHRvbyBzb29uXFxuaWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcXFwiY29tcGxldGVcXFwiIHx8XFxuXFx0KCBkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcXFwibG9hZGluZ1xcXCIgJiYgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCApICkge1xcblxcblxcdC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxcblxcdHdpbmRvdy5zZXRUaW1lb3V0KCBqUXVlcnkucmVhZHkgKTtcXG5cXG59IGVsc2Uge1xcblxcblxcdC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcXG5cXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcXFwiRE9NQ29udGVudExvYWRlZFxcXCIsIGNvbXBsZXRlZCApO1xcblxcblxcdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXFxuXFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFxcXCJsb2FkXFxcIiwgY29tcGxldGVkICk7XFxufVxcblxcblxcblxcblxcbi8vIE11bHRpZnVuY3Rpb25hbCBtZXRob2QgdG8gZ2V0IGFuZCBzZXQgdmFsdWVzIG9mIGEgY29sbGVjdGlvblxcbi8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxcbnZhciBhY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XFxuXFx0dmFyIGkgPSAwLFxcblxcdFxcdGxlbiA9IGVsZW1zLmxlbmd0aCxcXG5cXHRcXHRidWxrID0ga2V5ID09IG51bGw7XFxuXFxuXFx0Ly8gU2V0cyBtYW55IHZhbHVlc1xcblxcdGlmICggdG9UeXBlKCBrZXkgKSA9PT0gXFxcIm9iamVjdFxcXCIgKSB7XFxuXFx0XFx0Y2hhaW5hYmxlID0gdHJ1ZTtcXG5cXHRcXHRmb3IgKCBpIGluIGtleSApIHtcXG5cXHRcXHRcXHRhY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5WyBpIF0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcXG5cXHRcXHR9XFxuXFxuXFx0Ly8gU2V0cyBvbmUgdmFsdWVcXG5cXHR9IGVsc2UgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xcblxcdFxcdGNoYWluYWJsZSA9IHRydWU7XFxuXFxuXFx0XFx0aWYgKCAhaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcXG5cXHRcXHRcXHRyYXcgPSB0cnVlO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIGJ1bGsgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XFxuXFx0XFx0XFx0aWYgKCByYXcgKSB7XFxuXFx0XFx0XFx0XFx0Zm4uY2FsbCggZWxlbXMsIHZhbHVlICk7XFxuXFx0XFx0XFx0XFx0Zm4gPSBudWxsO1xcblxcblxcdFxcdFxcdC8vIC4uLmV4Y2VwdCB3aGVuIGV4ZWN1dGluZyBmdW5jdGlvbiB2YWx1ZXNcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGJ1bGsgPSBmbjtcXG5cXHRcXHRcXHRcXHRmbiA9IGZ1bmN0aW9uKCBlbGVtLCBrZXksIHZhbHVlICkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBidWxrLmNhbGwoIGpRdWVyeSggZWxlbSApLCB2YWx1ZSApO1xcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIGZuICkge1xcblxcdFxcdFxcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xcblxcdFxcdFxcdFxcdGZuKFxcblxcdFxcdFxcdFxcdFxcdGVsZW1zWyBpIF0sIGtleSwgcmF3ID9cXG5cXHRcXHRcXHRcXHRcXHR2YWx1ZSA6XFxuXFx0XFx0XFx0XFx0XFx0dmFsdWUuY2FsbCggZWxlbXNbIGkgXSwgaSwgZm4oIGVsZW1zWyBpIF0sIGtleSApIClcXG5cXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdGlmICggY2hhaW5hYmxlICkge1xcblxcdFxcdHJldHVybiBlbGVtcztcXG5cXHR9XFxuXFxuXFx0Ly8gR2V0c1xcblxcdGlmICggYnVsayApIHtcXG5cXHRcXHRyZXR1cm4gZm4uY2FsbCggZWxlbXMgKTtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIGxlbiA/IGZuKCBlbGVtc1sgMCBdLCBrZXkgKSA6IGVtcHR5R2V0O1xcbn07XFxuXFxuXFxuLy8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXFxudmFyIHJtc1ByZWZpeCA9IC9eLW1zLS8sXFxuXFx0cmRhc2hBbHBoYSA9IC8tKFthLXpdKS9nO1xcblxcbi8vIFVzZWQgYnkgY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxcbmZ1bmN0aW9uIGZjYW1lbENhc2UoIGFsbCwgbGV0dGVyICkge1xcblxcdHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcXG59XFxuXFxuLy8gQ29udmVydCBkYXNoZWQgdG8gY2FtZWxDYXNlOyB1c2VkIGJ5IHRoZSBjc3MgYW5kIGRhdGEgbW9kdWxlc1xcbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcXG4vLyBNaWNyb3NvZnQgZm9yZ290IHRvIGh1bXAgdGhlaXIgdmVuZG9yIHByZWZpeCAoIzk1NzIpXFxuZnVuY3Rpb24gY2FtZWxDYXNlKCBzdHJpbmcgKSB7XFxuXFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFxcXCJtcy1cXFwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xcbn1cXG52YXIgYWNjZXB0RGF0YSA9IGZ1bmN0aW9uKCBvd25lciApIHtcXG5cXG5cXHQvLyBBY2NlcHRzIG9ubHk6XFxuXFx0Ly8gIC0gTm9kZVxcblxcdC8vICAgIC0gTm9kZS5FTEVNRU5UX05PREVcXG5cXHQvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxcblxcdC8vICAtIE9iamVjdFxcblxcdC8vICAgIC0gQW55XFxuXFx0cmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xcbn07XFxuXFxuXFxuXFxuXFxuZnVuY3Rpb24gRGF0YSgpIHtcXG5cXHR0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIERhdGEudWlkKys7XFxufVxcblxcbkRhdGEudWlkID0gMTtcXG5cXG5EYXRhLnByb3RvdHlwZSA9IHtcXG5cXG5cXHRjYWNoZTogZnVuY3Rpb24oIG93bmVyICkge1xcblxcblxcdFxcdC8vIENoZWNrIGlmIHRoZSBvd25lciBvYmplY3QgYWxyZWFkeSBoYXMgYSBjYWNoZVxcblxcdFxcdHZhciB2YWx1ZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcXG5cXG5cXHRcXHQvLyBJZiBub3QsIGNyZWF0ZSBvbmVcXG5cXHRcXHRpZiAoICF2YWx1ZSApIHtcXG5cXHRcXHRcXHR2YWx1ZSA9IHt9O1xcblxcblxcdFxcdFxcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxcblxcdFxcdFxcdC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgIzgzMzUuXFxuXFx0XFx0XFx0Ly8gQWx3YXlzIHJldHVybiBhbiBlbXB0eSBvYmplY3QuXFxuXFx0XFx0XFx0aWYgKCBhY2NlcHREYXRhKCBvd25lciApICkge1xcblxcblxcdFxcdFxcdFxcdC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcXG5cXHRcXHRcXHRcXHQvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxcblxcdFxcdFxcdFxcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdmFsdWU7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gT3RoZXJ3aXNlIHNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5XFxuXFx0XFx0XFx0XFx0Ly8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcXG5cXHRcXHRcXHRcXHQvLyBkZWxldGVkIHdoZW4gZGF0YSBpcyByZW1vdmVkXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIG93bmVyLCB0aGlzLmV4cGFuZG8sIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YWx1ZTogdmFsdWUsXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29uZmlndXJhYmxlOiB0cnVlXFxuXFx0XFx0XFx0XFx0XFx0fSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB2YWx1ZTtcXG5cXHR9LFxcblxcdHNldDogZnVuY3Rpb24oIG93bmVyLCBkYXRhLCB2YWx1ZSApIHtcXG5cXHRcXHR2YXIgcHJvcCxcXG5cXHRcXHRcXHRjYWNoZSA9IHRoaXMuY2FjaGUoIG93bmVyICk7XFxuXFxuXFx0XFx0Ly8gSGFuZGxlOiBbIG93bmVyLCBrZXksIHZhbHVlIF0gYXJnc1xcblxcdFxcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1NylcXG5cXHRcXHRpZiAoIHR5cGVvZiBkYXRhID09PSBcXFwic3RyaW5nXFxcIiApIHtcXG5cXHRcXHRcXHRjYWNoZVsgY2FtZWxDYXNlKCBkYXRhICkgXSA9IHZhbHVlO1xcblxcblxcdFxcdC8vIEhhbmRsZTogWyBvd25lciwgeyBwcm9wZXJ0aWVzIH0gXSBhcmdzXFxuXFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHQvLyBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxcblxcdFxcdFxcdGZvciAoIHByb3AgaW4gZGF0YSApIHtcXG5cXHRcXHRcXHRcXHRjYWNoZVsgY2FtZWxDYXNlKCBwcm9wICkgXSA9IGRhdGFbIHByb3AgXTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiBjYWNoZTtcXG5cXHR9LFxcblxcdGdldDogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XFxuXFx0XFx0cmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID9cXG5cXHRcXHRcXHR0aGlzLmNhY2hlKCBvd25lciApIDpcXG5cXG5cXHRcXHRcXHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXFxuXFx0XFx0XFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdICYmIG93bmVyWyB0aGlzLmV4cGFuZG8gXVsgY2FtZWxDYXNlKCBrZXkgKSBdO1xcblxcdH0sXFxuXFx0YWNjZXNzOiBmdW5jdGlvbiggb3duZXIsIGtleSwgdmFsdWUgKSB7XFxuXFxuXFx0XFx0Ly8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxcblxcdFxcdC8vXFxuXFx0XFx0Ly8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxcblxcdFxcdC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxcblxcdFxcdC8vXFxuXFx0XFx0Ly8gVGFrZSB0aGUgXFxcInJlYWRcXFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxcblxcdFxcdC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcXG5cXHRcXHQvL1xcblxcdFxcdC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3RcXG5cXHRcXHQvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XFxuXFx0XFx0Ly9cXG5cXHRcXHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8XFxuXFx0XFx0XFx0XFx0KCAoIGtleSAmJiB0eXBlb2Yga2V5ID09PSBcXFwic3RyaW5nXFxcIiApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5nZXQoIG93bmVyLCBrZXkgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcXG5cXHRcXHQvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcXG5cXHRcXHQvL1xcblxcdFxcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcXG5cXHRcXHQvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxcblxcdFxcdC8vXFxuXFx0XFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XFxuXFxuXFx0XFx0Ly8gU2luY2UgdGhlIFxcXCJzZXRcXFwiIHBhdGggY2FuIGhhdmUgdHdvIHBvc3NpYmxlIGVudHJ5IHBvaW50c1xcblxcdFxcdC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxcblxcdFxcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBrZXk7XFxuXFx0fSxcXG5cXHRyZW1vdmU6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xcblxcdFxcdHZhciBpLFxcblxcdFxcdFxcdGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xcblxcblxcdFxcdGlmICggY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICgga2V5ICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcXG5cXHRcXHRcXHRpZiAoIEFycmF5LmlzQXJyYXkoIGtleSApICkge1xcblxcblxcdFxcdFxcdFxcdC8vIElmIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXFxuXFx0XFx0XFx0XFx0Ly8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXFxuXFx0XFx0XFx0XFx0a2V5ID0ga2V5Lm1hcCggY2FtZWxDYXNlICk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRrZXkgPSBjYW1lbENhc2UoIGtleSApO1xcblxcblxcdFxcdFxcdFxcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cXG5cXHRcXHRcXHRcXHQvLyBPdGhlcndpc2UsIGNyZWF0ZSBhbiBhcnJheSBieSBtYXRjaGluZyBub24td2hpdGVzcGFjZVxcblxcdFxcdFxcdFxcdGtleSA9IGtleSBpbiBjYWNoZSA/XFxuXFx0XFx0XFx0XFx0XFx0WyBrZXkgXSA6XFxuXFx0XFx0XFx0XFx0XFx0KCBrZXkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpID0ga2V5Lmxlbmd0aDtcXG5cXG5cXHRcXHRcXHR3aGlsZSAoIGktLSApIHtcXG5cXHRcXHRcXHRcXHRkZWxldGUgY2FjaGVbIGtleVsgaSBdIF07XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgdGhlcmUncyBubyBtb3JlIGRhdGFcXG5cXHRcXHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xcblxcblxcdFxcdFxcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDVcXG5cXHRcXHRcXHQvLyBXZWJraXQgJiBCbGluayBwZXJmb3JtYW5jZSBzdWZmZXJzIHdoZW4gZGVsZXRpbmcgcHJvcGVydGllc1xcblxcdFxcdFxcdC8vIGZyb20gRE9NIG5vZGVzLCBzbyBzZXQgdG8gdW5kZWZpbmVkIGluc3RlYWRcXG5cXHRcXHRcXHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzg2MDcgKGJ1ZyByZXN0cmljdGVkKVxcblxcdFxcdFxcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XFxuXFx0XFx0XFx0XFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0ZGVsZXRlIG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH0sXFxuXFx0aGFzRGF0YTogZnVuY3Rpb24oIG93bmVyICkge1xcblxcdFxcdHZhciBjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcXG5cXHRcXHRyZXR1cm4gY2FjaGUgIT09IHVuZGVmaW5lZCAmJiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICk7XFxuXFx0fVxcbn07XFxudmFyIGRhdGFQcml2ID0gbmV3IERhdGEoKTtcXG5cXG52YXIgZGF0YVVzZXIgPSBuZXcgRGF0YSgpO1xcblxcblxcblxcbi8vXFx0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxcbi8vXFxuLy9cXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXFxuLy9cXHQyLiBJbXByb3ZlIHRoZSBtb2R1bGUncyBtYWludGFpbmFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIHN0b3JhZ2VcXG4vL1xcdFxcdHBhdGhzIHRvIGEgc2luZ2xlIG1lY2hhbmlzbS5cXG4vL1xcdDMuIFVzZSB0aGUgc2FtZSBzaW5nbGUgbWVjaGFuaXNtIHRvIHN1cHBvcnQgXFxcInByaXZhdGVcXFwiIGFuZCBcXFwidXNlclxcXCIgZGF0YS5cXG4vL1xcdDQuIF9OZXZlcl8gZXhwb3NlIFxcXCJwcml2YXRlXFxcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXFxuLy9cXHQ1LiBBdm9pZCBleHBvc2luZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9uIHVzZXIgb2JqZWN0cyAoZWcuIGV4cGFuZG8gcHJvcGVydGllcylcXG4vL1xcdDYuIFByb3ZpZGUgYSBjbGVhciBwYXRoIGZvciBpbXBsZW1lbnRhdGlvbiB1cGdyYWRlIHRvIFdlYWtNYXAgaW4gMjAxNFxcblxcbnZhciByYnJhY2UgPSAvXig/OlxcXFx7W1xcXFx3XFxcXFddKlxcXFx9fFxcXFxbW1xcXFx3XFxcXFddKlxcXFxdKSQvLFxcblxcdHJtdWx0aURhc2ggPSAvW0EtWl0vZztcXG5cXG5mdW5jdGlvbiBnZXREYXRhKCBkYXRhICkge1xcblxcdGlmICggZGF0YSA9PT0gXFxcInRydWVcXFwiICkge1xcblxcdFxcdHJldHVybiB0cnVlO1xcblxcdH1cXG5cXG5cXHRpZiAoIGRhdGEgPT09IFxcXCJmYWxzZVxcXCIgKSB7XFxuXFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdH1cXG5cXG5cXHRpZiAoIGRhdGEgPT09IFxcXCJudWxsXFxcIiApIHtcXG5cXHRcXHRyZXR1cm4gbnVsbDtcXG5cXHR9XFxuXFxuXFx0Ly8gT25seSBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHJpbmdcXG5cXHRpZiAoIGRhdGEgPT09ICtkYXRhICsgXFxcIlxcXCIgKSB7XFxuXFx0XFx0cmV0dXJuICtkYXRhO1xcblxcdH1cXG5cXG5cXHRpZiAoIHJicmFjZS50ZXN0KCBkYXRhICkgKSB7XFxuXFx0XFx0cmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKTtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIGRhdGE7XFxufVxcblxcbmZ1bmN0aW9uIGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKSB7XFxuXFx0dmFyIG5hbWU7XFxuXFxuXFx0Ly8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueVxcblxcdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxcblxcdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XFxuXFx0XFx0bmFtZSA9IFxcXCJkYXRhLVxcXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXFxcIi0kJlxcXCIgKS50b0xvd2VyQ2FzZSgpO1xcblxcdFxcdGRhdGEgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xcblxcblxcdFxcdGlmICggdHlwZW9mIGRhdGEgPT09IFxcXCJzdHJpbmdcXFwiICkge1xcblxcdFxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0XFx0ZGF0YSA9IGdldERhdGEoIGRhdGEgKTtcXG5cXHRcXHRcXHR9IGNhdGNoICggZSApIHt9XFxuXFxuXFx0XFx0XFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXFxuXFx0XFx0XFx0ZGF0YVVzZXIuc2V0KCBlbGVtLCBrZXksIGRhdGEgKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdGRhdGEgPSB1bmRlZmluZWQ7XFxuXFx0XFx0fVxcblxcdH1cXG5cXHRyZXR1cm4gZGF0YTtcXG59XFxuXFxualF1ZXJ5LmV4dGVuZCgge1xcblxcdGhhc0RhdGE6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdHJldHVybiBkYXRhVXNlci5oYXNEYXRhKCBlbGVtICkgfHwgZGF0YVByaXYuaGFzRGF0YSggZWxlbSApO1xcblxcdH0sXFxuXFxuXFx0ZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XFxuXFx0XFx0cmV0dXJuIGRhdGFVc2VyLmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xcblxcdH0sXFxuXFxuXFx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XFxuXFx0XFx0ZGF0YVVzZXIucmVtb3ZlKCBlbGVtLCBuYW1lICk7XFxuXFx0fSxcXG5cXG5cXHQvLyBUT0RPOiBOb3cgdGhhdCBhbGwgY2FsbHMgdG8gX2RhdGEgYW5kIF9yZW1vdmVEYXRhIGhhdmUgYmVlbiByZXBsYWNlZFxcblxcdC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFQcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxcblxcdF9kYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcXG5cXHRcXHRyZXR1cm4gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XFxuXFx0fSxcXG5cXG5cXHRfcmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XFxuXFx0XFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBuYW1lICk7XFxuXFx0fVxcbn0gKTtcXG5cXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XFxuXFx0ZGF0YTogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XFxuXFx0XFx0dmFyIGksIG5hbWUsIGRhdGEsXFxuXFx0XFx0XFx0ZWxlbSA9IHRoaXNbIDAgXSxcXG5cXHRcXHRcXHRhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xcblxcblxcdFxcdC8vIEdldHMgYWxsIHZhbHVlc1xcblxcdFxcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XFxuXFx0XFx0XFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcXG5cXHRcXHRcXHRcXHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhUHJpdi5nZXQoIGVsZW0sIFxcXCJoYXNEYXRhQXR0cnNcXFwiICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aSA9IGF0dHJzLmxlbmd0aDtcXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAoIGktLSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICgjMTQ4OTQpXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBhdHRyc1sgaSBdICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG5hbWUgPSBhdHRyc1sgaSBdLm5hbWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBuYW1lLmluZGV4T2YoIFxcXCJkYXRhLVxcXCIgKSA9PT0gMCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRuYW1lID0gY2FtZWxDYXNlKCBuYW1lLnNsaWNlKCA1ICkgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhQXR0ciggZWxlbSwgbmFtZSwgZGF0YVsgbmFtZSBdICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcXFwiaGFzRGF0YUF0dHJzXFxcIiwgdHJ1ZSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGRhdGE7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXFxuXFx0XFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcXFwib2JqZWN0XFxcIiApIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSApO1xcblxcdFxcdFxcdH0gKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xcblxcdFxcdFxcdHZhciBkYXRhO1xcblxcblxcdFxcdFxcdC8vIFRoZSBjYWxsaW5nIGpRdWVyeSBvYmplY3QgKGVsZW1lbnQgbWF0Y2hlcykgaXMgbm90IGVtcHR5XFxuXFx0XFx0XFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcXG5cXHRcXHRcXHQvLyBgdmFsdWVgIHBhcmFtZXRlciB3YXMgbm90IHVuZGVmaW5lZC4gQW4gZW1wdHkgalF1ZXJ5IG9iamVjdFxcblxcdFxcdFxcdC8vIHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGZvciBlbGVtID0gdGhpc1sgMCBdIHdoaWNoIHdpbGxcXG5cXHRcXHRcXHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxcblxcdFxcdFxcdGlmICggZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcXG5cXHRcXHRcXHRcXHQvLyBUaGUga2V5IHdpbGwgYWx3YXlzIGJlIGNhbWVsQ2FzZWQgaW4gRGF0YVxcblxcdFxcdFxcdFxcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGtleSApO1xcblxcdFxcdFxcdFxcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBkYXRhO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBBdHRlbXB0IHRvIFxcXCJkaXNjb3ZlclxcXCIgdGhlIGRhdGEgaW5cXG5cXHRcXHRcXHRcXHQvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXFxuXFx0XFx0XFx0XFx0ZGF0YSA9IGRhdGFBdHRyKCBlbGVtLCBrZXkgKTtcXG5cXHRcXHRcXHRcXHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZGF0YTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU2V0IHRoZSBkYXRhLi4uXFxuXFx0XFx0XFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBXZSBhbHdheXMgc3RvcmUgdGhlIGNhbWVsQ2FzZWQga2V5XFxuXFx0XFx0XFx0XFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXksIHZhbHVlICk7XFxuXFx0XFx0XFx0fSApO1xcblxcdFxcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xcblxcdH0sXFxuXFxuXFx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xcblxcdFxcdH0gKTtcXG5cXHR9XFxufSApO1xcblxcblxcbmpRdWVyeS5leHRlbmQoIHtcXG5cXHRxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGRhdGEgKSB7XFxuXFx0XFx0dmFyIHF1ZXVlO1xcblxcblxcdFxcdGlmICggZWxlbSApIHtcXG5cXHRcXHRcXHR0eXBlID0gKCB0eXBlIHx8IFxcXCJmeFxcXCIgKSArIFxcXCJxdWV1ZVxcXCI7XFxuXFx0XFx0XFx0cXVldWUgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIHR5cGUgKTtcXG5cXG5cXHRcXHRcXHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXFxuXFx0XFx0XFx0aWYgKCBkYXRhICkge1xcblxcdFxcdFxcdFxcdGlmICggIXF1ZXVlIHx8IEFycmF5LmlzQXJyYXkoIGRhdGEgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRxdWV1ZSA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSApICk7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRxdWV1ZS5wdXNoKCBkYXRhICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gcXVldWUgfHwgW107XFxuXFx0XFx0fVxcblxcdH0sXFxuXFxuXFx0ZGVxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XFxuXFx0XFx0dHlwZSA9IHR5cGUgfHwgXFxcImZ4XFxcIjtcXG5cXG5cXHRcXHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIGVsZW0sIHR5cGUgKSxcXG5cXHRcXHRcXHRzdGFydExlbmd0aCA9IHF1ZXVlLmxlbmd0aCxcXG5cXHRcXHRcXHRmbiA9IHF1ZXVlLnNoaWZ0KCksXFxuXFx0XFx0XFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIHR5cGUgKSxcXG5cXHRcXHRcXHRuZXh0ID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0alF1ZXJ5LmRlcXVldWUoIGVsZW0sIHR5cGUgKTtcXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcXG5cXHRcXHRpZiAoIGZuID09PSBcXFwiaW5wcm9ncmVzc1xcXCIgKSB7XFxuXFx0XFx0XFx0Zm4gPSBxdWV1ZS5zaGlmdCgpO1xcblxcdFxcdFxcdHN0YXJ0TGVuZ3RoLS07XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggZm4gKSB7XFxuXFxuXFx0XFx0XFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xcblxcdFxcdFxcdC8vIGF1dG9tYXRpY2FsbHkgZGVxdWV1ZWRcXG5cXHRcXHRcXHRpZiAoIHR5cGUgPT09IFxcXCJmeFxcXCIgKSB7XFxuXFx0XFx0XFx0XFx0cXVldWUudW5zaGlmdCggXFxcImlucHJvZ3Jlc3NcXFwiICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cXG5cXHRcXHRcXHRkZWxldGUgaG9va3Muc3RvcDtcXG5cXHRcXHRcXHRmbi5jYWxsKCBlbGVtLCBuZXh0LCBob29rcyApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcXG5cXHRcXHRcXHRob29rcy5lbXB0eS5maXJlKCk7XFxuXFx0XFx0fVxcblxcdH0sXFxuXFxuXFx0Ly8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcXG5cXHRfcXVldWVIb29rczogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XFxuXFx0XFx0dmFyIGtleSA9IHR5cGUgKyBcXFwicXVldWVIb29rc1xcXCI7XFxuXFx0XFx0cmV0dXJuIGRhdGFQcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBrZXksIHtcXG5cXHRcXHRcXHRlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyggXFxcIm9uY2UgbWVtb3J5XFxcIiApLmFkZCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBbIHR5cGUgKyBcXFwicXVldWVcXFwiLCBrZXkgXSApO1xcblxcdFxcdFxcdH0gKVxcblxcdFxcdH0gKTtcXG5cXHR9XFxufSApO1xcblxcbmpRdWVyeS5mbi5leHRlbmQoIHtcXG5cXHRxdWV1ZTogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XFxuXFx0XFx0dmFyIHNldHRlciA9IDI7XFxuXFxuXFx0XFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXFxcInN0cmluZ1xcXCIgKSB7XFxuXFx0XFx0XFx0ZGF0YSA9IHR5cGU7XFxuXFx0XFx0XFx0dHlwZSA9IFxcXCJmeFxcXCI7XFxuXFx0XFx0XFx0c2V0dGVyLS07XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggYXJndW1lbnRzLmxlbmd0aCA8IHNldHRlciApIHtcXG5cXHRcXHRcXHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWyAwIF0sIHR5cGUgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/XFxuXFx0XFx0XFx0dGhpcyA6XFxuXFx0XFx0XFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIGRhdGEgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBFbnN1cmUgYSBob29rcyBmb3IgdGhpcyBxdWV1ZVxcblxcdFxcdFxcdFxcdGpRdWVyeS5fcXVldWVIb29rcyggdGhpcywgdHlwZSApO1xcblxcblxcdFxcdFxcdFxcdGlmICggdHlwZSA9PT0gXFxcImZ4XFxcIiAmJiBxdWV1ZVsgMCBdICE9PSBcXFwiaW5wcm9ncmVzc1xcXCIgKSB7XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSApO1xcblxcdH0sXFxuXFx0ZGVxdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcXG5cXHRcXHR9ICk7XFxuXFx0fSxcXG5cXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcXFwiZnhcXFwiLCBbXSApO1xcblxcdH0sXFxuXFxuXFx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxcblxcdC8vIGFyZSBlbXB0aWVkIChmeCBpcyB0aGUgdHlwZSBieSBkZWZhdWx0KVxcblxcdHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmogKSB7XFxuXFx0XFx0dmFyIHRtcCxcXG5cXHRcXHRcXHRjb3VudCA9IDEsXFxuXFx0XFx0XFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcXG5cXHRcXHRcXHRlbGVtZW50cyA9IHRoaXMsXFxuXFx0XFx0XFx0aSA9IHRoaXMubGVuZ3RoLFxcblxcdFxcdFxcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRpZiAoICEoIC0tY291bnQgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRkZWZlci5yZXNvbHZlV2l0aCggZWxlbWVudHMsIFsgZWxlbWVudHMgXSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdGlmICggdHlwZW9mIHR5cGUgIT09IFxcXCJzdHJpbmdcXFwiICkge1xcblxcdFxcdFxcdG9iaiA9IHR5cGU7XFxuXFx0XFx0XFx0dHlwZSA9IHVuZGVmaW5lZDtcXG5cXHRcXHR9XFxuXFx0XFx0dHlwZSA9IHR5cGUgfHwgXFxcImZ4XFxcIjtcXG5cXG5cXHRcXHR3aGlsZSAoIGktLSApIHtcXG5cXHRcXHRcXHR0bXAgPSBkYXRhUHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcXFwicXVldWVIb29rc1xcXCIgKTtcXG5cXHRcXHRcXHRpZiAoIHRtcCAmJiB0bXAuZW1wdHkgKSB7XFxuXFx0XFx0XFx0XFx0Y291bnQrKztcXG5cXHRcXHRcXHRcXHR0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHRcXHRyZXNvbHZlKCk7XFxuXFx0XFx0cmV0dXJuIGRlZmVyLnByb21pc2UoIG9iaiApO1xcblxcdH1cXG59ICk7XFxudmFyIHBudW0gPSAoIC9bKy1dPyg/OlxcXFxkKlxcXFwufClcXFxcZCsoPzpbZUVdWystXT9cXFxcZCt8KS8gKS5zb3VyY2U7XFxuXFxudmFyIHJjc3NOdW0gPSBuZXcgUmVnRXhwKCBcXFwiXig/OihbKy1dKT18KShcXFwiICsgcG51bSArIFxcXCIpKFthLXolXSopJFxcXCIsIFxcXCJpXFxcIiApO1xcblxcblxcbnZhciBjc3NFeHBhbmQgPSBbIFxcXCJUb3BcXFwiLCBcXFwiUmlnaHRcXFwiLCBcXFwiQm90dG9tXFxcIiwgXFxcIkxlZnRcXFwiIF07XFxuXFxudmFyIGlzSGlkZGVuV2l0aGluVHJlZSA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcXG5cXG5cXHRcXHQvLyBpc0hpZGRlbldpdGhpblRyZWUgbWlnaHQgYmUgY2FsbGVkIGZyb20galF1ZXJ5I2ZpbHRlciBmdW5jdGlvbjtcXG5cXHRcXHQvLyBpbiB0aGF0IGNhc2UsIGVsZW1lbnQgd2lsbCBiZSBzZWNvbmQgYXJndW1lbnRcXG5cXHRcXHRlbGVtID0gZWwgfHwgZWxlbTtcXG5cXG5cXHRcXHQvLyBJbmxpbmUgc3R5bGUgdHJ1bXBzIGFsbFxcblxcdFxcdHJldHVybiBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFxcXCJub25lXFxcIiB8fFxcblxcdFxcdFxcdGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXFxcIlxcXCIgJiZcXG5cXG5cXHRcXHRcXHQvLyBPdGhlcndpc2UsIGNoZWNrIGNvbXB1dGVkIHN0eWxlXFxuXFx0XFx0XFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQzIC0gNDVcXG5cXHRcXHRcXHQvLyBEaXNjb25uZWN0ZWQgZWxlbWVudHMgY2FuIGhhdmUgY29tcHV0ZWQgZGlzcGxheTogbm9uZSwgc28gZmlyc3QgY29uZmlybSB0aGF0IGVsZW0gaXNcXG5cXHRcXHRcXHQvLyBpbiB0aGUgZG9jdW1lbnQuXFxuXFx0XFx0XFx0alF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSAmJlxcblxcblxcdFxcdFxcdGpRdWVyeS5jc3MoIGVsZW0sIFxcXCJkaXNwbGF5XFxcIiApID09PSBcXFwibm9uZVxcXCI7XFxuXFx0fTtcXG5cXG52YXIgc3dhcCA9IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjaywgYXJncyApIHtcXG5cXHR2YXIgcmV0LCBuYW1lLFxcblxcdFxcdG9sZCA9IHt9O1xcblxcblxcdC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xcblxcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcXG5cXHRcXHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcXG5cXHRcXHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XFxuXFx0fVxcblxcblxcdHJldCA9IGNhbGxiYWNrLmFwcGx5KCBlbGVtLCBhcmdzIHx8IFtdICk7XFxuXFxuXFx0Ly8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXFxuXFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xcblxcdFxcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9sZFsgbmFtZSBdO1xcblxcdH1cXG5cXG5cXHRyZXR1cm4gcmV0O1xcbn07XFxuXFxuXFxuXFxuXFxuZnVuY3Rpb24gYWRqdXN0Q1NTKCBlbGVtLCBwcm9wLCB2YWx1ZVBhcnRzLCB0d2VlbiApIHtcXG5cXHR2YXIgYWRqdXN0ZWQsIHNjYWxlLFxcblxcdFxcdG1heEl0ZXJhdGlvbnMgPSAyMCxcXG5cXHRcXHRjdXJyZW50VmFsdWUgPSB0d2VlbiA/XFxuXFx0XFx0XFx0ZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHR3ZWVuLmN1cigpO1xcblxcdFxcdFxcdH0gOlxcblxcdFxcdFxcdGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wLCBcXFwiXFxcIiApO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0aW5pdGlhbCA9IGN1cnJlbnRWYWx1ZSgpLFxcblxcdFxcdHVuaXQgPSB2YWx1ZVBhcnRzICYmIHZhbHVlUGFydHNbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFxcXCJcXFwiIDogXFxcInB4XFxcIiApLFxcblxcblxcdFxcdC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXFxuXFx0XFx0aW5pdGlhbEluVW5pdCA9ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdIHx8IHVuaXQgIT09IFxcXCJweFxcXCIgJiYgK2luaXRpYWwgKSAmJlxcblxcdFxcdFxcdHJjc3NOdW0uZXhlYyggalF1ZXJ5LmNzcyggZWxlbSwgcHJvcCApICk7XFxuXFxuXFx0aWYgKCBpbml0aWFsSW5Vbml0ICYmIGluaXRpYWxJblVuaXRbIDMgXSAhPT0gdW5pdCApIHtcXG5cXG5cXHRcXHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NTRcXG5cXHRcXHQvLyBIYWx2ZSB0aGUgaXRlcmF0aW9uIHRhcmdldCB2YWx1ZSB0byBwcmV2ZW50IGludGVyZmVyZW5jZSBmcm9tIENTUyB1cHBlciBib3VuZHMgKGdoLTIxNDQpXFxuXFx0XFx0aW5pdGlhbCA9IGluaXRpYWwgLyAyO1xcblxcblxcdFxcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3NcXG5cXHRcXHR1bml0ID0gdW5pdCB8fCBpbml0aWFsSW5Vbml0WyAzIF07XFxuXFxuXFx0XFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcXG5cXHRcXHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWwgfHwgMTtcXG5cXG5cXHRcXHR3aGlsZSAoIG1heEl0ZXJhdGlvbnMtLSApIHtcXG5cXG5cXHRcXHRcXHQvLyBFdmFsdWF0ZSBhbmQgdXBkYXRlIG91ciBiZXN0IGd1ZXNzIChkb3VibGluZyBndWVzc2VzIHRoYXQgemVybyBvdXQpLlxcblxcdFxcdFxcdC8vIEZpbmlzaCBpZiB0aGUgc2NhbGUgZXF1YWxzIG9yIGNyb3NzZXMgMSAobWFraW5nIHRoZSBvbGQqbmV3IHByb2R1Y3Qgbm9uLXBvc2l0aXZlKS5cXG5cXHRcXHRcXHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XFxuXFx0XFx0XFx0aWYgKCAoIDEgLSBzY2FsZSApICogKCAxIC0gKCBzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCB8fCAwLjUgKSApIDw9IDAgKSB7XFxuXFx0XFx0XFx0XFx0bWF4SXRlcmF0aW9ucyA9IDA7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0IC8gc2NhbGU7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0ICogMjtcXG5cXHRcXHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XFxuXFxuXFx0XFx0Ly8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxcblxcdFxcdHZhbHVlUGFydHMgPSB2YWx1ZVBhcnRzIHx8IFtdO1xcblxcdH1cXG5cXG5cXHRpZiAoIHZhbHVlUGFydHMgKSB7XFxuXFx0XFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsSW5Vbml0IHx8ICtpbml0aWFsIHx8IDA7XFxuXFxuXFx0XFx0Ly8gQXBwbHkgcmVsYXRpdmUgb2Zmc2V0ICgrPS8tPSkgaWYgc3BlY2lmaWVkXFxuXFx0XFx0YWRqdXN0ZWQgPSB2YWx1ZVBhcnRzWyAxIF0gP1xcblxcdFxcdFxcdGluaXRpYWxJblVuaXQgKyAoIHZhbHVlUGFydHNbIDEgXSArIDEgKSAqIHZhbHVlUGFydHNbIDIgXSA6XFxuXFx0XFx0XFx0K3ZhbHVlUGFydHNbIDIgXTtcXG5cXHRcXHRpZiAoIHR3ZWVuICkge1xcblxcdFxcdFxcdHR3ZWVuLnVuaXQgPSB1bml0O1xcblxcdFxcdFxcdHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcXG5cXHRcXHRcXHR0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcXG5cXHRcXHR9XFxuXFx0fVxcblxcdHJldHVybiBhZGp1c3RlZDtcXG59XFxuXFxuXFxudmFyIGRlZmF1bHREaXNwbGF5TWFwID0ge307XFxuXFxuZnVuY3Rpb24gZ2V0RGVmYXVsdERpc3BsYXkoIGVsZW0gKSB7XFxuXFx0dmFyIHRlbXAsXFxuXFx0XFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxcblxcdFxcdG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSxcXG5cXHRcXHRkaXNwbGF5ID0gZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF07XFxuXFxuXFx0aWYgKCBkaXNwbGF5ICkge1xcblxcdFxcdHJldHVybiBkaXNwbGF5O1xcblxcdH1cXG5cXG5cXHR0ZW1wID0gZG9jLmJvZHkuYXBwZW5kQ2hpbGQoIGRvYy5jcmVhdGVFbGVtZW50KCBub2RlTmFtZSApICk7XFxuXFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIHRlbXAsIFxcXCJkaXNwbGF5XFxcIiApO1xcblxcblxcdHRlbXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGVtcCApO1xcblxcblxcdGlmICggZGlzcGxheSA9PT0gXFxcIm5vbmVcXFwiICkge1xcblxcdFxcdGRpc3BsYXkgPSBcXFwiYmxvY2tcXFwiO1xcblxcdH1cXG5cXHRkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XFxuXFxuXFx0cmV0dXJuIGRpc3BsYXk7XFxufVxcblxcbmZ1bmN0aW9uIHNob3dIaWRlKCBlbGVtZW50cywgc2hvdyApIHtcXG5cXHR2YXIgZGlzcGxheSwgZWxlbSxcXG5cXHRcXHR2YWx1ZXMgPSBbXSxcXG5cXHRcXHRpbmRleCA9IDAsXFxuXFx0XFx0bGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xcblxcblxcdC8vIERldGVybWluZSBuZXcgZGlzcGxheSB2YWx1ZSBmb3IgZWxlbWVudHMgdGhhdCBuZWVkIHRvIGNoYW5nZVxcblxcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XFxuXFx0XFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xcblxcdFxcdGlmICggIWVsZW0uc3R5bGUgKSB7XFxuXFx0XFx0XFx0Y29udGludWU7XFxuXFx0XFx0fVxcblxcblxcdFxcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XFxuXFx0XFx0aWYgKCBzaG93ICkge1xcblxcblxcdFxcdFxcdC8vIFNpbmNlIHdlIGZvcmNlIHZpc2liaWxpdHkgdXBvbiBjYXNjYWRlLWhpZGRlbiBlbGVtZW50cywgYW4gaW1tZWRpYXRlIChhbmQgc2xvdylcXG5cXHRcXHRcXHQvLyBjaGVjayBpcyByZXF1aXJlZCBpbiB0aGlzIGZpcnN0IGxvb3AgdW5sZXNzIHdlIGhhdmUgYSBub25lbXB0eSBkaXNwbGF5IHZhbHVlIChlaXRoZXJcXG5cXHRcXHRcXHQvLyBpbmxpbmUgb3IgYWJvdXQtdG8tYmUtcmVzdG9yZWQpXFxuXFx0XFx0XFx0aWYgKCBkaXNwbGF5ID09PSBcXFwibm9uZVxcXCIgKSB7XFxuXFx0XFx0XFx0XFx0dmFsdWVzWyBpbmRleCBdID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcXFwiZGlzcGxheVxcXCIgKSB8fCBudWxsO1xcblxcdFxcdFxcdFxcdGlmICggIXZhbHVlc1sgaW5kZXggXSApIHtcXG5cXHRcXHRcXHRcXHRcXHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBcXFwiXFxcIjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcXFwiXFxcIiAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSApIHtcXG5cXHRcXHRcXHRcXHR2YWx1ZXNbIGluZGV4IF0gPSBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdGlmICggZGlzcGxheSAhPT0gXFxcIm5vbmVcXFwiICkge1xcblxcdFxcdFxcdFxcdHZhbHVlc1sgaW5kZXggXSA9IFxcXCJub25lXFxcIjtcXG5cXG5cXHRcXHRcXHRcXHQvLyBSZW1lbWJlciB3aGF0IHdlJ3JlIG92ZXJ3cml0aW5nXFxuXFx0XFx0XFx0XFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcXFwiZGlzcGxheVxcXCIsIGRpc3BsYXkgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3AgdG8gYXZvaWQgY29uc3RhbnQgcmVmbG93XFxuXFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcXG5cXHRcXHRpZiAoIHZhbHVlc1sgaW5kZXggXSAhPSBudWxsICkge1xcblxcdFxcdFxcdGVsZW1lbnRzWyBpbmRleCBdLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZXNbIGluZGV4IF07XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRyZXR1cm4gZWxlbWVudHM7XFxufVxcblxcbmpRdWVyeS5mbi5leHRlbmQoIHtcXG5cXHRzaG93OiBmdW5jdGlvbigpIHtcXG5cXHRcXHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMsIHRydWUgKTtcXG5cXHR9LFxcblxcdGhpZGU6IGZ1bmN0aW9uKCkge1xcblxcdFxcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xcblxcdH0sXFxuXFx0dG9nZ2xlOiBmdW5jdGlvbiggc3RhdGUgKSB7XFxuXFx0XFx0aWYgKCB0eXBlb2Ygc3RhdGUgPT09IFxcXCJib29sZWFuXFxcIiApIHtcXG5cXHRcXHRcXHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRpZiAoIGlzSGlkZGVuV2l0aGluVHJlZSggdGhpcyApICkge1xcblxcdFxcdFxcdFxcdGpRdWVyeSggdGhpcyApLnNob3coKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGpRdWVyeSggdGhpcyApLmhpZGUoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSApO1xcblxcdH1cXG59ICk7XFxudmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xcblxcbnZhciBydGFnTmFtZSA9ICggLzwoW2Etel1bXlxcXFwvXFxcXDA+XFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXSspL2kgKTtcXG5cXG52YXIgcnNjcmlwdFR5cGUgPSAoIC9eJHxebW9kdWxlJHxcXFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaSApO1xcblxcblxcblxcbi8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXFxudmFyIHdyYXBNYXAgPSB7XFxuXFxuXFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcXG5cXHRvcHRpb246IFsgMSwgXFxcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cXFwiLCBcXFwiPC9zZWxlY3Q+XFxcIiBdLFxcblxcblxcdC8vIFhIVE1MIHBhcnNlcnMgZG8gbm90IG1hZ2ljYWxseSBpbnNlcnQgZWxlbWVudHMgaW4gdGhlXFxuXFx0Ly8gc2FtZSB3YXkgdGhhdCB0YWcgc291cCBwYXJzZXJzIGRvLiBTbyB3ZSBjYW5ub3Qgc2hvcnRlblxcblxcdC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cXG5cXHR0aGVhZDogWyAxLCBcXFwiPHRhYmxlPlxcXCIsIFxcXCI8L3RhYmxlPlxcXCIgXSxcXG5cXHRjb2w6IFsgMiwgXFxcIjx0YWJsZT48Y29sZ3JvdXA+XFxcIiwgXFxcIjwvY29sZ3JvdXA+PC90YWJsZT5cXFwiIF0sXFxuXFx0dHI6IFsgMiwgXFxcIjx0YWJsZT48dGJvZHk+XFxcIiwgXFxcIjwvdGJvZHk+PC90YWJsZT5cXFwiIF0sXFxuXFx0dGQ6IFsgMywgXFxcIjx0YWJsZT48dGJvZHk+PHRyPlxcXCIsIFxcXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cXFwiIF0sXFxuXFxuXFx0X2RlZmF1bHQ6IFsgMCwgXFxcIlxcXCIsIFxcXCJcXFwiIF1cXG59O1xcblxcbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XFxud3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uO1xcblxcbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XFxud3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XFxuXFxuXFxuZnVuY3Rpb24gZ2V0QWxsKCBjb250ZXh0LCB0YWcgKSB7XFxuXFxuXFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxcblxcdC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKCMxNTE1MSlcXG5cXHR2YXIgcmV0O1xcblxcblxcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFxcXCJ1bmRlZmluZWRcXFwiICkge1xcblxcdFxcdHJldCA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcXFwiKlxcXCIgKTtcXG5cXG5cXHR9IGVsc2UgaWYgKCB0eXBlb2YgY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsICE9PSBcXFwidW5kZWZpbmVkXFxcIiApIHtcXG5cXHRcXHRyZXQgPSBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyB8fCBcXFwiKlxcXCIgKTtcXG5cXG5cXHR9IGVsc2Uge1xcblxcdFxcdHJldCA9IFtdO1xcblxcdH1cXG5cXG5cXHRpZiAoIHRhZyA9PT0gdW5kZWZpbmVkIHx8IHRhZyAmJiBub2RlTmFtZSggY29udGV4dCwgdGFnICkgKSB7XFxuXFx0XFx0cmV0dXJuIGpRdWVyeS5tZXJnZSggWyBjb250ZXh0IF0sIHJldCApO1xcblxcdH1cXG5cXG5cXHRyZXR1cm4gcmV0O1xcbn1cXG5cXG5cXG4vLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcXG5mdW5jdGlvbiBzZXRHbG9iYWxFdmFsKCBlbGVtcywgcmVmRWxlbWVudHMgKSB7XFxuXFx0dmFyIGkgPSAwLFxcblxcdFxcdGwgPSBlbGVtcy5sZW5ndGg7XFxuXFxuXFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xcblxcdFxcdGRhdGFQcml2LnNldChcXG5cXHRcXHRcXHRlbGVtc1sgaSBdLFxcblxcdFxcdFxcdFxcXCJnbG9iYWxFdmFsXFxcIixcXG5cXHRcXHRcXHQhcmVmRWxlbWVudHMgfHwgZGF0YVByaXYuZ2V0KCByZWZFbGVtZW50c1sgaSBdLCBcXFwiZ2xvYmFsRXZhbFxcXCIgKVxcblxcdFxcdCk7XFxuXFx0fVxcbn1cXG5cXG5cXG52YXIgcmh0bWwgPSAvPHwmIz9cXFxcdys7LztcXG5cXG5mdW5jdGlvbiBidWlsZEZyYWdtZW50KCBlbGVtcywgY29udGV4dCwgc2NyaXB0cywgc2VsZWN0aW9uLCBpZ25vcmVkICkge1xcblxcdHZhciBlbGVtLCB0bXAsIHRhZywgd3JhcCwgY29udGFpbnMsIGosXFxuXFx0XFx0ZnJhZ21lbnQgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcXG5cXHRcXHRub2RlcyA9IFtdLFxcblxcdFxcdGkgPSAwLFxcblxcdFxcdGwgPSBlbGVtcy5sZW5ndGg7XFxuXFxuXFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xcblxcdFxcdGVsZW0gPSBlbGVtc1sgaSBdO1xcblxcblxcdFxcdGlmICggZWxlbSB8fCBlbGVtID09PSAwICkge1xcblxcblxcdFxcdFxcdC8vIEFkZCBub2RlcyBkaXJlY3RseVxcblxcdFxcdFxcdGlmICggdG9UeXBlKCBlbGVtICkgPT09IFxcXCJvYmplY3RcXFwiICkge1xcblxcblxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxcblxcdFxcdFxcdFxcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcXG5cXHRcXHRcXHRcXHRqUXVlcnkubWVyZ2UoIG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gWyBlbGVtIF0gOiBlbGVtICk7XFxuXFxuXFx0XFx0XFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcXG5cXHRcXHRcXHRcXHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcXG5cXG5cXHRcXHRcXHQvLyBDb252ZXJ0IGh0bWwgaW50byBET00gbm9kZXNcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHRtcCA9IHRtcCB8fCBmcmFnbWVudC5hcHBlbmRDaGlsZCggY29udGV4dC5jcmVhdGVFbGVtZW50KCBcXFwiZGl2XFxcIiApICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxcblxcdFxcdFxcdFxcdHRhZyA9ICggcnRhZ05hbWUuZXhlYyggZWxlbSApIHx8IFsgXFxcIlxcXCIsIFxcXCJcXFwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCk7XFxuXFx0XFx0XFx0XFx0d3JhcCA9IHdyYXBNYXBbIHRhZyBdIHx8IHdyYXBNYXAuX2RlZmF1bHQ7XFxuXFx0XFx0XFx0XFx0dG1wLmlubmVySFRNTCA9IHdyYXBbIDEgXSArIGpRdWVyeS5odG1sUHJlZmlsdGVyKCBlbGVtICkgKyB3cmFwWyAyIF07XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRGVzY2VuZCB0aHJvdWdoIHdyYXBwZXJzIHRvIHRoZSByaWdodCBjb250ZW50XFxuXFx0XFx0XFx0XFx0aiA9IHdyYXBbIDAgXTtcXG5cXHRcXHRcXHRcXHR3aGlsZSAoIGotLSApIHtcXG5cXHRcXHRcXHRcXHRcXHR0bXAgPSB0bXAubGFzdENoaWxkO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcXG5cXHRcXHRcXHRcXHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XFxuXFx0XFx0XFx0XFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxcblxcdFxcdFxcdFxcdHRtcCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRW5zdXJlIHRoZSBjcmVhdGVkIG5vZGVzIGFyZSBvcnBoYW5lZCAoIzEyMzkyKVxcblxcdFxcdFxcdFxcdHRtcC50ZXh0Q29udGVudCA9IFxcXCJcXFwiO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdC8vIFJlbW92ZSB3cmFwcGVyIGZyb20gZnJhZ21lbnRcXG5cXHRmcmFnbWVudC50ZXh0Q29udGVudCA9IFxcXCJcXFwiO1xcblxcblxcdGkgPSAwO1xcblxcdHdoaWxlICggKCBlbGVtID0gbm9kZXNbIGkrKyBdICkgKSB7XFxuXFxuXFx0XFx0Ly8gU2tpcCBlbGVtZW50cyBhbHJlYWR5IGluIHRoZSBjb250ZXh0IGNvbGxlY3Rpb24gKHRyYWMtNDA4NylcXG5cXHRcXHRpZiAoIHNlbGVjdGlvbiAmJiBqUXVlcnkuaW5BcnJheSggZWxlbSwgc2VsZWN0aW9uICkgPiAtMSApIHtcXG5cXHRcXHRcXHRpZiAoIGlnbm9yZWQgKSB7XFxuXFx0XFx0XFx0XFx0aWdub3JlZC5wdXNoKCBlbGVtICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGNvbnRpbnVlO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRjb250YWlucyA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XFxuXFxuXFx0XFx0Ly8gQXBwZW5kIHRvIGZyYWdtZW50XFxuXFx0XFx0dG1wID0gZ2V0QWxsKCBmcmFnbWVudC5hcHBlbmRDaGlsZCggZWxlbSApLCBcXFwic2NyaXB0XFxcIiApO1xcblxcblxcdFxcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3RvcnlcXG5cXHRcXHRpZiAoIGNvbnRhaW5zICkge1xcblxcdFxcdFxcdHNldEdsb2JhbEV2YWwoIHRtcCApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBDYXB0dXJlIGV4ZWN1dGFibGVzXFxuXFx0XFx0aWYgKCBzY3JpcHRzICkge1xcblxcdFxcdFxcdGogPSAwO1xcblxcdFxcdFxcdHdoaWxlICggKCBlbGVtID0gdG1wWyBqKysgXSApICkge1xcblxcdFxcdFxcdFxcdGlmICggcnNjcmlwdFR5cGUudGVzdCggZWxlbS50eXBlIHx8IFxcXCJcXFwiICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0c2NyaXB0cy5wdXNoKCBlbGVtICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdHJldHVybiBmcmFnbWVudDtcXG59XFxuXFxuXFxuKCBmdW5jdGlvbigpIHtcXG5cXHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXFxuXFx0XFx0ZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFxcXCJkaXZcXFwiICkgKSxcXG5cXHRcXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFxcXCJpbnB1dFxcXCIgKTtcXG5cXG5cXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XFxuXFx0Ly8gQ2hlY2sgc3RhdGUgbG9zdCBpZiB0aGUgbmFtZSBpcyBzZXQgKCMxMTIxNylcXG5cXHQvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXFxuXFx0Ly8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICgjMTQ5MDEpXFxuXFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcXFwidHlwZVxcXCIsIFxcXCJyYWRpb1xcXCIgKTtcXG5cXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFxcXCJjaGVja2VkXFxcIiwgXFxcImNoZWNrZWRcXFwiICk7XFxuXFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcXFwibmFtZVxcXCIsIFxcXCJ0XFxcIiApO1xcblxcblxcdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcXG5cXG5cXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIG9ubHlcXG5cXHQvLyBPbGRlciBXZWJLaXQgZG9lc24ndCBjbG9uZSBjaGVja2VkIHN0YXRlIGNvcnJlY3RseSBpbiBmcmFnbWVudHNcXG5cXHRzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmNoZWNrZWQ7XFxuXFxuXFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XFxuXFx0Ly8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcXG5cXHRkaXYuaW5uZXJIVE1MID0gXFxcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cXFwiO1xcblxcdHN1cHBvcnQubm9DbG9uZUNoZWNrZWQgPSAhIWRpdi5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlO1xcbn0gKSgpO1xcbnZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XFxuXFxuXFxuXFxudmFyXFxuXFx0cmtleUV2ZW50ID0gL15rZXkvLFxcblxcdHJtb3VzZUV2ZW50ID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51fGRyYWd8ZHJvcCl8Y2xpY2svLFxcblxcdHJ0eXBlbmFtZXNwYWNlID0gL14oW14uXSopKD86XFxcXC4oLispfCkvO1xcblxcbmZ1bmN0aW9uIHJldHVyblRydWUoKSB7XFxuXFx0cmV0dXJuIHRydWU7XFxufVxcblxcbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xcblxcdHJldHVybiBmYWxzZTtcXG59XFxuXFxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcXG4vLyBTZWUgIzEzMzkzIGZvciBtb3JlIGluZm9cXG5mdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcXG5cXHR0cnkge1xcblxcdFxcdHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xcblxcdH0gY2F0Y2ggKCBlcnIgKSB7IH1cXG59XFxuXFxuZnVuY3Rpb24gb24oIGVsZW0sIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIG9uZSApIHtcXG5cXHR2YXIgb3JpZ0ZuLCB0eXBlO1xcblxcblxcdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xcblxcdGlmICggdHlwZW9mIHR5cGVzID09PSBcXFwib2JqZWN0XFxcIiApIHtcXG5cXG5cXHRcXHQvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxcblxcdFxcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcXFwic3RyaW5nXFxcIiApIHtcXG5cXG5cXHRcXHRcXHQvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXFxuXFx0XFx0XFx0ZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XFxuXFx0XFx0XFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XFxuXFx0XFx0fVxcblxcdFxcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XFxuXFx0XFx0XFx0b24oIGVsZW0sIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1sgdHlwZSBdLCBvbmUgKTtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIGVsZW07XFxuXFx0fVxcblxcblxcdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XFxuXFxuXFx0XFx0Ly8gKCB0eXBlcywgZm4gKVxcblxcdFxcdGZuID0gc2VsZWN0b3I7XFxuXFx0XFx0ZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xcblxcdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XFxuXFx0XFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFxcXCJzdHJpbmdcXFwiICkge1xcblxcblxcdFxcdFxcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXFxuXFx0XFx0XFx0Zm4gPSBkYXRhO1xcblxcdFxcdFxcdGRhdGEgPSB1bmRlZmluZWQ7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHQvLyAoIHR5cGVzLCBkYXRhLCBmbiApXFxuXFx0XFx0XFx0Zm4gPSBkYXRhO1xcblxcdFxcdFxcdGRhdGEgPSBzZWxlY3RvcjtcXG5cXHRcXHRcXHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcXG5cXHRcXHR9XFxuXFx0fVxcblxcdGlmICggZm4gPT09IGZhbHNlICkge1xcblxcdFxcdGZuID0gcmV0dXJuRmFsc2U7XFxuXFx0fSBlbHNlIGlmICggIWZuICkge1xcblxcdFxcdHJldHVybiBlbGVtO1xcblxcdH1cXG5cXG5cXHRpZiAoIG9uZSA9PT0gMSApIHtcXG5cXHRcXHRvcmlnRm4gPSBmbjtcXG5cXHRcXHRmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcXG5cXG5cXHRcXHRcXHQvLyBDYW4gdXNlIGFuIGVtcHR5IHNldCwgc2luY2UgZXZlbnQgY29udGFpbnMgdGhlIGluZm9cXG5cXHRcXHRcXHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XFxuXFx0XFx0XFx0cmV0dXJuIG9yaWdGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxcblxcdFxcdGZuLmd1aWQgPSBvcmlnRm4uZ3VpZCB8fCAoIG9yaWdGbi5ndWlkID0galF1ZXJ5Lmd1aWQrKyApO1xcblxcdH1cXG5cXHRyZXR1cm4gZWxlbS5lYWNoKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XFxuXFx0fSApO1xcbn1cXG5cXG4vKlxcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cXG4gKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxcbiAqL1xcbmpRdWVyeS5ldmVudCA9IHtcXG5cXG5cXHRnbG9iYWw6IHt9LFxcblxcblxcdGFkZDogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3RvciApIHtcXG5cXG5cXHRcXHR2YXIgaGFuZGxlT2JqSW4sIGV2ZW50SGFuZGxlLCB0bXAsXFxuXFx0XFx0XFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXFxuXFx0XFx0XFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxcblxcdFxcdFxcdGVsZW1EYXRhID0gZGF0YVByaXYuZ2V0KCBlbGVtICk7XFxuXFxuXFx0XFx0Ly8gRG9uJ3QgYXR0YWNoIGV2ZW50cyB0byBub0RhdGEgb3IgdGV4dC9jb21tZW50IG5vZGVzIChidXQgYWxsb3cgcGxhaW4gb2JqZWN0cylcXG5cXHRcXHRpZiAoICFlbGVtRGF0YSApIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxcblxcdFxcdGlmICggaGFuZGxlci5oYW5kbGVyICkge1xcblxcdFxcdFxcdGhhbmRsZU9iakluID0gaGFuZGxlcjtcXG5cXHRcXHRcXHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcXG5cXHRcXHRcXHRzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBFbnN1cmUgdGhhdCBpbnZhbGlkIHNlbGVjdG9ycyB0aHJvdyBleGNlcHRpb25zIGF0IGF0dGFjaCB0aW1lXFxuXFx0XFx0Ly8gRXZhbHVhdGUgYWdhaW5zdCBkb2N1bWVudEVsZW1lbnQgaW4gY2FzZSBlbGVtIGlzIGEgbm9uLWVsZW1lbnQgbm9kZSAoZS5nLiwgZG9jdW1lbnQpXFxuXFx0XFx0aWYgKCBzZWxlY3RvciApIHtcXG5cXHRcXHRcXHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGRvY3VtZW50RWxlbWVudCwgc2VsZWN0b3IgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXFxuXFx0XFx0aWYgKCAhaGFuZGxlci5ndWlkICkge1xcblxcdFxcdFxcdGhhbmRsZXIuZ3VpZCA9IGpRdWVyeS5ndWlkKys7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3RcXG5cXHRcXHRpZiAoICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xcblxcdFxcdFxcdGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyA9IHt9O1xcblxcdFxcdH1cXG5cXHRcXHRpZiAoICEoIGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlICkgKSB7XFxuXFx0XFx0XFx0ZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbiggZSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBEaXNjYXJkIHRoZSBzZWNvbmQgZXZlbnQgb2YgYSBqUXVlcnkuZXZlbnQudHJpZ2dlcigpIGFuZFxcblxcdFxcdFxcdFxcdC8vIHdoZW4gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gXFxcInVuZGVmaW5lZFxcXCIgJiYgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCAhPT0gZS50eXBlID9cXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoIGVsZW0sIGFyZ3VtZW50cyApIDogdW5kZWZpbmVkO1xcblxcdFxcdFxcdH07XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2VcXG5cXHRcXHR0eXBlcyA9ICggdHlwZXMgfHwgXFxcIlxcXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXFxcIlxcXCIgXTtcXG5cXHRcXHR0ID0gdHlwZXMubGVuZ3RoO1xcblxcdFxcdHdoaWxlICggdC0tICkge1xcblxcdFxcdFxcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcXG5cXHRcXHRcXHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcXG5cXHRcXHRcXHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcXFwiXFxcIiApLnNwbGl0KCBcXFwiLlxcXCIgKS5zb3J0KCk7XFxuXFxuXFx0XFx0XFx0Ly8gVGhlcmUgKm11c3QqIGJlIGEgdHlwZSwgbm8gYXR0YWNoaW5nIG5hbWVzcGFjZS1vbmx5IGhhbmRsZXJzXFxuXFx0XFx0XFx0aWYgKCAhdHlwZSApIHtcXG5cXHRcXHRcXHRcXHRjb250aW51ZTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gSWYgZXZlbnQgY2hhbmdlcyBpdHMgdHlwZSwgdXNlIHRoZSBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY2hhbmdlZCB0eXBlXFxuXFx0XFx0XFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XFxuXFxuXFx0XFx0XFx0Ly8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXFxuXFx0XFx0XFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xcblxcblxcdFxcdFxcdC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcXG5cXHRcXHRcXHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcXG5cXG5cXHRcXHRcXHQvLyBoYW5kbGVPYmogaXMgcGFzc2VkIHRvIGFsbCBldmVudCBoYW5kbGVyc1xcblxcdFxcdFxcdGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoIHtcXG5cXHRcXHRcXHRcXHR0eXBlOiB0eXBlLFxcblxcdFxcdFxcdFxcdG9yaWdUeXBlOiBvcmlnVHlwZSxcXG5cXHRcXHRcXHRcXHRkYXRhOiBkYXRhLFxcblxcdFxcdFxcdFxcdGhhbmRsZXI6IGhhbmRsZXIsXFxuXFx0XFx0XFx0XFx0Z3VpZDogaGFuZGxlci5ndWlkLFxcblxcdFxcdFxcdFxcdHNlbGVjdG9yOiBzZWxlY3RvcixcXG5cXHRcXHRcXHRcXHRuZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApLFxcblxcdFxcdFxcdFxcdG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKCBcXFwiLlxcXCIgKVxcblxcdFxcdFxcdH0sIGhhbmRsZU9iakluICk7XFxuXFxuXFx0XFx0XFx0Ly8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3RcXG5cXHRcXHRcXHRpZiAoICEoIGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gKSApIHtcXG5cXHRcXHRcXHRcXHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XFxuXFx0XFx0XFx0XFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXFxuXFx0XFx0XFx0XFx0aWYgKCAhc3BlY2lhbC5zZXR1cCB8fFxcblxcdFxcdFxcdFxcdFxcdHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggc3BlY2lhbC5hZGQgKSB7XFxuXFx0XFx0XFx0XFx0c3BlY2lhbC5hZGQuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCAhaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcXG5cXHRcXHRcXHRpZiAoIHNlbGVjdG9yICkge1xcblxcdFxcdFxcdFxcdGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXFxuXFx0XFx0XFx0alF1ZXJ5LmV2ZW50Lmdsb2JhbFsgdHlwZSBdID0gdHJ1ZTtcXG5cXHRcXHR9XFxuXFxuXFx0fSxcXG5cXG5cXHQvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcXG5cXHRyZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xcblxcblxcdFxcdHZhciBqLCBvcmlnQ291bnQsIHRtcCxcXG5cXHRcXHRcXHRldmVudHMsIHQsIGhhbmRsZU9iaixcXG5cXHRcXHRcXHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXFxuXFx0XFx0XFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICkgJiYgZGF0YVByaXYuZ2V0KCBlbGVtICk7XFxuXFxuXFx0XFx0aWYgKCAhZWxlbURhdGEgfHwgISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBPbmNlIGZvciBlYWNoIHR5cGUubmFtZXNwYWNlIGluIHR5cGVzOyB0eXBlIG1heSBiZSBvbWl0dGVkXFxuXFx0XFx0dHlwZXMgPSAoIHR5cGVzIHx8IFxcXCJcXFwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFxcXCJcXFwiIF07XFxuXFx0XFx0dCA9IHR5cGVzLmxlbmd0aDtcXG5cXHRcXHR3aGlsZSAoIHQtLSApIHtcXG5cXHRcXHRcXHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XFxuXFx0XFx0XFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XFxuXFx0XFx0XFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXFxcIlxcXCIgKS5zcGxpdCggXFxcIi5cXFwiICkuc29ydCgpO1xcblxcblxcdFxcdFxcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxcblxcdFxcdFxcdGlmICggIXR5cGUgKSB7XFxuXFx0XFx0XFx0XFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGNvbnRpbnVlO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcXG5cXHRcXHRcXHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XFxuXFx0XFx0XFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcXG5cXHRcXHRcXHR0bXAgPSB0bXBbIDIgXSAmJlxcblxcdFxcdFxcdFxcdG5ldyBSZWdFeHAoIFxcXCIoXnxcXFxcXFxcXC4pXFxcIiArIG5hbWVzcGFjZXMuam9pbiggXFxcIlxcXFxcXFxcLig/Oi4qXFxcXFxcXFwufClcXFwiICkgKyBcXFwiKFxcXFxcXFxcLnwkKVxcXCIgKTtcXG5cXG5cXHRcXHRcXHQvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXFxuXFx0XFx0XFx0b3JpZ0NvdW50ID0gaiA9IGhhbmRsZXJzLmxlbmd0aDtcXG5cXHRcXHRcXHR3aGlsZSAoIGotLSApIHtcXG5cXHRcXHRcXHRcXHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaiBdO1xcblxcblxcdFxcdFxcdFxcdGlmICggKCBtYXBwZWRUeXBlcyB8fCBvcmlnVHlwZSA9PT0gaGFuZGxlT2JqLm9yaWdUeXBlICkgJiZcXG5cXHRcXHRcXHRcXHRcXHQoICFoYW5kbGVyIHx8IGhhbmRsZXIuZ3VpZCA9PT0gaGFuZGxlT2JqLmd1aWQgKSAmJlxcblxcdFxcdFxcdFxcdFxcdCggIXRtcCB8fCB0bXAudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkgJiZcXG5cXHRcXHRcXHRcXHRcXHQoICFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8XFxuXFx0XFx0XFx0XFx0XFx0XFx0c2VsZWN0b3IgPT09IFxcXCIqKlxcXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aGFuZGxlcnMuc3BsaWNlKCBqLCAxICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBoYW5kbGVPYmouc2VsZWN0b3IgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHNwZWNpYWwucmVtb3ZlICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3RcXG5cXHRcXHRcXHQvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcXG5cXHRcXHRcXHRpZiAoIG9yaWdDb3VudCAmJiAhaGFuZGxlcnMubGVuZ3RoICkge1xcblxcdFxcdFxcdFxcdGlmICggIXNwZWNpYWwudGVhcmRvd24gfHxcXG5cXHRcXHRcXHRcXHRcXHRzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSApID09PSBmYWxzZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGVsZW1EYXRhLmhhbmRsZSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBSZW1vdmUgZGF0YSBhbmQgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxcblxcdFxcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGV2ZW50cyApICkge1xcblxcdFxcdFxcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXFxcImhhbmRsZSBldmVudHNcXFwiICk7XFxuXFx0XFx0fVxcblxcdH0sXFxuXFxuXFx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBuYXRpdmVFdmVudCApIHtcXG5cXG5cXHRcXHQvLyBNYWtlIGEgd3JpdGFibGUgalF1ZXJ5LkV2ZW50IGZyb20gdGhlIG5hdGl2ZSBldmVudCBvYmplY3RcXG5cXHRcXHR2YXIgZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KCBuYXRpdmVFdmVudCApO1xcblxcblxcdFxcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaiwgaGFuZGxlclF1ZXVlLFxcblxcdFxcdFxcdGFyZ3MgPSBuZXcgQXJyYXkoIGFyZ3VtZW50cy5sZW5ndGggKSxcXG5cXHRcXHRcXHRoYW5kbGVycyA9ICggZGF0YVByaXYuZ2V0KCB0aGlzLCBcXFwiZXZlbnRzXFxcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcXG5cXHRcXHRcXHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGV2ZW50LnR5cGUgXSB8fCB7fTtcXG5cXG5cXHRcXHQvLyBVc2UgdGhlIGZpeC1lZCBqUXVlcnkuRXZlbnQgcmF0aGVyIHRoYW4gdGhlIChyZWFkLW9ubHkpIG5hdGl2ZSBldmVudFxcblxcdFxcdGFyZ3NbIDAgXSA9IGV2ZW50O1xcblxcblxcdFxcdGZvciAoIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkge1xcblxcdFxcdFxcdGFyZ3NbIGkgXSA9IGFyZ3VtZW50c1sgaSBdO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRoaXM7XFxuXFxuXFx0XFx0Ly8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxcblxcdFxcdGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gRGV0ZXJtaW5lIGhhbmRsZXJzXFxuXFx0XFx0aGFuZGxlclF1ZXVlID0galF1ZXJ5LmV2ZW50LmhhbmRsZXJzLmNhbGwoIHRoaXMsIGV2ZW50LCBoYW5kbGVycyApO1xcblxcblxcdFxcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXFxuXFx0XFx0aSA9IDA7XFxuXFx0XFx0d2hpbGUgKCAoIG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XFxuXFx0XFx0XFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcXG5cXG5cXHRcXHRcXHRqID0gMDtcXG5cXHRcXHRcXHR3aGlsZSAoICggaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1sgaisrIF0gKSAmJlxcblxcdFxcdFxcdFxcdCFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xcblxcblxcdFxcdFxcdFxcdC8vIFRyaWdnZXJlZCBldmVudCBtdXN0IGVpdGhlciAxKSBoYXZlIG5vIG5hbWVzcGFjZSwgb3IgMikgaGF2ZSBuYW1lc3BhY2UocylcXG5cXHRcXHRcXHRcXHQvLyBhIHN1YnNldCBvciBlcXVhbCB0byB0aG9zZSBpbiB0aGUgYm91bmQgZXZlbnQgKGJvdGggY2FuIGhhdmUgbm8gbmFtZXNwYWNlKS5cXG5cXHRcXHRcXHRcXHRpZiAoICFldmVudC5ybmFtZXNwYWNlIHx8IGV2ZW50LnJuYW1lc3BhY2UudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcXG5cXHRcXHRcXHRcXHRcXHRldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0ID0gKCAoIGpRdWVyeS5ldmVudC5zcGVjaWFsWyBoYW5kbGVPYmoub3JpZ1R5cGUgXSB8fCB7fSApLmhhbmRsZSB8fFxcblxcdFxcdFxcdFxcdFxcdFxcdGhhbmRsZU9iai5oYW5kbGVyICkuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCAoIGV2ZW50LnJlc3VsdCA9IHJldCApID09PSBmYWxzZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQ2FsbCB0aGUgcG9zdERpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZVxcblxcdFxcdGlmICggc3BlY2lhbC5wb3N0RGlzcGF0Y2ggKSB7XFxuXFx0XFx0XFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcXG5cXHR9LFxcblxcblxcdGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xcblxcdFxcdHZhciBpLCBoYW5kbGVPYmosIHNlbCwgbWF0Y2hlZEhhbmRsZXJzLCBtYXRjaGVkU2VsZWN0b3JzLFxcblxcdFxcdFxcdGhhbmRsZXJRdWV1ZSA9IFtdLFxcblxcdFxcdFxcdGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxcblxcdFxcdFxcdGN1ciA9IGV2ZW50LnRhcmdldDtcXG5cXG5cXHRcXHQvLyBGaW5kIGRlbGVnYXRlIGhhbmRsZXJzXFxuXFx0XFx0aWYgKCBkZWxlZ2F0ZUNvdW50ICYmXFxuXFxuXFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUgPD05XFxuXFx0XFx0XFx0Ly8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKHRyYWMtMTMxODApXFxuXFx0XFx0XFx0Y3VyLm5vZGVUeXBlICYmXFxuXFxuXFx0XFx0XFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQyXFxuXFx0XFx0XFx0Ly8gU3VwcHJlc3Mgc3BlYy12aW9sYXRpbmcgY2xpY2tzIGluZGljYXRpbmcgYSBub24tcHJpbWFyeSBwb2ludGVyIGJ1dHRvbiAodHJhYy0zODYxKVxcblxcdFxcdFxcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50LXR5cGUtY2xpY2tcXG5cXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XFxuXFx0XFx0XFx0Ly8gLi4uYnV0IG5vdCBhcnJvdyBrZXkgXFxcImNsaWNrc1xcXCIgb2YgcmFkaW8gaW5wdXRzLCB3aGljaCBjYW4gaGF2ZSBgYnV0dG9uYCAtMSAoZ2gtMjM0MylcXG5cXHRcXHRcXHQhKCBldmVudC50eXBlID09PSBcXFwiY2xpY2tcXFwiICYmIGV2ZW50LmJ1dHRvbiA+PSAxICkgKSB7XFxuXFxuXFx0XFx0XFx0Zm9yICggOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRG9uJ3QgY2hlY2sgbm9uLWVsZW1lbnRzICgjMTMyMDgpXFxuXFx0XFx0XFx0XFx0Ly8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXFxuXFx0XFx0XFx0XFx0aWYgKCBjdXIubm9kZVR5cGUgPT09IDEgJiYgISggZXZlbnQudHlwZSA9PT0gXFxcImNsaWNrXFxcIiAmJiBjdXIuZGlzYWJsZWQgPT09IHRydWUgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRtYXRjaGVkSGFuZGxlcnMgPSBbXTtcXG5cXHRcXHRcXHRcXHRcXHRtYXRjaGVkU2VsZWN0b3JzID0ge307XFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxcblxcdFxcdFxcdFxcdFxcdFxcdHNlbCA9IGhhbmRsZU9iai5zZWxlY3RvciArIFxcXCIgXFxcIjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID09PSB1bmRlZmluZWQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+IC0xIDpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG1hdGNoZWRIYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmICggbWF0Y2hlZEhhbmRsZXJzLmxlbmd0aCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVkSGFuZGxlcnMgfSApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXFxuXFx0XFx0Y3VyID0gdGhpcztcXG5cXHRcXHRpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XFxuXFx0XFx0XFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogaGFuZGxlcnMuc2xpY2UoIGRlbGVnYXRlQ291bnQgKSB9ICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBoYW5kbGVyUXVldWU7XFxuXFx0fSxcXG5cXG5cXHRhZGRQcm9wOiBmdW5jdGlvbiggbmFtZSwgaG9vayApIHtcXG5cXHRcXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIGpRdWVyeS5FdmVudC5wcm90b3R5cGUsIG5hbWUsIHtcXG5cXHRcXHRcXHRlbnVtZXJhYmxlOiB0cnVlLFxcblxcdFxcdFxcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG5cXG5cXHRcXHRcXHRnZXQ6IGlzRnVuY3Rpb24oIGhvb2sgKSA/XFxuXFx0XFx0XFx0XFx0ZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGhvb2soIHRoaXMub3JpZ2luYWxFdmVudCApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9IDpcXG5cXHRcXHRcXHRcXHRmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5vcmlnaW5hbEV2ZW50WyBuYW1lIF07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XFxuXFx0XFx0XFx0XFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCBuYW1lLCB7XFxuXFx0XFx0XFx0XFx0XFx0ZW51bWVyYWJsZTogdHJ1ZSxcXG5cXHRcXHRcXHRcXHRcXHRjb25maWd1cmFibGU6IHRydWUsXFxuXFx0XFx0XFx0XFx0XFx0d3JpdGFibGU6IHRydWUsXFxuXFx0XFx0XFx0XFx0XFx0dmFsdWU6IHZhbHVlXFxuXFx0XFx0XFx0XFx0fSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9ICk7XFxuXFx0fSxcXG5cXG5cXHRmaXg6IGZ1bmN0aW9uKCBvcmlnaW5hbEV2ZW50ICkge1xcblxcdFxcdHJldHVybiBvcmlnaW5hbEV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cXG5cXHRcXHRcXHRvcmlnaW5hbEV2ZW50IDpcXG5cXHRcXHRcXHRuZXcgalF1ZXJ5LkV2ZW50KCBvcmlnaW5hbEV2ZW50ICk7XFxuXFx0fSxcXG5cXG5cXHRzcGVjaWFsOiB7XFxuXFx0XFx0bG9hZDoge1xcblxcblxcdFxcdFxcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcXG5cXHRcXHRcXHRub0J1YmJsZTogdHJ1ZVxcblxcdFxcdH0sXFxuXFx0XFx0Zm9jdXM6IHtcXG5cXG5cXHRcXHRcXHQvLyBGaXJlIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3RcXG5cXHRcXHRcXHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRpZiAoIHRoaXMgIT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5mb2N1cyApIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmZvY3VzKCk7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdGRlbGVnYXRlVHlwZTogXFxcImZvY3VzaW5cXFwiXFxuXFx0XFx0fSxcXG5cXHRcXHRibHVyOiB7XFxuXFx0XFx0XFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCB0aGlzID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuYmx1ciApIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmJsdXIoKTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0ZGVsZWdhdGVUeXBlOiBcXFwiZm9jdXNvdXRcXFwiXFxuXFx0XFx0fSxcXG5cXHRcXHRjbGljazoge1xcblxcblxcdFxcdFxcdC8vIEZvciBjaGVja2JveCwgZmlyZSBuYXRpdmUgZXZlbnQgc28gY2hlY2tlZCBzdGF0ZSB3aWxsIGJlIHJpZ2h0XFxuXFx0XFx0XFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCB0aGlzLnR5cGUgPT09IFxcXCJjaGVja2JveFxcXCIgJiYgdGhpcy5jbGljayAmJiBub2RlTmFtZSggdGhpcywgXFxcImlucHV0XFxcIiApICkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuY2xpY2soKTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIGRvbid0IGZpcmUgbmF0aXZlIC5jbGljaygpIG9uIGxpbmtzXFxuXFx0XFx0XFx0X2RlZmF1bHQ6IGZ1bmN0aW9uKCBldmVudCApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gbm9kZU5hbWUoIGV2ZW50LnRhcmdldCwgXFxcImFcXFwiICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0YmVmb3JldW5sb2FkOiB7XFxuXFx0XFx0XFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcXG5cXHRcXHRcXHRcXHQvLyBGaXJlZm94IGRvZXNuJ3QgYWxlcnQgaWYgdGhlIHJldHVyblZhbHVlIGZpZWxkIGlzIG5vdCBzZXQuXFxuXFx0XFx0XFx0XFx0aWYgKCBldmVudC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBldmVudC5vcmlnaW5hbEV2ZW50ICkge1xcblxcdFxcdFxcdFxcdFxcdGV2ZW50Lm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWUgPSBldmVudC5yZXN1bHQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcbn07XFxuXFxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcXG5cXG5cXHQvLyBUaGlzIFxcXCJpZlxcXCIgaXMgbmVlZGVkIGZvciBwbGFpbiBvYmplY3RzXFxuXFx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XFxuXFx0XFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUgKTtcXG5cXHR9XFxufTtcXG5cXG5qUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcXG5cXG5cXHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcXG5cXHRpZiAoICEoIHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQgKSApIHtcXG5cXHRcXHRyZXR1cm4gbmV3IGpRdWVyeS5FdmVudCggc3JjLCBwcm9wcyApO1xcblxcdH1cXG5cXG5cXHQvLyBFdmVudCBvYmplY3RcXG5cXHRpZiAoIHNyYyAmJiBzcmMudHlwZSApIHtcXG5cXHRcXHR0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XFxuXFx0XFx0dGhpcy50eXBlID0gc3JjLnR5cGU7XFxuXFxuXFx0XFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcXG5cXHRcXHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cXG5cXHRcXHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XFxuXFx0XFx0XFx0XFx0c3JjLmRlZmF1bHRQcmV2ZW50ZWQgPT09IHVuZGVmaW5lZCAmJlxcblxcblxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seVxcblxcdFxcdFxcdFxcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgP1xcblxcdFxcdFxcdHJldHVyblRydWUgOlxcblxcdFxcdFxcdHJldHVybkZhbHNlO1xcblxcblxcdFxcdC8vIENyZWF0ZSB0YXJnZXQgcHJvcGVydGllc1xcblxcdFxcdC8vIFN1cHBvcnQ6IFNhZmFyaSA8PTYgLSA3IG9ubHlcXG5cXHRcXHQvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAoIzUwNCwgIzEzMTQzKVxcblxcdFxcdHRoaXMudGFyZ2V0ID0gKCBzcmMudGFyZ2V0ICYmIHNyYy50YXJnZXQubm9kZVR5cGUgPT09IDMgKSA/XFxuXFx0XFx0XFx0c3JjLnRhcmdldC5wYXJlbnROb2RlIDpcXG5cXHRcXHRcXHRzcmMudGFyZ2V0O1xcblxcblxcdFxcdHRoaXMuY3VycmVudFRhcmdldCA9IHNyYy5jdXJyZW50VGFyZ2V0O1xcblxcdFxcdHRoaXMucmVsYXRlZFRhcmdldCA9IHNyYy5yZWxhdGVkVGFyZ2V0O1xcblxcblxcdC8vIEV2ZW50IHR5cGVcXG5cXHR9IGVsc2Uge1xcblxcdFxcdHRoaXMudHlwZSA9IHNyYztcXG5cXHR9XFxuXFxuXFx0Ly8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3RcXG5cXHRpZiAoIHByb3BzICkge1xcblxcdFxcdGpRdWVyeS5leHRlbmQoIHRoaXMsIHByb3BzICk7XFxuXFx0fVxcblxcblxcdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXFxuXFx0dGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xcblxcblxcdC8vIE1hcmsgaXQgYXMgZml4ZWRcXG5cXHR0aGlzWyBqUXVlcnkuZXhwYW5kbyBdID0gdHJ1ZTtcXG59O1xcblxcbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xcblxcdGNvbnN0cnVjdG9yOiBqUXVlcnkuRXZlbnQsXFxuXFx0aXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcXG5cXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXFxuXFx0aXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxcblxcdGlzU2ltdWxhdGVkOiBmYWxzZSxcXG5cXG5cXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XFxuXFx0XFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XFxuXFxuXFx0XFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xcblxcblxcdFxcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcXG5cXHRcXHRcXHRlLnByZXZlbnREZWZhdWx0KCk7XFxuXFx0XFx0fVxcblxcdH0sXFxuXFx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcXG5cXHRcXHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcXG5cXG5cXHRcXHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcXG5cXG5cXHRcXHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XFxuXFx0XFx0XFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcXG5cXHRcXHR9XFxuXFx0fSxcXG5cXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xcblxcdFxcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xcblxcblxcdFxcdHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xcblxcblxcdFxcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcXG5cXHRcXHRcXHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xcblxcdH1cXG59O1xcblxcbi8vIEluY2x1ZGVzIGFsbCBjb21tb24gZXZlbnQgcHJvcHMgaW5jbHVkaW5nIEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50IHNwZWNpZmljIHByb3BzXFxualF1ZXJ5LmVhY2goIHtcXG5cXHRhbHRLZXk6IHRydWUsXFxuXFx0YnViYmxlczogdHJ1ZSxcXG5cXHRjYW5jZWxhYmxlOiB0cnVlLFxcblxcdGNoYW5nZWRUb3VjaGVzOiB0cnVlLFxcblxcdGN0cmxLZXk6IHRydWUsXFxuXFx0ZGV0YWlsOiB0cnVlLFxcblxcdGV2ZW50UGhhc2U6IHRydWUsXFxuXFx0bWV0YUtleTogdHJ1ZSxcXG5cXHRwYWdlWDogdHJ1ZSxcXG5cXHRwYWdlWTogdHJ1ZSxcXG5cXHRzaGlmdEtleTogdHJ1ZSxcXG5cXHR2aWV3OiB0cnVlLFxcblxcdFxcXCJjaGFyXFxcIjogdHJ1ZSxcXG5cXHRjaGFyQ29kZTogdHJ1ZSxcXG5cXHRrZXk6IHRydWUsXFxuXFx0a2V5Q29kZTogdHJ1ZSxcXG5cXHRidXR0b246IHRydWUsXFxuXFx0YnV0dG9uczogdHJ1ZSxcXG5cXHRjbGllbnRYOiB0cnVlLFxcblxcdGNsaWVudFk6IHRydWUsXFxuXFx0b2Zmc2V0WDogdHJ1ZSxcXG5cXHRvZmZzZXRZOiB0cnVlLFxcblxcdHBvaW50ZXJJZDogdHJ1ZSxcXG5cXHRwb2ludGVyVHlwZTogdHJ1ZSxcXG5cXHRzY3JlZW5YOiB0cnVlLFxcblxcdHNjcmVlblk6IHRydWUsXFxuXFx0dGFyZ2V0VG91Y2hlczogdHJ1ZSxcXG5cXHR0b0VsZW1lbnQ6IHRydWUsXFxuXFx0dG91Y2hlczogdHJ1ZSxcXG5cXG5cXHR3aGljaDogZnVuY3Rpb24oIGV2ZW50ICkge1xcblxcdFxcdHZhciBidXR0b24gPSBldmVudC5idXR0b247XFxuXFxuXFx0XFx0Ly8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXFxuXFx0XFx0aWYgKCBldmVudC53aGljaCA9PSBudWxsICYmIHJrZXlFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGV2ZW50LmNoYXJDb2RlICE9IG51bGwgPyBldmVudC5jaGFyQ29kZSA6IGV2ZW50LmtleUNvZGU7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcXG5cXHRcXHRpZiAoICFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCAmJiBybW91c2VFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XFxuXFx0XFx0XFx0aWYgKCBidXR0b24gJiAxICkge1xcblxcdFxcdFxcdFxcdHJldHVybiAxO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIGJ1dHRvbiAmIDIgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIDM7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggYnV0dG9uICYgNCApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gMjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIDA7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBldmVudC53aGljaDtcXG5cXHR9XFxufSwgalF1ZXJ5LmV2ZW50LmFkZFByb3AgKTtcXG5cXG4vLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3NcXG4vLyBzbyB0aGF0IGV2ZW50IGRlbGVnYXRpb24gd29ya3MgaW4galF1ZXJ5Llxcbi8vIERvIHRoZSBzYW1lIGZvciBwb2ludGVyZW50ZXIvcG9pbnRlcmxlYXZlIGFuZCBwb2ludGVyb3Zlci9wb2ludGVyb3V0XFxuLy9cXG4vLyBTdXBwb3J0OiBTYWZhcmkgNyBvbmx5XFxuLy8gU2FmYXJpIHNlbmRzIG1vdXNlZW50ZXIgdG9vIG9mdGVuOyBzZWU6XFxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDcwMjU4XFxuLy8gZm9yIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYnVnIChpdCBleGlzdGVkIGluIG9sZGVyIENocm9tZSB2ZXJzaW9ucyBhcyB3ZWxsKS5cXG5qUXVlcnkuZWFjaCgge1xcblxcdG1vdXNlZW50ZXI6IFxcXCJtb3VzZW92ZXJcXFwiLFxcblxcdG1vdXNlbGVhdmU6IFxcXCJtb3VzZW91dFxcXCIsXFxuXFx0cG9pbnRlcmVudGVyOiBcXFwicG9pbnRlcm92ZXJcXFwiLFxcblxcdHBvaW50ZXJsZWF2ZTogXFxcInBvaW50ZXJvdXRcXFwiXFxufSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcXG5cXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgb3JpZyBdID0ge1xcblxcdFxcdGRlbGVnYXRlVHlwZTogZml4LFxcblxcdFxcdGJpbmRUeXBlOiBmaXgsXFxuXFxuXFx0XFx0aGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XFxuXFx0XFx0XFx0dmFyIHJldCxcXG5cXHRcXHRcXHRcXHR0YXJnZXQgPSB0aGlzLFxcblxcdFxcdFxcdFxcdHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxcblxcdFxcdFxcdFxcdGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcXG5cXG5cXHRcXHRcXHQvLyBGb3IgbW91c2VlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxcblxcdFxcdFxcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XFxuXFx0XFx0XFx0aWYgKCAhcmVsYXRlZCB8fCAoIHJlbGF0ZWQgIT09IHRhcmdldCAmJiAhalF1ZXJ5LmNvbnRhaW5zKCB0YXJnZXQsIHJlbGF0ZWQgKSApICkge1xcblxcdFxcdFxcdFxcdGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XFxuXFx0XFx0XFx0XFx0cmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xcblxcdFxcdFxcdFxcdGV2ZW50LnR5cGUgPSBmaXg7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiByZXQ7XFxuXFx0XFx0fVxcblxcdH07XFxufSApO1xcblxcbmpRdWVyeS5mbi5leHRlbmQoIHtcXG5cXG5cXHRvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XFxuXFx0XFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XFxuXFx0fSxcXG5cXHRvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xcblxcdFxcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgMSApO1xcblxcdH0sXFxuXFx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcXG5cXHRcXHR2YXIgaGFuZGxlT2JqLCB0eXBlO1xcblxcdFxcdGlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkge1xcblxcblxcdFxcdFxcdC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcXG5cXHRcXHRcXHRoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XFxuXFx0XFx0XFx0alF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcXG5cXHRcXHRcXHRcXHRoYW5kbGVPYmoubmFtZXNwYWNlID9cXG5cXHRcXHRcXHRcXHRcXHRoYW5kbGVPYmoub3JpZ1R5cGUgKyBcXFwiLlxcXCIgKyBoYW5kbGVPYmoubmFtZXNwYWNlIDpcXG5cXHRcXHRcXHRcXHRcXHRoYW5kbGVPYmoub3JpZ1R5cGUsXFxuXFx0XFx0XFx0XFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxcblxcdFxcdFxcdFxcdGhhbmRsZU9iai5oYW5kbGVyXFxuXFx0XFx0XFx0KTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHR9XFxuXFx0XFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFxcXCJvYmplY3RcXFwiICkge1xcblxcblxcdFxcdFxcdC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXFxuXFx0XFx0XFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcXG5cXHRcXHRcXHRcXHR0aGlzLm9mZiggdHlwZSwgc2VsZWN0b3IsIHR5cGVzWyB0eXBlIF0gKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0fVxcblxcdFxcdGlmICggc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXFxcImZ1bmN0aW9uXFxcIiApIHtcXG5cXG5cXHRcXHRcXHQvLyAoIHR5cGVzIFssIGZuXSApXFxuXFx0XFx0XFx0Zm4gPSBzZWxlY3RvcjtcXG5cXHRcXHRcXHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcXG5cXHRcXHR9XFxuXFx0XFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XFxuXFx0XFx0XFx0Zm4gPSByZXR1cm5GYWxzZTtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xcblxcdFxcdH0gKTtcXG5cXHR9XFxufSApO1xcblxcblxcbnZhclxcblxcblxcdC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cXG5cXG5cXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzbGludC9lc2xpbnQvaXNzdWVzLzMyMjlcXG5cXHRyeGh0bWxUYWcgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbYS16XVteXFxcXC9cXFxcMD5cXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdKilbXj5dKilcXFxcLz4vZ2ksXFxuXFxuXFx0LyogZXNsaW50LWVuYWJsZSAqL1xcblxcblxcdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSwgRWRnZSAxMiAtIDEzIG9ubHlcXG5cXHQvLyBJbiBJRS9FZGdlIHVzaW5nIHJlZ2V4IGdyb3VwcyBoZXJlIGNhdXNlcyBzZXZlcmUgc2xvd2Rvd25zLlxcblxcdC8vIFNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzE3MzY1MTIvXFxuXFx0cm5vSW5uZXJodG1sID0gLzxzY3JpcHR8PHN0eWxlfDxsaW5rL2ksXFxuXFxuXFx0Ly8gY2hlY2tlZD1cXFwiY2hlY2tlZFxcXCIgb3IgY2hlY2tlZFxcblxcdHJjaGVja2VkID0gL2NoZWNrZWRcXFxccyooPzpbXj1dfD1cXFxccyouY2hlY2tlZC4pL2ksXFxuXFx0cmNsZWFuU2NyaXB0ID0gL15cXFxccyo8ISg/OlxcXFxbQ0RBVEFcXFxcW3wtLSl8KD86XFxcXF1cXFxcXXwtLSk+XFxcXHMqJC9nO1xcblxcbi8vIFByZWZlciBhIHRib2R5IG92ZXIgaXRzIHBhcmVudCB0YWJsZSBmb3IgY29udGFpbmluZyBuZXcgcm93c1xcbmZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldCggZWxlbSwgY29udGVudCApIHtcXG5cXHRpZiAoIG5vZGVOYW1lKCBlbGVtLCBcXFwidGFibGVcXFwiICkgJiZcXG5cXHRcXHRub2RlTmFtZSggY29udGVudC5ub2RlVHlwZSAhPT0gMTEgPyBjb250ZW50IDogY29udGVudC5maXJzdENoaWxkLCBcXFwidHJcXFwiICkgKSB7XFxuXFxuXFx0XFx0cmV0dXJuIGpRdWVyeSggZWxlbSApLmNoaWxkcmVuKCBcXFwidGJvZHlcXFwiIClbIDAgXSB8fCBlbGVtO1xcblxcdH1cXG5cXG5cXHRyZXR1cm4gZWxlbTtcXG59XFxuXFxuLy8gUmVwbGFjZS9yZXN0b3JlIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiBzY3JpcHQgZWxlbWVudHMgZm9yIHNhZmUgRE9NIG1hbmlwdWxhdGlvblxcbmZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XFxuXFx0ZWxlbS50eXBlID0gKCBlbGVtLmdldEF0dHJpYnV0ZSggXFxcInR5cGVcXFwiICkgIT09IG51bGwgKSArIFxcXCIvXFxcIiArIGVsZW0udHlwZTtcXG5cXHRyZXR1cm4gZWxlbTtcXG59XFxuZnVuY3Rpb24gcmVzdG9yZVNjcmlwdCggZWxlbSApIHtcXG5cXHRpZiAoICggZWxlbS50eXBlIHx8IFxcXCJcXFwiICkuc2xpY2UoIDAsIDUgKSA9PT0gXFxcInRydWUvXFxcIiApIHtcXG5cXHRcXHRlbGVtLnR5cGUgPSBlbGVtLnR5cGUuc2xpY2UoIDUgKTtcXG5cXHR9IGVsc2Uge1xcblxcdFxcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBcXFwidHlwZVxcXCIgKTtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIGVsZW07XFxufVxcblxcbmZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XFxuXFx0dmFyIGksIGwsIHR5cGUsIHBkYXRhT2xkLCBwZGF0YUN1ciwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XFxuXFxuXFx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xcblxcdFxcdHJldHVybjtcXG5cXHR9XFxuXFxuXFx0Ly8gMS4gQ29weSBwcml2YXRlIGRhdGE6IGV2ZW50cywgaGFuZGxlcnMsIGV0Yy5cXG5cXHRpZiAoIGRhdGFQcml2Lmhhc0RhdGEoIHNyYyApICkge1xcblxcdFxcdHBkYXRhT2xkID0gZGF0YVByaXYuYWNjZXNzKCBzcmMgKTtcXG5cXHRcXHRwZGF0YUN1ciA9IGRhdGFQcml2LnNldCggZGVzdCwgcGRhdGFPbGQgKTtcXG5cXHRcXHRldmVudHMgPSBwZGF0YU9sZC5ldmVudHM7XFxuXFxuXFx0XFx0aWYgKCBldmVudHMgKSB7XFxuXFx0XFx0XFx0ZGVsZXRlIHBkYXRhQ3VyLmhhbmRsZTtcXG5cXHRcXHRcXHRwZGF0YUN1ci5ldmVudHMgPSB7fTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcXG5cXHRcXHRcXHRcXHRmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuZXZlbnQuYWRkKCBkZXN0LCB0eXBlLCBldmVudHNbIHR5cGUgXVsgaSBdICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdC8vIDIuIENvcHkgdXNlciBkYXRhXFxuXFx0aWYgKCBkYXRhVXNlci5oYXNEYXRhKCBzcmMgKSApIHtcXG5cXHRcXHR1ZGF0YU9sZCA9IGRhdGFVc2VyLmFjY2Vzcyggc3JjICk7XFxuXFx0XFx0dWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgdWRhdGFPbGQgKTtcXG5cXG5cXHRcXHRkYXRhVXNlci5zZXQoIGRlc3QsIHVkYXRhQ3VyICk7XFxuXFx0fVxcbn1cXG5cXG4vLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcXG5mdW5jdGlvbiBmaXhJbnB1dCggc3JjLCBkZXN0ICkge1xcblxcdHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcXG5cXG5cXHQvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cXG5cXHRpZiAoIG5vZGVOYW1lID09PSBcXFwiaW5wdXRcXFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XFxuXFx0XFx0ZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XFxuXFxuXFx0Ly8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcXG5cXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXFxcImlucHV0XFxcIiB8fCBub2RlTmFtZSA9PT0gXFxcInRleHRhcmVhXFxcIiApIHtcXG5cXHRcXHRkZXN0LmRlZmF1bHRWYWx1ZSA9IHNyYy5kZWZhdWx0VmFsdWU7XFxuXFx0fVxcbn1cXG5cXG5mdW5jdGlvbiBkb21NYW5pcCggY29sbGVjdGlvbiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKSB7XFxuXFxuXFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xcblxcdGFyZ3MgPSBjb25jYXQuYXBwbHkoIFtdLCBhcmdzICk7XFxuXFxuXFx0dmFyIGZyYWdtZW50LCBmaXJzdCwgc2NyaXB0cywgaGFzU2NyaXB0cywgbm9kZSwgZG9jLFxcblxcdFxcdGkgPSAwLFxcblxcdFxcdGwgPSBjb2xsZWN0aW9uLmxlbmd0aCxcXG5cXHRcXHRpTm9DbG9uZSA9IGwgLSAxLFxcblxcdFxcdHZhbHVlID0gYXJnc1sgMCBdLFxcblxcdFxcdHZhbHVlSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIHZhbHVlICk7XFxuXFxuXFx0Ly8gV2UgY2FuJ3QgY2xvbmVOb2RlIGZyYWdtZW50cyB0aGF0IGNvbnRhaW4gY2hlY2tlZCwgaW4gV2ViS2l0XFxuXFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gfHxcXG5cXHRcXHRcXHQoIGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXFxcInN0cmluZ1xcXCIgJiZcXG5cXHRcXHRcXHRcXHQhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcXG5cXHRcXHRyZXR1cm4gY29sbGVjdGlvbi5lYWNoKCBmdW5jdGlvbiggaW5kZXggKSB7XFxuXFx0XFx0XFx0dmFyIHNlbGYgPSBjb2xsZWN0aW9uLmVxKCBpbmRleCApO1xcblxcdFxcdFxcdGlmICggdmFsdWVJc0Z1bmN0aW9uICkge1xcblxcdFxcdFxcdFxcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRkb21NYW5pcCggc2VsZiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKTtcXG5cXHRcXHR9ICk7XFxuXFx0fVxcblxcblxcdGlmICggbCApIHtcXG5cXHRcXHRmcmFnbWVudCA9IGJ1aWxkRnJhZ21lbnQoIGFyZ3MsIGNvbGxlY3Rpb25bIDAgXS5vd25lckRvY3VtZW50LCBmYWxzZSwgY29sbGVjdGlvbiwgaWdub3JlZCApO1xcblxcdFxcdGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcXG5cXG5cXHRcXHRpZiAoIGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICkge1xcblxcdFxcdFxcdGZyYWdtZW50ID0gZmlyc3Q7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFJlcXVpcmUgZWl0aGVyIG5ldyBjb250ZW50IG9yIGFuIGludGVyZXN0IGluIGlnbm9yZWQgZWxlbWVudHMgdG8gaW52b2tlIHRoZSBjYWxsYmFja1xcblxcdFxcdGlmICggZmlyc3QgfHwgaWdub3JlZCApIHtcXG5cXHRcXHRcXHRzY3JpcHRzID0galF1ZXJ5Lm1hcCggZ2V0QWxsKCBmcmFnbWVudCwgXFxcInNjcmlwdFxcXCIgKSwgZGlzYWJsZVNjcmlwdCApO1xcblxcdFxcdFxcdGhhc1NjcmlwdHMgPSBzY3JpcHRzLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXFxuXFx0XFx0XFx0Ly8gaW5zdGVhZCBvZiB0aGUgZmlyc3QgYmVjYXVzZSBpdCBjYW4gZW5kIHVwXFxuXFx0XFx0XFx0Ly8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cXG5cXHRcXHRcXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XFxuXFx0XFx0XFx0XFx0bm9kZSA9IGZyYWdtZW50O1xcblxcblxcdFxcdFxcdFxcdGlmICggaSAhPT0gaU5vQ2xvbmUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0bm9kZSA9IGpRdWVyeS5jbG9uZSggbm9kZSwgdHJ1ZSwgdHJ1ZSApO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGhhc1NjcmlwdHMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxcblxcdFxcdFxcdFxcdFxcdFxcdGpRdWVyeS5tZXJnZSggc2NyaXB0cywgZ2V0QWxsKCBub2RlLCBcXFwic2NyaXB0XFxcIiApICk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRjYWxsYmFjay5jYWxsKCBjb2xsZWN0aW9uWyBpIF0sIG5vZGUsIGkgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBoYXNTY3JpcHRzICkge1xcblxcdFxcdFxcdFxcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xcblxcdFxcdFxcdFxcdGpRdWVyeS5tYXAoIHNjcmlwdHMsIHJlc3RvcmVTY3JpcHQgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBFdmFsdWF0ZSBleGVjdXRhYmxlIHNjcmlwdHMgb24gZmlyc3QgZG9jdW1lbnQgaW5zZXJ0aW9uXFxuXFx0XFx0XFx0XFx0Zm9yICggaSA9IDA7IGkgPCBoYXNTY3JpcHRzOyBpKysgKSB7XFxuXFx0XFx0XFx0XFx0XFx0bm9kZSA9IHNjcmlwdHNbIGkgXTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIG5vZGUudHlwZSB8fCBcXFwiXFxcIiApICYmXFxuXFx0XFx0XFx0XFx0XFx0XFx0IWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXFxcImdsb2JhbEV2YWxcXFwiICkgJiZcXG5cXHRcXHRcXHRcXHRcXHRcXHRqUXVlcnkuY29udGFpbnMoIGRvYywgbm9kZSApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggbm9kZS5zcmMgJiYgKCBub2RlLnR5cGUgfHwgXFxcIlxcXCIgKS50b0xvd2VyQ2FzZSgpICAhPT0gXFxcIm1vZHVsZVxcXCIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGpRdWVyeS5fZXZhbFVybCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0RE9NRXZhbCggbm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKCByY2xlYW5TY3JpcHQsIFxcXCJcXFwiICksIGRvYywgbm9kZSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdHJldHVybiBjb2xsZWN0aW9uO1xcbn1cXG5cXG5mdW5jdGlvbiByZW1vdmUoIGVsZW0sIHNlbGVjdG9yLCBrZWVwRGF0YSApIHtcXG5cXHR2YXIgbm9kZSxcXG5cXHRcXHRub2RlcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIGVsZW0gKSA6IGVsZW0sXFxuXFx0XFx0aSA9IDA7XFxuXFxuXFx0Zm9yICggOyAoIG5vZGUgPSBub2Rlc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xcblxcdFxcdGlmICggIWtlZXBEYXRhICYmIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XFxuXFx0XFx0XFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBub2RlICkgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBub2RlLnBhcmVudE5vZGUgKSB7XFxuXFx0XFx0XFx0aWYgKCBrZWVwRGF0YSAmJiBqUXVlcnkuY29udGFpbnMoIG5vZGUub3duZXJEb2N1bWVudCwgbm9kZSApICkge1xcblxcdFxcdFxcdFxcdHNldEdsb2JhbEV2YWwoIGdldEFsbCggbm9kZSwgXFxcInNjcmlwdFxcXCIgKSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdHJldHVybiBlbGVtO1xcbn1cXG5cXG5qUXVlcnkuZXh0ZW5kKCB7XFxuXFx0aHRtbFByZWZpbHRlcjogZnVuY3Rpb24oIGh0bWwgKSB7XFxuXFx0XFx0cmV0dXJuIGh0bWwucmVwbGFjZSggcnhodG1sVGFnLCBcXFwiPCQxPjwvJDI+XFxcIiApO1xcblxcdH0sXFxuXFxuXFx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcXG5cXHRcXHR2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcXG5cXHRcXHRcXHRjbG9uZSA9IGVsZW0uY2xvbmVOb2RlKCB0cnVlICksXFxuXFx0XFx0XFx0aW5QYWdlID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcXG5cXG5cXHRcXHQvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcXG5cXHRcXHRpZiAoICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSApICYmXFxuXFx0XFx0XFx0XFx0IWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xcblxcblxcdFxcdFxcdC8vIFdlIGVzY2hldyBTaXp6bGUgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczogaHR0cHM6Ly9qc3BlcmYuY29tL2dldGFsbC12cy1zaXp6bGUvMlxcblxcdFxcdFxcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcXG5cXHRcXHRcXHRzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xcblxcblxcdFxcdFxcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xcblxcdFxcdFxcdFxcdGZpeElucHV0KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxcblxcdFxcdGlmICggZGF0YUFuZEV2ZW50cyApIHtcXG5cXHRcXHRcXHRpZiAoIGRlZXBEYXRhQW5kRXZlbnRzICkge1xcblxcdFxcdFxcdFxcdHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XFxuXFx0XFx0XFx0XFx0ZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcXG5cXHRcXHRcXHRcXHRcXHRjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRjbG9uZUNvcHlFdmVudCggZWxlbSwgY2xvbmUgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3RvcnlcXG5cXHRcXHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCBcXFwic2NyaXB0XFxcIiApO1xcblxcdFxcdGlmICggZGVzdEVsZW1lbnRzLmxlbmd0aCA+IDAgKSB7XFxuXFx0XFx0XFx0c2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXFxcInNjcmlwdFxcXCIgKSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcXG5cXHRcXHRyZXR1cm4gY2xvbmU7XFxuXFx0fSxcXG5cXG5cXHRjbGVhbkRhdGE6IGZ1bmN0aW9uKCBlbGVtcyApIHtcXG5cXHRcXHR2YXIgZGF0YSwgZWxlbSwgdHlwZSxcXG5cXHRcXHRcXHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWwsXFxuXFx0XFx0XFx0aSA9IDA7XFxuXFxuXFx0XFx0Zm9yICggOyAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT09IHVuZGVmaW5lZDsgaSsrICkge1xcblxcdFxcdFxcdGlmICggYWNjZXB0RGF0YSggZWxlbSApICkge1xcblxcdFxcdFxcdFxcdGlmICggKCBkYXRhID0gZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBkYXRhLmV2ZW50cyApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCB0eXBlIGluIGRhdGEuZXZlbnRzICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggc3BlY2lhbFsgdHlwZSBdICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcXG5cXHRcXHRcXHRcXHRcXHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcXG5cXHRcXHRcXHRcXHRcXHRlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmICggZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXFxuXFx0XFx0XFx0XFx0XFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXFxuXFx0XFx0XFx0XFx0XFx0ZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG59ICk7XFxuXFxualF1ZXJ5LmZuLmV4dGVuZCgge1xcblxcdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xcblxcdFxcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yLCB0cnVlICk7XFxuXFx0fSxcXG5cXG5cXHRyZW1vdmU6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcXG5cXHRcXHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciApO1xcblxcdH0sXFxuXFxuXFx0dGV4dDogZnVuY3Rpb24oIHZhbHVlICkge1xcblxcdFxcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XFxuXFx0XFx0XFx0XFx0alF1ZXJ5LnRleHQoIHRoaXMgKSA6XFxuXFx0XFx0XFx0XFx0dGhpcy5lbXB0eSgpLmVhY2goIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdFxcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSApO1xcblxcdFxcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XFxuXFx0fSxcXG5cXG5cXHRhcHBlbmQ6IGZ1bmN0aW9uKCkge1xcblxcdFxcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcXG5cXHRcXHRcXHRcXHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XFxuXFx0XFx0XFx0XFx0dGFyZ2V0LmFwcGVuZENoaWxkKCBlbGVtICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gKTtcXG5cXHR9LFxcblxcblxcdHByZXBlbmQ6IGZ1bmN0aW9uKCkge1xcblxcdFxcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcXG5cXHRcXHRcXHRcXHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XFxuXFx0XFx0XFx0XFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSApO1xcblxcdH0sXFxuXFxuXFx0YmVmb3JlOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9ICk7XFxuXFx0fSxcXG5cXG5cXHRhZnRlcjogZnVuY3Rpb24oKSB7XFxuXFx0XFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xcblxcdFxcdFxcdFxcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSApO1xcblxcdH0sXFxuXFxuXFx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xcblxcdFxcdHZhciBlbGVtLFxcblxcdFxcdFxcdGkgPSAwO1xcblxcblxcdFxcdGZvciAoIDsgKCBlbGVtID0gdGhpc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xcblxcdFxcdFxcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xcblxcdFxcdFxcdFxcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xcblxcblxcdFxcdFxcdFxcdC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXFxuXFx0XFx0XFx0XFx0ZWxlbS50ZXh0Q29udGVudCA9IFxcXCJcXFwiO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0fSxcXG5cXG5cXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xcblxcdFxcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XFxuXFx0XFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xcblxcblxcdFxcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcXG5cXHRcXHR9ICk7XFxuXFx0fSxcXG5cXG5cXHRodG1sOiBmdW5jdGlvbiggdmFsdWUgKSB7XFxuXFx0XFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xcblxcdFxcdFxcdHZhciBlbGVtID0gdGhpc1sgMCBdIHx8IHt9LFxcblxcdFxcdFxcdFxcdGkgPSAwLFxcblxcdFxcdFxcdFxcdGwgPSB0aGlzLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZWxlbS5pbm5lckhUTUw7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFNlZSBpZiB3ZSBjYW4gdGFrZSBhIHNob3J0Y3V0IGFuZCBqdXN0IHVzZSBpbm5lckhUTUxcXG5cXHRcXHRcXHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXFxcInN0cmluZ1xcXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXFxuXFx0XFx0XFx0XFx0IXdyYXBNYXBbICggcnRhZ05hbWUuZXhlYyggdmFsdWUgKSB8fCBbIFxcXCJcXFwiLCBcXFwiXFxcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpIF0gKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFsdWUgPSBqUXVlcnkuaHRtbFByZWZpbHRlciggdmFsdWUgKTtcXG5cXG5cXHRcXHRcXHRcXHR0cnkge1xcblxcdFxcdFxcdFxcdFxcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRlbGVtID0gdGhpc1sgaSBdIHx8IHt9O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZWxlbSA9IDA7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXFxuXFx0XFx0XFx0XFx0fSBjYXRjaCAoIGUgKSB7fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIGVsZW0gKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcXG5cXHR9LFxcblxcblxcdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcXG5cXHRcXHR2YXIgaWdub3JlZCA9IFtdO1xcblxcblxcdFxcdC8vIE1ha2UgdGhlIGNoYW5nZXMsIHJlcGxhY2luZyBlYWNoIG5vbi1pZ25vcmVkIGNvbnRleHQgZWxlbWVudCB3aXRoIHRoZSBuZXcgY29udGVudFxcblxcdFxcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xcblxcblxcdFxcdFxcdGlmICggalF1ZXJ5LmluQXJyYXkoIHRoaXMsIGlnbm9yZWQgKSA8IDAgKSB7XFxuXFx0XFx0XFx0XFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcXG5cXHRcXHRcXHRcXHRpZiAoIHBhcmVudCApIHtcXG5cXHRcXHRcXHRcXHRcXHRwYXJlbnQucmVwbGFjZUNoaWxkKCBlbGVtLCB0aGlzICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHQvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXFxuXFx0XFx0fSwgaWdub3JlZCApO1xcblxcdH1cXG59ICk7XFxuXFxualF1ZXJ5LmVhY2goIHtcXG5cXHRhcHBlbmRUbzogXFxcImFwcGVuZFxcXCIsXFxuXFx0cHJlcGVuZFRvOiBcXFwicHJlcGVuZFxcXCIsXFxuXFx0aW5zZXJ0QmVmb3JlOiBcXFwiYmVmb3JlXFxcIixcXG5cXHRpbnNlcnRBZnRlcjogXFxcImFmdGVyXFxcIixcXG5cXHRyZXBsYWNlQWxsOiBcXFwicmVwbGFjZVdpdGhcXFwiXFxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xcblxcdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xcblxcdFxcdHZhciBlbGVtcyxcXG5cXHRcXHRcXHRyZXQgPSBbXSxcXG5cXHRcXHRcXHRpbnNlcnQgPSBqUXVlcnkoIHNlbGVjdG9yICksXFxuXFx0XFx0XFx0bGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxcblxcdFxcdFxcdGkgPSAwO1xcblxcblxcdFxcdGZvciAoIDsgaSA8PSBsYXN0OyBpKysgKSB7XFxuXFx0XFx0XFx0ZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUoIHRydWUgKTtcXG5cXHRcXHRcXHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XFxuXFxuXFx0XFx0XFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XFxuXFx0XFx0XFx0Ly8gLmdldCgpIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxcblxcdFxcdFxcdHB1c2guYXBwbHkoIHJldCwgZWxlbXMuZ2V0KCkgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcXG5cXHR9O1xcbn0gKTtcXG52YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cCggXFxcIl4oXFxcIiArIHBudW0gKyBcXFwiKSg/IXB4KVthLXolXSskXFxcIiwgXFxcImlcXFwiICk7XFxuXFxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcblxcdFxcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seSwgRmlyZWZveCA8PTMwICgjMTUwOTgsICMxNDE1MClcXG5cXHRcXHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcXG5cXHRcXHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXFxcImRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGVcXFwiXFxuXFx0XFx0dmFyIHZpZXcgPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XFxuXFxuXFx0XFx0aWYgKCAhdmlldyB8fCAhdmlldy5vcGVuZXIgKSB7XFxuXFx0XFx0XFx0dmlldyA9IHdpbmRvdztcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSApO1xcblxcdH07XFxuXFxudmFyIHJib3hTdHlsZSA9IG5ldyBSZWdFeHAoIGNzc0V4cGFuZC5qb2luKCBcXFwifFxcXCIgKSwgXFxcImlcXFwiICk7XFxuXFxuXFxuXFxuKCBmdW5jdGlvbigpIHtcXG5cXG5cXHQvLyBFeGVjdXRpbmcgYm90aCBwaXhlbFBvc2l0aW9uICYgYm94U2l6aW5nUmVsaWFibGUgdGVzdHMgcmVxdWlyZSBvbmx5IG9uZSBsYXlvdXRcXG5cXHQvLyBzbyB0aGV5J3JlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIHRpbWUgdG8gc2F2ZSB0aGUgc2Vjb25kIGNvbXB1dGF0aW9uLlxcblxcdGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xcblxcblxcdFxcdC8vIFRoaXMgaXMgYSBzaW5nbGV0b24sIHdlIG5lZWQgdG8gZXhlY3V0ZSBpdCBvbmx5IG9uY2VcXG5cXHRcXHRpZiAoICFkaXYgKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFxcXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4O3dpZHRoOjYwcHg7XFxcIiArXFxuXFx0XFx0XFx0XFxcIm1hcmdpbi10b3A6MXB4O3BhZGRpbmc6MDtib3JkZXI6MFxcXCI7XFxuXFx0XFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxcblxcdFxcdFxcdFxcXCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzpzY3JvbGw7XFxcIiArXFxuXFx0XFx0XFx0XFxcIm1hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7XFxcIiArXFxuXFx0XFx0XFx0XFxcIndpZHRoOjYwJTt0b3A6MSVcXFwiO1xcblxcdFxcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICkuYXBwZW5kQ2hpbGQoIGRpdiApO1xcblxcblxcdFxcdHZhciBkaXZTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYgKTtcXG5cXHRcXHRwaXhlbFBvc2l0aW9uVmFsID0gZGl2U3R5bGUudG9wICE9PSBcXFwiMSVcXFwiO1xcblxcblxcdFxcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gNDRcXG5cXHRcXHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLm1hcmdpbkxlZnQgKSA9PT0gMTI7XFxuXFxuXFx0XFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgU2FmYXJpIDw9OS4xIC0gMTAuMSwgaU9TIDw9Ny4wIC0gOS4zXFxuXFx0XFx0Ly8gU29tZSBzdHlsZXMgY29tZSBiYWNrIHdpdGggcGVyY2VudGFnZSB2YWx1ZXMsIGV2ZW4gdGhvdWdoIHRoZXkgc2hvdWxkbid0XFxuXFx0XFx0ZGl2LnN0eWxlLnJpZ2h0ID0gXFxcIjYwJVxcXCI7XFxuXFx0XFx0cGl4ZWxCb3hTdHlsZXNWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLnJpZ2h0ICkgPT09IDM2O1xcblxcblxcdFxcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XFxuXFx0XFx0Ly8gRGV0ZWN0IG1pc3JlcG9ydGluZyBvZiBjb250ZW50IGRpbWVuc2lvbnMgZm9yIGJveC1zaXppbmc6Ym9yZGVyLWJveCBlbGVtZW50c1xcblxcdFxcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS53aWR0aCApID09PSAzNjtcXG5cXG5cXHRcXHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcXG5cXHRcXHQvLyBEZXRlY3Qgb3ZlcmZsb3c6c2Nyb2xsIHNjcmV3aW5lc3MgKGdoLTM2OTkpXFxuXFx0XFx0ZGl2LnN0eWxlLnBvc2l0aW9uID0gXFxcImFic29sdXRlXFxcIjtcXG5cXHRcXHRzY3JvbGxib3hTaXplVmFsID0gZGl2Lm9mZnNldFdpZHRoID09PSAzNiB8fCBcXFwiYWJzb2x1dGVcXFwiO1xcblxcblxcdFxcdGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XFxuXFxuXFx0XFx0Ly8gTnVsbGlmeSB0aGUgZGl2IHNvIGl0IHdvdWxkbid0IGJlIHN0b3JlZCBpbiB0aGUgbWVtb3J5IGFuZFxcblxcdFxcdC8vIGl0IHdpbGwgYWxzbyBiZSBhIHNpZ24gdGhhdCBjaGVja3MgYWxyZWFkeSBwZXJmb3JtZWRcXG5cXHRcXHRkaXYgPSBudWxsO1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiByb3VuZFBpeGVsTWVhc3VyZXMoIG1lYXN1cmUgKSB7XFxuXFx0XFx0cmV0dXJuIE1hdGgucm91bmQoIHBhcnNlRmxvYXQoIG1lYXN1cmUgKSApO1xcblxcdH1cXG5cXG5cXHR2YXIgcGl4ZWxQb3NpdGlvblZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsIHNjcm9sbGJveFNpemVWYWwsIHBpeGVsQm94U3R5bGVzVmFsLFxcblxcdFxcdHJlbGlhYmxlTWFyZ2luTGVmdFZhbCxcXG5cXHRcXHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcXFwiZGl2XFxcIiApLFxcblxcdFxcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFxcXCJkaXZcXFwiICk7XFxuXFxuXFx0Ly8gRmluaXNoIGVhcmx5IGluIGxpbWl0ZWQgKG5vbi1icm93c2VyKSBlbnZpcm9ubWVudHNcXG5cXHRpZiAoICFkaXYuc3R5bGUgKSB7XFxuXFx0XFx0cmV0dXJuO1xcblxcdH1cXG5cXG5cXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XFxuXFx0Ly8gU3R5bGUgb2YgY2xvbmVkIGVsZW1lbnQgYWZmZWN0cyBzb3VyY2UgZWxlbWVudCBjbG9uZWQgKCM4OTA4KVxcblxcdGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFxcXCJjb250ZW50LWJveFxcXCI7XFxuXFx0ZGl2LmNsb25lTm9kZSggdHJ1ZSApLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXFxcIlxcXCI7XFxuXFx0c3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFxcXCJjb250ZW50LWJveFxcXCI7XFxuXFxuXFx0alF1ZXJ5LmV4dGVuZCggc3VwcG9ydCwge1xcblxcdFxcdGJveFNpemluZ1JlbGlhYmxlOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRjb21wdXRlU3R5bGVUZXN0cygpO1xcblxcdFxcdFxcdHJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDtcXG5cXHRcXHR9LFxcblxcdFxcdHBpeGVsQm94U3R5bGVzOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRjb21wdXRlU3R5bGVUZXN0cygpO1xcblxcdFxcdFxcdHJldHVybiBwaXhlbEJveFN0eWxlc1ZhbDtcXG5cXHRcXHR9LFxcblxcdFxcdHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XFxuXFx0XFx0XFx0cmV0dXJuIHBpeGVsUG9zaXRpb25WYWw7XFxuXFx0XFx0fSxcXG5cXHRcXHRyZWxpYWJsZU1hcmdpbkxlZnQ6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XFxuXFx0XFx0XFx0cmV0dXJuIHJlbGlhYmxlTWFyZ2luTGVmdFZhbDtcXG5cXHRcXHR9LFxcblxcdFxcdHNjcm9sbGJveFNpemU6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XFxuXFx0XFx0XFx0cmV0dXJuIHNjcm9sbGJveFNpemVWYWw7XFxuXFx0XFx0fVxcblxcdH0gKTtcXG59ICkoKTtcXG5cXG5cXG5mdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xcblxcdHZhciB3aWR0aCwgbWluV2lkdGgsIG1heFdpZHRoLCByZXQsXFxuXFxuXFx0XFx0Ly8gU3VwcG9ydDogRmlyZWZveCA1MStcXG5cXHRcXHQvLyBSZXRyaWV2aW5nIHN0eWxlIGJlZm9yZSBjb21wdXRlZCBzb21laG93XFxuXFx0XFx0Ly8gZml4ZXMgYW4gaXNzdWUgd2l0aCBnZXR0aW5nIHdyb25nIHZhbHVlc1xcblxcdFxcdC8vIG9uIGRldGFjaGVkIGVsZW1lbnRzXFxuXFx0XFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xcblxcblxcdGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKCBlbGVtICk7XFxuXFxuXFx0Ly8gZ2V0UHJvcGVydHlWYWx1ZSBpcyBuZWVkZWQgZm9yOlxcblxcdC8vICAgLmNzcygnZmlsdGVyJykgKElFIDkgb25seSwgIzEyNTM3KVxcblxcdC8vICAgLmNzcygnLS1jdXN0b21Qcm9wZXJ0eSkgKCMzMTQ0KVxcblxcdGlmICggY29tcHV0ZWQgKSB7XFxuXFx0XFx0cmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF07XFxuXFxuXFx0XFx0aWYgKCByZXQgPT09IFxcXCJcXFwiICYmICFqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICkge1xcblxcdFxcdFxcdHJldCA9IGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFxcXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXFxcIlxcblxcdFxcdC8vIEFuZHJvaWQgQnJvd3NlciByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIHNvbWUgdmFsdWVzLFxcblxcdFxcdC8vIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHMuXFxuXFx0XFx0Ly8gVGhpcyBpcyBhZ2FpbnN0IHRoZSBDU1NPTSBkcmFmdCBzcGVjOlxcblxcdFxcdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXFxuXFx0XFx0aWYgKCAhc3VwcG9ydC5waXhlbEJveFN0eWxlcygpICYmIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiByYm94U3R5bGUudGVzdCggbmFtZSApICkge1xcblxcblxcdFxcdFxcdC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcXG5cXHRcXHRcXHR3aWR0aCA9IHN0eWxlLndpZHRoO1xcblxcdFxcdFxcdG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XFxuXFx0XFx0XFx0bWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcXG5cXG5cXHRcXHRcXHQvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XFxuXFx0XFx0XFx0c3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xcblxcdFxcdFxcdHJldCA9IGNvbXB1dGVkLndpZHRoO1xcblxcblxcdFxcdFxcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcXG5cXHRcXHRcXHRzdHlsZS53aWR0aCA9IHdpZHRoO1xcblxcdFxcdFxcdHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XFxuXFx0XFx0XFx0c3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aDtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdHJldHVybiByZXQgIT09IHVuZGVmaW5lZCA/XFxuXFxuXFx0XFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxcblxcdFxcdC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXFxuXFx0XFx0cmV0ICsgXFxcIlxcXCIgOlxcblxcdFxcdHJldDtcXG59XFxuXFxuXFxuZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xcblxcblxcdC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXFxuXFx0cmV0dXJuIHtcXG5cXHRcXHRnZXQ6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdGlmICggY29uZGl0aW9uRm4oKSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWVcXG5cXHRcXHRcXHRcXHQvLyB0byBtaXNzaW5nIGRlcGVuZGVuY3kpLCByZW1vdmUgaXQuXFxuXFx0XFx0XFx0XFx0ZGVsZXRlIHRoaXMuZ2V0O1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXFxuXFx0XFx0XFx0cmV0dXJuICggdGhpcy5nZXQgPSBob29rRm4gKS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XFxuXFx0XFx0fVxcblxcdH07XFxufVxcblxcblxcbnZhclxcblxcblxcdC8vIFN3YXBwYWJsZSBpZiBkaXNwbGF5IGlzIG5vbmUgb3Igc3RhcnRzIHdpdGggdGFibGVcXG5cXHQvLyBleGNlcHQgXFxcInRhYmxlXFxcIiwgXFxcInRhYmxlLWNlbGxcXFwiLCBvciBcXFwidGFibGUtY2FwdGlvblxcXCJcXG5cXHQvLyBTZWUgaGVyZSBmb3IgZGlzcGxheSB2YWx1ZXM6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvQ1NTL2Rpc3BsYXlcXG5cXHRyZGlzcGxheXN3YXAgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXFxuXFx0cmN1c3RvbVByb3AgPSAvXi0tLyxcXG5cXHRjc3NTaG93ID0geyBwb3NpdGlvbjogXFxcImFic29sdXRlXFxcIiwgdmlzaWJpbGl0eTogXFxcImhpZGRlblxcXCIsIGRpc3BsYXk6IFxcXCJibG9ja1xcXCIgfSxcXG5cXHRjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XFxuXFx0XFx0bGV0dGVyU3BhY2luZzogXFxcIjBcXFwiLFxcblxcdFxcdGZvbnRXZWlnaHQ6IFxcXCI0MDBcXFwiXFxuXFx0fSxcXG5cXG5cXHRjc3NQcmVmaXhlcyA9IFsgXFxcIldlYmtpdFxcXCIsIFxcXCJNb3pcXFwiLCBcXFwibXNcXFwiIF0sXFxuXFx0ZW1wdHlTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFxcXCJkaXZcXFwiICkuc3R5bGU7XFxuXFxuLy8gUmV0dXJuIGEgY3NzIHByb3BlcnR5IG1hcHBlZCB0byBhIHBvdGVudGlhbGx5IHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eVxcbmZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKCBuYW1lICkge1xcblxcblxcdC8vIFNob3J0Y3V0IGZvciBuYW1lcyB0aGF0IGFyZSBub3QgdmVuZG9yIHByZWZpeGVkXFxuXFx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XFxuXFx0XFx0cmV0dXJuIG5hbWU7XFxuXFx0fVxcblxcblxcdC8vIENoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcXG5cXHR2YXIgY2FwTmFtZSA9IG5hbWVbIDAgXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSggMSApLFxcblxcdFxcdGkgPSBjc3NQcmVmaXhlcy5sZW5ndGg7XFxuXFxuXFx0d2hpbGUgKCBpLS0gKSB7XFxuXFx0XFx0bmFtZSA9IGNzc1ByZWZpeGVzWyBpIF0gKyBjYXBOYW1lO1xcblxcdFxcdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xcblxcdFxcdFxcdHJldHVybiBuYW1lO1xcblxcdFxcdH1cXG5cXHR9XFxufVxcblxcbi8vIFJldHVybiBhIHByb3BlcnR5IG1hcHBlZCBhbG9uZyB3aGF0IGpRdWVyeS5jc3NQcm9wcyBzdWdnZXN0cyBvciB0b1xcbi8vIGEgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5LlxcbmZ1bmN0aW9uIGZpbmFsUHJvcE5hbWUoIG5hbWUgKSB7XFxuXFx0dmFyIHJldCA9IGpRdWVyeS5jc3NQcm9wc1sgbmFtZSBdO1xcblxcdGlmICggIXJldCApIHtcXG5cXHRcXHRyZXQgPSBqUXVlcnkuY3NzUHJvcHNbIG5hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBuYW1lICkgfHwgbmFtZTtcXG5cXHR9XFxuXFx0cmV0dXJuIHJldDtcXG59XFxuXFxuZnVuY3Rpb24gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApIHtcXG5cXG5cXHQvLyBBbnkgcmVsYXRpdmUgKCsvLSkgdmFsdWVzIGhhdmUgYWxyZWFkeSBiZWVuXFxuXFx0Ly8gbm9ybWFsaXplZCBhdCB0aGlzIHBvaW50XFxuXFx0dmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICk7XFxuXFx0cmV0dXJuIG1hdGNoZXMgP1xcblxcblxcdFxcdC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFxcXCJzdWJ0cmFjdFxcXCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xcblxcdFxcdE1hdGgubWF4KCAwLCBtYXRjaGVzWyAyIF0gLSAoIHN1YnRyYWN0IHx8IDAgKSApICsgKCBtYXRjaGVzWyAzIF0gfHwgXFxcInB4XFxcIiApIDpcXG5cXHRcXHR2YWx1ZTtcXG59XFxuXFxuZnVuY3Rpb24gYm94TW9kZWxBZGp1c3RtZW50KCBlbGVtLCBkaW1lbnNpb24sIGJveCwgaXNCb3JkZXJCb3gsIHN0eWxlcywgY29tcHV0ZWRWYWwgKSB7XFxuXFx0dmFyIGkgPSBkaW1lbnNpb24gPT09IFxcXCJ3aWR0aFxcXCIgPyAxIDogMCxcXG5cXHRcXHRleHRyYSA9IDAsXFxuXFx0XFx0ZGVsdGEgPSAwO1xcblxcblxcdC8vIEFkanVzdG1lbnQgbWF5IG5vdCBiZSBuZWNlc3NhcnlcXG5cXHRpZiAoIGJveCA9PT0gKCBpc0JvcmRlckJveCA/IFxcXCJib3JkZXJcXFwiIDogXFxcImNvbnRlbnRcXFwiICkgKSB7XFxuXFx0XFx0cmV0dXJuIDA7XFxuXFx0fVxcblxcblxcdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiApIHtcXG5cXG5cXHRcXHQvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW5cXG5cXHRcXHRpZiAoIGJveCA9PT0gXFxcIm1hcmdpblxcXCIgKSB7XFxuXFx0XFx0XFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgYm94ICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgY29udGVudC1ib3gsIHdlJ3JlIHNlZWtpbmcgXFxcInBhZGRpbmdcXFwiIG9yIFxcXCJib3JkZXJcXFwiIG9yIFxcXCJtYXJnaW5cXFwiXFxuXFx0XFx0aWYgKCAhaXNCb3JkZXJCb3ggKSB7XFxuXFxuXFx0XFx0XFx0Ly8gQWRkIHBhZGRpbmdcXG5cXHRcXHRcXHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcXFwicGFkZGluZ1xcXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XFxuXFxuXFx0XFx0XFx0Ly8gRm9yIFxcXCJib3JkZXJcXFwiIG9yIFxcXCJtYXJnaW5cXFwiLCBhZGQgYm9yZGVyXFxuXFx0XFx0XFx0aWYgKCBib3ggIT09IFxcXCJwYWRkaW5nXFxcIiApIHtcXG5cXHRcXHRcXHRcXHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcXFwiYm9yZGVyXFxcIiArIGNzc0V4cGFuZFsgaSBdICsgXFxcIldpZHRoXFxcIiwgdHJ1ZSwgc3R5bGVzICk7XFxuXFxuXFx0XFx0XFx0Ly8gQnV0IHN0aWxsIGtlZXAgdHJhY2sgb2YgaXQgb3RoZXJ3aXNlXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRleHRyYSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcXFwiYm9yZGVyXFxcIiArIGNzc0V4cGFuZFsgaSBdICsgXFxcIldpZHRoXFxcIiwgdHJ1ZSwgc3R5bGVzICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBib3JkZXItYm94IChjb250ZW50ICsgcGFkZGluZyArIGJvcmRlciksIHdlJ3JlIHNlZWtpbmcgXFxcImNvbnRlbnRcXFwiIG9yXFxuXFx0XFx0Ly8gXFxcInBhZGRpbmdcXFwiIG9yIFxcXCJtYXJnaW5cXFwiXFxuXFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHQvLyBGb3IgXFxcImNvbnRlbnRcXFwiLCBzdWJ0cmFjdCBwYWRkaW5nXFxuXFx0XFx0XFx0aWYgKCBib3ggPT09IFxcXCJjb250ZW50XFxcIiApIHtcXG5cXHRcXHRcXHRcXHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcXFwicGFkZGluZ1xcXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEZvciBcXFwiY29udGVudFxcXCIgb3IgXFxcInBhZGRpbmdcXFwiLCBzdWJ0cmFjdCBib3JkZXJcXG5cXHRcXHRcXHRpZiAoIGJveCAhPT0gXFxcIm1hcmdpblxcXCIgKSB7XFxuXFx0XFx0XFx0XFx0ZGVsdGEgLT0galF1ZXJ5LmNzcyggZWxlbSwgXFxcImJvcmRlclxcXCIgKyBjc3NFeHBhbmRbIGkgXSArIFxcXCJXaWR0aFxcXCIsIHRydWUsIHN0eWxlcyApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdC8vIEFjY291bnQgZm9yIHBvc2l0aXZlIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXIgd2hlbiByZXF1ZXN0ZWQgYnkgcHJvdmlkaW5nIGNvbXB1dGVkVmFsXFxuXFx0aWYgKCAhaXNCb3JkZXJCb3ggJiYgY29tcHV0ZWRWYWwgPj0gMCApIHtcXG5cXG5cXHRcXHQvLyBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgYSByb3VuZGVkIHN1bSBvZiBjb250ZW50LCBwYWRkaW5nLCBzY3JvbGwgZ3V0dGVyLCBhbmQgYm9yZGVyXFxuXFx0XFx0Ly8gQXNzdW1pbmcgaW50ZWdlciBzY3JvbGwgZ3V0dGVyLCBzdWJ0cmFjdCB0aGUgcmVzdCBhbmQgcm91bmQgZG93blxcblxcdFxcdGRlbHRhICs9IE1hdGgubWF4KCAwLCBNYXRoLmNlaWwoXFxuXFx0XFx0XFx0ZWxlbVsgXFxcIm9mZnNldFxcXCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXSAtXFxuXFx0XFx0XFx0Y29tcHV0ZWRWYWwgLVxcblxcdFxcdFxcdGRlbHRhIC1cXG5cXHRcXHRcXHRleHRyYSAtXFxuXFx0XFx0XFx0MC41XFxuXFx0XFx0KSApO1xcblxcdH1cXG5cXG5cXHRyZXR1cm4gZGVsdGE7XFxufVxcblxcbmZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKSB7XFxuXFxuXFx0Ly8gU3RhcnQgd2l0aCBjb21wdXRlZCBzdHlsZVxcblxcdHZhciBzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcXG5cXHRcXHR2YWwgPSBjdXJDU1MoIGVsZW0sIGRpbWVuc2lvbiwgc3R5bGVzICksXFxuXFx0XFx0aXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKCBlbGVtLCBcXFwiYm94U2l6aW5nXFxcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcXFwiYm9yZGVyLWJveFxcXCIsXFxuXFx0XFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94O1xcblxcblxcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxcblxcdC8vIFJldHVybiBhIGNvbmZvdW5kaW5nIG5vbi1waXhlbCB2YWx1ZSBvciBmZWlnbiBpZ25vcmFuY2UsIGFzIGFwcHJvcHJpYXRlLlxcblxcdGlmICggcm51bW5vbnB4LnRlc3QoIHZhbCApICkge1xcblxcdFxcdGlmICggIWV4dHJhICkge1xcblxcdFxcdFxcdHJldHVybiB2YWw7XFxuXFx0XFx0fVxcblxcdFxcdHZhbCA9IFxcXCJhdXRvXFxcIjtcXG5cXHR9XFxuXFxuXFx0Ly8gQ2hlY2sgZm9yIHN0eWxlIGluIGNhc2UgYSBicm93c2VyIHdoaWNoIHJldHVybnMgdW5yZWxpYWJsZSB2YWx1ZXNcXG5cXHQvLyBmb3IgZ2V0Q29tcHV0ZWRTdHlsZSBzaWxlbnRseSBmYWxscyBiYWNrIHRvIHRoZSByZWxpYWJsZSBlbGVtLnN0eWxlXFxuXFx0dmFsdWVJc0JvcmRlckJveCA9IHZhbHVlSXNCb3JkZXJCb3ggJiZcXG5cXHRcXHQoIHN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCB2YWwgPT09IGVsZW0uc3R5bGVbIGRpbWVuc2lvbiBdICk7XFxuXFxuXFx0Ly8gRmFsbCBiYWNrIHRvIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCB3aGVuIHZhbHVlIGlzIFxcXCJhdXRvXFxcIlxcblxcdC8vIFRoaXMgaGFwcGVucyBmb3IgaW5saW5lIGVsZW1lbnRzIHdpdGggbm8gZXhwbGljaXQgc2V0dGluZyAoZ2gtMzU3MSlcXG5cXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIC0gNC4zIG9ubHlcXG5cXHQvLyBBbHNvIHVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIG1pc3JlcG9ydGVkIGlubGluZSBkaW1lbnNpb25zIChnaC0zNjAyKVxcblxcdGlmICggdmFsID09PSBcXFwiYXV0b1xcXCIgfHxcXG5cXHRcXHQhcGFyc2VGbG9hdCggdmFsICkgJiYgalF1ZXJ5LmNzcyggZWxlbSwgXFxcImRpc3BsYXlcXFwiLCBmYWxzZSwgc3R5bGVzICkgPT09IFxcXCJpbmxpbmVcXFwiICkge1xcblxcblxcdFxcdHZhbCA9IGVsZW1bIFxcXCJvZmZzZXRcXFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF07XFxuXFxuXFx0XFx0Ly8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IHByb3ZpZGUgYm9yZGVyLWJveCB2YWx1ZXNcXG5cXHRcXHR2YWx1ZUlzQm9yZGVyQm94ID0gdHJ1ZTtcXG5cXHR9XFxuXFxuXFx0Ly8gTm9ybWFsaXplIFxcXCJcXFwiIGFuZCBhdXRvXFxuXFx0dmFsID0gcGFyc2VGbG9hdCggdmFsICkgfHwgMDtcXG5cXG5cXHQvLyBBZGp1c3QgZm9yIHRoZSBlbGVtZW50J3MgYm94IG1vZGVsXFxuXFx0cmV0dXJuICggdmFsICtcXG5cXHRcXHRib3hNb2RlbEFkanVzdG1lbnQoXFxuXFx0XFx0XFx0ZWxlbSxcXG5cXHRcXHRcXHRkaW1lbnNpb24sXFxuXFx0XFx0XFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFxcXCJib3JkZXJcXFwiIDogXFxcImNvbnRlbnRcXFwiICksXFxuXFx0XFx0XFx0dmFsdWVJc0JvcmRlckJveCxcXG5cXHRcXHRcXHRzdHlsZXMsXFxuXFxuXFx0XFx0XFx0Ly8gUHJvdmlkZSB0aGUgY3VycmVudCBjb21wdXRlZCBzaXplIHRvIHJlcXVlc3Qgc2Nyb2xsIGd1dHRlciBjYWxjdWxhdGlvbiAoZ2gtMzU4OSlcXG5cXHRcXHRcXHR2YWxcXG5cXHRcXHQpXFxuXFx0KSArIFxcXCJweFxcXCI7XFxufVxcblxcbmpRdWVyeS5leHRlbmQoIHtcXG5cXG5cXHQvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcXG5cXHQvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcXG5cXHRjc3NIb29rczoge1xcblxcdFxcdG9wYWNpdHk6IHtcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcXG5cXHRcXHRcXHRcXHRpZiAoIGNvbXB1dGVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHJldCA9IGN1ckNTUyggZWxlbSwgXFxcIm9wYWNpdHlcXFwiICk7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHJldCA9PT0gXFxcIlxcXCIgPyBcXFwiMVxcXCIgOiByZXQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fSxcXG5cXG5cXHQvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcXFwicHhcXFwiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXNcXG5cXHRjc3NOdW1iZXI6IHtcXG5cXHRcXHRcXFwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnRcXFwiOiB0cnVlLFxcblxcdFxcdFxcXCJjb2x1bW5Db3VudFxcXCI6IHRydWUsXFxuXFx0XFx0XFxcImZpbGxPcGFjaXR5XFxcIjogdHJ1ZSxcXG5cXHRcXHRcXFwiZmxleEdyb3dcXFwiOiB0cnVlLFxcblxcdFxcdFxcXCJmbGV4U2hyaW5rXFxcIjogdHJ1ZSxcXG5cXHRcXHRcXFwiZm9udFdlaWdodFxcXCI6IHRydWUsXFxuXFx0XFx0XFxcImxpbmVIZWlnaHRcXFwiOiB0cnVlLFxcblxcdFxcdFxcXCJvcGFjaXR5XFxcIjogdHJ1ZSxcXG5cXHRcXHRcXFwib3JkZXJcXFwiOiB0cnVlLFxcblxcdFxcdFxcXCJvcnBoYW5zXFxcIjogdHJ1ZSxcXG5cXHRcXHRcXFwid2lkb3dzXFxcIjogdHJ1ZSxcXG5cXHRcXHRcXFwiekluZGV4XFxcIjogdHJ1ZSxcXG5cXHRcXHRcXFwiem9vbVxcXCI6IHRydWVcXG5cXHR9LFxcblxcblxcdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcXG5cXHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXFxuXFx0Y3NzUHJvcHM6IHt9LFxcblxcblxcdC8vIEdldCBhbmQgc2V0IHRoZSBzdHlsZSBwcm9wZXJ0eSBvbiBhIERPTSBOb2RlXFxuXFx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XFxuXFxuXFx0XFx0Ly8gRG9uJ3Qgc2V0IHN0eWxlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXFxuXFx0XFx0aWYgKCAhZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIWVsZW0uc3R5bGUgKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcXG5cXHRcXHR2YXIgcmV0LCB0eXBlLCBob29rcyxcXG5cXHRcXHRcXHRvcmlnTmFtZSA9IGNhbWVsQ2FzZSggbmFtZSApLFxcblxcdFxcdFxcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKSxcXG5cXHRcXHRcXHRzdHlsZSA9IGVsZW0uc3R5bGU7XFxuXFxuXFx0XFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lLiBXZSBkb24ndFxcblxcdFxcdC8vIHdhbnQgdG8gcXVlcnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxcblxcdFxcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cXG5cXHRcXHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XFxuXFx0XFx0XFx0bmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXFxuXFx0XFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XFxuXFxuXFx0XFx0Ly8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXFxuXFx0XFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdHR5cGUgPSB0eXBlb2YgdmFsdWU7XFxuXFxuXFx0XFx0XFx0Ly8gQ29udmVydCBcXFwiKz1cXFwiIG9yIFxcXCItPVxcXCIgdG8gcmVsYXRpdmUgbnVtYmVycyAoIzczNDUpXFxuXFx0XFx0XFx0aWYgKCB0eXBlID09PSBcXFwic3RyaW5nXFxcIiAmJiAoIHJldCA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmIHJldFsgMSBdICkge1xcblxcdFxcdFxcdFxcdHZhbHVlID0gYWRqdXN0Q1NTKCBlbGVtLCBuYW1lLCByZXQgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBGaXhlcyBidWcgIzkyMzdcXG5cXHRcXHRcXHRcXHR0eXBlID0gXFxcIm51bWJlclxcXCI7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIE1ha2Ugc3VyZSB0aGF0IG51bGwgYW5kIE5hTiB2YWx1ZXMgYXJlbid0IHNldCAoIzcxMTYpXFxuXFx0XFx0XFx0aWYgKCB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIElmIGEgbnVtYmVyIHdhcyBwYXNzZWQgaW4sIGFkZCB0aGUgdW5pdCAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxcblxcdFxcdFxcdGlmICggdHlwZSA9PT0gXFxcIm51bWJlclxcXCIgKSB7XFxuXFx0XFx0XFx0XFx0dmFsdWUgKz0gcmV0ICYmIHJldFsgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgb3JpZ05hbWUgXSA/IFxcXCJcXFwiIDogXFxcInB4XFxcIiApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXFxuXFx0XFx0XFx0aWYgKCAhc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgJiYgdmFsdWUgPT09IFxcXCJcXFwiICYmIG5hbWUuaW5kZXhPZiggXFxcImJhY2tncm91bmRcXFwiICkgPT09IDAgKSB7XFxuXFx0XFx0XFx0XFx0c3R5bGVbIG5hbWUgXSA9IFxcXCJpbmhlcml0XFxcIjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXFxuXFx0XFx0XFx0aWYgKCAhaG9va3MgfHwgISggXFxcInNldFxcXCIgaW4gaG9va3MgKSB8fFxcblxcdFxcdFxcdFxcdCggdmFsdWUgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGlzQ3VzdG9tUHJvcCApIHtcXG5cXHRcXHRcXHRcXHRcXHRzdHlsZS5zZXRQcm9wZXJ0eSggbmFtZSwgdmFsdWUgKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXFxuXFx0XFx0XFx0aWYgKCBob29rcyAmJiBcXFwiZ2V0XFxcIiBpbiBob29rcyAmJlxcblxcdFxcdFxcdFxcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJldDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3RcXG5cXHRcXHRcXHRyZXR1cm4gc3R5bGVbIG5hbWUgXTtcXG5cXHRcXHR9XFxuXFx0fSxcXG5cXG5cXHRjc3M6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzICkge1xcblxcdFxcdHZhciB2YWwsIG51bSwgaG9va3MsXFxuXFx0XFx0XFx0b3JpZ05hbWUgPSBjYW1lbENhc2UoIG5hbWUgKSxcXG5cXHRcXHRcXHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICk7XFxuXFxuXFx0XFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lLiBXZSBkb24ndFxcblxcdFxcdC8vIHdhbnQgdG8gbW9kaWZ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcXG5cXHRcXHQvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXFxuXFx0XFx0aWYgKCAhaXNDdXN0b21Qcm9wICkge1xcblxcdFxcdFxcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBUcnkgcHJlZml4ZWQgbmFtZSBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCBuYW1lXFxuXFx0XFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XFxuXFxuXFx0XFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcXG5cXHRcXHRpZiAoIGhvb2tzICYmIFxcXCJnZXRcXFwiIGluIGhvb2tzICkge1xcblxcdFxcdFxcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gT3RoZXJ3aXNlLCBpZiBhIHdheSB0byBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGV4aXN0cywgdXNlIHRoYXRcXG5cXHRcXHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIENvbnZlcnQgXFxcIm5vcm1hbFxcXCIgdG8gY29tcHV0ZWQgdmFsdWVcXG5cXHRcXHRpZiAoIHZhbCA9PT0gXFxcIm5vcm1hbFxcXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XFxuXFx0XFx0XFx0dmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtWyBuYW1lIF07XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIE1ha2UgbnVtZXJpYyBpZiBmb3JjZWQgb3IgYSBxdWFsaWZpZXIgd2FzIHByb3ZpZGVkIGFuZCB2YWwgbG9va3MgbnVtZXJpY1xcblxcdFxcdGlmICggZXh0cmEgPT09IFxcXCJcXFwiIHx8IGV4dHJhICkge1xcblxcdFxcdFxcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xcblxcdFxcdFxcdHJldHVybiBleHRyYSA9PT0gdHJ1ZSB8fCBpc0Zpbml0ZSggbnVtICkgPyBudW0gfHwgMCA6IHZhbDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHZhbDtcXG5cXHR9XFxufSApO1xcblxcbmpRdWVyeS5lYWNoKCBbIFxcXCJoZWlnaHRcXFwiLCBcXFwid2lkdGhcXFwiIF0sIGZ1bmN0aW9uKCBpLCBkaW1lbnNpb24gKSB7XFxuXFx0alF1ZXJ5LmNzc0hvb2tzWyBkaW1lbnNpb24gXSA9IHtcXG5cXHRcXHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XFxuXFx0XFx0XFx0aWYgKCBjb21wdXRlZCApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cXG5cXHRcXHRcXHRcXHQvLyBidXQgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdFxcblxcdFxcdFxcdFxcdHJldHVybiByZGlzcGxheXN3YXAudGVzdCggalF1ZXJ5LmNzcyggZWxlbSwgXFxcImRpc3BsYXlcXFwiICkgKSAmJlxcblxcblxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4K1xcblxcdFxcdFxcdFxcdFxcdC8vIFRhYmxlIGNvbHVtbnMgaW4gU2FmYXJpIGhhdmUgbm9uLXplcm8gb2Zmc2V0V2lkdGggJiB6ZXJvXFxuXFx0XFx0XFx0XFx0XFx0Ly8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggdW5sZXNzIGRpc3BsYXkgaXMgY2hhbmdlZC5cXG5cXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcXG5cXHRcXHRcXHRcXHRcXHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlXFxuXFx0XFx0XFx0XFx0XFx0Ly8gaW4gSUUgdGhyb3dzIGFuIGVycm9yLlxcblxcdFxcdFxcdFxcdFxcdCggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggfHwgIWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKSA/XFxuXFx0XFx0XFx0XFx0XFx0XFx0c3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9ICkgOlxcblxcdFxcdFxcdFxcdFxcdFxcdGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSB7XFxuXFx0XFx0XFx0dmFyIG1hdGNoZXMsXFxuXFx0XFx0XFx0XFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXFxuXFx0XFx0XFx0XFx0aXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKCBlbGVtLCBcXFwiYm94U2l6aW5nXFxcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcXFwiYm9yZGVyLWJveFxcXCIsXFxuXFx0XFx0XFx0XFx0c3VidHJhY3QgPSBleHRyYSAmJiBib3hNb2RlbEFkanVzdG1lbnQoXFxuXFx0XFx0XFx0XFx0XFx0ZWxlbSxcXG5cXHRcXHRcXHRcXHRcXHRkaW1lbnNpb24sXFxuXFx0XFx0XFx0XFx0XFx0ZXh0cmEsXFxuXFx0XFx0XFx0XFx0XFx0aXNCb3JkZXJCb3gsXFxuXFx0XFx0XFx0XFx0XFx0c3R5bGVzXFxuXFx0XFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHQvLyBBY2NvdW50IGZvciB1bnJlbGlhYmxlIGJvcmRlci1ib3ggZGltZW5zaW9ucyBieSBjb21wYXJpbmcgb2Zmc2V0KiB0byBjb21wdXRlZCBhbmRcXG5cXHRcXHRcXHQvLyBmYWtpbmcgYSBjb250ZW50LWJveCB0byBnZXQgYm9yZGVyIGFuZCBwYWRkaW5nIChnaC0zNjk5KVxcblxcdFxcdFxcdGlmICggaXNCb3JkZXJCb3ggJiYgc3VwcG9ydC5zY3JvbGxib3hTaXplKCkgPT09IHN0eWxlcy5wb3NpdGlvbiApIHtcXG5cXHRcXHRcXHRcXHRzdWJ0cmFjdCAtPSBNYXRoLmNlaWwoXFxuXFx0XFx0XFx0XFx0XFx0ZWxlbVsgXFxcIm9mZnNldFxcXCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXSAtXFxuXFx0XFx0XFx0XFx0XFx0cGFyc2VGbG9hdCggc3R5bGVzWyBkaW1lbnNpb24gXSApIC1cXG5cXHRcXHRcXHRcXHRcXHRib3hNb2RlbEFkanVzdG1lbnQoIGVsZW0sIGRpbWVuc2lvbiwgXFxcImJvcmRlclxcXCIsIGZhbHNlLCBzdHlsZXMgKSAtXFxuXFx0XFx0XFx0XFx0XFx0MC41XFxuXFx0XFx0XFx0XFx0KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQ29udmVydCB0byBwaXhlbHMgaWYgdmFsdWUgYWRqdXN0bWVudCBpcyBuZWVkZWRcXG5cXHRcXHRcXHRpZiAoIHN1YnRyYWN0ICYmICggbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmXFxuXFx0XFx0XFx0XFx0KCBtYXRjaGVzWyAzIF0gfHwgXFxcInB4XFxcIiApICE9PSBcXFwicHhcXFwiICkge1xcblxcblxcdFxcdFxcdFxcdGVsZW0uc3R5bGVbIGRpbWVuc2lvbiBdID0gdmFsdWU7XFxuXFx0XFx0XFx0XFx0dmFsdWUgPSBqUXVlcnkuY3NzKCBlbGVtLCBkaW1lbnNpb24gKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG59ICk7XFxuXFxualF1ZXJ5LmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucmVsaWFibGVNYXJnaW5MZWZ0LFxcblxcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcXG5cXHRcXHRpZiAoIGNvbXB1dGVkICkge1xcblxcdFxcdFxcdHJldHVybiAoIHBhcnNlRmxvYXQoIGN1ckNTUyggZWxlbSwgXFxcIm1hcmdpbkxlZnRcXFwiICkgKSB8fFxcblxcdFxcdFxcdFxcdGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtXFxuXFx0XFx0XFx0XFx0XFx0c3dhcCggZWxlbSwgeyBtYXJnaW5MZWZ0OiAwIH0sIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XFxuXFx0XFx0XFx0XFx0XFx0fSApXFxuXFx0XFx0XFx0XFx0KSArIFxcXCJweFxcXCI7XFxuXFx0XFx0fVxcblxcdH1cXG4pO1xcblxcbi8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcXG5qUXVlcnkuZWFjaCgge1xcblxcdG1hcmdpbjogXFxcIlxcXCIsXFxuXFx0cGFkZGluZzogXFxcIlxcXCIsXFxuXFx0Ym9yZGVyOiBcXFwiV2lkdGhcXFwiXFxufSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xcblxcdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0gPSB7XFxuXFx0XFx0ZXhwYW5kOiBmdW5jdGlvbiggdmFsdWUgKSB7XFxuXFx0XFx0XFx0dmFyIGkgPSAwLFxcblxcdFxcdFxcdFxcdGV4cGFuZGVkID0ge30sXFxuXFxuXFx0XFx0XFx0XFx0Ly8gQXNzdW1lcyBhIHNpbmdsZSBudW1iZXIgaWYgbm90IGEgc3RyaW5nXFxuXFx0XFx0XFx0XFx0cGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFxcXCJzdHJpbmdcXFwiID8gdmFsdWUuc3BsaXQoIFxcXCIgXFxcIiApIDogWyB2YWx1ZSBdO1xcblxcblxcdFxcdFxcdGZvciAoIDsgaSA8IDQ7IGkrKyApIHtcXG5cXHRcXHRcXHRcXHRleHBhbmRlZFsgcHJlZml4ICsgY3NzRXhwYW5kWyBpIF0gKyBzdWZmaXggXSA9XFxuXFx0XFx0XFx0XFx0XFx0cGFydHNbIGkgXSB8fCBwYXJ0c1sgaSAtIDIgXSB8fCBwYXJ0c1sgMCBdO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gZXhwYW5kZWQ7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0aWYgKCBwcmVmaXggIT09IFxcXCJtYXJnaW5cXFwiICkge1xcblxcdFxcdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0uc2V0ID0gc2V0UG9zaXRpdmVOdW1iZXI7XFxuXFx0fVxcbn0gKTtcXG5cXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XFxuXFx0Y3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XFxuXFx0XFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xcblxcdFxcdFxcdHZhciBzdHlsZXMsIGxlbixcXG5cXHRcXHRcXHRcXHRtYXAgPSB7fSxcXG5cXHRcXHRcXHRcXHRpID0gMDtcXG5cXG5cXHRcXHRcXHRpZiAoIEFycmF5LmlzQXJyYXkoIG5hbWUgKSApIHtcXG5cXHRcXHRcXHRcXHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKTtcXG5cXHRcXHRcXHRcXHRsZW4gPSBuYW1lLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcXG5cXHRcXHRcXHRcXHRcXHRtYXBbIG5hbWVbIGkgXSBdID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZVsgaSBdLCBmYWxzZSwgc3R5bGVzICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJldHVybiBtYXA7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cXG5cXHRcXHRcXHRcXHRqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUsIHZhbHVlICkgOlxcblxcdFxcdFxcdFxcdGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcXG5cXHRcXHR9LCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcXG5cXHR9XFxufSApO1xcblxcblxcbmZ1bmN0aW9uIFR3ZWVuKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApIHtcXG5cXHRyZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xcbn1cXG5qUXVlcnkuVHdlZW4gPSBUd2VlbjtcXG5cXG5Ud2Vlbi5wcm90b3R5cGUgPSB7XFxuXFx0Y29uc3RydWN0b3I6IFR3ZWVuLFxcblxcdGluaXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCApIHtcXG5cXHRcXHR0aGlzLmVsZW0gPSBlbGVtO1xcblxcdFxcdHRoaXMucHJvcCA9IHByb3A7XFxuXFx0XFx0dGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgalF1ZXJ5LmVhc2luZy5fZGVmYXVsdDtcXG5cXHRcXHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xcblxcdFxcdHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XFxuXFx0XFx0dGhpcy5lbmQgPSBlbmQ7XFxuXFx0XFx0dGhpcy51bml0ID0gdW5pdCB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFxcXCJcXFwiIDogXFxcInB4XFxcIiApO1xcblxcdH0sXFxuXFx0Y3VyOiBmdW5jdGlvbigpIHtcXG5cXHRcXHR2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xcblxcblxcdFxcdHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xcblxcdFxcdFxcdGhvb2tzLmdldCggdGhpcyApIDpcXG5cXHRcXHRcXHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KCB0aGlzICk7XFxuXFx0fSxcXG5cXHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xcblxcdFxcdHZhciBlYXNlZCxcXG5cXHRcXHRcXHRob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XFxuXFxuXFx0XFx0aWYgKCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKSB7XFxuXFx0XFx0XFx0dGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXFxuXFx0XFx0XFx0XFx0cGVyY2VudCwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogcGVyY2VudCwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uXFxuXFx0XFx0XFx0KTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHRoaXMucG9zID0gZWFzZWQgPSBwZXJjZW50O1xcblxcdFxcdH1cXG5cXHRcXHR0aGlzLm5vdyA9ICggdGhpcy5lbmQgLSB0aGlzLnN0YXJ0ICkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XFxuXFxuXFx0XFx0aWYgKCB0aGlzLm9wdGlvbnMuc3RlcCApIHtcXG5cXHRcXHRcXHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggaG9va3MgJiYgaG9va3Muc2V0ICkge1xcblxcdFxcdFxcdGhvb2tzLnNldCggdGhpcyApO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXHR9XFxufTtcXG5cXG5Ud2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XFxuXFxuVHdlZW4ucHJvcEhvb2tzID0ge1xcblxcdF9kZWZhdWx0OiB7XFxuXFx0XFx0Z2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XFxuXFx0XFx0XFx0dmFyIHJlc3VsdDtcXG5cXG5cXHRcXHRcXHQvLyBVc2UgYSBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCBkaXJlY3RseSB3aGVuIGl0IGlzIG5vdCBhIERPTSBlbGVtZW50LFxcblxcdFxcdFxcdC8vIG9yIHdoZW4gdGhlcmUgaXMgbm8gbWF0Y2hpbmcgc3R5bGUgcHJvcGVydHkgdGhhdCBleGlzdHMuXFxuXFx0XFx0XFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICE9PSAxIHx8XFxuXFx0XFx0XFx0XFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdICE9IG51bGwgJiYgdHdlZW4uZWxlbS5zdHlsZVsgdHdlZW4ucHJvcCBdID09IG51bGwgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XFxuXFx0XFx0XFx0Ly8gYXR0ZW1wdCBhIHBhcnNlRmxvYXQgYW5kIGZhbGxiYWNrIHRvIGEgc3RyaW5nIGlmIHRoZSBwYXJzZSBmYWlscy5cXG5cXHRcXHRcXHQvLyBTaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXFxcIjEwcHhcXFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XFxuXFx0XFx0XFx0Ly8gY29tcGxleCB2YWx1ZXMgc3VjaCBhcyBcXFwicm90YXRlKDFyYWQpXFxcIiBhcmUgcmV0dXJuZWQgYXMtaXMuXFxuXFx0XFx0XFx0cmVzdWx0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXFxcIlxcXCIgKTtcXG5cXG5cXHRcXHRcXHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFxcXCJhdXRvXFxcIiBhcmUgY29udmVydGVkIHRvIDAuXFxuXFx0XFx0XFx0cmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcXFwiYXV0b1xcXCIgPyAwIDogcmVzdWx0O1xcblxcdFxcdH0sXFxuXFx0XFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XFxuXFxuXFx0XFx0XFx0Ly8gVXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQuXFxuXFx0XFx0XFx0Ly8gVXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlLlxcblxcdFxcdFxcdC8vIFVzZSAuc3R5bGUgaWYgYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGUuXFxuXFx0XFx0XFx0aWYgKCBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdICkge1xcblxcdFxcdFxcdFxcdGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0oIHR3ZWVuICk7XFxuXFx0XFx0XFx0fSBlbHNlIGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxcblxcdFxcdFxcdFxcdCggdHdlZW4uZWxlbS5zdHlsZVsgalF1ZXJ5LmNzc1Byb3BzWyB0d2Vlbi5wcm9wIF0gXSAhPSBudWxsIHx8XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmNzc0hvb2tzWyB0d2Vlbi5wcm9wIF0gKSApIHtcXG5cXHRcXHRcXHRcXHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG59O1xcblxcbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XFxuLy8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXFxuVHdlZW4ucHJvcEhvb2tzLnNjcm9sbFRvcCA9IFR3ZWVuLnByb3BIb29rcy5zY3JvbGxMZWZ0ID0ge1xcblxcdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xcblxcdFxcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUgKSB7XFxuXFx0XFx0XFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xcblxcdFxcdH1cXG5cXHR9XFxufTtcXG5cXG5qUXVlcnkuZWFzaW5nID0ge1xcblxcdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XFxuXFx0XFx0cmV0dXJuIHA7XFxuXFx0fSxcXG5cXHRzd2luZzogZnVuY3Rpb24oIHAgKSB7XFxuXFx0XFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKCBwICogTWF0aC5QSSApIC8gMjtcXG5cXHR9LFxcblxcdF9kZWZhdWx0OiBcXFwic3dpbmdcXFwiXFxufTtcXG5cXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcXG5cXG4vLyBCYWNrIGNvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxcbmpRdWVyeS5meC5zdGVwID0ge307XFxuXFxuXFxuXFxuXFxudmFyXFxuXFx0ZnhOb3csIGluUHJvZ3Jlc3MsXFxuXFx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXFxuXFx0cnJ1biA9IC9xdWV1ZUhvb2tzJC87XFxuXFxuZnVuY3Rpb24gc2NoZWR1bGUoKSB7XFxuXFx0aWYgKCBpblByb2dyZXNzICkge1xcblxcdFxcdGlmICggZG9jdW1lbnQuaGlkZGVuID09PSBmYWxzZSAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICkge1xcblxcdFxcdFxcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHNjaGVkdWxlICk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHR3aW5kb3cuc2V0VGltZW91dCggc2NoZWR1bGUsIGpRdWVyeS5meC5pbnRlcnZhbCApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRqUXVlcnkuZngudGljaygpO1xcblxcdH1cXG59XFxuXFxuLy8gQW5pbWF0aW9ucyBjcmVhdGVkIHN5bmNocm9ub3VzbHkgd2lsbCBydW4gc3luY2hyb25vdXNseVxcbmZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xcblxcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcXG5cXHRcXHRmeE5vdyA9IHVuZGVmaW5lZDtcXG5cXHR9ICk7XFxuXFx0cmV0dXJuICggZnhOb3cgPSBEYXRlLm5vdygpICk7XFxufVxcblxcbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXFxuZnVuY3Rpb24gZ2VuRngoIHR5cGUsIGluY2x1ZGVXaWR0aCApIHtcXG5cXHR2YXIgd2hpY2gsXFxuXFx0XFx0aSA9IDAsXFxuXFx0XFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xcblxcblxcdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcXG5cXHQvLyBvdGhlcndpc2Ugc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxcblxcdGluY2x1ZGVXaWR0aCA9IGluY2x1ZGVXaWR0aCA/IDEgOiAwO1xcblxcdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcXG5cXHRcXHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xcblxcdFxcdGF0dHJzWyBcXFwibWFyZ2luXFxcIiArIHdoaWNoIF0gPSBhdHRyc1sgXFxcInBhZGRpbmdcXFwiICsgd2hpY2ggXSA9IHR5cGU7XFxuXFx0fVxcblxcblxcdGlmICggaW5jbHVkZVdpZHRoICkge1xcblxcdFxcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XFxuXFx0fVxcblxcblxcdHJldHVybiBhdHRycztcXG59XFxuXFxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XFxuXFx0dmFyIHR3ZWVuLFxcblxcdFxcdGNvbGxlY3Rpb24gPSAoIEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdICkuY29uY2F0KCBBbmltYXRpb24udHdlZW5lcnNbIFxcXCIqXFxcIiBdICksXFxuXFx0XFx0aW5kZXggPSAwLFxcblxcdFxcdGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xcblxcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XFxuXFx0XFx0aWYgKCAoIHR3ZWVuID0gY29sbGVjdGlvblsgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIHByb3AsIHZhbHVlICkgKSApIHtcXG5cXG5cXHRcXHRcXHQvLyBXZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxcblxcdFxcdFxcdHJldHVybiB0d2VlbjtcXG5cXHRcXHR9XFxuXFx0fVxcbn1cXG5cXG5mdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKCBlbGVtLCBwcm9wcywgb3B0cyApIHtcXG5cXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgaG9va3MsIG9sZGZpcmUsIHByb3BUd2VlbiwgcmVzdG9yZURpc3BsYXksIGRpc3BsYXksXFxuXFx0XFx0aXNCb3ggPSBcXFwid2lkdGhcXFwiIGluIHByb3BzIHx8IFxcXCJoZWlnaHRcXFwiIGluIHByb3BzLFxcblxcdFxcdGFuaW0gPSB0aGlzLFxcblxcdFxcdG9yaWcgPSB7fSxcXG5cXHRcXHRzdHlsZSA9IGVsZW0uc3R5bGUsXFxuXFx0XFx0aGlkZGVuID0gZWxlbS5ub2RlVHlwZSAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSxcXG5cXHRcXHRkYXRhU2hvdyA9IGRhdGFQcml2LmdldCggZWxlbSwgXFxcImZ4c2hvd1xcXCIgKTtcXG5cXG5cXHQvLyBRdWV1ZS1za2lwcGluZyBhbmltYXRpb25zIGhpamFjayB0aGUgZnggaG9va3NcXG5cXHRpZiAoICFvcHRzLnF1ZXVlICkge1xcblxcdFxcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCBcXFwiZnhcXFwiICk7XFxuXFx0XFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xcblxcdFxcdFxcdGhvb2tzLnVucXVldWVkID0gMDtcXG5cXHRcXHRcXHRvbGRmaXJlID0gaG9va3MuZW1wdHkuZmlyZTtcXG5cXHRcXHRcXHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCAhaG9va3MudW5xdWV1ZWQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0b2xkZmlyZSgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9O1xcblxcdFxcdH1cXG5cXHRcXHRob29rcy51bnF1ZXVlZCsrO1xcblxcblxcdFxcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcXG5cXG5cXHRcXHRcXHQvLyBFbnN1cmUgdGhlIGNvbXBsZXRlIGhhbmRsZXIgaXMgY2FsbGVkIGJlZm9yZSB0aGlzIGNvbXBsZXRlc1xcblxcdFxcdFxcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRob29rcy51bnF1ZXVlZC0tO1xcblxcdFxcdFxcdFxcdGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXFxcImZ4XFxcIiApLmxlbmd0aCApIHtcXG5cXHRcXHRcXHRcXHRcXHRob29rcy5lbXB0eS5maXJlKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gKTtcXG5cXHRcXHR9ICk7XFxuXFx0fVxcblxcblxcdC8vIERldGVjdCBzaG93L2hpZGUgYW5pbWF0aW9uc1xcblxcdGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XFxuXFx0XFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xcblxcdFxcdGlmICggcmZ4dHlwZXMudGVzdCggdmFsdWUgKSApIHtcXG5cXHRcXHRcXHRkZWxldGUgcHJvcHNbIHByb3AgXTtcXG5cXHRcXHRcXHR0b2dnbGUgPSB0b2dnbGUgfHwgdmFsdWUgPT09IFxcXCJ0b2dnbGVcXFwiO1xcblxcdFxcdFxcdGlmICggdmFsdWUgPT09ICggaGlkZGVuID8gXFxcImhpZGVcXFwiIDogXFxcInNob3dcXFwiICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gUHJldGVuZCB0byBiZSBoaWRkZW4gaWYgdGhpcyBpcyBhIFxcXCJzaG93XFxcIiBhbmRcXG5cXHRcXHRcXHRcXHQvLyB0aGVyZSBpcyBzdGlsbCBkYXRhIGZyb20gYSBzdG9wcGVkIHNob3cvaGlkZVxcblxcdFxcdFxcdFxcdGlmICggdmFsdWUgPT09IFxcXCJzaG93XFxcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aGlkZGVuID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBJZ25vcmUgYWxsIG90aGVyIG5vLW9wIHNob3cvaGlkZSBkYXRhXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRjb250aW51ZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdG9yaWdbIHByb3AgXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHQvLyBCYWlsIG91dCBpZiB0aGlzIGlzIGEgbm8tb3AgbGlrZSAuaGlkZSgpLmhpZGUoKVxcblxcdHByb3BUd2VlbiA9ICFqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcHMgKTtcXG5cXHRpZiAoICFwcm9wVHdlZW4gJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcXG5cXHRcXHRyZXR1cm47XFxuXFx0fVxcblxcblxcdC8vIFJlc3RyaWN0IFxcXCJvdmVyZmxvd1xcXCIgYW5kIFxcXCJkaXNwbGF5XFxcIiBzdHlsZXMgZHVyaW5nIGJveCBhbmltYXRpb25zXFxuXFx0aWYgKCBpc0JveCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xcblxcblxcdFxcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcXG5cXHRcXHQvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFIGRvZXMgbm90IGluZmVyIHRoZSBzaG9ydGhhbmRcXG5cXHRcXHQvLyBmcm9tIGlkZW50aWNhbGx5LXZhbHVlZCBvdmVyZmxvd1ggYW5kIG92ZXJmbG93WSBhbmQgRWRnZSBqdXN0IG1pcnJvcnNcXG5cXHRcXHQvLyB0aGUgb3ZlcmZsb3dYIHZhbHVlIHRoZXJlLlxcblxcdFxcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xcblxcblxcdFxcdC8vIElkZW50aWZ5IGEgZGlzcGxheSB0eXBlLCBwcmVmZXJyaW5nIG9sZCBzaG93L2hpZGUgZGF0YSBvdmVyIHRoZSBDU1MgY2FzY2FkZVxcblxcdFxcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVNob3cgJiYgZGF0YVNob3cuZGlzcGxheTtcXG5cXHRcXHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XFxuXFx0XFx0XFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFxcXCJkaXNwbGF5XFxcIiApO1xcblxcdFxcdH1cXG5cXHRcXHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXFxcImRpc3BsYXlcXFwiICk7XFxuXFx0XFx0aWYgKCBkaXNwbGF5ID09PSBcXFwibm9uZVxcXCIgKSB7XFxuXFx0XFx0XFx0aWYgKCByZXN0b3JlRGlzcGxheSApIHtcXG5cXHRcXHRcXHRcXHRkaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBHZXQgbm9uZW1wdHkgdmFsdWUocykgYnkgdGVtcG9yYXJpbHkgZm9yY2luZyB2aXNpYmlsaXR5XFxuXFx0XFx0XFx0XFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XFxuXFx0XFx0XFx0XFx0cmVzdG9yZURpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXkgfHwgcmVzdG9yZURpc3BsYXk7XFxuXFx0XFx0XFx0XFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFxcXCJkaXNwbGF5XFxcIiApO1xcblxcdFxcdFxcdFxcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQW5pbWF0ZSBpbmxpbmUgZWxlbWVudHMgYXMgaW5saW5lLWJsb2NrXFxuXFx0XFx0aWYgKCBkaXNwbGF5ID09PSBcXFwiaW5saW5lXFxcIiB8fCBkaXNwbGF5ID09PSBcXFwiaW5saW5lLWJsb2NrXFxcIiAmJiByZXN0b3JlRGlzcGxheSAhPSBudWxsICkge1xcblxcdFxcdFxcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXFxcImZsb2F0XFxcIiApID09PSBcXFwibm9uZVxcXCIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgZGlzcGxheSB2YWx1ZSBhdCB0aGUgZW5kIG9mIHB1cmUgc2hvdy9oaWRlIGFuaW1hdGlvbnNcXG5cXHRcXHRcXHRcXHRpZiAoICFwcm9wVHdlZW4gKSB7XFxuXFx0XFx0XFx0XFx0XFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzdHlsZS5kaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XFxuXFx0XFx0XFx0XFx0XFx0fSApO1xcblxcdFxcdFxcdFxcdFxcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRkaXNwbGF5ID0gc3R5bGUuZGlzcGxheTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXN0b3JlRGlzcGxheSA9IGRpc3BsYXkgPT09IFxcXCJub25lXFxcIiA/IFxcXCJcXFwiIDogZGlzcGxheTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHN0eWxlLmRpc3BsYXkgPSBcXFwiaW5saW5lLWJsb2NrXFxcIjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRpZiAoIG9wdHMub3ZlcmZsb3cgKSB7XFxuXFx0XFx0c3R5bGUub3ZlcmZsb3cgPSBcXFwiaGlkZGVuXFxcIjtcXG5cXHRcXHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XFxuXFx0XFx0XFx0c3R5bGUub3ZlcmZsb3dYID0gb3B0cy5vdmVyZmxvd1sgMSBdO1xcblxcdFxcdFxcdHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcXG5cXHRcXHR9ICk7XFxuXFx0fVxcblxcblxcdC8vIEltcGxlbWVudCBzaG93L2hpZGUgYW5pbWF0aW9uc1xcblxcdHByb3BUd2VlbiA9IGZhbHNlO1xcblxcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcXG5cXG5cXHRcXHQvLyBHZW5lcmFsIHNob3cvaGlkZSBzZXR1cCBmb3IgdGhpcyBlbGVtZW50IGFuaW1hdGlvblxcblxcdFxcdGlmICggIXByb3BUd2VlbiApIHtcXG5cXHRcXHRcXHRpZiAoIGRhdGFTaG93ICkge1xcblxcdFxcdFxcdFxcdGlmICggXFxcImhpZGRlblxcXCIgaW4gZGF0YVNob3cgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aGlkZGVuID0gZGF0YVNob3cuaGlkZGVuO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGRhdGFTaG93ID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBcXFwiZnhzaG93XFxcIiwgeyBkaXNwbGF5OiByZXN0b3JlRGlzcGxheSB9ICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFN0b3JlIGhpZGRlbi92aXNpYmxlIGZvciB0b2dnbGUgc28gYC5zdG9wKCkudG9nZ2xlKClgIFxcXCJyZXZlcnNlc1xcXCJcXG5cXHRcXHRcXHRpZiAoIHRvZ2dsZSApIHtcXG5cXHRcXHRcXHRcXHRkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBTaG93IGVsZW1lbnRzIGJlZm9yZSBhbmltYXRpbmcgdGhlbVxcblxcdFxcdFxcdGlmICggaGlkZGVuICkge1xcblxcdFxcdFxcdFxcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cXG5cXG5cXHRcXHRcXHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xcblxcblxcdFxcdFxcdC8qIGVzbGludC1lbmFibGUgbm8tbG9vcC1mdW5jICovXFxuXFxuXFx0XFx0XFx0XFx0Ly8gVGhlIGZpbmFsIHN0ZXAgb2YgYSBcXFwiaGlkZVxcXCIgYW5pbWF0aW9uIGlzIGFjdHVhbGx5IGhpZGluZyB0aGUgZWxlbWVudFxcblxcdFxcdFxcdFxcdGlmICggIWhpZGRlbiApIHtcXG5cXHRcXHRcXHRcXHRcXHRzaG93SGlkZSggWyBlbGVtIF0gKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcXFwiZnhzaG93XFxcIiApO1xcblxcdFxcdFxcdFxcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIG9yaWdbIHByb3AgXSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9ICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFBlci1wcm9wZXJ0eSBzZXR1cFxcblxcdFxcdHByb3BUd2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xcblxcdFxcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xcblxcdFxcdFxcdGRhdGFTaG93WyBwcm9wIF0gPSBwcm9wVHdlZW4uc3RhcnQ7XFxuXFx0XFx0XFx0aWYgKCBoaWRkZW4gKSB7XFxuXFx0XFx0XFx0XFx0cHJvcFR3ZWVuLmVuZCA9IHByb3BUd2Vlbi5zdGFydDtcXG5cXHRcXHRcXHRcXHRwcm9wVHdlZW4uc3RhcnQgPSAwO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcbn1cXG5cXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcXG5cXHR2YXIgaW5kZXgsIG5hbWUsIGVhc2luZywgdmFsdWUsIGhvb2tzO1xcblxcblxcdC8vIGNhbWVsQ2FzZSwgc3BlY2lhbEVhc2luZyBhbmQgZXhwYW5kIGNzc0hvb2sgcGFzc1xcblxcdGZvciAoIGluZGV4IGluIHByb3BzICkge1xcblxcdFxcdG5hbWUgPSBjYW1lbENhc2UoIGluZGV4ICk7XFxuXFx0XFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xcblxcdFxcdHZhbHVlID0gcHJvcHNbIGluZGV4IF07XFxuXFx0XFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xcblxcdFxcdFxcdGVhc2luZyA9IHZhbHVlWyAxIF07XFxuXFx0XFx0XFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyAwIF07XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggaW5kZXggIT09IG5hbWUgKSB7XFxuXFx0XFx0XFx0cHJvcHNbIG5hbWUgXSA9IHZhbHVlO1xcblxcdFxcdFxcdGRlbGV0ZSBwcm9wc1sgaW5kZXggXTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTtcXG5cXHRcXHRpZiAoIGhvb2tzICYmIFxcXCJleHBhbmRcXFwiIGluIGhvb2tzICkge1xcblxcdFxcdFxcdHZhbHVlID0gaG9va3MuZXhwYW5kKCB2YWx1ZSApO1xcblxcdFxcdFxcdGRlbGV0ZSBwcm9wc1sgbmFtZSBdO1xcblxcblxcdFxcdFxcdC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cXG5cXHRcXHRcXHQvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFxcXCJuYW1lXFxcIlxcblxcdFxcdFxcdGZvciAoIGluZGV4IGluIHZhbHVlICkge1xcblxcdFxcdFxcdFxcdGlmICggISggaW5kZXggaW4gcHJvcHMgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyBpbmRleCBdO1xcblxcdFxcdFxcdFxcdFxcdHNwZWNpYWxFYXNpbmdbIGluZGV4IF0gPSBlYXNpbmc7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHNwZWNpYWxFYXNpbmdbIG5hbWUgXSA9IGVhc2luZztcXG5cXHRcXHR9XFxuXFx0fVxcbn1cXG5cXG5mdW5jdGlvbiBBbmltYXRpb24oIGVsZW0sIHByb3BlcnRpZXMsIG9wdGlvbnMgKSB7XFxuXFx0dmFyIHJlc3VsdCxcXG5cXHRcXHRzdG9wcGVkLFxcblxcdFxcdGluZGV4ID0gMCxcXG5cXHRcXHRsZW5ndGggPSBBbmltYXRpb24ucHJlZmlsdGVycy5sZW5ndGgsXFxuXFx0XFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoIGZ1bmN0aW9uKCkge1xcblxcblxcdFxcdFxcdC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxcblxcdFxcdFxcdGRlbGV0ZSB0aWNrLmVsZW07XFxuXFx0XFx0fSApLFxcblxcdFxcdHRpY2sgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRpZiAoIHN0b3BwZWQgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxcblxcdFxcdFxcdFxcdHJlbWFpbmluZyA9IE1hdGgubWF4KCAwLCBhbmltYXRpb24uc3RhcnRUaW1lICsgYW5pbWF0aW9uLmR1cmF0aW9uIC0gY3VycmVudFRpbWUgKSxcXG5cXG5cXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuMyBvbmx5XFxuXFx0XFx0XFx0XFx0Ly8gQXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIGAxIC0gKCAwLjUgfHwgMCApYCAoIzEyNDk3KVxcblxcdFxcdFxcdFxcdHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcXG5cXHRcXHRcXHRcXHRwZXJjZW50ID0gMSAtIHRlbXAsXFxuXFx0XFx0XFx0XFx0aW5kZXggPSAwLFxcblxcdFxcdFxcdFxcdGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xcblxcblxcdFxcdFxcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XFxuXFx0XFx0XFx0XFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIHBlcmNlbnQgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZyBdICk7XFxuXFxuXFx0XFx0XFx0Ly8gSWYgdGhlcmUncyBtb3JlIHRvIGRvLCB5aWVsZFxcblxcdFxcdFxcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xcblxcdFxcdFxcdFxcdHJldHVybiByZW1haW5pbmc7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIElmIHRoaXMgd2FzIGFuIGVtcHR5IGFuaW1hdGlvbiwgc3ludGhlc2l6ZSBhIGZpbmFsIHByb2dyZXNzIG5vdGlmaWNhdGlvblxcblxcdFxcdFxcdGlmICggIWxlbmd0aCApIHtcXG5cXHRcXHRcXHRcXHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFJlc29sdmUgdGhlIGFuaW1hdGlvbiBhbmQgcmVwb3J0IGl0cyBjb25jbHVzaW9uXFxuXFx0XFx0XFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0fSxcXG5cXHRcXHRhbmltYXRpb24gPSBkZWZlcnJlZC5wcm9taXNlKCB7XFxuXFx0XFx0XFx0ZWxlbTogZWxlbSxcXG5cXHRcXHRcXHRwcm9wczogalF1ZXJ5LmV4dGVuZCgge30sIHByb3BlcnRpZXMgKSxcXG5cXHRcXHRcXHRvcHRzOiBqUXVlcnkuZXh0ZW5kKCB0cnVlLCB7XFxuXFx0XFx0XFx0XFx0c3BlY2lhbEVhc2luZzoge30sXFxuXFx0XFx0XFx0XFx0ZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XFxuXFx0XFx0XFx0fSwgb3B0aW9ucyApLFxcblxcdFxcdFxcdG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcXG5cXHRcXHRcXHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXFxuXFx0XFx0XFx0c3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxcblxcdFxcdFxcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxcblxcdFxcdFxcdHR3ZWVuczogW10sXFxuXFx0XFx0XFx0Y3JlYXRlVHdlZW46IGZ1bmN0aW9uKCBwcm9wLCBlbmQgKSB7XFxuXFx0XFx0XFx0XFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxcblxcdFxcdFxcdFxcdFxcdFxcdGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbIHByb3AgXSB8fCBhbmltYXRpb24ub3B0cy5lYXNpbmcgKTtcXG5cXHRcXHRcXHRcXHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHR3ZWVuO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0c3RvcDogZnVuY3Rpb24oIGdvdG9FbmQgKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGluZGV4ID0gMCxcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcXG5cXHRcXHRcXHRcXHRcXHQvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcXG5cXHRcXHRcXHRcXHRcXHRsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xcblxcdFxcdFxcdFxcdGlmICggc3RvcHBlZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0c3RvcHBlZCA9IHRydWU7XFxuXFx0XFx0XFx0XFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcXG5cXHRcXHRcXHRcXHRcXHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBSZXNvbHZlIHdoZW4gd2UgcGxheWVkIHRoZSBsYXN0IGZyYW1lOyBvdGhlcndpc2UsIHJlamVjdFxcblxcdFxcdFxcdFxcdGlmICggZ290b0VuZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XFxuXFx0XFx0XFx0XFx0XFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdGRlZmVycmVkLnJlamVjdFdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gKSxcXG5cXHRcXHRwcm9wcyA9IGFuaW1hdGlvbi5wcm9wcztcXG5cXG5cXHRwcm9wRmlsdGVyKCBwcm9wcywgYW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZyApO1xcblxcblxcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XFxuXFx0XFx0cmVzdWx0ID0gQW5pbWF0aW9uLnByZWZpbHRlcnNbIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBlbGVtLCBwcm9wcywgYW5pbWF0aW9uLm9wdHMgKTtcXG5cXHRcXHRpZiAoIHJlc3VsdCApIHtcXG5cXHRcXHRcXHRpZiAoIGlzRnVuY3Rpb24oIHJlc3VsdC5zdG9wICkgKSB7XFxuXFx0XFx0XFx0XFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCBhbmltYXRpb24uZWxlbSwgYW5pbWF0aW9uLm9wdHMucXVldWUgKS5zdG9wID1cXG5cXHRcXHRcXHRcXHRcXHRyZXN1bHQuc3RvcC5iaW5kKCByZXN1bHQgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIHJlc3VsdDtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdGpRdWVyeS5tYXAoIHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uICk7XFxuXFxuXFx0aWYgKCBpc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xcblxcdFxcdGFuaW1hdGlvbi5vcHRzLnN0YXJ0LmNhbGwoIGVsZW0sIGFuaW1hdGlvbiApO1xcblxcdH1cXG5cXG5cXHQvLyBBdHRhY2ggY2FsbGJhY2tzIGZyb20gb3B0aW9uc1xcblxcdGFuaW1hdGlvblxcblxcdFxcdC5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxcblxcdFxcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXFxuXFx0XFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxcblxcdFxcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xcblxcblxcdGpRdWVyeS5meC50aW1lcihcXG5cXHRcXHRqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7XFxuXFx0XFx0XFx0ZWxlbTogZWxlbSxcXG5cXHRcXHRcXHRhbmltOiBhbmltYXRpb24sXFxuXFx0XFx0XFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXFxuXFx0XFx0fSApXFxuXFx0KTtcXG5cXG5cXHRyZXR1cm4gYW5pbWF0aW9uO1xcbn1cXG5cXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XFxuXFxuXFx0dHdlZW5lcnM6IHtcXG5cXHRcXHRcXFwiKlxcXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xcblxcdFxcdFxcdHZhciB0d2VlbiA9IHRoaXMuY3JlYXRlVHdlZW4oIHByb3AsIHZhbHVlICk7XFxuXFx0XFx0XFx0YWRqdXN0Q1NTKCB0d2Vlbi5lbGVtLCBwcm9wLCByY3NzTnVtLmV4ZWMoIHZhbHVlICksIHR3ZWVuICk7XFxuXFx0XFx0XFx0cmV0dXJuIHR3ZWVuO1xcblxcdFxcdH0gXVxcblxcdH0sXFxuXFxuXFx0dHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHtcXG5cXHRcXHRpZiAoIGlzRnVuY3Rpb24oIHByb3BzICkgKSB7XFxuXFx0XFx0XFx0Y2FsbGJhY2sgPSBwcm9wcztcXG5cXHRcXHRcXHRwcm9wcyA9IFsgXFxcIipcXFwiIF07XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRwcm9wcyA9IHByb3BzLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHZhciBwcm9wLFxcblxcdFxcdFxcdGluZGV4ID0gMCxcXG5cXHRcXHRcXHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XFxuXFxuXFx0XFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcXG5cXHRcXHRcXHRwcm9wID0gcHJvcHNbIGluZGV4IF07XFxuXFx0XFx0XFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gPSBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXTtcXG5cXHRcXHRcXHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXS51bnNoaWZ0KCBjYWxsYmFjayApO1xcblxcdFxcdH1cXG5cXHR9LFxcblxcblxcdHByZWZpbHRlcnM6IFsgZGVmYXVsdFByZWZpbHRlciBdLFxcblxcblxcdHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xcblxcdFxcdGlmICggcHJlcGVuZCApIHtcXG5cXHRcXHRcXHRBbmltYXRpb24ucHJlZmlsdGVycy51bnNoaWZ0KCBjYWxsYmFjayApO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0QW5pbWF0aW9uLnByZWZpbHRlcnMucHVzaCggY2FsbGJhY2sgKTtcXG5cXHRcXHR9XFxuXFx0fVxcbn0gKTtcXG5cXG5qUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XFxuXFx0dmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXFxcIm9iamVjdFxcXCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcXG5cXHRcXHRjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxcblxcdFxcdFxcdGlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXFxuXFx0XFx0ZHVyYXRpb246IHNwZWVkLFxcblxcdFxcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXFxuXFx0fTtcXG5cXG5cXHQvLyBHbyB0byB0aGUgZW5kIHN0YXRlIGlmIGZ4IGFyZSBvZmZcXG5cXHRpZiAoIGpRdWVyeS5meC5vZmYgKSB7XFxuXFx0XFx0b3B0LmR1cmF0aW9uID0gMDtcXG5cXG5cXHR9IGVsc2Uge1xcblxcdFxcdGlmICggdHlwZW9mIG9wdC5kdXJhdGlvbiAhPT0gXFxcIm51bWJlclxcXCIgKSB7XFxuXFx0XFx0XFx0aWYgKCBvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyApIHtcXG5cXHRcXHRcXHRcXHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzWyBvcHQuZHVyYXRpb24gXTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0Ly8gTm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXFxcImZ4XFxcIlxcblxcdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xcblxcdFxcdG9wdC5xdWV1ZSA9IFxcXCJmeFxcXCI7XFxuXFx0fVxcblxcblxcdC8vIFF1ZXVlaW5nXFxuXFx0b3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcXG5cXG5cXHRvcHQuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRpZiAoIGlzRnVuY3Rpb24oIG9wdC5vbGQgKSApIHtcXG5cXHRcXHRcXHRvcHQub2xkLmNhbGwoIHRoaXMgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBvcHQucXVldWUgKSB7XFxuXFx0XFx0XFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIG9wdC5xdWV1ZSApO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdHJldHVybiBvcHQ7XFxufTtcXG5cXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XFxuXFx0ZmFkZVRvOiBmdW5jdGlvbiggc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrICkge1xcblxcblxcdFxcdC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxcblxcdFxcdHJldHVybiB0aGlzLmZpbHRlciggaXNIaWRkZW5XaXRoaW5UcmVlICkuY3NzKCBcXFwib3BhY2l0eVxcXCIsIDAgKS5zaG93KClcXG5cXG5cXHRcXHRcXHQvLyBBbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcXG5cXHRcXHRcXHQuZW5kKCkuYW5pbWF0ZSggeyBvcGFjaXR5OiB0byB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xcblxcdH0sXFxuXFx0YW5pbWF0ZTogZnVuY3Rpb24oIHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xcblxcdFxcdHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wICksXFxuXFx0XFx0XFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxcblxcdFxcdFxcdGRvQW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gT3BlcmF0ZSBvbiBhIGNvcHkgb2YgcHJvcCBzbyBwZXItcHJvcGVydHkgZWFzaW5nIHdvbid0IGJlIGxvc3RcXG5cXHRcXHRcXHRcXHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XFxuXFx0XFx0XFx0XFx0aWYgKCBlbXB0eSB8fCBkYXRhUHJpdi5nZXQoIHRoaXMsIFxcXCJmaW5pc2hcXFwiICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0YW5pbS5zdG9wKCB0cnVlICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH07XFxuXFx0XFx0XFx0ZG9BbmltYXRpb24uZmluaXNoID0gZG9BbmltYXRpb247XFxuXFxuXFx0XFx0cmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xcblxcdFxcdFxcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XFxuXFx0XFx0XFx0dGhpcy5xdWV1ZSggb3B0YWxsLnF1ZXVlLCBkb0FuaW1hdGlvbiApO1xcblxcdH0sXFxuXFx0c3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XFxuXFx0XFx0dmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uKCBob29rcyApIHtcXG5cXHRcXHRcXHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XFxuXFx0XFx0XFx0ZGVsZXRlIGhvb2tzLnN0b3A7XFxuXFx0XFx0XFx0c3RvcCggZ290b0VuZCApO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXFxcInN0cmluZ1xcXCIgKSB7XFxuXFx0XFx0XFx0Z290b0VuZCA9IGNsZWFyUXVldWU7XFxuXFx0XFx0XFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XFxuXFx0XFx0XFx0dHlwZSA9IHVuZGVmaW5lZDtcXG5cXHRcXHR9XFxuXFx0XFx0aWYgKCBjbGVhclF1ZXVlICYmIHR5cGUgIT09IGZhbHNlICkge1xcblxcdFxcdFxcdHRoaXMucXVldWUoIHR5cGUgfHwgXFxcImZ4XFxcIiwgW10gKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0dmFyIGRlcXVldWUgPSB0cnVlLFxcblxcdFxcdFxcdFxcdGluZGV4ID0gdHlwZSAhPSBudWxsICYmIHR5cGUgKyBcXFwicXVldWVIb29rc1xcXCIsXFxuXFx0XFx0XFx0XFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcXG5cXHRcXHRcXHRcXHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBpbmRleCApIHtcXG5cXHRcXHRcXHRcXHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICkge1xcblxcdFxcdFxcdFxcdFxcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcXG5cXHRcXHRcXHRcXHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmXFxuXFx0XFx0XFx0XFx0XFx0KCB0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xcblxcdFxcdFxcdFxcdFxcdGRlcXVldWUgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZC5cXG5cXHRcXHRcXHQvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXFxuXFx0XFx0XFx0Ly8gd2lsbCBkZXF1ZXVlIGJ1dCBvbmx5IGlmIHRoZXkgd2VyZSBnb3RvRW5kLlxcblxcdFxcdFxcdGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcXG5cXHRcXHRcXHRcXHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9ICk7XFxuXFx0fSxcXG5cXHRmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xcblxcdFxcdGlmICggdHlwZSAhPT0gZmFsc2UgKSB7XFxuXFx0XFx0XFx0dHlwZSA9IHR5cGUgfHwgXFxcImZ4XFxcIjtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0dmFyIGluZGV4LFxcblxcdFxcdFxcdFxcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKSxcXG5cXHRcXHRcXHRcXHRxdWV1ZSA9IGRhdGFbIHR5cGUgKyBcXFwicXVldWVcXFwiIF0sXFxuXFx0XFx0XFx0XFx0aG9va3MgPSBkYXRhWyB0eXBlICsgXFxcInF1ZXVlSG9va3NcXFwiIF0sXFxuXFx0XFx0XFx0XFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcXG5cXHRcXHRcXHRcXHRsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XFxuXFxuXFx0XFx0XFx0Ly8gRW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxcblxcdFxcdFxcdGRhdGEuZmluaXNoID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHQvLyBFbXB0eSB0aGUgcXVldWUgZmlyc3RcXG5cXHRcXHRcXHRqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIFtdICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBob29rcyAmJiBob29rcy5zdG9wICkge1xcblxcdFxcdFxcdFxcdGhvb2tzLnN0b3AuY2FsbCggdGhpcywgdHJ1ZSApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBMb29rIGZvciBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsIGFuZCBmaW5pc2ggdGhlbVxcblxcdFxcdFxcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggdHJ1ZSApO1xcblxcdFxcdFxcdFxcdFxcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxcblxcdFxcdFxcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCBxdWV1ZVsgaW5kZXggXSAmJiBxdWV1ZVsgaW5kZXggXS5maW5pc2ggKSB7XFxuXFx0XFx0XFx0XFx0XFx0cXVldWVbIGluZGV4IF0uZmluaXNoLmNhbGwoIHRoaXMgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXFxuXFx0XFx0XFx0ZGVsZXRlIGRhdGEuZmluaXNoO1xcblxcdFxcdH0gKTtcXG5cXHR9XFxufSApO1xcblxcbmpRdWVyeS5lYWNoKCBbIFxcXCJ0b2dnbGVcXFwiLCBcXFwic2hvd1xcXCIsIFxcXCJoaWRlXFxcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcXG5cXHR2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTtcXG5cXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcXG5cXHRcXHRyZXR1cm4gc3BlZWQgPT0gbnVsbCB8fCB0eXBlb2Ygc3BlZWQgPT09IFxcXCJib29sZWFuXFxcIiA/XFxuXFx0XFx0XFx0Y3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDpcXG5cXHRcXHRcXHR0aGlzLmFuaW1hdGUoIGdlbkZ4KCBuYW1lLCB0cnVlICksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XFxuXFx0fTtcXG59ICk7XFxuXFxuLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xcbmpRdWVyeS5lYWNoKCB7XFxuXFx0c2xpZGVEb3duOiBnZW5GeCggXFxcInNob3dcXFwiICksXFxuXFx0c2xpZGVVcDogZ2VuRngoIFxcXCJoaWRlXFxcIiApLFxcblxcdHNsaWRlVG9nZ2xlOiBnZW5GeCggXFxcInRvZ2dsZVxcXCIgKSxcXG5cXHRmYWRlSW46IHsgb3BhY2l0eTogXFxcInNob3dcXFwiIH0sXFxuXFx0ZmFkZU91dDogeyBvcGFjaXR5OiBcXFwiaGlkZVxcXCIgfSxcXG5cXHRmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFxcXCJ0b2dnbGVcXFwiIH1cXG59LCBmdW5jdGlvbiggbmFtZSwgcHJvcHMgKSB7XFxuXFx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XFxuXFx0fTtcXG59ICk7XFxuXFxualF1ZXJ5LnRpbWVycyA9IFtdO1xcbmpRdWVyeS5meC50aWNrID0gZnVuY3Rpb24oKSB7XFxuXFx0dmFyIHRpbWVyLFxcblxcdFxcdGkgPSAwLFxcblxcdFxcdHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XFxuXFxuXFx0ZnhOb3cgPSBEYXRlLm5vdygpO1xcblxcblxcdGZvciAoIDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKyApIHtcXG5cXHRcXHR0aW1lciA9IHRpbWVyc1sgaSBdO1xcblxcblxcdFxcdC8vIFJ1biB0aGUgdGltZXIgYW5kIHNhZmVseSByZW1vdmUgaXQgd2hlbiBkb25lIChhbGxvd2luZyBmb3IgZXh0ZXJuYWwgcmVtb3ZhbClcXG5cXHRcXHRpZiAoICF0aW1lcigpICYmIHRpbWVyc1sgaSBdID09PSB0aW1lciApIHtcXG5cXHRcXHRcXHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdGlmICggIXRpbWVycy5sZW5ndGggKSB7XFxuXFx0XFx0alF1ZXJ5LmZ4LnN0b3AoKTtcXG5cXHR9XFxuXFx0ZnhOb3cgPSB1bmRlZmluZWQ7XFxufTtcXG5cXG5qUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XFxuXFx0alF1ZXJ5LnRpbWVycy5wdXNoKCB0aW1lciApO1xcblxcdGpRdWVyeS5meC5zdGFydCgpO1xcbn07XFxuXFxualF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XFxualF1ZXJ5LmZ4LnN0YXJ0ID0gZnVuY3Rpb24oKSB7XFxuXFx0aWYgKCBpblByb2dyZXNzICkge1xcblxcdFxcdHJldHVybjtcXG5cXHR9XFxuXFxuXFx0aW5Qcm9ncmVzcyA9IHRydWU7XFxuXFx0c2NoZWR1bGUoKTtcXG59O1xcblxcbmpRdWVyeS5meC5zdG9wID0gZnVuY3Rpb24oKSB7XFxuXFx0aW5Qcm9ncmVzcyA9IG51bGw7XFxufTtcXG5cXG5qUXVlcnkuZnguc3BlZWRzID0ge1xcblxcdHNsb3c6IDYwMCxcXG5cXHRmYXN0OiAyMDAsXFxuXFxuXFx0Ly8gRGVmYXVsdCBzcGVlZFxcblxcdF9kZWZhdWx0OiA0MDBcXG59O1xcblxcblxcbi8vIEJhc2VkIG9mZiBvZiB0aGUgcGx1Z2luIGJ5IENsaW50IEhlbGZlcnMsIHdpdGggcGVybWlzc2lvbi5cXG4vLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxMDAzMjQwMTQ3NDcvaHR0cDovL2JsaW5kc2lnbmFscy5jb20vaW5kZXgucGhwLzIwMDkvMDcvanF1ZXJ5LWRlbGF5L1xcbmpRdWVyeS5mbi5kZWxheSA9IGZ1bmN0aW9uKCB0aW1lLCB0eXBlICkge1xcblxcdHRpbWUgPSBqUXVlcnkuZnggPyBqUXVlcnkuZnguc3BlZWRzWyB0aW1lIF0gfHwgdGltZSA6IHRpbWU7XFxuXFx0dHlwZSA9IHR5cGUgfHwgXFxcImZ4XFxcIjtcXG5cXG5cXHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSwgZnVuY3Rpb24oIG5leHQsIGhvb2tzICkge1xcblxcdFxcdHZhciB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoIG5leHQsIHRpbWUgKTtcXG5cXHRcXHRob29rcy5zdG9wID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dCApO1xcblxcdFxcdH07XFxuXFx0fSApO1xcbn07XFxuXFxuXFxuKCBmdW5jdGlvbigpIHtcXG5cXHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcXFwiaW5wdXRcXFwiICksXFxuXFx0XFx0c2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXFxcInNlbGVjdFxcXCIgKSxcXG5cXHRcXHRvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFxcXCJvcHRpb25cXFwiICkgKTtcXG5cXG5cXHRpbnB1dC50eXBlID0gXFxcImNoZWNrYm94XFxcIjtcXG5cXG5cXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4zIG9ubHlcXG5cXHQvLyBEZWZhdWx0IHZhbHVlIGZvciBhIGNoZWNrYm94IHNob3VsZCBiZSBcXFwib25cXFwiXFxuXFx0c3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFxcXCJcXFwiO1xcblxcblxcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxcblxcdC8vIE11c3QgYWNjZXNzIHNlbGVjdGVkSW5kZXggdG8gbWFrZSBkZWZhdWx0IG9wdGlvbnMgc2VsZWN0XFxuXFx0c3VwcG9ydC5vcHRTZWxlY3RlZCA9IG9wdC5zZWxlY3RlZDtcXG5cXG5cXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcXG5cXHQvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xcblxcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXFxcImlucHV0XFxcIiApO1xcblxcdGlucHV0LnZhbHVlID0gXFxcInRcXFwiO1xcblxcdGlucHV0LnR5cGUgPSBcXFwicmFkaW9cXFwiO1xcblxcdHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcXFwidFxcXCI7XFxufSApKCk7XFxuXFxuXFxudmFyIGJvb2xIb29rLFxcblxcdGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlO1xcblxcbmpRdWVyeS5mbi5leHRlbmQoIHtcXG5cXHRhdHRyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XFxuXFx0XFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LmF0dHIsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xcblxcdH0sXFxuXFxuXFx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0alF1ZXJ5LnJlbW92ZUF0dHIoIHRoaXMsIG5hbWUgKTtcXG5cXHRcXHR9ICk7XFxuXFx0fVxcbn0gKTtcXG5cXG5qUXVlcnkuZXh0ZW5kKCB7XFxuXFx0YXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xcblxcdFxcdHZhciByZXQsIGhvb2tzLFxcblxcdFxcdFxcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcXG5cXG5cXHRcXHQvLyBEb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXFxuXFx0XFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXFxuXFx0XFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IFxcXCJ1bmRlZmluZWRcXFwiICkge1xcblxcdFxcdFxcdHJldHVybiBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSwgdmFsdWUgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQXR0cmlidXRlIGhvb2tzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBsb3dlcmNhc2UgdmVyc2lvblxcblxcdFxcdC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcXG5cXHRcXHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcXG5cXHRcXHRcXHRob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8XFxuXFx0XFx0XFx0XFx0KCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogdW5kZWZpbmVkICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRcXHRpZiAoIHZhbHVlID09PSBudWxsICkge1xcblxcdFxcdFxcdFxcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIGhvb2tzICYmIFxcXCJzZXRcXFwiIGluIGhvb2tzICYmXFxuXFx0XFx0XFx0XFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdFxcdHJldHVybiByZXQ7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCB2YWx1ZSArIFxcXCJcXFwiICk7XFxuXFx0XFx0XFx0cmV0dXJuIHZhbHVlO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIGhvb2tzICYmIFxcXCJnZXRcXFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcXG5cXHRcXHRcXHRyZXR1cm4gcmV0O1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXQgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBuYW1lICk7XFxuXFxuXFx0XFx0Ly8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcXG5cXHRcXHRyZXR1cm4gcmV0ID09IG51bGwgPyB1bmRlZmluZWQgOiByZXQ7XFxuXFx0fSxcXG5cXG5cXHRhdHRySG9va3M6IHtcXG5cXHRcXHR0eXBlOiB7XFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCAhc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcXFwicmFkaW9cXFwiICYmXFxuXFx0XFx0XFx0XFx0XFx0bm9kZU5hbWUoIGVsZW0sIFxcXCJpbnB1dFxcXCIgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgdmFsID0gZWxlbS52YWx1ZTtcXG5cXHRcXHRcXHRcXHRcXHRlbGVtLnNldEF0dHJpYnV0ZSggXFxcInR5cGVcXFwiLCB2YWx1ZSApO1xcblxcdFxcdFxcdFxcdFxcdGlmICggdmFsICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGVsZW0udmFsdWUgPSB2YWw7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiB2YWx1ZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9LFxcblxcblxcdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcXG5cXHRcXHR2YXIgbmFtZSxcXG5cXHRcXHRcXHRpID0gMCxcXG5cXG5cXHRcXHRcXHQvLyBBdHRyaWJ1dGUgbmFtZXMgY2FuIGNvbnRhaW4gbm9uLUhUTUwgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXFxuXFx0XFx0XFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjYXR0cmlidXRlcy0yXFxuXFx0XFx0XFx0YXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcXG5cXG5cXHRcXHRpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xcblxcdFxcdFxcdHdoaWxlICggKCBuYW1lID0gYXR0ck5hbWVzWyBpKysgXSApICkge1xcblxcdFxcdFxcdFxcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxufSApO1xcblxcbi8vIEhvb2tzIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcXG5ib29sSG9vayA9IHtcXG5cXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcXG5cXHRcXHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcXG5cXG5cXHRcXHRcXHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXFxuXFx0XFx0XFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lICk7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiBuYW1lO1xcblxcdH1cXG59O1xcblxcbmpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcXFx3Ky9nICksIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xcblxcdHZhciBnZXR0ZXIgPSBhdHRySGFuZGxlWyBuYW1lIF0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcXG5cXG5cXHRhdHRySGFuZGxlWyBuYW1lIF0gPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XFxuXFx0XFx0dmFyIHJldCwgaGFuZGxlLFxcblxcdFxcdFxcdGxvd2VyY2FzZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XFxuXFxuXFx0XFx0aWYgKCAhaXNYTUwgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcCBieSB0ZW1wb3JhcmlseSByZW1vdmluZyB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIGdldHRlclxcblxcdFxcdFxcdGhhbmRsZSA9IGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXTtcXG5cXHRcXHRcXHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSByZXQ7XFxuXFx0XFx0XFx0cmV0ID0gZ2V0dGVyKCBlbGVtLCBuYW1lLCBpc1hNTCApICE9IG51bGwgP1xcblxcdFxcdFxcdFxcdGxvd2VyY2FzZU5hbWUgOlxcblxcdFxcdFxcdFxcdG51bGw7XFxuXFx0XFx0XFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gaGFuZGxlO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gcmV0O1xcblxcdH07XFxufSApO1xcblxcblxcblxcblxcbnZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcXG5cXHRyY2xpY2thYmxlID0gL14oPzphfGFyZWEpJC9pO1xcblxcbmpRdWVyeS5mbi5leHRlbmQoIHtcXG5cXHRwcm9wOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XFxuXFx0XFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xcblxcdH0sXFxuXFxuXFx0cmVtb3ZlUHJvcDogZnVuY3Rpb24oIG5hbWUgKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0ZGVsZXRlIHRoaXNbIGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZSBdO1xcblxcdFxcdH0gKTtcXG5cXHR9XFxufSApO1xcblxcbmpRdWVyeS5leHRlbmQoIHtcXG5cXHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XFxuXFx0XFx0dmFyIHJldCwgaG9va3MsXFxuXFx0XFx0XFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xcblxcblxcdFxcdC8vIERvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcXG5cXHRcXHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xcblxcdFxcdFxcdG5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XFxuXFx0XFx0XFx0aG9va3MgPSBqUXVlcnkucHJvcEhvb2tzWyBuYW1lIF07XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRcXHRpZiAoIGhvb2tzICYmIFxcXCJzZXRcXFwiIGluIGhvb2tzICYmXFxuXFx0XFx0XFx0XFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdFxcdHJldHVybiByZXQ7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiAoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggaG9va3MgJiYgXFxcImdldFxcXCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xcblxcdFxcdFxcdHJldHVybiByZXQ7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBlbGVtWyBuYW1lIF07XFxuXFx0fSxcXG5cXG5cXHRwcm9wSG9va3M6IHtcXG5cXHRcXHR0YWJJbmRleDoge1xcblxcdFxcdFxcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxcblxcdFxcdFxcdFxcdC8vIGVsZW0udGFiSW5kZXggZG9lc24ndCBhbHdheXMgcmV0dXJuIHRoZVxcblxcdFxcdFxcdFxcdC8vIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxcblxcdFxcdFxcdFxcdC8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDE0MTExNjIzMzM0Ny9odHRwOi8vZmx1aWRwcm9qZWN0Lm9yZy9ibG9nLzIwMDgvMDEvMDkvZ2V0dGluZy1zZXR0aW5nLWFuZC1yZW1vdmluZy10YWJpbmRleC12YWx1ZXMtd2l0aC1qYXZhc2NyaXB0L1xcblxcdFxcdFxcdFxcdC8vIFVzZSBwcm9wZXIgYXR0cmlidXRlIHJldHJpZXZhbCgjMTIwNzIpXFxuXFx0XFx0XFx0XFx0dmFyIHRhYmluZGV4ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXFxcInRhYmluZGV4XFxcIiApO1xcblxcblxcdFxcdFxcdFxcdGlmICggdGFiaW5kZXggKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHBhcnNlSW50KCB0YWJpbmRleCwgMTAgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKFxcblxcdFxcdFxcdFxcdFxcdHJmb2N1c2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApIHx8XFxuXFx0XFx0XFx0XFx0XFx0cmNsaWNrYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiZcXG5cXHRcXHRcXHRcXHRcXHRlbGVtLmhyZWZcXG5cXHRcXHRcXHRcXHQpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gMDtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIC0xO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fSxcXG5cXG5cXHRwcm9wRml4OiB7XFxuXFx0XFx0XFxcImZvclxcXCI6IFxcXCJodG1sRm9yXFxcIixcXG5cXHRcXHRcXFwiY2xhc3NcXFwiOiBcXFwiY2xhc3NOYW1lXFxcIlxcblxcdH1cXG59ICk7XFxuXFxuLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XFxuLy8gQWNjZXNzaW5nIHRoZSBzZWxlY3RlZEluZGV4IHByb3BlcnR5XFxuLy8gZm9yY2VzIHRoZSBicm93c2VyIHRvIHJlc3BlY3Qgc2V0dGluZyBzZWxlY3RlZFxcbi8vIG9uIHRoZSBvcHRpb25cXG4vLyBUaGUgZ2V0dGVyIGVuc3VyZXMgYSBkZWZhdWx0IG9wdGlvbiBpcyBzZWxlY3RlZFxcbi8vIHdoZW4gaW4gYW4gb3B0Z3JvdXBcXG4vLyBlc2xpbnQgcnVsZSBcXFwibm8tdW51c2VkLWV4cHJlc3Npb25zXFxcIiBpcyBkaXNhYmxlZCBmb3IgdGhpcyBjb2RlXFxuLy8gc2luY2UgaXQgY29uc2lkZXJzIHN1Y2ggYWNjZXNzaW9ucyBub29wXFxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcXG5cXHRqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkID0ge1xcblxcdFxcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFxuXFx0XFx0XFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXFxcIm9mZlxcXCIgKi9cXG5cXG5cXHRcXHRcXHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xcblxcdFxcdFxcdGlmICggcGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlICkge1xcblxcdFxcdFxcdFxcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBudWxsO1xcblxcdFxcdH0sXFxuXFx0XFx0c2V0OiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXG5cXHRcXHRcXHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcXFwib2ZmXFxcIiAqL1xcblxcblxcdFxcdFxcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XFxuXFx0XFx0XFx0aWYgKCBwYXJlbnQgKSB7XFxuXFx0XFx0XFx0XFx0cGFyZW50LnNlbGVjdGVkSW5kZXg7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBwYXJlbnQucGFyZW50Tm9kZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH07XFxufVxcblxcbmpRdWVyeS5lYWNoKCBbXFxuXFx0XFxcInRhYkluZGV4XFxcIixcXG5cXHRcXFwicmVhZE9ubHlcXFwiLFxcblxcdFxcXCJtYXhMZW5ndGhcXFwiLFxcblxcdFxcXCJjZWxsU3BhY2luZ1xcXCIsXFxuXFx0XFxcImNlbGxQYWRkaW5nXFxcIixcXG5cXHRcXFwicm93U3BhblxcXCIsXFxuXFx0XFxcImNvbFNwYW5cXFwiLFxcblxcdFxcXCJ1c2VNYXBcXFwiLFxcblxcdFxcXCJmcmFtZUJvcmRlclxcXCIsXFxuXFx0XFxcImNvbnRlbnRFZGl0YWJsZVxcXCJcXG5dLCBmdW5jdGlvbigpIHtcXG5cXHRqUXVlcnkucHJvcEZpeFsgdGhpcy50b0xvd2VyQ2FzZSgpIF0gPSB0aGlzO1xcbn0gKTtcXG5cXG5cXG5cXG5cXG5cXHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZSBhY2NvcmRpbmcgdG8gSFRNTCBzcGVjXFxuXFx0Ly8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS1hc2NpaS13aGl0ZXNwYWNlXFxuXFx0ZnVuY3Rpb24gc3RyaXBBbmRDb2xsYXBzZSggdmFsdWUgKSB7XFxuXFx0XFx0dmFyIHRva2VucyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XFxuXFx0XFx0cmV0dXJuIHRva2Vucy5qb2luKCBcXFwiIFxcXCIgKTtcXG5cXHR9XFxuXFxuXFxuZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XFxuXFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlICYmIGVsZW0uZ2V0QXR0cmlidXRlKCBcXFwiY2xhc3NcXFwiICkgfHwgXFxcIlxcXCI7XFxufVxcblxcbmZ1bmN0aW9uIGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApIHtcXG5cXHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XFxuXFx0XFx0cmV0dXJuIHZhbHVlO1xcblxcdH1cXG5cXHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXFxcInN0cmluZ1xcXCIgKSB7XFxuXFx0XFx0cmV0dXJuIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XFxuXFx0fVxcblxcdHJldHVybiBbXTtcXG59XFxuXFxualF1ZXJ5LmZuLmV4dGVuZCgge1xcblxcdGFkZENsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XFxuXFx0XFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxcblxcdFxcdFxcdGkgPSAwO1xcblxcblxcdFxcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcXG5cXHRcXHRcXHRcXHRqUXVlcnkoIHRoaXMgKS5hZGRDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XFxuXFx0XFx0XFx0fSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRjbGFzc2VzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XFxuXFxuXFx0XFx0aWYgKCBjbGFzc2VzLmxlbmd0aCApIHtcXG5cXHRcXHRcXHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XFxuXFx0XFx0XFx0XFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xcblxcdFxcdFxcdFxcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcXFwiIFxcXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXFxcIiBcXFwiICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBjdXIgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aiA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGN1ci5pbmRleE9mKCBcXFwiIFxcXCIgKyBjbGF6eiArIFxcXCIgXFxcIiApIDwgMCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjdXIgKz0gY2xhenogKyBcXFwiIFxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxcblxcdFxcdFxcdFxcdFxcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGVsZW0uc2V0QXR0cmlidXRlKCBcXFwiY2xhc3NcXFwiLCBmaW5hbFZhbHVlICk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB0aGlzO1xcblxcdH0sXFxuXFxuXFx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcXG5cXHRcXHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXFxuXFx0XFx0XFx0aSA9IDA7XFxuXFxuXFx0XFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xcblxcdFxcdFxcdFxcdGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcXG5cXHRcXHRcXHR9ICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuYXR0ciggXFxcImNsYXNzXFxcIiwgXFxcIlxcXCIgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Y2xhc3NlcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xcblxcblxcdFxcdGlmICggY2xhc3Nlcy5sZW5ndGggKSB7XFxuXFx0XFx0XFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xcblxcdFxcdFxcdFxcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxcblxcdFxcdFxcdFxcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcXFwiIFxcXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXFxcIiBcXFwiICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBjdXIgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aiA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXFxuXFx0XFx0XFx0XFx0XFx0XFx0d2hpbGUgKCBjdXIuaW5kZXhPZiggXFxcIiBcXFwiICsgY2xhenogKyBcXFwiIFxcXCIgKSA+IC0xICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGN1ciA9IGN1ci5yZXBsYWNlKCBcXFwiIFxcXCIgKyBjbGF6eiArIFxcXCIgXFxcIiwgXFxcIiBcXFwiICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxcblxcdFxcdFxcdFxcdFxcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGVsZW0uc2V0QXR0cmlidXRlKCBcXFwiY2xhc3NcXFwiLCBmaW5hbFZhbHVlICk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB0aGlzO1xcblxcdH0sXFxuXFxuXFx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XFxuXFx0XFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWUsXFxuXFx0XFx0XFx0aXNWYWxpZFZhbHVlID0gdHlwZSA9PT0gXFxcInN0cmluZ1xcXCIgfHwgQXJyYXkuaXNBcnJheSggdmFsdWUgKTtcXG5cXG5cXHRcXHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXFxcImJvb2xlYW5cXFwiICYmIGlzVmFsaWRWYWx1ZSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gc3RhdGVWYWwgPyB0aGlzLmFkZENsYXNzKCB2YWx1ZSApIDogdGhpcy5yZW1vdmVDbGFzcyggdmFsdWUgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xcblxcdFxcdFxcdFxcdGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKFxcblxcdFxcdFxcdFxcdFxcdHZhbHVlLmNhbGwoIHRoaXMsIGksIGdldENsYXNzKCB0aGlzICksIHN0YXRlVmFsICksXFxuXFx0XFx0XFx0XFx0XFx0c3RhdGVWYWxcXG5cXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdH0gKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0dmFyIGNsYXNzTmFtZSwgaSwgc2VsZiwgY2xhc3NOYW1lcztcXG5cXG5cXHRcXHRcXHRpZiAoIGlzVmFsaWRWYWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBUb2dnbGUgaW5kaXZpZHVhbCBjbGFzcyBuYW1lc1xcblxcdFxcdFxcdFxcdGkgPSAwO1xcblxcdFxcdFxcdFxcdHNlbGYgPSBqUXVlcnkoIHRoaXMgKTtcXG5cXHRcXHRcXHRcXHRjbGFzc05hbWVzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XFxuXFxuXFx0XFx0XFx0XFx0d2hpbGUgKCAoIGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkrKyBdICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gQ2hlY2sgZWFjaCBjbGFzc05hbWUgZ2l2ZW4sIHNwYWNlIHNlcGFyYXRlZCBsaXN0XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBzZWxmLmhhc0NsYXNzKCBjbGFzc05hbWUgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdHNlbGYuYWRkQ2xhc3MoIGNsYXNzTmFtZSApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gVG9nZ2xlIHdob2xlIGNsYXNzIG5hbWVcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFxcXCJib29sZWFuXFxcIiApIHtcXG5cXHRcXHRcXHRcXHRjbGFzc05hbWUgPSBnZXRDbGFzcyggdGhpcyApO1xcblxcdFxcdFxcdFxcdGlmICggY2xhc3NOYW1lICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcXG5cXHRcXHRcXHRcXHRcXHRkYXRhUHJpdi5zZXQoIHRoaXMsIFxcXCJfX2NsYXNzTmFtZV9fXFxcIiwgY2xhc3NOYW1lICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXFxuXFx0XFx0XFx0XFx0Ly8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cXG5cXHRcXHRcXHRcXHQvLyBPdGhlcndpc2UgYnJpbmcgYmFjayB3aGF0ZXZlciB3YXMgcHJldmlvdXNseSBzYXZlZCAoaWYgYW55dGhpbmcpLFxcblxcdFxcdFxcdFxcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cXG5cXHRcXHRcXHRcXHRpZiAoIHRoaXMuc2V0QXR0cmlidXRlICkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuc2V0QXR0cmlidXRlKCBcXFwiY2xhc3NcXFwiLFxcblxcdFxcdFxcdFxcdFxcdFxcdGNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2UgP1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcXCJcXFwiIDpcXG5cXHRcXHRcXHRcXHRcXHRcXHRkYXRhUHJpdi5nZXQoIHRoaXMsIFxcXCJfX2NsYXNzTmFtZV9fXFxcIiApIHx8IFxcXCJcXFwiXFxuXFx0XFx0XFx0XFx0XFx0KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gKTtcXG5cXHR9LFxcblxcblxcdGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XFxuXFx0XFx0dmFyIGNsYXNzTmFtZSwgZWxlbSxcXG5cXHRcXHRcXHRpID0gMDtcXG5cXG5cXHRcXHRjbGFzc05hbWUgPSBcXFwiIFxcXCIgKyBzZWxlY3RvciArIFxcXCIgXFxcIjtcXG5cXHRcXHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XFxuXFx0XFx0XFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmXFxuXFx0XFx0XFx0XFx0KCBcXFwiIFxcXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBnZXRDbGFzcyggZWxlbSApICkgKyBcXFwiIFxcXCIgKS5pbmRleE9mKCBjbGFzc05hbWUgKSA+IC0xICkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdH1cXG59ICk7XFxuXFxuXFxuXFxuXFxudmFyIHJyZXR1cm4gPSAvXFxcXHIvZztcXG5cXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XFxuXFx0dmFsOiBmdW5jdGlvbiggdmFsdWUgKSB7XFxuXFx0XFx0dmFyIGhvb2tzLCByZXQsIHZhbHVlSXNGdW5jdGlvbixcXG5cXHRcXHRcXHRlbGVtID0gdGhpc1sgMCBdO1xcblxcblxcdFxcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XFxuXFx0XFx0XFx0aWYgKCBlbGVtICkge1xcblxcdFxcdFxcdFxcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fFxcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS52YWxIb29rc1sgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBob29rcyAmJlxcblxcdFxcdFxcdFxcdFxcdFxcXCJnZXRcXFwiIGluIGhvb2tzICYmXFxuXFx0XFx0XFx0XFx0XFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIFxcXCJ2YWx1ZVxcXCIgKSApICE9PSB1bmRlZmluZWRcXG5cXHRcXHRcXHRcXHQpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gcmV0O1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXQgPSBlbGVtLnZhbHVlO1xcblxcblxcdFxcdFxcdFxcdC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcXG5cXHRcXHRcXHRcXHRpZiAoIHR5cGVvZiByZXQgPT09IFxcXCJzdHJpbmdcXFwiICkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiByZXQucmVwbGFjZSggcnJldHVybiwgXFxcIlxcXCIgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJldCA9PSBudWxsID8gXFxcIlxcXCIgOiByZXQ7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggdmFsdWUgKTtcXG5cXG5cXHRcXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcXG5cXHRcXHRcXHR2YXIgdmFsO1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5ub2RlVHlwZSAhPT0gMSApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggdmFsdWVJc0Z1bmN0aW9uICkge1xcblxcdFxcdFxcdFxcdHZhbCA9IHZhbHVlLmNhbGwoIHRoaXMsIGksIGpRdWVyeSggdGhpcyApLnZhbCgpICk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHR2YWwgPSB2YWx1ZTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXFxcIlxcXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcXG5cXHRcXHRcXHRpZiAoIHZhbCA9PSBudWxsICkge1xcblxcdFxcdFxcdFxcdHZhbCA9IFxcXCJcXFwiO1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09IFxcXCJudW1iZXJcXFwiICkge1xcblxcdFxcdFxcdFxcdHZhbCArPSBcXFwiXFxcIjtcXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcXG5cXHRcXHRcXHRcXHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFxcXCJcXFwiIDogdmFsdWUgKyBcXFwiXFxcIjtcXG5cXHRcXHRcXHRcXHR9ICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xcblxcblxcdFxcdFxcdC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXFxuXFx0XFx0XFx0aWYgKCAhaG9va3MgfHwgISggXFxcInNldFxcXCIgaW4gaG9va3MgKSB8fCBob29rcy5zZXQoIHRoaXMsIHZhbCwgXFxcInZhbHVlXFxcIiApID09PSB1bmRlZmluZWQgKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy52YWx1ZSA9IHZhbDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSApO1xcblxcdH1cXG59ICk7XFxuXFxualF1ZXJ5LmV4dGVuZCgge1xcblxcdHZhbEhvb2tzOiB7XFxuXFx0XFx0b3B0aW9uOiB7XFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdmFsID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXFxcInZhbHVlXFxcIiApO1xcblxcdFxcdFxcdFxcdHJldHVybiB2YWwgIT0gbnVsbCA/XFxuXFx0XFx0XFx0XFx0XFx0dmFsIDpcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEgb25seVxcblxcdFxcdFxcdFxcdFxcdC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICgjMTQ2ODYsICMxNDg1OClcXG5cXHRcXHRcXHRcXHRcXHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZVxcblxcdFxcdFxcdFxcdFxcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXFxuXFx0XFx0XFx0XFx0XFx0c3RyaXBBbmRDb2xsYXBzZSggalF1ZXJ5LnRleHQoIGVsZW0gKSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdHNlbGVjdDoge1xcblxcdFxcdFxcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0XFx0dmFyIHZhbHVlLCBvcHRpb24sIGksXFxuXFx0XFx0XFx0XFx0XFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcXG5cXHRcXHRcXHRcXHRcXHRpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcXG5cXHRcXHRcXHRcXHRcXHRvbmUgPSBlbGVtLnR5cGUgPT09IFxcXCJzZWxlY3Qtb25lXFxcIixcXG5cXHRcXHRcXHRcXHRcXHR2YWx1ZXMgPSBvbmUgPyBudWxsIDogW10sXFxuXFx0XFx0XFx0XFx0XFx0bWF4ID0gb25lID8gaW5kZXggKyAxIDogb3B0aW9ucy5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBpbmRleCA8IDAgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aSA9IG1heDtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdGkgPSBvbmUgPyBpbmRleCA6IDA7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNlbGVjdGVkIG9wdGlvbnNcXG5cXHRcXHRcXHRcXHRmb3IgKCA7IGkgPCBtYXg7IGkrKyApIHtcXG5cXHRcXHRcXHRcXHRcXHRvcHRpb24gPSBvcHRpb25zWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcXG5cXHRcXHRcXHRcXHRcXHQvLyBJRTgtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcXG5cXHRcXHRcXHRcXHRcXHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0IW9wdGlvbi5kaXNhYmxlZCAmJlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCggIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0IW5vZGVOYW1lKCBvcHRpb24ucGFyZW50Tm9kZSwgXFxcIm9wdGdyb3VwXFxcIiApICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gR2V0IHRoZSBzcGVjaWZpYyB2YWx1ZSBmb3IgdGhlIG9wdGlvblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhbHVlID0galF1ZXJ5KCBvcHRpb24gKS52YWwoKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBXZSBkb24ndCBuZWVkIGFuIGFycmF5IGZvciBvbmUgc2VsZWN0c1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggb25lICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB2YWx1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJldHVybiB2YWx1ZXM7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcXG5cXHRcXHRcXHRcXHR2YXIgb3B0aW9uU2V0LCBvcHRpb24sXFxuXFx0XFx0XFx0XFx0XFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcXG5cXHRcXHRcXHRcXHRcXHR2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApLFxcblxcdFxcdFxcdFxcdFxcdGkgPSBvcHRpb25zLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHRcXHR3aGlsZSAoIGktLSApIHtcXG5cXHRcXHRcXHRcXHRcXHRvcHRpb24gPSBvcHRpb25zWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0LyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIG9wdGlvbi5zZWxlY3RlZCA9XFxuXFx0XFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPiAtMVxcblxcdFxcdFxcdFxcdFxcdCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdG9wdGlvblNldCA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRm9yY2UgYnJvd3NlcnMgdG8gYmVoYXZlIGNvbnNpc3RlbnRseSB3aGVuIG5vbi1tYXRjaGluZyB2YWx1ZSBpcyBzZXRcXG5cXHRcXHRcXHRcXHRpZiAoICFvcHRpb25TZXQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiB2YWx1ZXM7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxufSApO1xcblxcbi8vIFJhZGlvcyBhbmQgY2hlY2tib3hlcyBnZXR0ZXIvc2V0dGVyXFxualF1ZXJ5LmVhY2goIFsgXFxcInJhZGlvXFxcIiwgXFxcImNoZWNrYm94XFxcIiBdLCBmdW5jdGlvbigpIHtcXG5cXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcXG5cXHRcXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcXG5cXHRcXHRcXHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeSggZWxlbSApLnZhbCgpLCB2YWx1ZSApID4gLTEgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH07XFxuXFx0aWYgKCAhc3VwcG9ydC5jaGVja09uICkge1xcblxcdFxcdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdLmdldCA9IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXFxcInZhbHVlXFxcIiApID09PSBudWxsID8gXFxcIm9uXFxcIiA6IGVsZW0udmFsdWU7XFxuXFx0XFx0fTtcXG5cXHR9XFxufSApO1xcblxcblxcblxcblxcbi8vIFJldHVybiBqUXVlcnkgZm9yIGF0dHJpYnV0ZXMtb25seSBpbmNsdXNpb25cXG5cXG5cXG5zdXBwb3J0LmZvY3VzaW4gPSBcXFwib25mb2N1c2luXFxcIiBpbiB3aW5kb3c7XFxuXFxuXFxudmFyIHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLFxcblxcdHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrID0gZnVuY3Rpb24oIGUgKSB7XFxuXFx0XFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcXG5cXHR9O1xcblxcbmpRdWVyeS5leHRlbmQoIGpRdWVyeS5ldmVudCwge1xcblxcblxcdHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xcblxcblxcdFxcdHZhciBpLCBjdXIsIHRtcCwgYnViYmxlVHlwZSwgb250eXBlLCBoYW5kbGUsIHNwZWNpYWwsIGxhc3RFbGVtZW50LFxcblxcdFxcdFxcdGV2ZW50UGF0aCA9IFsgZWxlbSB8fCBkb2N1bWVudCBdLFxcblxcdFxcdFxcdHR5cGUgPSBoYXNPd24uY2FsbCggZXZlbnQsIFxcXCJ0eXBlXFxcIiApID8gZXZlbnQudHlwZSA6IGV2ZW50LFxcblxcdFxcdFxcdG5hbWVzcGFjZXMgPSBoYXNPd24uY2FsbCggZXZlbnQsIFxcXCJuYW1lc3BhY2VcXFwiICkgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoIFxcXCIuXFxcIiApIDogW107XFxuXFxuXFx0XFx0Y3VyID0gbGFzdEVsZW1lbnQgPSB0bXAgPSBlbGVtID0gZWxlbSB8fCBkb2N1bWVudDtcXG5cXG5cXHRcXHQvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xcblxcdFxcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4ICkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gZm9jdXMvYmx1ciBtb3JwaHMgdG8gZm9jdXNpbi9vdXQ7IGVuc3VyZSB3ZSdyZSBub3QgZmlyaW5nIHRoZW0gcmlnaHQgbm93XFxuXFx0XFx0aWYgKCByZm9jdXNNb3JwaC50ZXN0KCB0eXBlICsgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCApICkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCB0eXBlLmluZGV4T2YoIFxcXCIuXFxcIiApID4gLTEgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxcblxcdFxcdFxcdG5hbWVzcGFjZXMgPSB0eXBlLnNwbGl0KCBcXFwiLlxcXCIgKTtcXG5cXHRcXHRcXHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xcblxcdFxcdFxcdG5hbWVzcGFjZXMuc29ydCgpO1xcblxcdFxcdH1cXG5cXHRcXHRvbnR5cGUgPSB0eXBlLmluZGV4T2YoIFxcXCI6XFxcIiApIDwgMCAmJiBcXFwib25cXFwiICsgdHlwZTtcXG5cXG5cXHRcXHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYSBqUXVlcnkuRXZlbnQgb2JqZWN0LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmdcXG5cXHRcXHRldmVudCA9IGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cXG5cXHRcXHRcXHRldmVudCA6XFxuXFx0XFx0XFx0bmV3IGpRdWVyeS5FdmVudCggdHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcXFwib2JqZWN0XFxcIiAmJiBldmVudCApO1xcblxcblxcdFxcdC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcXG5cXHRcXHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcXG5cXHRcXHRldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oIFxcXCIuXFxcIiApO1xcblxcdFxcdGV2ZW50LnJuYW1lc3BhY2UgPSBldmVudC5uYW1lc3BhY2UgP1xcblxcdFxcdFxcdG5ldyBSZWdFeHAoIFxcXCIoXnxcXFxcXFxcXC4pXFxcIiArIG5hbWVzcGFjZXMuam9pbiggXFxcIlxcXFxcXFxcLig/Oi4qXFxcXFxcXFwufClcXFwiICkgKyBcXFwiKFxcXFxcXFxcLnwkKVxcXCIgKSA6XFxuXFx0XFx0XFx0bnVsbDtcXG5cXG5cXHRcXHQvLyBDbGVhbiB1cCB0aGUgZXZlbnQgaW4gY2FzZSBpdCBpcyBiZWluZyByZXVzZWRcXG5cXHRcXHRldmVudC5yZXN1bHQgPSB1bmRlZmluZWQ7XFxuXFx0XFx0aWYgKCAhZXZlbnQudGFyZ2V0ICkge1xcblxcdFxcdFxcdGV2ZW50LnRhcmdldCA9IGVsZW07XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3RcXG5cXHRcXHRkYXRhID0gZGF0YSA9PSBudWxsID9cXG5cXHRcXHRcXHRbIGV2ZW50IF0gOlxcblxcdFxcdFxcdGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEsIFsgZXZlbnQgXSApO1xcblxcblxcdFxcdC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcXG5cXHRcXHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcXG5cXHRcXHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxcblxcdFxcdC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXFxuXFx0XFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFpc1dpbmRvdyggZWxlbSApICkge1xcblxcblxcdFxcdFxcdGJ1YmJsZVR5cGUgPSBzcGVjaWFsLmRlbGVnYXRlVHlwZSB8fCB0eXBlO1xcblxcdFxcdFxcdGlmICggIXJmb2N1c01vcnBoLnRlc3QoIGJ1YmJsZVR5cGUgKyB0eXBlICkgKSB7XFxuXFx0XFx0XFx0XFx0Y3VyID0gY3VyLnBhcmVudE5vZGU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcXG5cXHRcXHRcXHRcXHRldmVudFBhdGgucHVzaCggY3VyICk7XFxuXFx0XFx0XFx0XFx0dG1wID0gY3VyO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBPbmx5IGFkZCB3aW5kb3cgaWYgd2UgZ290IHRvIGRvY3VtZW50IChlLmcuLCBub3QgcGxhaW4gb2JqIG9yIGRldGFjaGVkIERPTSlcXG5cXHRcXHRcXHRpZiAoIHRtcCA9PT0gKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgKSApIHtcXG5cXHRcXHRcXHRcXHRldmVudFBhdGgucHVzaCggdG1wLmRlZmF1bHRWaWV3IHx8IHRtcC5wYXJlbnRXaW5kb3cgfHwgd2luZG93ICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXFxuXFx0XFx0aSA9IDA7XFxuXFx0XFx0d2hpbGUgKCAoIGN1ciA9IGV2ZW50UGF0aFsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcXG5cXHRcXHRcXHRsYXN0RWxlbWVudCA9IGN1cjtcXG5cXHRcXHRcXHRldmVudC50eXBlID0gaSA+IDEgP1xcblxcdFxcdFxcdFxcdGJ1YmJsZVR5cGUgOlxcblxcdFxcdFxcdFxcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcXG5cXG5cXHRcXHRcXHQvLyBqUXVlcnkgaGFuZGxlclxcblxcdFxcdFxcdGhhbmRsZSA9ICggZGF0YVByaXYuZ2V0KCBjdXIsIFxcXCJldmVudHNcXFwiICkgfHwge30gKVsgZXZlbnQudHlwZSBdICYmXFxuXFx0XFx0XFx0XFx0ZGF0YVByaXYuZ2V0KCBjdXIsIFxcXCJoYW5kbGVcXFwiICk7XFxuXFx0XFx0XFx0aWYgKCBoYW5kbGUgKSB7XFxuXFx0XFx0XFx0XFx0aGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gTmF0aXZlIGhhbmRsZXJcXG5cXHRcXHRcXHRoYW5kbGUgPSBvbnR5cGUgJiYgY3VyWyBvbnR5cGUgXTtcXG5cXHRcXHRcXHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YSggY3VyICkgKSB7XFxuXFx0XFx0XFx0XFx0ZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcXG5cXHRcXHRcXHRcXHRpZiAoIGV2ZW50LnJlc3VsdCA9PT0gZmFsc2UgKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHRcXHRldmVudC50eXBlID0gdHlwZTtcXG5cXG5cXHRcXHQvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XFxuXFx0XFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcXG5cXG5cXHRcXHRcXHRpZiAoICggIXNwZWNpYWwuX2RlZmF1bHQgfHxcXG5cXHRcXHRcXHRcXHRzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UgKSAmJlxcblxcdFxcdFxcdFxcdGFjY2VwdERhdGEoIGVsZW0gKSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxcblxcdFxcdFxcdFxcdC8vIERvbid0IGRvIGRlZmF1bHQgYWN0aW9ucyBvbiB3aW5kb3csIHRoYXQncyB3aGVyZSBnbG9iYWwgdmFyaWFibGVzIGJlICgjNjE3MClcXG5cXHRcXHRcXHRcXHRpZiAoIG9udHlwZSAmJiBpc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXFxuXFx0XFx0XFx0XFx0XFx0dG1wID0gZWxlbVsgb250eXBlIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB0bXAgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxlbVsgb250eXBlIF0gPSBudWxsO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRsYXN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRlbGVtWyB0eXBlIF0oKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bGFzdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHVuZGVmaW5lZDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHRtcCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRlbGVtWyBvbnR5cGUgXSA9IHRtcDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcXG5cXHR9LFxcblxcblxcdC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZVxcblxcdC8vIFVzZWQgb25seSBmb3IgYGZvY3VzKGluIHwgb3V0KWAgZXZlbnRzXFxuXFx0c2ltdWxhdGU6IGZ1bmN0aW9uKCB0eXBlLCBlbGVtLCBldmVudCApIHtcXG5cXHRcXHR2YXIgZSA9IGpRdWVyeS5leHRlbmQoXFxuXFx0XFx0XFx0bmV3IGpRdWVyeS5FdmVudCgpLFxcblxcdFxcdFxcdGV2ZW50LFxcblxcdFxcdFxcdHtcXG5cXHRcXHRcXHRcXHR0eXBlOiB0eXBlLFxcblxcdFxcdFxcdFxcdGlzU2ltdWxhdGVkOiB0cnVlXFxuXFx0XFx0XFx0fVxcblxcdFxcdCk7XFxuXFxuXFx0XFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIGUsIG51bGwsIGVsZW0gKTtcXG5cXHR9XFxuXFxufSApO1xcblxcbmpRdWVyeS5mbi5leHRlbmQoIHtcXG5cXG5cXHR0cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpcyApO1xcblxcdFxcdH0gKTtcXG5cXHR9LFxcblxcdHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcXG5cXHRcXHR2YXIgZWxlbSA9IHRoaXNbIDAgXTtcXG5cXHRcXHRpZiAoIGVsZW0gKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCBlbGVtLCB0cnVlICk7XFxuXFx0XFx0fVxcblxcdH1cXG59ICk7XFxuXFxuXFxuLy8gU3VwcG9ydDogRmlyZWZveCA8PTQ0XFxuLy8gRmlyZWZveCBkb2Vzbid0IGhhdmUgZm9jdXMoaW4gfCBvdXQpIGV2ZW50c1xcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njg3Nzg3XFxuLy9cXG4vLyBTdXBwb3J0OiBDaHJvbWUgPD00OCAtIDQ5LCBTYWZhcmkgPD05LjAgLSA5LjFcXG4vLyBmb2N1cyhpbiB8IG91dCkgZXZlbnRzIGZpcmUgYWZ0ZXIgZm9jdXMgJiBibHVyIGV2ZW50cyxcXG4vLyB3aGljaCBpcyBzcGVjIHZpb2xhdGlvbiAtIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWZvY3VzZXZlbnQtZXZlbnQtb3JkZXJcXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0OTg1N1xcbmlmICggIXN1cHBvcnQuZm9jdXNpbiApIHtcXG5cXHRqUXVlcnkuZWFjaCggeyBmb2N1czogXFxcImZvY3VzaW5cXFwiLCBibHVyOiBcXFwiZm9jdXNvdXRcXFwiIH0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XFxuXFxuXFx0XFx0Ly8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcXG5cXHRcXHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcXG5cXHRcXHRcXHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApICk7XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZml4IF0gPSB7XFxuXFx0XFx0XFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcXG5cXHRcXHRcXHRcXHRcXHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoICFhdHRhY2hlcyApIHtcXG5cXHRcXHRcXHRcXHRcXHRkb2MuYWRkRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXFxuXFx0XFx0XFx0XFx0XFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICkgLSAxO1xcblxcblxcdFxcdFxcdFxcdGlmICggIWF0dGFjaGVzICkge1xcblxcdFxcdFxcdFxcdFxcdGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XFxuXFx0XFx0XFx0XFx0XFx0ZGF0YVByaXYucmVtb3ZlKCBkb2MsIGZpeCApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgYXR0YWNoZXMgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFx0fSApO1xcbn1cXG52YXIgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XFxuXFxudmFyIG5vbmNlID0gRGF0ZS5ub3coKTtcXG5cXG52YXIgcnF1ZXJ5ID0gKCAvXFxcXD8vICk7XFxuXFxuXFxuXFxuLy8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xcblxcdHZhciB4bWw7XFxuXFx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXFxcInN0cmluZ1xcXCIgKSB7XFxuXFx0XFx0cmV0dXJuIG51bGw7XFxuXFx0fVxcblxcblxcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XFxuXFx0Ly8gSUUgdGhyb3dzIG9uIHBhcnNlRnJvbVN0cmluZyB3aXRoIGludmFsaWQgaW5wdXQuXFxuXFx0dHJ5IHtcXG5cXHRcXHR4bWwgPSAoIG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkgKS5wYXJzZUZyb21TdHJpbmcoIGRhdGEsIFxcXCJ0ZXh0L3htbFxcXCIgKTtcXG5cXHR9IGNhdGNoICggZSApIHtcXG5cXHRcXHR4bWwgPSB1bmRlZmluZWQ7XFxuXFx0fVxcblxcblxcdGlmICggIXhtbCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFxcXCJwYXJzZXJlcnJvclxcXCIgKS5sZW5ndGggKSB7XFxuXFx0XFx0alF1ZXJ5LmVycm9yKCBcXFwiSW52YWxpZCBYTUw6IFxcXCIgKyBkYXRhICk7XFxuXFx0fVxcblxcdHJldHVybiB4bWw7XFxufTtcXG5cXG5cXG52YXJcXG5cXHRyYnJhY2tldCA9IC9cXFxcW1xcXFxdJC8sXFxuXFx0ckNSTEYgPSAvXFxcXHI/XFxcXG4vZyxcXG5cXHRyc3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXFxuXFx0cnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xcblxcbmZ1bmN0aW9uIGJ1aWxkUGFyYW1zKCBwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCApIHtcXG5cXHR2YXIgbmFtZTtcXG5cXG5cXHRpZiAoIEFycmF5LmlzQXJyYXkoIG9iaiApICkge1xcblxcblxcdFxcdC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxcblxcdFxcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xcblxcdFxcdFxcdGlmICggdHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdCggcHJlZml4ICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxcblxcdFxcdFxcdFxcdGFkZCggcHJlZml4LCB2ICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cXG5cXHRcXHRcXHRcXHRidWlsZFBhcmFtcyhcXG5cXHRcXHRcXHRcXHRcXHRwcmVmaXggKyBcXFwiW1xcXCIgKyAoIHR5cGVvZiB2ID09PSBcXFwib2JqZWN0XFxcIiAmJiB2ICE9IG51bGwgPyBpIDogXFxcIlxcXCIgKSArIFxcXCJdXFxcIixcXG5cXHRcXHRcXHRcXHRcXHR2LFxcblxcdFxcdFxcdFxcdFxcdHRyYWRpdGlvbmFsLFxcblxcdFxcdFxcdFxcdFxcdGFkZFxcblxcdFxcdFxcdFxcdCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gKTtcXG5cXG5cXHR9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgdG9UeXBlKCBvYmogKSA9PT0gXFxcIm9iamVjdFxcXCIgKSB7XFxuXFxuXFx0XFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxcblxcdFxcdGZvciAoIG5hbWUgaW4gb2JqICkge1xcblxcdFxcdFxcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcXFwiW1xcXCIgKyBuYW1lICsgXFxcIl1cXFwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xcblxcdFxcdH1cXG5cXG5cXHR9IGVsc2Uge1xcblxcblxcdFxcdC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cXG5cXHRcXHRhZGQoIHByZWZpeCwgb2JqICk7XFxuXFx0fVxcbn1cXG5cXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxcbi8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xcbmpRdWVyeS5wYXJhbSA9IGZ1bmN0aW9uKCBhLCB0cmFkaXRpb25hbCApIHtcXG5cXHR2YXIgcHJlZml4LFxcblxcdFxcdHMgPSBbXSxcXG5cXHRcXHRhZGQgPSBmdW5jdGlvbigga2V5LCB2YWx1ZU9yRnVuY3Rpb24gKSB7XFxuXFxuXFx0XFx0XFx0Ly8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCB1c2UgaXRzIHJldHVybiB2YWx1ZVxcblxcdFxcdFxcdHZhciB2YWx1ZSA9IGlzRnVuY3Rpb24oIHZhbHVlT3JGdW5jdGlvbiApID9cXG5cXHRcXHRcXHRcXHR2YWx1ZU9yRnVuY3Rpb24oKSA6XFxuXFx0XFx0XFx0XFx0dmFsdWVPckZ1bmN0aW9uO1xcblxcblxcdFxcdFxcdHNbIHMubGVuZ3RoIF0gPSBlbmNvZGVVUklDb21wb25lbnQoIGtleSApICsgXFxcIj1cXFwiICtcXG5cXHRcXHRcXHRcXHRlbmNvZGVVUklDb21wb25lbnQoIHZhbHVlID09IG51bGwgPyBcXFwiXFxcIiA6IHZhbHVlICk7XFxuXFx0XFx0fTtcXG5cXG5cXHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxcblxcdGlmICggQXJyYXkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcXG5cXG5cXHRcXHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcXG5cXHRcXHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0YWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTtcXG5cXHRcXHR9ICk7XFxuXFxuXFx0fSBlbHNlIHtcXG5cXG5cXHRcXHQvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcXFwib2xkXFxcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcXG5cXHRcXHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cXG5cXHRcXHRmb3IgKCBwcmVmaXggaW4gYSApIHtcXG5cXHRcXHRcXHRidWlsZFBhcmFtcyggcHJlZml4LCBhWyBwcmVmaXggXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxcblxcdHJldHVybiBzLmpvaW4oIFxcXCImXFxcIiApO1xcbn07XFxuXFxualF1ZXJ5LmZuLmV4dGVuZCgge1xcblxcdHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XFxuXFx0XFx0cmV0dXJuIGpRdWVyeS5wYXJhbSggdGhpcy5zZXJpYWxpemVBcnJheSgpICk7XFxuXFx0fSxcXG5cXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcXG5cXG5cXHRcXHRcXHQvLyBDYW4gYWRkIHByb3BIb29rIGZvciBcXFwiZWxlbWVudHNcXFwiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xcblxcdFxcdFxcdHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKCB0aGlzLCBcXFwiZWxlbWVudHNcXFwiICk7XFxuXFx0XFx0XFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XFxuXFx0XFx0fSApXFxuXFx0XFx0LmZpbHRlciggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0dmFyIHR5cGUgPSB0aGlzLnR5cGU7XFxuXFxuXFx0XFx0XFx0Ly8gVXNlIC5pcyggXFxcIjpkaXNhYmxlZFxcXCIgKSBzbyB0aGF0IGZpZWxkc2V0W2Rpc2FibGVkXSB3b3Jrc1xcblxcdFxcdFxcdHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcXFwiOmRpc2FibGVkXFxcIiApICYmXFxuXFx0XFx0XFx0XFx0cnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxcblxcdFxcdFxcdFxcdCggdGhpcy5jaGVja2VkIHx8ICFyY2hlY2thYmxlVHlwZS50ZXN0KCB0eXBlICkgKTtcXG5cXHRcXHR9IClcXG5cXHRcXHQubWFwKCBmdW5jdGlvbiggaSwgZWxlbSApIHtcXG5cXHRcXHRcXHR2YXIgdmFsID0galF1ZXJ5KCB0aGlzICkudmFsKCk7XFxuXFxuXFx0XFx0XFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gbnVsbDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsICkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXFxcIlxcXFxyXFxcXG5cXFwiICkgfTtcXG5cXHRcXHRcXHRcXHR9ICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXFxcIlxcXFxyXFxcXG5cXFwiICkgfTtcXG5cXHRcXHR9ICkuZ2V0KCk7XFxuXFx0fVxcbn0gKTtcXG5cXG5cXG52YXJcXG5cXHRyMjAgPSAvJTIwL2csXFxuXFx0cmhhc2ggPSAvIy4qJC8sXFxuXFx0cmFudGlDYWNoZSA9IC8oWz8mXSlfPVteJl0qLyxcXG5cXHRyaGVhZGVycyA9IC9eKC4qPyk6WyBcXFxcdF0qKFteXFxcXHJcXFxcbl0qKSQvbWcsXFxuXFxuXFx0Ly8gIzc2NTMsICM4MTI1LCAjODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXFxuXFx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcXG5cXHRybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcXG5cXHRycHJvdG9jb2wgPSAvXlxcXFwvXFxcXC8vLFxcblxcblxcdC8qIFByZWZpbHRlcnNcXG5cXHQgKiAxKSBUaGV5IGFyZSB1c2VmdWwgdG8gaW50cm9kdWNlIGN1c3RvbSBkYXRhVHlwZXMgKHNlZSBhamF4L2pzb25wLmpzIGZvciBhbiBleGFtcGxlKVxcblxcdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XFxuXFx0ICogICAgLSBCRUZPUkUgYXNraW5nIGZvciBhIHRyYW5zcG9ydFxcblxcdCAqICAgIC0gQUZURVIgcGFyYW0gc2VyaWFsaXphdGlvbiAocy5kYXRhIGlzIGEgc3RyaW5nIGlmIHMucHJvY2Vzc0RhdGEgaXMgdHJ1ZSlcXG5cXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXFxuXFx0ICogNCkgdGhlIGNhdGNoYWxsIHN5bWJvbCBcXFwiKlxcXCIgY2FuIGJlIHVzZWRcXG5cXHQgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvIFxcXCIqXFxcIiBpZiBuZWVkZWRcXG5cXHQgKi9cXG5cXHRwcmVmaWx0ZXJzID0ge30sXFxuXFxuXFx0LyogVHJhbnNwb3J0cyBiaW5kaW5nc1xcblxcdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcXG5cXHQgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFxcXCIqXFxcIiBjYW4gYmUgdXNlZFxcblxcdCAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFxcXCIqXFxcIiBpZiBuZWVkZWRcXG5cXHQgKi9cXG5cXHR0cmFuc3BvcnRzID0ge30sXFxuXFxuXFx0Ly8gQXZvaWQgY29tbWVudC1wcm9sb2cgY2hhciBzZXF1ZW5jZSAoIzEwMDk4KTsgbXVzdCBhcHBlYXNlIGxpbnQgYW5kIGV2YWRlIGNvbXByZXNzaW9uXFxuXFx0YWxsVHlwZXMgPSBcXFwiKi9cXFwiLmNvbmNhdCggXFxcIipcXFwiICksXFxuXFxuXFx0Ly8gQW5jaG9yIHRhZyBmb3IgcGFyc2luZyB0aGUgZG9jdW1lbnQgb3JpZ2luXFxuXFx0b3JpZ2luQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXFxcImFcXFwiICk7XFxuXFx0b3JpZ2luQW5jaG9yLmhyZWYgPSBsb2NhdGlvbi5ocmVmO1xcblxcbi8vIEJhc2UgXFxcImNvbnN0cnVjdG9yXFxcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XFxuZnVuY3Rpb24gYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUgKSB7XFxuXFxuXFx0Ly8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcXFwiKlxcXCJcXG5cXHRyZXR1cm4gZnVuY3Rpb24oIGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYyApIHtcXG5cXG5cXHRcXHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFxcXCJzdHJpbmdcXFwiICkge1xcblxcdFxcdFxcdGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XFxuXFx0XFx0XFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXFxcIipcXFwiO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR2YXIgZGF0YVR5cGUsXFxuXFx0XFx0XFx0aSA9IDAsXFxuXFx0XFx0XFx0ZGF0YVR5cGVzID0gZGF0YVR5cGVFeHByZXNzaW9uLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcXG5cXG5cXHRcXHRpZiAoIGlzRnVuY3Rpb24oIGZ1bmMgKSApIHtcXG5cXG5cXHRcXHRcXHQvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgZGF0YVR5cGVFeHByZXNzaW9uXFxuXFx0XFx0XFx0d2hpbGUgKCAoIGRhdGFUeXBlID0gZGF0YVR5cGVzWyBpKysgXSApICkge1xcblxcblxcdFxcdFxcdFxcdC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXFxuXFx0XFx0XFx0XFx0aWYgKCBkYXRhVHlwZVsgMCBdID09PSBcXFwiK1xcXCIgKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGF0YVR5cGUgPSBkYXRhVHlwZS5zbGljZSggMSApIHx8IFxcXCIqXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBPdGhlcndpc2UgYXBwZW5kXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnB1c2goIGZ1bmMgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9O1xcbn1cXG5cXG4vLyBCYXNlIGluc3BlY3Rpb24gZnVuY3Rpb24gZm9yIHByZWZpbHRlcnMgYW5kIHRyYW5zcG9ydHNcXG5mdW5jdGlvbiBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlLCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICkge1xcblxcblxcdHZhciBpbnNwZWN0ZWQgPSB7fSxcXG5cXHRcXHRzZWVraW5nVHJhbnNwb3J0ID0gKCBzdHJ1Y3R1cmUgPT09IHRyYW5zcG9ydHMgKTtcXG5cXG5cXHRmdW5jdGlvbiBpbnNwZWN0KCBkYXRhVHlwZSApIHtcXG5cXHRcXHR2YXIgc2VsZWN0ZWQ7XFxuXFx0XFx0aW5zcGVjdGVkWyBkYXRhVHlwZSBdID0gdHJ1ZTtcXG5cXHRcXHRqUXVlcnkuZWFjaCggc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdLCBmdW5jdGlvbiggXywgcHJlZmlsdGVyT3JGYWN0b3J5ICkge1xcblxcdFxcdFxcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XFxuXFx0XFx0XFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVPclRyYW5zcG9ydCA9PT0gXFxcInN0cmluZ1xcXCIgJiZcXG5cXHRcXHRcXHRcXHQhc2Vla2luZ1RyYW5zcG9ydCAmJiAhaW5zcGVjdGVkWyBkYXRhVHlwZU9yVHJhbnNwb3J0IF0gKSB7XFxuXFxuXFx0XFx0XFx0XFx0b3B0aW9ucy5kYXRhVHlwZXMudW5zaGlmdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xcblxcdFxcdFxcdFxcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gISggc2VsZWN0ZWQgPSBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gKTtcXG5cXHRcXHRyZXR1cm4gc2VsZWN0ZWQ7XFxuXFx0fVxcblxcblxcdHJldHVybiBpbnNwZWN0KCBvcHRpb25zLmRhdGFUeXBlc1sgMCBdICkgfHwgIWluc3BlY3RlZFsgXFxcIipcXFwiIF0gJiYgaW5zcGVjdCggXFxcIipcXFwiICk7XFxufVxcblxcbi8vIEEgc3BlY2lhbCBleHRlbmQgZm9yIGFqYXggb3B0aW9uc1xcbi8vIHRoYXQgdGFrZXMgXFxcImZsYXRcXFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxcbi8vIEZpeGVzICM5ODg3XFxuZnVuY3Rpb24gYWpheEV4dGVuZCggdGFyZ2V0LCBzcmMgKSB7XFxuXFx0dmFyIGtleSwgZGVlcCxcXG5cXHRcXHRmbGF0T3B0aW9ucyA9IGpRdWVyeS5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnMgfHwge307XFxuXFxuXFx0Zm9yICgga2V5IGluIHNyYyApIHtcXG5cXHRcXHRpZiAoIHNyY1sga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRcXHQoIGZsYXRPcHRpb25zWyBrZXkgXSA/IHRhcmdldCA6ICggZGVlcCB8fCAoIGRlZXAgPSB7fSApICkgKVsga2V5IF0gPSBzcmNbIGtleSBdO1xcblxcdFxcdH1cXG5cXHR9XFxuXFx0aWYgKCBkZWVwICkge1xcblxcdFxcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xcblxcdH1cXG5cXG5cXHRyZXR1cm4gdGFyZ2V0O1xcbn1cXG5cXG4vKiBIYW5kbGVzIHJlc3BvbnNlcyB0byBhbiBhamF4IHJlcXVlc3Q6XFxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcXG4gKiAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcXG4gKi9cXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xcblxcblxcdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcXG5cXHRcXHRjb250ZW50cyA9IHMuY29udGVudHMsXFxuXFx0XFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XFxuXFxuXFx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3NcXG5cXHR3aGlsZSAoIGRhdGFUeXBlc1sgMCBdID09PSBcXFwiKlxcXCIgKSB7XFxuXFx0XFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XFxuXFx0XFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdGN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXFxcIkNvbnRlbnQtVHlwZVxcXCIgKTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZVxcblxcdGlmICggY3QgKSB7XFxuXFx0XFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcXG5cXHRcXHRcXHRpZiAoIGNvbnRlbnRzWyB0eXBlIF0gJiYgY29udGVudHNbIHR5cGUgXS50ZXN0KCBjdCApICkge1xcblxcdFxcdFxcdFxcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSByZXNwb25zZSBmb3IgdGhlIGV4cGVjdGVkIGRhdGFUeXBlXFxuXFx0aWYgKCBkYXRhVHlwZXNbIDAgXSBpbiByZXNwb25zZXMgKSB7XFxuXFx0XFx0ZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1sgMCBdO1xcblxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0Ly8gVHJ5IGNvbnZlcnRpYmxlIGRhdGFUeXBlc1xcblxcdFxcdGZvciAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xcblxcdFxcdFxcdGlmICggIWRhdGFUeXBlc1sgMCBdIHx8IHMuY29udmVydGVyc1sgdHlwZSArIFxcXCIgXFxcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XFxuXFx0XFx0XFx0XFx0ZmluYWxEYXRhVHlwZSA9IHR5cGU7XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XFxuXFx0XFx0XFx0XFx0Zmlyc3REYXRhVHlwZSA9IHR5cGU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBPciBqdXN0IHVzZSBmaXJzdCBvbmVcXG5cXHRcXHRmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xcblxcdH1cXG5cXG5cXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXFxuXFx0Ly8gV2UgYWRkIHRoZSBkYXRhVHlwZSB0byB0aGUgbGlzdCBpZiBuZWVkZWRcXG5cXHQvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXFxuXFx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xcblxcdFxcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XFxuXFx0XFx0XFx0ZGF0YVR5cGVzLnVuc2hpZnQoIGZpbmFsRGF0YVR5cGUgKTtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIHJlc3BvbnNlc1sgZmluYWxEYXRhVHlwZSBdO1xcblxcdH1cXG59XFxuXFxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxcbiAqIEFsc28gc2V0cyB0aGUgcmVzcG9uc2VYWFggZmllbGRzIG9uIHRoZSBqcVhIUiBpbnN0YW5jZVxcbiAqL1xcbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcXG5cXHR2YXIgY29udjIsIGN1cnJlbnQsIGNvbnYsIHRtcCwgcHJldixcXG5cXHRcXHRjb252ZXJ0ZXJzID0ge30sXFxuXFxuXFx0XFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxcblxcdFxcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XFxuXFxuXFx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXFxuXFx0aWYgKCBkYXRhVHlwZXNbIDEgXSApIHtcXG5cXHRcXHRmb3IgKCBjb252IGluIHMuY29udmVydGVycyApIHtcXG5cXHRcXHRcXHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xcblxcblxcdC8vIENvbnZlcnQgdG8gZWFjaCBzZXF1ZW50aWFsIGRhdGFUeXBlXFxuXFx0d2hpbGUgKCBjdXJyZW50ICkge1xcblxcblxcdFxcdGlmICggcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdICkge1xcblxcdFxcdFxcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxcblxcdFxcdGlmICggIXByZXYgJiYgaXNTdWNjZXNzICYmIHMuZGF0YUZpbHRlciApIHtcXG5cXHRcXHRcXHRyZXNwb25zZSA9IHMuZGF0YUZpbHRlciggcmVzcG9uc2UsIHMuZGF0YVR5cGUgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cHJldiA9IGN1cnJlbnQ7XFxuXFx0XFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xcblxcblxcdFxcdGlmICggY3VycmVudCApIHtcXG5cXG5cXHRcXHRcXHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXFxuXFx0XFx0XFx0aWYgKCBjdXJyZW50ID09PSBcXFwiKlxcXCIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y3VycmVudCA9IHByZXY7XFxuXFxuXFx0XFx0XFx0Ly8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIHByZXYgIT09IFxcXCIqXFxcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xcblxcblxcdFxcdFxcdFxcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXFxuXFx0XFx0XFx0XFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcXFwiIFxcXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXFxcIiogXFxcIiArIGN1cnJlbnQgXTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxcblxcdFxcdFxcdFxcdGlmICggIWNvbnYgKSB7XFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBJZiBjb252MiBvdXRwdXRzIGN1cnJlbnRcXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAgPSBjb252Mi5zcGxpdCggXFxcIiBcXFwiICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB0bXBbIDEgXSA9PT0gY3VycmVudCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBJZiBwcmV2IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYWNjZXB0ZWQgaW5wdXRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFxcXCIgXFxcIiArIHRtcFsgMCBdIF0gfHxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjb252ZXJ0ZXJzWyBcXFwiKiBcXFwiICsgdG1wWyAwIF0gXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGNvbnYgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggY29udiA9PT0gdHJ1ZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBPdGhlcndpc2UsIGluc2VydCB0aGUgaW50ZXJtZWRpYXRlIGRhdGFUeXBlXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmICggY29udmVydGVyc1sgY29udjIgXSAhPT0gdHJ1ZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjdXJyZW50ID0gdG1wWyAwIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcXG5cXHRcXHRcXHRcXHRpZiAoIGNvbnYgIT09IHRydWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxcblxcdFxcdFxcdFxcdFxcdGlmICggY29udiAmJiBzLnRocm93cyApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0cnkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGNhdGNoICggZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHN0YXRlOiBcXFwicGFyc2VyZXJyb3JcXFwiLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGVycm9yOiBjb252ID8gZSA6IFxcXCJObyBjb252ZXJzaW9uIGZyb20gXFxcIiArIHByZXYgKyBcXFwiIHRvIFxcXCIgKyBjdXJyZW50XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRyZXR1cm4geyBzdGF0ZTogXFxcInN1Y2Nlc3NcXFwiLCBkYXRhOiByZXNwb25zZSB9O1xcbn1cXG5cXG5qUXVlcnkuZXh0ZW5kKCB7XFxuXFxuXFx0Ly8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXFxuXFx0YWN0aXZlOiAwLFxcblxcblxcdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3RcXG5cXHRsYXN0TW9kaWZpZWQ6IHt9LFxcblxcdGV0YWc6IHt9LFxcblxcblxcdGFqYXhTZXR0aW5nczoge1xcblxcdFxcdHVybDogbG9jYXRpb24uaHJlZixcXG5cXHRcXHR0eXBlOiBcXFwiR0VUXFxcIixcXG5cXHRcXHRpc0xvY2FsOiBybG9jYWxQcm90b2NvbC50ZXN0KCBsb2NhdGlvbi5wcm90b2NvbCApLFxcblxcdFxcdGdsb2JhbDogdHJ1ZSxcXG5cXHRcXHRwcm9jZXNzRGF0YTogdHJ1ZSxcXG5cXHRcXHRhc3luYzogdHJ1ZSxcXG5cXHRcXHRjb250ZW50VHlwZTogXFxcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFxcXCIsXFxuXFxuXFx0XFx0LypcXG5cXHRcXHR0aW1lb3V0OiAwLFxcblxcdFxcdGRhdGE6IG51bGwsXFxuXFx0XFx0ZGF0YVR5cGU6IG51bGwsXFxuXFx0XFx0dXNlcm5hbWU6IG51bGwsXFxuXFx0XFx0cGFzc3dvcmQ6IG51bGwsXFxuXFx0XFx0Y2FjaGU6IG51bGwsXFxuXFx0XFx0dGhyb3dzOiBmYWxzZSxcXG5cXHRcXHR0cmFkaXRpb25hbDogZmFsc2UsXFxuXFx0XFx0aGVhZGVyczoge30sXFxuXFx0XFx0Ki9cXG5cXG5cXHRcXHRhY2NlcHRzOiB7XFxuXFx0XFx0XFx0XFxcIipcXFwiOiBhbGxUeXBlcyxcXG5cXHRcXHRcXHR0ZXh0OiBcXFwidGV4dC9wbGFpblxcXCIsXFxuXFx0XFx0XFx0aHRtbDogXFxcInRleHQvaHRtbFxcXCIsXFxuXFx0XFx0XFx0eG1sOiBcXFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFxcXCIsXFxuXFx0XFx0XFx0anNvbjogXFxcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFxcXCJcXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvbnRlbnRzOiB7XFxuXFx0XFx0XFx0eG1sOiAvXFxcXGJ4bWxcXFxcYi8sXFxuXFx0XFx0XFx0aHRtbDogL1xcXFxiaHRtbC8sXFxuXFx0XFx0XFx0anNvbjogL1xcXFxianNvblxcXFxiL1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0cmVzcG9uc2VGaWVsZHM6IHtcXG5cXHRcXHRcXHR4bWw6IFxcXCJyZXNwb25zZVhNTFxcXCIsXFxuXFx0XFx0XFx0dGV4dDogXFxcInJlc3BvbnNlVGV4dFxcXCIsXFxuXFx0XFx0XFx0anNvbjogXFxcInJlc3BvbnNlSlNPTlxcXCJcXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIERhdGEgY29udmVydGVyc1xcblxcdFxcdC8vIEtleXMgc2VwYXJhdGUgc291cmNlIChvciBjYXRjaGFsbCBcXFwiKlxcXCIpIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXFxuXFx0XFx0Y29udmVydGVyczoge1xcblxcblxcdFxcdFxcdC8vIENvbnZlcnQgYW55dGhpbmcgdG8gdGV4dFxcblxcdFxcdFxcdFxcXCIqIHRleHRcXFwiOiBTdHJpbmcsXFxuXFxuXFx0XFx0XFx0Ly8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXFxuXFx0XFx0XFx0XFxcInRleHQgaHRtbFxcXCI6IHRydWUsXFxuXFxuXFx0XFx0XFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxcblxcdFxcdFxcdFxcXCJ0ZXh0IGpzb25cXFwiOiBKU09OLnBhcnNlLFxcblxcblxcdFxcdFxcdC8vIFBhcnNlIHRleHQgYXMgeG1sXFxuXFx0XFx0XFx0XFxcInRleHQgeG1sXFxcIjogalF1ZXJ5LnBhcnNlWE1MXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxcblxcdFxcdC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcXG5cXHRcXHQvLyBhbmQgd2hlbiB5b3UgY3JlYXRlIG9uZSB0aGF0IHNob3VsZG4ndCBiZVxcblxcdFxcdC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxcblxcdFxcdGZsYXRPcHRpb25zOiB7XFxuXFx0XFx0XFx0dXJsOiB0cnVlLFxcblxcdFxcdFxcdGNvbnRleHQ6IHRydWVcXG5cXHRcXHR9XFxuXFx0fSxcXG5cXG5cXHQvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxcblxcdC8vIHdpdGggYm90aCBhamF4U2V0dGluZ3MgYW5kIHNldHRpbmdzIGZpZWxkcy5cXG5cXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxcblxcdGFqYXhTZXR1cDogZnVuY3Rpb24oIHRhcmdldCwgc2V0dGluZ3MgKSB7XFxuXFx0XFx0cmV0dXJuIHNldHRpbmdzID9cXG5cXG5cXHRcXHRcXHQvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxcblxcdFxcdFxcdGFqYXhFeHRlbmQoIGFqYXhFeHRlbmQoIHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyApLCBzZXR0aW5ncyApIDpcXG5cXG5cXHRcXHRcXHQvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXFxuXFx0XFx0XFx0YWpheEV4dGVuZCggalF1ZXJ5LmFqYXhTZXR0aW5ncywgdGFyZ2V0ICk7XFxuXFx0fSxcXG5cXG5cXHRhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMgKSxcXG5cXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcXG5cXG5cXHQvLyBNYWluIG1ldGhvZFxcblxcdGFqYXg6IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XFxuXFxuXFx0XFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcXG5cXHRcXHRpZiAoIHR5cGVvZiB1cmwgPT09IFxcXCJvYmplY3RcXFwiICkge1xcblxcdFxcdFxcdG9wdGlvbnMgPSB1cmw7XFxuXFx0XFx0XFx0dXJsID0gdW5kZWZpbmVkO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdFxcblxcdFxcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcblxcblxcdFxcdHZhciB0cmFuc3BvcnQsXFxuXFxuXFx0XFx0XFx0Ly8gVVJMIHdpdGhvdXQgYW50aS1jYWNoZSBwYXJhbVxcblxcdFxcdFxcdGNhY2hlVVJMLFxcblxcblxcdFxcdFxcdC8vIFJlc3BvbnNlIGhlYWRlcnNcXG5cXHRcXHRcXHRyZXNwb25zZUhlYWRlcnNTdHJpbmcsXFxuXFx0XFx0XFx0cmVzcG9uc2VIZWFkZXJzLFxcblxcblxcdFxcdFxcdC8vIHRpbWVvdXQgaGFuZGxlXFxuXFx0XFx0XFx0dGltZW91dFRpbWVyLFxcblxcblxcdFxcdFxcdC8vIFVybCBjbGVhbnVwIHZhclxcblxcdFxcdFxcdHVybEFuY2hvcixcXG5cXG5cXHRcXHRcXHQvLyBSZXF1ZXN0IHN0YXRlIChiZWNvbWVzIGZhbHNlIHVwb24gc2VuZCBhbmQgdHJ1ZSB1cG9uIGNvbXBsZXRpb24pXFxuXFx0XFx0XFx0Y29tcGxldGVkLFxcblxcblxcdFxcdFxcdC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxcblxcdFxcdFxcdGZpcmVHbG9iYWxzLFxcblxcblxcdFxcdFxcdC8vIExvb3AgdmFyaWFibGVcXG5cXHRcXHRcXHRpLFxcblxcblxcdFxcdFxcdC8vIHVuY2FjaGVkIHBhcnQgb2YgdGhlIHVybFxcblxcdFxcdFxcdHVuY2FjaGVkLFxcblxcblxcdFxcdFxcdC8vIENyZWF0ZSB0aGUgZmluYWwgb3B0aW9ucyBvYmplY3RcXG5cXHRcXHRcXHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcXG5cXG5cXHRcXHRcXHQvLyBDYWxsYmFja3MgY29udGV4dFxcblxcdFxcdFxcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxcblxcblxcdFxcdFxcdC8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHMgaXMgY2FsbGJhY2tDb250ZXh0IGlmIGl0IGlzIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IGNvbGxlY3Rpb25cXG5cXHRcXHRcXHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcXG5cXHRcXHRcXHRcXHQoIGNhbGxiYWNrQ29udGV4dC5ub2RlVHlwZSB8fCBjYWxsYmFja0NvbnRleHQuanF1ZXJ5ICkgP1xcblxcdFxcdFxcdFxcdFxcdGpRdWVyeSggY2FsbGJhY2tDb250ZXh0ICkgOlxcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS5ldmVudCxcXG5cXG5cXHRcXHRcXHQvLyBEZWZlcnJlZHNcXG5cXHRcXHRcXHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLFxcblxcdFxcdFxcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcXFwib25jZSBtZW1vcnlcXFwiICksXFxuXFxuXFx0XFx0XFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3NcXG5cXHRcXHRcXHRzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxcblxcblxcdFxcdFxcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXFxuXFx0XFx0XFx0cmVxdWVzdEhlYWRlcnMgPSB7fSxcXG5cXHRcXHRcXHRyZXF1ZXN0SGVhZGVyc05hbWVzID0ge30sXFxuXFxuXFx0XFx0XFx0Ly8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXFxuXFx0XFx0XFx0c3RyQWJvcnQgPSBcXFwiY2FuY2VsZWRcXFwiLFxcblxcblxcdFxcdFxcdC8vIEZha2UgeGhyXFxuXFx0XFx0XFx0anFYSFIgPSB7XFxuXFx0XFx0XFx0XFx0cmVhZHlTdGF0ZTogMCxcXG5cXG5cXHRcXHRcXHRcXHQvLyBCdWlsZHMgaGVhZGVycyBoYXNodGFibGUgaWYgbmVlZGVkXFxuXFx0XFx0XFx0XFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIG1hdGNoO1xcblxcdFxcdFxcdFxcdFxcdGlmICggY29tcGxldGVkICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggIXJlc3BvbnNlSGVhZGVycyApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXNwb25zZUhlYWRlcnMgPSB7fTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpIF0gPSBtYXRjaFsgMiBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0bWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpIF07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoO1xcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0Ly8gUmF3IHN0cmluZ1xcblxcdFxcdFxcdFxcdGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGNvbXBsZXRlZCA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHQvLyBDYWNoZXMgdGhlIGhlYWRlclxcblxcdFxcdFxcdFxcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSA9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHwgbmFtZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXF1ZXN0SGVhZGVyc1sgbmFtZSBdID0gdmFsdWU7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0Ly8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcXG5cXHRcXHRcXHRcXHRvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiggdHlwZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHMubWltZVR5cGUgPSB0eXBlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXFxuXFx0XFx0XFx0XFx0c3RhdHVzQ29kZTogZnVuY3Rpb24oIG1hcCApIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgY29kZTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIG1hcCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGNvbXBsZXRlZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBFeGVjdXRlIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja3NcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRqcVhIUi5hbHdheXMoIG1hcFsganFYSFIuc3RhdHVzIF0gKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIExhenktYWRkIHRoZSBuZXcgY2FsbGJhY2tzIGluIGEgd2F5IHRoYXQgcHJlc2VydmVzIG9sZCBvbmVzXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggY29kZSBpbiBtYXAgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0c3RhdHVzQ29kZVsgY29kZSBdID0gWyBzdGF0dXNDb2RlWyBjb2RlIF0sIG1hcFsgY29kZSBdIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHQvLyBDYW5jZWwgdGhlIHJlcXVlc3RcXG5cXHRcXHRcXHRcXHRhYm9ydDogZnVuY3Rpb24oIHN0YXR1c1RleHQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGZpbmFsVGV4dCA9IHN0YXR1c1RleHQgfHwgc3RyQWJvcnQ7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB0cmFuc3BvcnQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0ZG9uZSggMCwgZmluYWxUZXh0ICk7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gQXR0YWNoIGRlZmVycmVkc1xcblxcdFxcdGRlZmVycmVkLnByb21pc2UoIGpxWEhSICk7XFxuXFxuXFx0XFx0Ly8gQWRkIHByb3RvY29sIGlmIG5vdCBwcm92aWRlZCAocHJlZmlsdGVycyBtaWdodCBleHBlY3QgaXQpXFxuXFx0XFx0Ly8gSGFuZGxlIGZhbHN5IHVybCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0ICgjMTAwOTM6IGNvbnNpc3RlbmN5IHdpdGggb2xkIHNpZ25hdHVyZSlcXG5cXHRcXHQvLyBXZSBhbHNvIHVzZSB0aGUgdXJsIHBhcmFtZXRlciBpZiBhdmFpbGFibGVcXG5cXHRcXHRzLnVybCA9ICggKCB1cmwgfHwgcy51cmwgfHwgbG9jYXRpb24uaHJlZiApICsgXFxcIlxcXCIgKVxcblxcdFxcdFxcdC5yZXBsYWNlKCBycHJvdG9jb2wsIGxvY2F0aW9uLnByb3RvY29sICsgXFxcIi8vXFxcIiApO1xcblxcblxcdFxcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxcblxcdFxcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XFxuXFxuXFx0XFx0Ly8gRXh0cmFjdCBkYXRhVHlwZXMgbGlzdFxcblxcdFxcdHMuZGF0YVR5cGVzID0gKCBzLmRhdGFUeXBlIHx8IFxcXCIqXFxcIiApLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFxcXCJcXFwiIF07XFxuXFxuXFx0XFx0Ly8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHRoZSBvcmlnaW4gZG9lc24ndCBtYXRjaCB0aGUgY3VycmVudCBvcmlnaW4uXFxuXFx0XFx0aWYgKCBzLmNyb3NzRG9tYWluID09IG51bGwgKSB7XFxuXFx0XFx0XFx0dXJsQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXFxcImFcXFwiICk7XFxuXFxuXFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEsIEVkZ2UgMTIgLSAxNVxcblxcdFxcdFxcdC8vIElFIHRocm93cyBleGNlcHRpb24gb24gYWNjZXNzaW5nIHRoZSBocmVmIHByb3BlcnR5IGlmIHVybCBpcyBtYWxmb3JtZWQsXFxuXFx0XFx0XFx0Ly8gZS5nLiBodHRwOi8vZXhhbXBsZS5jb206ODB4L1xcblxcdFxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0XFx0dXJsQW5jaG9yLmhyZWYgPSBzLnVybDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSBvbmx5XFxuXFx0XFx0XFx0XFx0Ly8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gcy51cmwgaXMgcmVsYXRpdmVcXG5cXHRcXHRcXHRcXHR1cmxBbmNob3IuaHJlZiA9IHVybEFuY2hvci5ocmVmO1xcblxcdFxcdFxcdFxcdHMuY3Jvc3NEb21haW4gPSBvcmlnaW5BbmNob3IucHJvdG9jb2wgKyBcXFwiLy9cXFwiICsgb3JpZ2luQW5jaG9yLmhvc3QgIT09XFxuXFx0XFx0XFx0XFx0XFx0dXJsQW5jaG9yLnByb3RvY29sICsgXFxcIi8vXFxcIiArIHVybEFuY2hvci5ob3N0O1xcblxcdFxcdFxcdH0gY2F0Y2ggKCBlICkge1xcblxcblxcdFxcdFxcdFxcdC8vIElmIHRoZXJlIGlzIGFuIGVycm9yIHBhcnNpbmcgdGhlIFVSTCwgYXNzdW1lIGl0IGlzIGNyb3NzRG9tYWluLFxcblxcdFxcdFxcdFxcdC8vIGl0IGNhbiBiZSByZWplY3RlZCBieSB0aGUgdHJhbnNwb3J0IGlmIGl0IGlzIGludmFsaWRcXG5cXHRcXHRcXHRcXHRzLmNyb3NzRG9tYWluID0gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIENvbnZlcnQgZGF0YSBpZiBub3QgYWxyZWFkeSBhIHN0cmluZ1xcblxcdFxcdGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gXFxcInN0cmluZ1xcXCIgKSB7XFxuXFx0XFx0XFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQXBwbHkgcHJlZmlsdGVyc1xcblxcdFxcdGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xcblxcblxcdFxcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXFxuXFx0XFx0aWYgKCBjb21wbGV0ZWQgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGpxWEhSO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xcblxcdFxcdC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIGpRdWVyeS5ldmVudCBpcyB1bmRlZmluZWQgaW4gYW4gQU1ELXVzYWdlIHNjZW5hcmlvICgjMTUxMTgpXFxuXFx0XFx0ZmlyZUdsb2JhbHMgPSBqUXVlcnkuZXZlbnQgJiYgcy5nbG9iYWw7XFxuXFxuXFx0XFx0Ly8gV2F0Y2ggZm9yIGEgbmV3IHNldCBvZiByZXF1ZXN0c1xcblxcdFxcdGlmICggZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwICkge1xcblxcdFxcdFxcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcXFwiYWpheFN0YXJ0XFxcIiApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBVcHBlcmNhc2UgdGhlIHR5cGVcXG5cXHRcXHRzLnR5cGUgPSBzLnR5cGUudG9VcHBlckNhc2UoKTtcXG5cXG5cXHRcXHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxcblxcdFxcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xcblxcblxcdFxcdC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxcblxcdFxcdC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxcblxcdFxcdC8vIFJlbW92ZSBoYXNoIHRvIHNpbXBsaWZ5IHVybCBtYW5pcHVsYXRpb25cXG5cXHRcXHRjYWNoZVVSTCA9IHMudXJsLnJlcGxhY2UoIHJoYXNoLCBcXFwiXFxcIiApO1xcblxcblxcdFxcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XFxuXFx0XFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xcblxcblxcdFxcdFxcdC8vIFJlbWVtYmVyIHRoZSBoYXNoIHNvIHdlIGNhbiBwdXQgaXQgYmFja1xcblxcdFxcdFxcdHVuY2FjaGVkID0gcy51cmwuc2xpY2UoIGNhY2hlVVJMLmxlbmd0aCApO1xcblxcblxcdFxcdFxcdC8vIElmIGRhdGEgaXMgYXZhaWxhYmxlIGFuZCBzaG91bGQgYmUgcHJvY2Vzc2VkLCBhcHBlbmQgZGF0YSB0byB1cmxcXG5cXHRcXHRcXHRpZiAoIHMuZGF0YSAmJiAoIHMucHJvY2Vzc0RhdGEgfHwgdHlwZW9mIHMuZGF0YSA9PT0gXFxcInN0cmluZ1xcXCIgKSApIHtcXG5cXHRcXHRcXHRcXHRjYWNoZVVSTCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXFxcIiZcXFwiIDogXFxcIj9cXFwiICkgKyBzLmRhdGE7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxcblxcdFxcdFxcdFxcdGRlbGV0ZSBzLmRhdGE7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEFkZCBvciB1cGRhdGUgYW50aS1jYWNoZSBwYXJhbSBpZiBuZWVkZWRcXG5cXHRcXHRcXHRpZiAoIHMuY2FjaGUgPT09IGZhbHNlICkge1xcblxcdFxcdFxcdFxcdGNhY2hlVVJMID0gY2FjaGVVUkwucmVwbGFjZSggcmFudGlDYWNoZSwgXFxcIiQxXFxcIiApO1xcblxcdFxcdFxcdFxcdHVuY2FjaGVkID0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFxcXCImXFxcIiA6IFxcXCI/XFxcIiApICsgXFxcIl89XFxcIiArICggbm9uY2UrKyApICsgdW5jYWNoZWQ7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFB1dCBoYXNoIGFuZCBhbnRpLWNhY2hlIG9uIHRoZSBVUkwgdGhhdCB3aWxsIGJlIHJlcXVlc3RlZCAoZ2gtMTczMilcXG5cXHRcXHRcXHRzLnVybCA9IGNhY2hlVVJMICsgdW5jYWNoZWQ7XFxuXFxuXFx0XFx0Ly8gQ2hhbmdlICclMjAnIHRvICcrJyBpZiB0aGlzIGlzIGVuY29kZWQgZm9ybSBib2R5IGNvbnRlbnQgKGdoLTI2NTgpXFxuXFx0XFx0fSBlbHNlIGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiZcXG5cXHRcXHRcXHQoIHMuY29udGVudFR5cGUgfHwgXFxcIlxcXCIgKS5pbmRleE9mKCBcXFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXFxcIiApID09PSAwICkge1xcblxcdFxcdFxcdHMuZGF0YSA9IHMuZGF0YS5yZXBsYWNlKCByMjAsIFxcXCIrXFxcIiApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxcblxcdFxcdGlmICggcy5pZk1vZGlmaWVkICkge1xcblxcdFxcdFxcdGlmICggalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApIHtcXG5cXHRcXHRcXHRcXHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcXFwiSWYtTW9kaWZpZWQtU2luY2VcXFwiLCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XFxuXFx0XFx0XFx0XFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXFxcIklmLU5vbmUtTWF0Y2hcXFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XFxuXFx0XFx0aWYgKCBzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8IG9wdGlvbnMuY29udGVudFR5cGUgKSB7XFxuXFx0XFx0XFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXFxcIkNvbnRlbnQtVHlwZVxcXCIsIHMuY29udGVudFR5cGUgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxcblxcdFxcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXFxuXFx0XFx0XFx0XFxcIkFjY2VwdFxcXCIsXFxuXFx0XFx0XFx0cy5kYXRhVHlwZXNbIDAgXSAmJiBzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSA/XFxuXFx0XFx0XFx0XFx0cy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gK1xcblxcdFxcdFxcdFxcdFxcdCggcy5kYXRhVHlwZXNbIDAgXSAhPT0gXFxcIipcXFwiID8gXFxcIiwgXFxcIiArIGFsbFR5cGVzICsgXFxcIjsgcT0wLjAxXFxcIiA6IFxcXCJcXFwiICkgOlxcblxcdFxcdFxcdFxcdHMuYWNjZXB0c1sgXFxcIipcXFwiIF1cXG5cXHRcXHQpO1xcblxcblxcdFxcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxcblxcdFxcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xcblxcdFxcdFxcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIGksIHMuaGVhZGVyc1sgaSBdICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcXG5cXHRcXHRpZiAoIHMuYmVmb3JlU2VuZCAmJlxcblxcdFxcdFxcdCggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgY29tcGxldGVkICkgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXFxuXFx0XFx0XFx0cmV0dXJuIGpxWEhSLmFib3J0KCk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxcblxcdFxcdHN0ckFib3J0ID0gXFxcImFib3J0XFxcIjtcXG5cXG5cXHRcXHQvLyBJbnN0YWxsIGNhbGxiYWNrcyBvbiBkZWZlcnJlZHNcXG5cXHRcXHRjb21wbGV0ZURlZmVycmVkLmFkZCggcy5jb21wbGV0ZSApO1xcblxcdFxcdGpxWEhSLmRvbmUoIHMuc3VjY2VzcyApO1xcblxcdFxcdGpxWEhSLmZhaWwoIHMuZXJyb3IgKTtcXG5cXG5cXHRcXHQvLyBHZXQgdHJhbnNwb3J0XFxuXFx0XFx0dHJhbnNwb3J0ID0gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XFxuXFxuXFx0XFx0Ly8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XFxuXFx0XFx0aWYgKCAhdHJhbnNwb3J0ICkge1xcblxcdFxcdFxcdGRvbmUoIC0xLCBcXFwiTm8gVHJhbnNwb3J0XFxcIiApO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0anFYSFIucmVhZHlTdGF0ZSA9IDE7XFxuXFxuXFx0XFx0XFx0Ly8gU2VuZCBnbG9iYWwgZXZlbnRcXG5cXHRcXHRcXHRpZiAoIGZpcmVHbG9iYWxzICkge1xcblxcdFxcdFxcdFxcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcXFwiYWpheFNlbmRcXFwiLCBbIGpxWEhSLCBzIF0gKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYWpheFNlbmQsIHN0b3AgdGhlcmVcXG5cXHRcXHRcXHRpZiAoIGNvbXBsZXRlZCApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4ganFYSFI7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFRpbWVvdXRcXG5cXHRcXHRcXHRpZiAoIHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCApIHtcXG5cXHRcXHRcXHRcXHR0aW1lb3V0VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XFx0anFYSFIuYWJvcnQoIFxcXCJ0aW1lb3V0XFxcIiApO1xcblxcdFxcdFxcdFxcdH0sIHMudGltZW91dCApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0cnkge1xcblxcdFxcdFxcdFxcdGNvbXBsZXRlZCA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xcblxcdFxcdFxcdH0gY2F0Y2ggKCBlICkge1xcblxcblxcdFxcdFxcdFxcdC8vIFJldGhyb3cgcG9zdC1jb21wbGV0aW9uIGV4Y2VwdGlvbnNcXG5cXHRcXHRcXHRcXHRpZiAoIGNvbXBsZXRlZCApIHtcXG5cXHRcXHRcXHRcXHRcXHR0aHJvdyBlO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBQcm9wYWdhdGUgb3RoZXJzIGFzIHJlc3VsdHNcXG5cXHRcXHRcXHRcXHRkb25lKCAtMSwgZSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXFxuXFx0XFx0ZnVuY3Rpb24gZG9uZSggc3RhdHVzLCBuYXRpdmVTdGF0dXNUZXh0LCByZXNwb25zZXMsIGhlYWRlcnMgKSB7XFxuXFx0XFx0XFx0dmFyIGlzU3VjY2Vzcywgc3VjY2VzcywgZXJyb3IsIHJlc3BvbnNlLCBtb2RpZmllZCxcXG5cXHRcXHRcXHRcXHRzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcXG5cXG5cXHRcXHRcXHQvLyBJZ25vcmUgcmVwZWF0IGludm9jYXRpb25zXFxuXFx0XFx0XFx0aWYgKCBjb21wbGV0ZWQgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRjb21wbGV0ZWQgPSB0cnVlO1xcblxcblxcdFxcdFxcdC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXFxuXFx0XFx0XFx0aWYgKCB0aW1lb3V0VGltZXIgKSB7XFxuXFx0XFx0XFx0XFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dFRpbWVyICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIERlcmVmZXJlbmNlIHRyYW5zcG9ydCBmb3IgZWFybHkgZ2FyYmFnZSBjb2xsZWN0aW9uXFxuXFx0XFx0XFx0Ly8gKG5vIG1hdHRlciBob3cgbG9uZyB0aGUganFYSFIgb2JqZWN0IHdpbGwgYmUgdXNlZClcXG5cXHRcXHRcXHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XFxuXFxuXFx0XFx0XFx0Ly8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVyc1xcblxcdFxcdFxcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXFxcIlxcXCI7XFxuXFxuXFx0XFx0XFx0Ly8gU2V0IHJlYWR5U3RhdGVcXG5cXHRcXHRcXHRqcVhIUi5yZWFkeVN0YXRlID0gc3RhdHVzID4gMCA/IDQgOiAwO1xcblxcblxcdFxcdFxcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXFxuXFx0XFx0XFx0aXNTdWNjZXNzID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7XFxuXFxuXFx0XFx0XFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcXG5cXHRcXHRcXHRpZiAoIHJlc3BvbnNlcyApIHtcXG5cXHRcXHRcXHRcXHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxcblxcdFxcdFxcdHJlc3BvbnNlID0gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICk7XFxuXFxuXFx0XFx0XFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcXG5cXHRcXHRcXHRpZiAoIGlzU3VjY2VzcyApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxcblxcdFxcdFxcdFxcdGlmICggcy5pZk1vZGlmaWVkICkge1xcblxcdFxcdFxcdFxcdFxcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFxcXCJMYXN0LU1vZGlmaWVkXFxcIiApO1xcblxcdFxcdFxcdFxcdFxcdGlmICggbW9kaWZpZWQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0alF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcXFwiZXRhZ1xcXCIgKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIG1vZGlmaWVkICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBpZiBubyBjb250ZW50XFxuXFx0XFx0XFx0XFx0aWYgKCBzdGF0dXMgPT09IDIwNCB8fCBzLnR5cGUgPT09IFxcXCJIRUFEXFxcIiApIHtcXG5cXHRcXHRcXHRcXHRcXHRzdGF0dXNUZXh0ID0gXFxcIm5vY29udGVudFxcXCI7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gaWYgbm90IG1vZGlmaWVkXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0c3RhdHVzVGV4dCA9IFxcXCJub3Rtb2RpZmllZFxcXCI7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSWYgd2UgaGF2ZSBkYXRhLCBsZXQncyBjb252ZXJ0IGl0XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XFxuXFx0XFx0XFx0XFx0XFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XFxuXFx0XFx0XFx0XFx0XFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcXG5cXHRcXHRcXHRcXHRcXHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xcblxcdFxcdFxcdFxcdGVycm9yID0gc3RhdHVzVGV4dDtcXG5cXHRcXHRcXHRcXHRpZiAoIHN0YXR1cyB8fCAhc3RhdHVzVGV4dCApIHtcXG5cXHRcXHRcXHRcXHRcXHRzdGF0dXNUZXh0ID0gXFxcImVycm9yXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHN0YXR1cyA8IDAgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c3RhdHVzID0gMDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdFxcblxcdFxcdFxcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcXG5cXHRcXHRcXHRqcVhIUi5zdGF0dXNUZXh0ID0gKCBuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQgKSArIFxcXCJcXFwiO1xcblxcblxcdFxcdFxcdC8vIFN1Y2Nlc3MvRXJyb3JcXG5cXHRcXHRcXHRpZiAoIGlzU3VjY2VzcyApIHtcXG5cXHRcXHRcXHRcXHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSIF0gKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGRlZmVycmVkLnJlamVjdFdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCwgZXJyb3IgXSApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xcblxcdFxcdFxcdGpxWEhSLnN0YXR1c0NvZGUoIHN0YXR1c0NvZGUgKTtcXG5cXHRcXHRcXHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xcblxcblxcdFxcdFxcdGlmICggZmlyZUdsb2JhbHMgKSB7XFxuXFx0XFx0XFx0XFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIGlzU3VjY2VzcyA/IFxcXCJhamF4U3VjY2Vzc1xcXCIgOiBcXFwiYWpheEVycm9yXFxcIixcXG5cXHRcXHRcXHRcXHRcXHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBDb21wbGV0ZVxcblxcdFxcdFxcdGNvbXBsZXRlRGVmZXJyZWQuZmlyZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCBdICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBmaXJlR2xvYmFscyApIHtcXG5cXHRcXHRcXHRcXHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXFxcImFqYXhDb21wbGV0ZVxcXCIsIFsganFYSFIsIHMgXSApO1xcblxcblxcdFxcdFxcdFxcdC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxcblxcdFxcdFxcdFxcdGlmICggISggLS1qUXVlcnkuYWN0aXZlICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFxcXCJhamF4U3RvcFxcXCIgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4ganFYSFI7XFxuXFx0fSxcXG5cXG5cXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcXG5cXHRcXHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXFxcImpzb25cXFwiICk7XFxuXFx0fSxcXG5cXG5cXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xcblxcdFxcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFxcXCJzY3JpcHRcXFwiICk7XFxuXFx0fVxcbn0gKTtcXG5cXG5qUXVlcnkuZWFjaCggWyBcXFwiZ2V0XFxcIiwgXFxcInBvc3RcXFwiIF0sIGZ1bmN0aW9uKCBpLCBtZXRob2QgKSB7XFxuXFx0alF1ZXJ5WyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlICkge1xcblxcblxcdFxcdC8vIFNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXFxuXFx0XFx0aWYgKCBpc0Z1bmN0aW9uKCBkYXRhICkgKSB7XFxuXFx0XFx0XFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XFxuXFx0XFx0XFx0Y2FsbGJhY2sgPSBkYXRhO1xcblxcdFxcdFxcdGRhdGEgPSB1bmRlZmluZWQ7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxcblxcdFxcdHJldHVybiBqUXVlcnkuYWpheCggalF1ZXJ5LmV4dGVuZCgge1xcblxcdFxcdFxcdHVybDogdXJsLFxcblxcdFxcdFxcdHR5cGU6IG1ldGhvZCxcXG5cXHRcXHRcXHRkYXRhVHlwZTogdHlwZSxcXG5cXHRcXHRcXHRkYXRhOiBkYXRhLFxcblxcdFxcdFxcdHN1Y2Nlc3M6IGNhbGxiYWNrXFxuXFx0XFx0fSwgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHVybCApICYmIHVybCApICk7XFxuXFx0fTtcXG59ICk7XFxuXFxuXFxualF1ZXJ5Ll9ldmFsVXJsID0gZnVuY3Rpb24oIHVybCApIHtcXG5cXHRyZXR1cm4galF1ZXJ5LmFqYXgoIHtcXG5cXHRcXHR1cmw6IHVybCxcXG5cXG5cXHRcXHQvLyBNYWtlIHRoaXMgZXhwbGljaXQsIHNpbmNlIHVzZXIgY2FuIG92ZXJyaWRlIHRoaXMgdGhyb3VnaCBhamF4U2V0dXAgKCMxMTI2NClcXG5cXHRcXHR0eXBlOiBcXFwiR0VUXFxcIixcXG5cXHRcXHRkYXRhVHlwZTogXFxcInNjcmlwdFxcXCIsXFxuXFx0XFx0Y2FjaGU6IHRydWUsXFxuXFx0XFx0YXN5bmM6IGZhbHNlLFxcblxcdFxcdGdsb2JhbDogZmFsc2UsXFxuXFx0XFx0XFxcInRocm93c1xcXCI6IHRydWVcXG5cXHR9ICk7XFxufTtcXG5cXG5cXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XFxuXFx0d3JhcEFsbDogZnVuY3Rpb24oIGh0bWwgKSB7XFxuXFx0XFx0dmFyIHdyYXA7XFxuXFxuXFx0XFx0aWYgKCB0aGlzWyAwIF0gKSB7XFxuXFx0XFx0XFx0aWYgKCBpc0Z1bmN0aW9uKCBodG1sICkgKSB7XFxuXFx0XFx0XFx0XFx0aHRtbCA9IGh0bWwuY2FsbCggdGhpc1sgMCBdICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXFxuXFx0XFx0XFx0d3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgKS5lcSggMCApLmNsb25lKCB0cnVlICk7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzWyAwIF0ucGFyZW50Tm9kZSApIHtcXG5cXHRcXHRcXHRcXHR3cmFwLmluc2VydEJlZm9yZSggdGhpc1sgMCBdICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHdyYXAubWFwKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHR2YXIgZWxlbSA9IHRoaXM7XFxuXFxuXFx0XFx0XFx0XFx0d2hpbGUgKCBlbGVtLmZpcnN0RWxlbWVudENoaWxkICkge1xcblxcdFxcdFxcdFxcdFxcdGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gZWxlbTtcXG5cXHRcXHRcXHR9ICkuYXBwZW5kKCB0aGlzICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB0aGlzO1xcblxcdH0sXFxuXFxuXFx0d3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcXG5cXHRcXHRpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcXG5cXHRcXHRcXHRcXHRqUXVlcnkoIHRoaXMgKS53cmFwSW5uZXIoIGh0bWwuY2FsbCggdGhpcywgaSApICk7XFxuXFx0XFx0XFx0fSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHR2YXIgc2VsZiA9IGpRdWVyeSggdGhpcyApLFxcblxcdFxcdFxcdFxcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xcblxcblxcdFxcdFxcdGlmICggY29udGVudHMubGVuZ3RoICkge1xcblxcdFxcdFxcdFxcdGNvbnRlbnRzLndyYXBBbGwoIGh0bWwgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHNlbGYuYXBwZW5kKCBodG1sICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gKTtcXG5cXHR9LFxcblxcblxcdHdyYXA6IGZ1bmN0aW9uKCBodG1sICkge1xcblxcdFxcdHZhciBodG1sSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIGh0bWwgKTtcXG5cXG5cXHRcXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcXG5cXHRcXHRcXHRqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBodG1sSXNGdW5jdGlvbiA/IGh0bWwuY2FsbCggdGhpcywgaSApIDogaHRtbCApO1xcblxcdFxcdH0gKTtcXG5cXHR9LFxcblxcblxcdHVud3JhcDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xcblxcdFxcdHRoaXMucGFyZW50KCBzZWxlY3RvciApLm5vdCggXFxcImJvZHlcXFwiICkuZWFjaCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0alF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xcblxcdFxcdH0gKTtcXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXHR9XFxufSApO1xcblxcblxcbmpRdWVyeS5leHByLnBzZXVkb3MuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0cmV0dXJuICFqUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUoIGVsZW0gKTtcXG59O1xcbmpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdHJldHVybiAhISggZWxlbS5vZmZzZXRXaWR0aCB8fCBlbGVtLm9mZnNldEhlaWdodCB8fCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICk7XFxufTtcXG5cXG5cXG5cXG5cXG5qUXVlcnkuYWpheFNldHRpbmdzLnhociA9IGZ1bmN0aW9uKCkge1xcblxcdHRyeSB7XFxuXFx0XFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcXG5cXHR9IGNhdGNoICggZSApIHt9XFxufTtcXG5cXG52YXIgeGhyU3VjY2Vzc1N0YXR1cyA9IHtcXG5cXG5cXHRcXHQvLyBGaWxlIHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIGNvZGUgMCwgYXNzdW1lIDIwMFxcblxcdFxcdDA6IDIwMCxcXG5cXG5cXHRcXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxcblxcdFxcdC8vICMxNDUwOiBzb21ldGltZXMgSUUgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxcblxcdFxcdDEyMjM6IDIwNFxcblxcdH0sXFxuXFx0eGhyU3VwcG9ydGVkID0galF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKTtcXG5cXG5zdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoIFxcXCJ3aXRoQ3JlZGVudGlhbHNcXFwiIGluIHhoclN1cHBvcnRlZCApO1xcbnN1cHBvcnQuYWpheCA9IHhoclN1cHBvcnRlZCA9ICEheGhyU3VwcG9ydGVkO1xcblxcbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBmdW5jdGlvbiggb3B0aW9ucyApIHtcXG5cXHR2YXIgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2s7XFxuXFxuXFx0Ly8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxcblxcdGlmICggc3VwcG9ydC5jb3JzIHx8IHhoclN1cHBvcnRlZCAmJiAhb3B0aW9ucy5jcm9zc0RvbWFpbiApIHtcXG5cXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdHNlbmQ6IGZ1bmN0aW9uKCBoZWFkZXJzLCBjb21wbGV0ZSApIHtcXG5cXHRcXHRcXHRcXHR2YXIgaSxcXG5cXHRcXHRcXHRcXHRcXHR4aHIgPSBvcHRpb25zLnhocigpO1xcblxcblxcdFxcdFxcdFxcdHhoci5vcGVuKFxcblxcdFxcdFxcdFxcdFxcdG9wdGlvbnMudHlwZSxcXG5cXHRcXHRcXHRcXHRcXHRvcHRpb25zLnVybCxcXG5cXHRcXHRcXHRcXHRcXHRvcHRpb25zLmFzeW5jLFxcblxcdFxcdFxcdFxcdFxcdG9wdGlvbnMudXNlcm5hbWUsXFxuXFx0XFx0XFx0XFx0XFx0b3B0aW9ucy5wYXNzd29yZFxcblxcdFxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxcblxcdFxcdFxcdFxcdGlmICggb3B0aW9ucy54aHJGaWVsZHMgKSB7XFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggaSBpbiBvcHRpb25zLnhockZpZWxkcyApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR4aHJbIGkgXSA9IG9wdGlvbnMueGhyRmllbGRzWyBpIF07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXFxuXFx0XFx0XFx0XFx0aWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xcblxcdFxcdFxcdFxcdFxcdHhoci5vdmVycmlkZU1pbWVUeXBlKCBvcHRpb25zLm1pbWVUeXBlICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXFxuXFx0XFx0XFx0XFx0Ly8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxcblxcdFxcdFxcdFxcdC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXFxuXFx0XFx0XFx0XFx0Ly8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXFxuXFx0XFx0XFx0XFx0Ly8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXFxuXFx0XFx0XFx0XFx0aWYgKCAhb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1sgXFxcIlgtUmVxdWVzdGVkLVdpdGhcXFwiIF0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0aGVhZGVyc1sgXFxcIlgtUmVxdWVzdGVkLVdpdGhcXFwiIF0gPSBcXFwiWE1MSHR0cFJlcXVlc3RcXFwiO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBTZXQgaGVhZGVyc1xcblxcdFxcdFxcdFxcdGZvciAoIGkgaW4gaGVhZGVycyApIHtcXG5cXHRcXHRcXHRcXHRcXHR4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIENhbGxiYWNrXFxuXFx0XFx0XFx0XFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggdHlwZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBjYWxsYmFjayApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjYWxsYmFjayA9IGVycm9yQ2FsbGJhY2sgPSB4aHIub25sb2FkID1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9udGltZW91dCA9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB0eXBlID09PSBcXFwiYWJvcnRcXFwiICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHhoci5hYm9ydCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFxcXCJlcnJvclxcXCIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBPbiBhIG1hbnVhbCBuYXRpdmUgYWJvcnQsIElFOSB0aHJvd3NcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBlcnJvcnMgb24gYW55IHByb3BlcnR5IGFjY2VzcyB0aGF0IGlzIG5vdCByZWFkeVN0YXRlXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB0eXBlb2YgeGhyLnN0YXR1cyAhPT0gXFxcIm51bWJlclxcXCIgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29tcGxldGUoIDAsIFxcXCJlcnJvclxcXCIgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbXBsZXRlKFxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIEZpbGU6IHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIDA7IHNlZSAjODYwNSwgIzE0MjA3XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0eGhyLnN0YXR1cyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR4aHIuc3RhdHVzVGV4dFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29tcGxldGUoXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0eGhyU3VjY2Vzc1N0YXR1c1sgeGhyLnN0YXR1cyBdIHx8IHhoci5zdGF0dXMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0eGhyLnN0YXR1c1RleHQsXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBJRTkgaGFzIG5vIFhIUjIgYnV0IHRocm93cyBvbiBiaW5hcnkgKHRyYWMtMTE0MjYpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gRm9yIFhIUjIgbm9uLXRleHQsIGxldCB0aGUgY2FsbGVyIGhhbmRsZSBpdCAoZ2gtMjQ5OClcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQoIHhoci5yZXNwb25zZVR5cGUgfHwgXFxcInRleHRcXFwiICkgIT09IFxcXCJ0ZXh0XFxcIiAgfHxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCAhPT0gXFxcInN0cmluZ1xcXCIgP1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHsgYmluYXJ5OiB4aHIucmVzcG9uc2UgfSA6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0eyB0ZXh0OiB4aHIucmVzcG9uc2VUZXh0IH0sXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0eGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBMaXN0ZW4gdG8gZXZlbnRzXFxuXFx0XFx0XFx0XFx0eGhyLm9ubG9hZCA9IGNhbGxiYWNrKCk7XFxuXFx0XFx0XFx0XFx0ZXJyb3JDYWxsYmFjayA9IHhoci5vbmVycm9yID0geGhyLm9udGltZW91dCA9IGNhbGxiYWNrKCBcXFwiZXJyb3JcXFwiICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XFxuXFx0XFx0XFx0XFx0Ly8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcXG5cXHRcXHRcXHRcXHQvLyB0byBoYW5kbGUgdW5jYXVnaHQgYWJvcnRzXFxuXFx0XFx0XFx0XFx0aWYgKCB4aHIub25hYm9ydCAhPT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdFxcdFxcdHhoci5vbmFib3J0ID0gZXJyb3JDYWxsYmFjaztcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBDaGVjayByZWFkeVN0YXRlIGJlZm9yZSB0aW1lb3V0IGFzIGl0IGNoYW5nZXNcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIEFsbG93IG9uZXJyb3IgdG8gYmUgY2FsbGVkIGZpcnN0LFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGJ1dCB0aGF0IHdpbGwgbm90IGhhbmRsZSBhIG5hdGl2ZSBhYm9ydFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIEFsc28sIHNhdmUgZXJyb3JDYWxsYmFjayB0byBhIHZhcmlhYmxlXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gYXMgeGhyLm9uZXJyb3IgY2Fubm90IGJlIGFjY2Vzc2VkXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggY2FsbGJhY2sgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZXJyb3JDYWxsYmFjaygpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9ICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIENyZWF0ZSB0aGUgYWJvcnQgY2FsbGJhY2tcXG5cXHRcXHRcXHRcXHRjYWxsYmFjayA9IGNhbGxiYWNrKCBcXFwiYWJvcnRcXFwiICk7XFxuXFxuXFx0XFx0XFx0XFx0dHJ5IHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXFxuXFx0XFx0XFx0XFx0XFx0eGhyLnNlbmQoIG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCApO1xcblxcdFxcdFxcdFxcdH0gY2F0Y2ggKCBlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBjYWxsYmFjayApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aHJvdyBlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRhYm9ydDogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCBjYWxsYmFjayApIHtcXG5cXHRcXHRcXHRcXHRcXHRjYWxsYmFjaygpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXHR9XFxufSApO1xcblxcblxcblxcblxcbi8vIFByZXZlbnQgYXV0by1leGVjdXRpb24gb2Ygc2NyaXB0cyB3aGVuIG5vIGV4cGxpY2l0IGRhdGFUeXBlIHdhcyBwcm92aWRlZCAoU2VlIGdoLTI0MzIpXFxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIGZ1bmN0aW9uKCBzICkge1xcblxcdGlmICggcy5jcm9zc0RvbWFpbiApIHtcXG5cXHRcXHRzLmNvbnRlbnRzLnNjcmlwdCA9IGZhbHNlO1xcblxcdH1cXG59ICk7XFxuXFxuLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcXG5qUXVlcnkuYWpheFNldHVwKCB7XFxuXFx0YWNjZXB0czoge1xcblxcdFxcdHNjcmlwdDogXFxcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgXFxcIiArXFxuXFx0XFx0XFx0XFxcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFxcXCJcXG5cXHR9LFxcblxcdGNvbnRlbnRzOiB7XFxuXFx0XFx0c2NyaXB0OiAvXFxcXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxcXGIvXFxuXFx0fSxcXG5cXHRjb252ZXJ0ZXJzOiB7XFxuXFx0XFx0XFxcInRleHQgc2NyaXB0XFxcIjogZnVuY3Rpb24oIHRleHQgKSB7XFxuXFx0XFx0XFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHRleHQgKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGV4dDtcXG5cXHRcXHR9XFxuXFx0fVxcbn0gKTtcXG5cXG4vLyBIYW5kbGUgY2FjaGUncyBzcGVjaWFsIGNhc2UgYW5kIGNyb3NzRG9tYWluXFxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFxcXCJzY3JpcHRcXFwiLCBmdW5jdGlvbiggcyApIHtcXG5cXHRpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRzLmNhY2hlID0gZmFsc2U7XFxuXFx0fVxcblxcdGlmICggcy5jcm9zc0RvbWFpbiApIHtcXG5cXHRcXHRzLnR5cGUgPSBcXFwiR0VUXFxcIjtcXG5cXHR9XFxufSApO1xcblxcbi8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxcbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBcXFwic2NyaXB0XFxcIiwgZnVuY3Rpb24oIHMgKSB7XFxuXFxuXFx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiByZXF1ZXN0c1xcblxcdGlmICggcy5jcm9zc0RvbWFpbiApIHtcXG5cXHRcXHR2YXIgc2NyaXB0LCBjYWxsYmFjaztcXG5cXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdHNlbmQ6IGZ1bmN0aW9uKCBfLCBjb21wbGV0ZSApIHtcXG5cXHRcXHRcXHRcXHRzY3JpcHQgPSBqUXVlcnkoIFxcXCI8c2NyaXB0PlxcXCIgKS5wcm9wKCB7XFxuXFx0XFx0XFx0XFx0XFx0Y2hhcnNldDogcy5zY3JpcHRDaGFyc2V0LFxcblxcdFxcdFxcdFxcdFxcdHNyYzogcy51cmxcXG5cXHRcXHRcXHRcXHR9ICkub24oXFxuXFx0XFx0XFx0XFx0XFx0XFxcImxvYWQgZXJyb3JcXFwiLFxcblxcdFxcdFxcdFxcdFxcdGNhbGxiYWNrID0gZnVuY3Rpb24oIGV2dCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzY3JpcHQucmVtb3ZlKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FsbGJhY2sgPSBudWxsO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggZXZ0ICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbXBsZXRlKCBldnQudHlwZSA9PT0gXFxcImVycm9yXFxcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gVXNlIG5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG91ciBkb21NYW5pcCBBSkFYIHRyaWNrZXJ5XFxuXFx0XFx0XFx0XFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0WyAwIF0gKTtcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdGFib3J0OiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRpZiAoIGNhbGxiYWNrICkge1xcblxcdFxcdFxcdFxcdFxcdGNhbGxiYWNrKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcdH1cXG59ICk7XFxuXFxuXFxuXFxuXFxudmFyIG9sZENhbGxiYWNrcyA9IFtdLFxcblxcdHJqc29ucCA9IC8oPSlcXFxcPyg/PSZ8JCl8XFxcXD9cXFxcPy87XFxuXFxuLy8gRGVmYXVsdCBqc29ucCBzZXR0aW5nc1xcbmpRdWVyeS5hamF4U2V0dXAoIHtcXG5cXHRqc29ucDogXFxcImNhbGxiYWNrXFxcIixcXG5cXHRqc29ucENhbGxiYWNrOiBmdW5jdGlvbigpIHtcXG5cXHRcXHR2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFxcXCJfXFxcIiArICggbm9uY2UrKyApICk7XFxuXFx0XFx0dGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7XFxuXFx0XFx0cmV0dXJuIGNhbGxiYWNrO1xcblxcdH1cXG59ICk7XFxuXFxuLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXFxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFxcXCJqc29uIGpzb25wXFxcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xcblxcblxcdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcXG5cXHRcXHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xcblxcdFxcdFxcdFxcXCJ1cmxcXFwiIDpcXG5cXHRcXHRcXHR0eXBlb2Ygcy5kYXRhID09PSBcXFwic3RyaW5nXFxcIiAmJlxcblxcdFxcdFxcdFxcdCggcy5jb250ZW50VHlwZSB8fCBcXFwiXFxcIiApXFxuXFx0XFx0XFx0XFx0XFx0LmluZGV4T2YoIFxcXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcXFwiICkgPT09IDAgJiZcXG5cXHRcXHRcXHRcXHRyanNvbnAudGVzdCggcy5kYXRhICkgJiYgXFxcImRhdGFcXFwiXFxuXFx0XFx0KTtcXG5cXG5cXHQvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXFxcImpzb25wXFxcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxcblxcdGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gXFxcImpzb25wXFxcIiApIHtcXG5cXG5cXHRcXHQvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XFxuXFx0XFx0Y2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0gaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xcblxcdFxcdFxcdHMuanNvbnBDYWxsYmFjaygpIDpcXG5cXHRcXHRcXHRzLmpzb25wQ2FsbGJhY2s7XFxuXFxuXFx0XFx0Ly8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxcblxcdFxcdGlmICgganNvblByb3AgKSB7XFxuXFx0XFx0XFx0c1sganNvblByb3AgXSA9IHNbIGpzb25Qcm9wIF0ucmVwbGFjZSggcmpzb25wLCBcXFwiJDFcXFwiICsgY2FsbGJhY2tOYW1lICk7XFxuXFx0XFx0fSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XFxuXFx0XFx0XFx0cy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFxcXCImXFxcIiA6IFxcXCI/XFxcIiApICsgcy5qc29ucCArIFxcXCI9XFxcIiArIGNhbGxiYWNrTmFtZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvblxcblxcdFxcdHMuY29udmVydGVyc1sgXFxcInNjcmlwdCBqc29uXFxcIiBdID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0aWYgKCAhcmVzcG9uc2VDb250YWluZXIgKSB7XFxuXFx0XFx0XFx0XFx0alF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyBcXFwiIHdhcyBub3QgY2FsbGVkXFxcIiApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIEZvcmNlIGpzb24gZGF0YVR5cGVcXG5cXHRcXHRzLmRhdGFUeXBlc1sgMCBdID0gXFxcImpzb25cXFwiO1xcblxcblxcdFxcdC8vIEluc3RhbGwgY2FsbGJhY2tcXG5cXHRcXHRvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XFxuXFx0XFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gQ2xlYW4tdXAgZnVuY3Rpb24gKGZpcmVzIGFmdGVyIGNvbnZlcnRlcnMpXFxuXFx0XFx0anFYSFIuYWx3YXlzKCBmdW5jdGlvbigpIHtcXG5cXG5cXHRcXHRcXHQvLyBJZiBwcmV2aW91cyB2YWx1ZSBkaWRuJ3QgZXhpc3QgLSByZW1vdmUgaXRcXG5cXHRcXHRcXHRpZiAoIG92ZXJ3cml0dGVuID09PSB1bmRlZmluZWQgKSB7XFxuXFx0XFx0XFx0XFx0alF1ZXJ5KCB3aW5kb3cgKS5yZW1vdmVQcm9wKCBjYWxsYmFja05hbWUgKTtcXG5cXG5cXHRcXHRcXHQvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxcblxcdFxcdFxcdGlmICggc1sgY2FsbGJhY2tOYW1lIF0gKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gTWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXFxuXFx0XFx0XFx0XFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xcblxcblxcdFxcdFxcdFxcdC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2VcXG5cXHRcXHRcXHRcXHRvbGRDYWxsYmFja3MucHVzaCggY2FsbGJhY2tOYW1lICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIENhbGwgaWYgaXQgd2FzIGEgZnVuY3Rpb24gYW5kIHdlIGhhdmUgYSByZXNwb25zZVxcblxcdFxcdFxcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcXG5cXHRcXHRcXHRcXHRvdmVyd3JpdHRlbiggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xcblxcdFxcdH0gKTtcXG5cXG5cXHRcXHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcXG5cXHRcXHRyZXR1cm4gXFxcInNjcmlwdFxcXCI7XFxuXFx0fVxcbn0gKTtcXG5cXG5cXG5cXG5cXG4vLyBTdXBwb3J0OiBTYWZhcmkgOCBvbmx5XFxuLy8gSW4gU2FmYXJpIDggZG9jdW1lbnRzIGNyZWF0ZWQgdmlhIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudFxcbi8vIGNvbGxhcHNlIHNpYmxpbmcgZm9ybXM6IHRoZSBzZWNvbmQgb25lIGJlY29tZXMgYSBjaGlsZCBvZiB0aGUgZmlyc3Qgb25lLlxcbi8vIEJlY2F1c2Ugb2YgdGhhdCwgdGhpcyBzZWN1cml0eSBtZWFzdXJlIGhhcyB0byBiZSBkaXNhYmxlZCBpbiBTYWZhcmkgOC5cXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM3MzM3XFxuc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgPSAoIGZ1bmN0aW9uKCkge1xcblxcdHZhciBib2R5ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcXFwiXFxcIiApLmJvZHk7XFxuXFx0Ym9keS5pbm5lckhUTUwgPSBcXFwiPGZvcm0+PC9mb3JtPjxmb3JtPjwvZm9ybT5cXFwiO1xcblxcdHJldHVybiBib2R5LmNoaWxkTm9kZXMubGVuZ3RoID09PSAyO1xcbn0gKSgpO1xcblxcblxcbi8vIEFyZ3VtZW50IFxcXCJkYXRhXFxcIiBzaG91bGQgYmUgc3RyaW5nIG9mIGh0bWxcXG4vLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsXFxuLy8gZGVmYXVsdHMgdG8gZG9jdW1lbnRcXG4vLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXFxualF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcXG5cXHRpZiAoIHR5cGVvZiBkYXRhICE9PSBcXFwic3RyaW5nXFxcIiApIHtcXG5cXHRcXHRyZXR1cm4gW107XFxuXFx0fVxcblxcdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFxcXCJib29sZWFuXFxcIiApIHtcXG5cXHRcXHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XFxuXFx0XFx0Y29udGV4dCA9IGZhbHNlO1xcblxcdH1cXG5cXG5cXHR2YXIgYmFzZSwgcGFyc2VkLCBzY3JpcHRzO1xcblxcblxcdGlmICggIWNvbnRleHQgKSB7XFxuXFxuXFx0XFx0Ly8gU3RvcCBzY3JpcHRzIG9yIGlubGluZSBldmVudCBoYW5kbGVycyBmcm9tIGJlaW5nIGV4ZWN1dGVkIGltbWVkaWF0ZWx5XFxuXFx0XFx0Ly8gYnkgdXNpbmcgZG9jdW1lbnQuaW1wbGVtZW50YXRpb25cXG5cXHRcXHRpZiAoIHN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ICkge1xcblxcdFxcdFxcdGNvbnRleHQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFxcXCJcXFwiICk7XFxuXFxuXFx0XFx0XFx0Ly8gU2V0IHRoZSBiYXNlIGhyZWYgZm9yIHRoZSBjcmVhdGVkIGRvY3VtZW50XFxuXFx0XFx0XFx0Ly8gc28gYW55IHBhcnNlZCBlbGVtZW50cyB3aXRoIFVSTHNcXG5cXHRcXHRcXHQvLyBhcmUgYmFzZWQgb24gdGhlIGRvY3VtZW50J3MgVVJMIChnaC0yOTY1KVxcblxcdFxcdFxcdGJhc2UgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFxcXCJiYXNlXFxcIiApO1xcblxcdFxcdFxcdGJhc2UuaHJlZiA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XFxuXFx0XFx0XFx0Y29udGV4dC5oZWFkLmFwcGVuZENoaWxkKCBiYXNlICk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRjb250ZXh0ID0gZG9jdW1lbnQ7XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKTtcXG5cXHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xcblxcblxcdC8vIFNpbmdsZSB0YWdcXG5cXHRpZiAoIHBhcnNlZCApIHtcXG5cXHRcXHRyZXR1cm4gWyBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIHBhcnNlZFsgMSBdICkgXTtcXG5cXHR9XFxuXFxuXFx0cGFyc2VkID0gYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcXG5cXG5cXHRpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XFxuXFx0XFx0alF1ZXJ5KCBzY3JpcHRzICkucmVtb3ZlKCk7XFxuXFx0fVxcblxcblxcdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBwYXJzZWQuY2hpbGROb2RlcyApO1xcbn07XFxuXFxuXFxuLyoqXFxuICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZVxcbiAqL1xcbmpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcXG5cXHR2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxcblxcdFxcdHNlbGYgPSB0aGlzLFxcblxcdFxcdG9mZiA9IHVybC5pbmRleE9mKCBcXFwiIFxcXCIgKTtcXG5cXG5cXHRpZiAoIG9mZiA+IC0xICkge1xcblxcdFxcdHNlbGVjdG9yID0gc3RyaXBBbmRDb2xsYXBzZSggdXJsLnNsaWNlKCBvZmYgKSApO1xcblxcdFxcdHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XFxuXFx0fVxcblxcblxcdC8vIElmIGl0J3MgYSBmdW5jdGlvblxcblxcdGlmICggaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XFxuXFxuXFx0XFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcXG5cXHRcXHRjYWxsYmFjayA9IHBhcmFtcztcXG5cXHRcXHRwYXJhbXMgPSB1bmRlZmluZWQ7XFxuXFxuXFx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xcblxcdH0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSBcXFwib2JqZWN0XFxcIiApIHtcXG5cXHRcXHR0eXBlID0gXFxcIlBPU1RcXFwiO1xcblxcdH1cXG5cXG5cXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxcblxcdGlmICggc2VsZi5sZW5ndGggPiAwICkge1xcblxcdFxcdGpRdWVyeS5hamF4KCB7XFxuXFx0XFx0XFx0dXJsOiB1cmwsXFxuXFxuXFx0XFx0XFx0Ly8gSWYgXFxcInR5cGVcXFwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcXFwiR0VUXFxcIiBtZXRob2Qgd2lsbCBiZSB1c2VkLlxcblxcdFxcdFxcdC8vIE1ha2UgdmFsdWUgb2YgdGhpcyBmaWVsZCBleHBsaWNpdCBzaW5jZVxcblxcdFxcdFxcdC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxcblxcdFxcdFxcdHR5cGU6IHR5cGUgfHwgXFxcIkdFVFxcXCIsXFxuXFx0XFx0XFx0ZGF0YVR5cGU6IFxcXCJodG1sXFxcIixcXG5cXHRcXHRcXHRkYXRhOiBwYXJhbXNcXG5cXHRcXHR9ICkuZG9uZSggZnVuY3Rpb24oIHJlc3BvbnNlVGV4dCApIHtcXG5cXG5cXHRcXHRcXHQvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcXG5cXHRcXHRcXHRyZXNwb25zZSA9IGFyZ3VtZW50cztcXG5cXG5cXHRcXHRcXHRzZWxmLmh0bWwoIHNlbGVjdG9yID9cXG5cXG5cXHRcXHRcXHRcXHQvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcXG5cXHRcXHRcXHRcXHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcXG5cXHRcXHRcXHRcXHRqUXVlcnkoIFxcXCI8ZGl2PlxcXCIgKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XFxuXFxuXFx0XFx0XFx0XFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcXG5cXHRcXHRcXHRcXHRyZXNwb25zZVRleHQgKTtcXG5cXG5cXHRcXHQvLyBJZiB0aGUgcmVxdWVzdCBzdWNjZWVkcywgdGhpcyBmdW5jdGlvbiBnZXRzIFxcXCJkYXRhXFxcIiwgXFxcInN0YXR1c1xcXCIsIFxcXCJqcVhIUlxcXCJcXG5cXHRcXHQvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXFxuXFx0XFx0Ly8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcXFwianFYSFJcXFwiLCBcXFwic3RhdHVzXFxcIiwgXFxcImVycm9yXFxcIlxcblxcdFxcdH0gKS5hbHdheXMoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xcblxcdFxcdFxcdHNlbGYuZWFjaCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcXG5cXHRcXHRcXHR9ICk7XFxuXFx0XFx0fSApO1xcblxcdH1cXG5cXG5cXHRyZXR1cm4gdGhpcztcXG59O1xcblxcblxcblxcblxcbi8vIEF0dGFjaCBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgY29tbW9uIEFKQVggZXZlbnRzXFxualF1ZXJ5LmVhY2goIFtcXG5cXHRcXFwiYWpheFN0YXJ0XFxcIixcXG5cXHRcXFwiYWpheFN0b3BcXFwiLFxcblxcdFxcXCJhamF4Q29tcGxldGVcXFwiLFxcblxcdFxcXCJhamF4RXJyb3JcXFwiLFxcblxcdFxcXCJhamF4U3VjY2Vzc1xcXCIsXFxuXFx0XFxcImFqYXhTZW5kXFxcIlxcbl0sIGZ1bmN0aW9uKCBpLCB0eXBlICkge1xcblxcdGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIGZuICkge1xcblxcdFxcdHJldHVybiB0aGlzLm9uKCB0eXBlLCBmbiApO1xcblxcdH07XFxufSApO1xcblxcblxcblxcblxcbmpRdWVyeS5leHByLnBzZXVkb3MuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGpRdWVyeS50aW1lcnMsIGZ1bmN0aW9uKCBmbiApIHtcXG5cXHRcXHRyZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcXG5cXHR9ICkubGVuZ3RoO1xcbn07XFxuXFxuXFxuXFxuXFxualF1ZXJ5Lm9mZnNldCA9IHtcXG5cXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xcblxcdFxcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXFxuXFx0XFx0XFx0cG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcXFwicG9zaXRpb25cXFwiICksXFxuXFx0XFx0XFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxcblxcdFxcdFxcdHByb3BzID0ge307XFxuXFxuXFx0XFx0Ly8gU2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxcblxcdFxcdGlmICggcG9zaXRpb24gPT09IFxcXCJzdGF0aWNcXFwiICkge1xcblxcdFxcdFxcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcXFwicmVsYXRpdmVcXFwiO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xcblxcdFxcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFxcXCJ0b3BcXFwiICk7XFxuXFx0XFx0Y3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFxcXCJsZWZ0XFxcIiApO1xcblxcdFxcdGNhbGN1bGF0ZVBvc2l0aW9uID0gKCBwb3NpdGlvbiA9PT0gXFxcImFic29sdXRlXFxcIiB8fCBwb3NpdGlvbiA9PT0gXFxcImZpeGVkXFxcIiApICYmXFxuXFx0XFx0XFx0KCBjdXJDU1NUb3AgKyBjdXJDU1NMZWZ0ICkuaW5kZXhPZiggXFxcImF1dG9cXFwiICkgPiAtMTtcXG5cXG5cXHRcXHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxcblxcdFxcdC8vIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxcblxcdFxcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XFxuXFx0XFx0XFx0Y3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XFxuXFx0XFx0XFx0Y3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xcblxcdFxcdFxcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xcblxcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0Y3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcXG5cXHRcXHRcXHRjdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggaXNGdW5jdGlvbiggb3B0aW9ucyApICkge1xcblxcblxcdFxcdFxcdC8vIFVzZSBqUXVlcnkuZXh0ZW5kIGhlcmUgdG8gYWxsb3cgbW9kaWZpY2F0aW9uIG9mIGNvb3JkaW5hdGVzIGFyZ3VtZW50IChnaC0xODQ4KVxcblxcdFxcdFxcdG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGpRdWVyeS5leHRlbmQoIHt9LCBjdXJPZmZzZXQgKSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XFxuXFx0XFx0XFx0cHJvcHMudG9wID0gKCBvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3AgKSArIGN1clRvcDtcXG5cXHRcXHR9XFxuXFx0XFx0aWYgKCBvcHRpb25zLmxlZnQgIT0gbnVsbCApIHtcXG5cXHRcXHRcXHRwcm9wcy5sZWZ0ID0gKCBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCApICsgY3VyTGVmdDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBcXFwidXNpbmdcXFwiIGluIG9wdGlvbnMgKSB7XFxuXFx0XFx0XFx0b3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xcblxcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0Y3VyRWxlbS5jc3MoIHByb3BzICk7XFxuXFx0XFx0fVxcblxcdH1cXG59O1xcblxcbmpRdWVyeS5mbi5leHRlbmQoIHtcXG5cXG5cXHQvLyBvZmZzZXQoKSByZWxhdGVzIGFuIGVsZW1lbnQncyBib3JkZXIgYm94IHRvIHRoZSBkb2N1bWVudCBvcmlnaW5cXG5cXHRvZmZzZXQ6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xcblxcblxcdFxcdC8vIFByZXNlcnZlIGNoYWluaW5nIGZvciBzZXR0ZXJcXG5cXHRcXHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XFxuXFx0XFx0XFx0cmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/XFxuXFx0XFx0XFx0XFx0dGhpcyA6XFxuXFx0XFx0XFx0XFx0dGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkub2Zmc2V0LnNldE9mZnNldCggdGhpcywgb3B0aW9ucywgaSApO1xcblxcdFxcdFxcdFxcdH0gKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dmFyIHJlY3QsIHdpbixcXG5cXHRcXHRcXHRlbGVtID0gdGhpc1sgMCBdO1xcblxcblxcdFxcdGlmICggIWVsZW0gKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBSZXR1cm4gemVyb3MgZm9yIGRpc2Nvbm5lY3RlZCBhbmQgaGlkZGVuIChkaXNwbGF5OiBub25lKSBlbGVtZW50cyAoZ2gtMjMxMClcXG5cXHRcXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcXG5cXHRcXHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhXFxuXFx0XFx0Ly8gZGlzY29ubmVjdGVkIG5vZGUgaW4gSUUgdGhyb3dzIGFuIGVycm9yXFxuXFx0XFx0aWYgKCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcXG5cXHRcXHRcXHRyZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAgfTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gR2V0IGRvY3VtZW50LXJlbGF0aXZlIHBvc2l0aW9uIGJ5IGFkZGluZyB2aWV3cG9ydCBzY3JvbGwgdG8gdmlld3BvcnQtcmVsYXRpdmUgZ0JDUlxcblxcdFxcdHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xcblxcdFxcdHdpbiA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcXG5cXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdHRvcDogcmVjdC50b3AgKyB3aW4ucGFnZVlPZmZzZXQsXFxuXFx0XFx0XFx0bGVmdDogcmVjdC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0XFxuXFx0XFx0fTtcXG5cXHR9LFxcblxcblxcdC8vIHBvc2l0aW9uKCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgbWFyZ2luIGJveCB0byBpdHMgb2Zmc2V0IHBhcmVudCdzIHBhZGRpbmcgYm94XFxuXFx0Ly8gVGhpcyBjb3JyZXNwb25kcyB0byB0aGUgYmVoYXZpb3Igb2YgQ1NTIGFic29sdXRlIHBvc2l0aW9uaW5nXFxuXFx0cG9zaXRpb246IGZ1bmN0aW9uKCkge1xcblxcdFxcdGlmICggIXRoaXNbIDAgXSApIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCwgZG9jLFxcblxcdFxcdFxcdGVsZW0gPSB0aGlzWyAwIF0sXFxuXFx0XFx0XFx0cGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcXG5cXG5cXHRcXHQvLyBwb3NpdGlvbjpmaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gdGhlIHZpZXdwb3J0LCB3aGljaCBpdHNlbGYgYWx3YXlzIGhhcyB6ZXJvIG9mZnNldFxcblxcdFxcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXFxcInBvc2l0aW9uXFxcIiApID09PSBcXFwiZml4ZWRcXFwiICkge1xcblxcblxcdFxcdFxcdC8vIEFzc3VtZSBwb3NpdGlvbjpmaXhlZCBpbXBsaWVzIGF2YWlsYWJpbGl0eSBvZiBnZXRCb3VuZGluZ0NsaWVudFJlY3RcXG5cXHRcXHRcXHRvZmZzZXQgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xcblxcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0b2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcXG5cXG5cXHRcXHRcXHQvLyBBY2NvdW50IGZvciB0aGUgKnJlYWwqIG9mZnNldCBwYXJlbnQsIHdoaWNoIGNhbiBiZSB0aGUgZG9jdW1lbnQgb3IgaXRzIHJvb3QgZWxlbWVudFxcblxcdFxcdFxcdC8vIHdoZW4gYSBzdGF0aWNhbGx5IHBvc2l0aW9uZWQgZWxlbWVudCBpcyBpZGVudGlmaWVkXFxuXFx0XFx0XFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50O1xcblxcdFxcdFxcdG9mZnNldFBhcmVudCA9IGVsZW0ub2Zmc2V0UGFyZW50IHx8IGRvYy5kb2N1bWVudEVsZW1lbnQ7XFxuXFx0XFx0XFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiZcXG5cXHRcXHRcXHRcXHQoIG9mZnNldFBhcmVudCA9PT0gZG9jLmJvZHkgfHwgb2Zmc2V0UGFyZW50ID09PSBkb2MuZG9jdW1lbnRFbGVtZW50ICkgJiZcXG5cXHRcXHRcXHRcXHRqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFxcXCJwb3NpdGlvblxcXCIgKSA9PT0gXFxcInN0YXRpY1xcXCIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50LnBhcmVudE5vZGU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICggb2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudCAhPT0gZWxlbSAmJiBvZmZzZXRQYXJlbnQubm9kZVR5cGUgPT09IDEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSW5jb3Jwb3JhdGUgYm9yZGVycyBpbnRvIGl0cyBvZmZzZXQsIHNpbmNlIHRoZXkgYXJlIG91dHNpZGUgaXRzIGNvbnRlbnQgb3JpZ2luXFxuXFx0XFx0XFx0XFx0cGFyZW50T2Zmc2V0ID0galF1ZXJ5KCBvZmZzZXRQYXJlbnQgKS5vZmZzZXQoKTtcXG5cXHRcXHRcXHRcXHRwYXJlbnRPZmZzZXQudG9wICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXFxcImJvcmRlclRvcFdpZHRoXFxcIiwgdHJ1ZSApO1xcblxcdFxcdFxcdFxcdHBhcmVudE9mZnNldC5sZWZ0ICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXFxcImJvcmRlckxlZnRXaWR0aFxcXCIsIHRydWUgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcXG5cXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdHRvcDogb2Zmc2V0LnRvcCAtIHBhcmVudE9mZnNldC50b3AgLSBqUXVlcnkuY3NzKCBlbGVtLCBcXFwibWFyZ2luVG9wXFxcIiwgdHJ1ZSApLFxcblxcdFxcdFxcdGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKCBlbGVtLCBcXFwibWFyZ2luTGVmdFxcXCIsIHRydWUgKVxcblxcdFxcdH07XFxuXFx0fSxcXG5cXG5cXHQvLyBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBkb2N1bWVudEVsZW1lbnQgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcXG5cXHQvLyAxKSBGb3IgdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBpZnJhbWUgd2l0aG91dCBvZmZzZXRQYXJlbnQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuXFxuXFx0Ly8gICAgZG9jdW1lbnRFbGVtZW50IG9mIHRoZSBwYXJlbnQgd2luZG93XFxuXFx0Ly8gMikgRm9yIHRoZSBoaWRkZW4gb3IgZGV0YWNoZWQgZWxlbWVudFxcblxcdC8vIDMpIEZvciBib2R5IG9yIGh0bWwgZWxlbWVudCwgaS5lLiBpbiBjYXNlIG9mIHRoZSBodG1sIG5vZGUgLSBpdCB3aWxsIHJldHVybiBpdHNlbGZcXG5cXHQvL1xcblxcdC8vIGJ1dCB0aG9zZSBleGNlcHRpb25zIHdlcmUgbmV2ZXIgcHJlc2VudGVkIGFzIGEgcmVhbCBsaWZlIHVzZS1jYXNlc1xcblxcdC8vIGFuZCBtaWdodCBiZSBjb25zaWRlcmVkIGFzIG1vcmUgcHJlZmVyYWJsZSByZXN1bHRzLlxcblxcdC8vXFxuXFx0Ly8gVGhpcyBsb2dpYywgaG93ZXZlciwgaXMgbm90IGd1YXJhbnRlZWQgYW5kIGNhbiBjaGFuZ2UgYXQgYW55IHBvaW50IGluIHRoZSBmdXR1cmVcXG5cXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xcblxcdFxcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0dmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50O1xcblxcblxcdFxcdFxcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXFxcInBvc2l0aW9uXFxcIiApID09PSBcXFwic3RhdGljXFxcIiApIHtcXG5cXHRcXHRcXHRcXHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50RWxlbWVudDtcXG5cXHRcXHR9ICk7XFxuXFx0fVxcbn0gKTtcXG5cXG4vLyBDcmVhdGUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIG1ldGhvZHNcXG5qUXVlcnkuZWFjaCggeyBzY3JvbGxMZWZ0OiBcXFwicGFnZVhPZmZzZXRcXFwiLCBzY3JvbGxUb3A6IFxcXCJwYWdlWU9mZnNldFxcXCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcXG5cXHR2YXIgdG9wID0gXFxcInBhZ2VZT2Zmc2V0XFxcIiA9PT0gcHJvcDtcXG5cXG5cXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcXG5cXHRcXHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gQ29hbGVzY2UgZG9jdW1lbnRzIGFuZCB3aW5kb3dzXFxuXFx0XFx0XFx0dmFyIHdpbjtcXG5cXHRcXHRcXHRpZiAoIGlzV2luZG93KCBlbGVtICkgKSB7XFxuXFx0XFx0XFx0XFx0d2luID0gZWxlbTtcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xcblxcdFxcdFxcdFxcdHdpbiA9IGVsZW0uZGVmYXVsdFZpZXc7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHdpbiA/IHdpblsgcHJvcCBdIDogZWxlbVsgbWV0aG9kIF07XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggd2luICkge1xcblxcdFxcdFxcdFxcdHdpbi5zY3JvbGxUbyhcXG5cXHRcXHRcXHRcXHRcXHQhdG9wID8gdmFsIDogd2luLnBhZ2VYT2Zmc2V0LFxcblxcdFxcdFxcdFxcdFxcdHRvcCA/IHZhbCA6IHdpbi5wYWdlWU9mZnNldFxcblxcdFxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRlbGVtWyBtZXRob2QgXSA9IHZhbDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGggKTtcXG5cXHR9O1xcbn0gKTtcXG5cXG4vLyBTdXBwb3J0OiBTYWZhcmkgPD03IC0gOS4xLCBDaHJvbWUgPD0zNyAtIDQ5XFxuLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cXG4vLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcXG4vLyBCbGluayBidWc6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTU4OTM0N1xcbi8vIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBwZXJjZW50IHdoZW4gc3BlY2lmaWVkIGZvciB0b3AvbGVmdC9ib3R0b20vcmlnaHQ7XFxuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcXG5qUXVlcnkuZWFjaCggWyBcXFwidG9wXFxcIiwgXFxcImxlZnRcXFwiIF0sIGZ1bmN0aW9uKCBpLCBwcm9wICkge1xcblxcdGpRdWVyeS5jc3NIb29rc1sgcHJvcCBdID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnBpeGVsUG9zaXRpb24sXFxuXFx0XFx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xcblxcdFxcdFxcdGlmICggY29tcHV0ZWQgKSB7XFxuXFx0XFx0XFx0XFx0Y29tcHV0ZWQgPSBjdXJDU1MoIGVsZW0sIHByb3AgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBJZiBjdXJDU1MgcmV0dXJucyBwZXJjZW50YWdlLCBmYWxsYmFjayB0byBvZmZzZXRcXG5cXHRcXHRcXHRcXHRyZXR1cm4gcm51bW5vbnB4LnRlc3QoIGNvbXB1dGVkICkgP1xcblxcdFxcdFxcdFxcdFxcdGpRdWVyeSggZWxlbSApLnBvc2l0aW9uKClbIHByb3AgXSArIFxcXCJweFxcXCIgOlxcblxcdFxcdFxcdFxcdFxcdGNvbXB1dGVkO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0KTtcXG59ICk7XFxuXFxuXFxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXFxualF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcXFwiaGVpZ2h0XFxcIiwgV2lkdGg6IFxcXCJ3aWR0aFxcXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XFxuXFx0alF1ZXJ5LmVhY2goIHsgcGFkZGluZzogXFxcImlubmVyXFxcIiArIG5hbWUsIGNvbnRlbnQ6IHR5cGUsIFxcXCJcXFwiOiBcXFwib3V0ZXJcXFwiICsgbmFtZSB9LFxcblxcdFxcdGZ1bmN0aW9uKCBkZWZhdWx0RXh0cmEsIGZ1bmNOYW1lICkge1xcblxcblxcdFxcdC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxcblxcdFxcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xcblxcdFxcdFxcdHZhciBjaGFpbmFibGUgPSBhcmd1bWVudHMubGVuZ3RoICYmICggZGVmYXVsdEV4dHJhIHx8IHR5cGVvZiBtYXJnaW4gIT09IFxcXCJib29sZWFuXFxcIiApLFxcblxcdFxcdFxcdFxcdGV4dHJhID0gZGVmYXVsdEV4dHJhIHx8ICggbWFyZ2luID09PSB0cnVlIHx8IHZhbHVlID09PSB0cnVlID8gXFxcIm1hcmdpblxcXCIgOiBcXFwiYm9yZGVyXFxcIiApO1xcblxcblxcdFxcdFxcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCB2YWx1ZSApIHtcXG5cXHRcXHRcXHRcXHR2YXIgZG9jO1xcblxcblxcdFxcdFxcdFxcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyAkKCB3aW5kb3cgKS5vdXRlcldpZHRoL0hlaWdodCByZXR1cm4gdy9oIGluY2x1ZGluZyBzY3JvbGxiYXJzIChnaC0xNzI5KVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBmdW5jTmFtZS5pbmRleE9mKCBcXFwib3V0ZXJcXFwiICkgPT09IDAgP1xcblxcdFxcdFxcdFxcdFxcdFxcdGVsZW1bIFxcXCJpbm5lclxcXCIgKyBuYW1lIF0gOlxcblxcdFxcdFxcdFxcdFxcdFxcdGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcXFwiY2xpZW50XFxcIiArIG5hbWUgXTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxcblxcdFxcdFxcdFxcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcXG5cXHRcXHRcXHRcXHRcXHRkb2MgPSBlbGVtLmRvY3VtZW50RWxlbWVudDtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXFxuXFx0XFx0XFx0XFx0XFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIE1hdGgubWF4KFxcblxcdFxcdFxcdFxcdFxcdFxcdGVsZW0uYm9keVsgXFxcInNjcm9sbFxcXCIgKyBuYW1lIF0sIGRvY1sgXFxcInNjcm9sbFxcXCIgKyBuYW1lIF0sXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxlbS5ib2R5WyBcXFwib2Zmc2V0XFxcIiArIG5hbWUgXSwgZG9jWyBcXFwib2Zmc2V0XFxcIiArIG5hbWUgXSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRkb2NbIFxcXCJjbGllbnRcXFwiICsgbmFtZSBdXFxuXFx0XFx0XFx0XFx0XFx0KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIEdldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQsIHJlcXVlc3RpbmcgYnV0IG5vdCBmb3JjaW5nIHBhcnNlRmxvYXRcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuY3NzKCBlbGVtLCB0eXBlLCBleHRyYSApIDpcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcXG5cXHRcXHRcXHR9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSApO1xcblxcdFxcdH07XFxuXFx0fSApO1xcbn0gKTtcXG5cXG5cXG5qUXVlcnkuZWFjaCggKCBcXFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgXFxcIiArXFxuXFx0XFxcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFxcXCIgK1xcblxcdFxcXCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XFxcIiApLnNwbGl0KCBcXFwiIFxcXCIgKSxcXG5cXHRmdW5jdGlvbiggaSwgbmFtZSApIHtcXG5cXG5cXHQvLyBIYW5kbGUgZXZlbnQgYmluZGluZ1xcblxcdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIGRhdGEsIGZuICkge1xcblxcdFxcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/XFxuXFx0XFx0XFx0dGhpcy5vbiggbmFtZSwgbnVsbCwgZGF0YSwgZm4gKSA6XFxuXFx0XFx0XFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XFxuXFx0fTtcXG59ICk7XFxuXFxualF1ZXJ5LmZuLmV4dGVuZCgge1xcblxcdGhvdmVyOiBmdW5jdGlvbiggZm5PdmVyLCBmbk91dCApIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5tb3VzZWVudGVyKCBmbk92ZXIgKS5tb3VzZWxlYXZlKCBmbk91dCB8fCBmbk92ZXIgKTtcXG5cXHR9XFxufSApO1xcblxcblxcblxcblxcbmpRdWVyeS5mbi5leHRlbmQoIHtcXG5cXG5cXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xcblxcdFxcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcXG5cXHR9LFxcblxcdHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5vZmYoIHR5cGVzLCBudWxsLCBmbiApO1xcblxcdH0sXFxuXFxuXFx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xcblxcdFxcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XFxuXFx0fSxcXG5cXHR1bmRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBmbiApIHtcXG5cXG5cXHRcXHQvLyAoIG5hbWVzcGFjZSApIG9yICggc2VsZWN0b3IsIHR5cGVzIFssIGZuXSApXFxuXFx0XFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgP1xcblxcdFxcdFxcdHRoaXMub2ZmKCBzZWxlY3RvciwgXFxcIioqXFxcIiApIDpcXG5cXHRcXHRcXHR0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yIHx8IFxcXCIqKlxcXCIsIGZuICk7XFxuXFx0fVxcbn0gKTtcXG5cXG4vLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcXG4vLyBhcmd1bWVudHMuXFxuLy8galF1ZXJ5LnByb3h5IGlzIGRlcHJlY2F0ZWQgdG8gcHJvbW90ZSBzdGFuZGFyZHMgKHNwZWNpZmljYWxseSBGdW5jdGlvbiNiaW5kKVxcbi8vIEhvd2V2ZXIsIGl0IGlzIG5vdCBzbGF0ZWQgZm9yIHJlbW92YWwgYW55IHRpbWUgc29vblxcbmpRdWVyeS5wcm94eSA9IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcXG5cXHR2YXIgdG1wLCBhcmdzLCBwcm94eTtcXG5cXG5cXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcXFwic3RyaW5nXFxcIiApIHtcXG5cXHRcXHR0bXAgPSBmblsgY29udGV4dCBdO1xcblxcdFxcdGNvbnRleHQgPSBmbjtcXG5cXHRcXHRmbiA9IHRtcDtcXG5cXHR9XFxuXFxuXFx0Ly8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcXG5cXHQvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxcblxcdGlmICggIWlzRnVuY3Rpb24oIGZuICkgKSB7XFxuXFx0XFx0cmV0dXJuIHVuZGVmaW5lZDtcXG5cXHR9XFxuXFxuXFx0Ly8gU2ltdWxhdGVkIGJpbmRcXG5cXHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAyICk7XFxuXFx0cHJveHkgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRyZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcXG5cXHR9O1xcblxcblxcdC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxcblxcdHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xcblxcblxcdHJldHVybiBwcm94eTtcXG59O1xcblxcbmpRdWVyeS5ob2xkUmVhZHkgPSBmdW5jdGlvbiggaG9sZCApIHtcXG5cXHRpZiAoIGhvbGQgKSB7XFxuXFx0XFx0alF1ZXJ5LnJlYWR5V2FpdCsrO1xcblxcdH0gZWxzZSB7XFxuXFx0XFx0alF1ZXJ5LnJlYWR5KCB0cnVlICk7XFxuXFx0fVxcbn07XFxualF1ZXJ5LmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xcbmpRdWVyeS5wYXJzZUpTT04gPSBKU09OLnBhcnNlO1xcbmpRdWVyeS5ub2RlTmFtZSA9IG5vZGVOYW1lO1xcbmpRdWVyeS5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcXG5qUXVlcnkuaXNXaW5kb3cgPSBpc1dpbmRvdztcXG5qUXVlcnkuY2FtZWxDYXNlID0gY2FtZWxDYXNlO1xcbmpRdWVyeS50eXBlID0gdG9UeXBlO1xcblxcbmpRdWVyeS5ub3cgPSBEYXRlLm5vdztcXG5cXG5qUXVlcnkuaXNOdW1lcmljID0gZnVuY3Rpb24oIG9iaiApIHtcXG5cXG5cXHQvLyBBcyBvZiBqUXVlcnkgMy4wLCBpc051bWVyaWMgaXMgbGltaXRlZCB0b1xcblxcdC8vIHN0cmluZ3MgYW5kIG51bWJlcnMgKHByaW1pdGl2ZXMgb3Igb2JqZWN0cylcXG5cXHQvLyB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIGZpbml0ZSBudW1iZXJzIChnaC0yNjYyKVxcblxcdHZhciB0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xcblxcdHJldHVybiAoIHR5cGUgPT09IFxcXCJudW1iZXJcXFwiIHx8IHR5cGUgPT09IFxcXCJzdHJpbmdcXFwiICkgJiZcXG5cXG5cXHRcXHQvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAoXFxcIlxcXCIpXFxuXFx0XFx0Ly8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXFxcIjB4Li4uXFxcIilcXG5cXHRcXHQvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cXG5cXHRcXHQhaXNOYU4oIG9iaiAtIHBhcnNlRmxvYXQoIG9iaiApICk7XFxufTtcXG5cXG5cXG5cXG5cXG4vLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcXG4vLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XFxuLy8gdW5kZXJzdGFuZHMgYW5vbnltb3VzIEFNRCBtb2R1bGVzLiBBIG5hbWVkIEFNRCBpcyBzYWZlc3QgYW5kIG1vc3Qgcm9idXN0XFxuLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxcbi8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxcbi8vIGZpbGUgbmFtZS4gRG8gdGhpcyBhZnRlciBjcmVhdGluZyB0aGUgZ2xvYmFsIHNvIHRoYXQgaWYgYW4gQU1EIG1vZHVsZSB3YW50c1xcbi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cXG5cXG4vLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxcbi8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cXG4vLyBBTUQgbG9hZGVyIGlzIHByZXNlbnQuIGpRdWVyeSBpcyBhIHNwZWNpYWwgY2FzZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cXG5cXG5pZiAoIHRydWUgKSB7XFxuXFx0IShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW10sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0cmV0dXJuIGpRdWVyeTtcXG5cXHR9LmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pLFxcblxcdFxcdFxcdFxcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcXG59XFxuXFxuXFxuXFxuXFxudmFyXFxuXFxuXFx0Ly8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXFxuXFx0X2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksXFxuXFxuXFx0Ly8gTWFwIG92ZXIgdGhlICQgaW4gY2FzZSBvZiBvdmVyd3JpdGVcXG5cXHRfJCA9IHdpbmRvdy4kO1xcblxcbmpRdWVyeS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oIGRlZXAgKSB7XFxuXFx0aWYgKCB3aW5kb3cuJCA9PT0galF1ZXJ5ICkge1xcblxcdFxcdHdpbmRvdy4kID0gXyQ7XFxuXFx0fVxcblxcblxcdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XFxuXFx0XFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XFxuXFx0fVxcblxcblxcdHJldHVybiBqUXVlcnk7XFxufTtcXG5cXG4vLyBFeHBvc2UgalF1ZXJ5IGFuZCAkIGlkZW50aWZpZXJzLCBldmVuIGluIEFNRFxcbi8vICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1NylcXG4vLyBhbmQgQ29tbW9uSlMgZm9yIGJyb3dzZXIgZW11bGF0b3JzICgjMTM1NjYpXFxuaWYgKCAhbm9HbG9iYWwgKSB7XFxuXFx0d2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0galF1ZXJ5O1xcbn1cXG5cXG5cXG5cXG5cXG5yZXR1cm4galF1ZXJ5O1xcbn0gKTtcXG5cXG5cXG4vLy8vLy8vLy8vLy8vLy8vLy9cXG4vLyBXRUJQQUNLIEZPT1RFUlxcbi8vIC4vfi9qcXVlcnkvZGlzdC9qcXVlcnkuanNcXG4vLyBtb2R1bGUgaWQgPSAxXFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9+L2pxdWVyeS9kaXN0L2pxdWVyeS5qcz9cIik7XG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJcXG5cXG4vKipcXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cXG4gKlxcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cXG4gKlxcbiAqIFxcbiAqL1xcblxcbmZ1bmN0aW9uIG1ha2VFbXB0eUZ1bmN0aW9uKGFyZykge1xcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgcmV0dXJuIGFyZztcXG4gIH07XFxufVxcblxcbi8qKlxcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbmQgZGlzY2FyZHMgaW5wdXRzOyBpdCBoYXMgbm8gc2lkZSBlZmZlY3RzLiBUaGlzIGlzXFxuICogcHJpbWFyaWx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5IGZvciBvdmVycmlkYWJsZSBmdW5jdGlvbiBlbmRwb2ludHMgd2hpY2hcXG4gKiBhbHdheXMgbmVlZCB0byBiZSBjYWxsYWJsZSwgc2luY2UgSlMgbGFja3MgYSBudWxsLWNhbGwgaWRpb20gYWxhIENvY29hLlxcbiAqL1xcbnZhciBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9O1xcblxcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMgPSBtYWtlRW1wdHlGdW5jdGlvbjtcXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UgPSBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSk7XFxuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWUgPSBtYWtlRW1wdHlGdW5jdGlvbih0cnVlKTtcXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCA9IG1ha2VFbXB0eUZ1bmN0aW9uKG51bGwpO1xcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24gKCkge1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XFxuICByZXR1cm4gYXJnO1xcbn07XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eUZ1bmN0aW9uO1xcblxcbi8vLy8vLy8vLy8vLy8vLy8vL1xcbi8vIFdFQlBBQ0sgRk9PVEVSXFxuLy8gLi9+L2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanNcXG4vLyBtb2R1bGUgaWQgPSAyXFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanM/XCIpO1xuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKHByb2Nlc3MpIHsvKipcXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cXG4gKlxcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cXG4gKlxcbiAqL1xcblxcblxcblxcbi8qKlxcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cXG4gKlxcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXFxuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXFxuICogZXhwZWN0aW5nLlxcbiAqXFxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcXG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXFxuICovXFxuXFxudmFyIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7fTtcXG5cXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xcbiAgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHtcXG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xcbiAgICB9XFxuICB9O1xcbn1cXG5cXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcXG4gIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCk7XFxuXFxuICBpZiAoIWNvbmRpdGlvbikge1xcbiAgICB2YXIgZXJyb3I7XFxuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICsgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJyk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XFxuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcXG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XFxuICAgICAgfSkpO1xcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XFxuICAgIH1cXG5cXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxcbiAgICB0aHJvdyBlcnJvcjtcXG4gIH1cXG59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XFxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oMCkpKVxcblxcbi8vLy8vLy8vLy8vLy8vLy8vL1xcbi8vIFdFQlBBQ0sgRk9PVEVSXFxuLy8gLi9+L2ZianMvbGliL2ludmFyaWFudC5qc1xcbi8vIG1vZHVsZSBpZCA9IDNcXG4vLyBtb2R1bGUgY2h1bmtzID0gMFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL34vZmJqcy9saWIvaW52YXJpYW50LmpzP1wiKTtcblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIi8qKlxcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxcbiAqXFxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXFxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxcbiAqL1xcblxcblxcblxcbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcXG5cXG5cXG4vLy8vLy8vLy8vLy8vLy8vLy9cXG4vLyBXRUJQQUNLIEZPT1RFUlxcbi8vIC4vfi9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qc1xcbi8vIG1vZHVsZSBpZCA9IDRcXG4vLyBtb2R1bGUgY2h1bmtzID0gMFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL34vcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanM/XCIpO1xuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZXZhbChcIi8qXFxuXFx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcXG5cXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXFxuKi9cXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XFxuXFx0dmFyIGxpc3QgPSBbXTtcXG5cXG5cXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXFxuXFx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xcblxcdFxcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xcblxcdFxcdFxcdHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xcblxcdFxcdFxcdGlmKGl0ZW1bMl0pIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gXFxcIkBtZWRpYSBcXFwiICsgaXRlbVsyXSArIFxcXCJ7XFxcIiArIGNvbnRlbnQgKyBcXFwifVxcXCI7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gY29udGVudDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSkuam9pbihcXFwiXFxcIik7XFxuXFx0fTtcXG5cXG5cXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxcblxcdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcXG5cXHRcXHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXFxcInN0cmluZ1xcXCIpXFxuXFx0XFx0XFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXFxcIlxcXCJdXTtcXG5cXHRcXHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xcblxcdFxcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XFxuXFx0XFx0XFx0dmFyIGlkID0gdGhpc1tpXVswXTtcXG5cXHRcXHRcXHRpZih0eXBlb2YgaWQgPT09IFxcXCJudW1iZXJcXFwiKVxcblxcdFxcdFxcdFxcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcXG5cXHRcXHR9XFxuXFx0XFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xcblxcdFxcdFxcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcXG5cXHRcXHRcXHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXFxuXFx0XFx0XFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcXG5cXHRcXHRcXHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxcblxcdFxcdFxcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXFxuXFx0XFx0XFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFxcXCJudW1iZXJcXFwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XFxuXFx0XFx0XFx0XFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xcblxcdFxcdFxcdFxcdFxcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xcblxcdFxcdFxcdFxcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XFxuXFx0XFx0XFx0XFx0XFx0aXRlbVsyXSA9IFxcXCIoXFxcIiArIGl0ZW1bMl0gKyBcXFwiKSBhbmQgKFxcXCIgKyBtZWRpYVF1ZXJ5ICsgXFxcIilcXFwiO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRsaXN0LnB1c2goaXRlbSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9O1xcblxcdHJldHVybiBsaXN0O1xcbn07XFxuXFxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcXG5cXHR2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7XFxuXFx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xcblxcdGlmICghY3NzTWFwcGluZykge1xcblxcdFxcdHJldHVybiBjb250ZW50O1xcblxcdH1cXG5cXG5cXHRpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XFxuXFx0XFx0dmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XFxuXFx0XFx0dmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcXG5cXHRcXHRcXHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXFxuXFx0XFx0fSk7XFxuXFxuXFx0XFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxcXG4nKTtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIFtjb250ZW50XS5qb2luKCdcXFxcbicpO1xcbn1cXG5cXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXFxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xcblxcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxcblxcdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xcblxcdHZhciBkYXRhID0gJ3NvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LCcgKyBiYXNlNjQ7XFxuXFxuXFx0cmV0dXJuICcvKiMgJyArIGRhdGEgKyAnICovJztcXG59XFxuXFxuXFxuLy8vLy8vLy8vLy8vLy8vLy8vXFxuLy8gV0VCUEFDSyBGT09URVJcXG4vLyAuL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcXG4vLyBtb2R1bGUgaWQgPSA1XFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzP1wiKTtcblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihwcm9jZXNzKSB7LyoqXFxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXFxuICpcXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXFxuICpcXG4gKi9cXG5cXG5cXG5cXG52YXIgZW1wdHlGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XFxuXFxuLyoqXFxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxcbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxcbiAqL1xcblxcbnZhciB3YXJuaW5nID0gZW1wdHlGdW5jdGlvbjtcXG5cXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIHByaW50V2FybmluZyhmb3JtYXQpIHtcXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XFxuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XFxuICAgIH1cXG5cXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcXG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XFxuICAgIH0pO1xcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcXG4gICAgfVxcbiAgICB0cnkge1xcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XFxuICAgIH0gY2F0Y2ggKHgpIHt9XFxuICB9O1xcblxcbiAgd2FybmluZyA9IGZ1bmN0aW9uIHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQpIHtcXG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcXG4gICAgfVxcblxcbiAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ0ZhaWxlZCBDb21wb3NpdGUgcHJvcFR5cGU6ICcpID09PSAwKSB7XFxuICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgQ29tcG9zaXRlQ29tcG9uZW50IHByb3B0eXBlIGNoZWNrLlxcbiAgICB9XFxuXFxuICAgIGlmICghY29uZGl0aW9uKSB7XFxuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcXG4gICAgICB9XFxuXFxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcXG4gICAgfVxcbiAgfTtcXG59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSlcXG5cXG4vLy8vLy8vLy8vLy8vLy8vLy9cXG4vLyBXRUJQQUNLIEZPT1RFUlxcbi8vIC4vfi9mYmpzL2xpYi93YXJuaW5nLmpzXFxuLy8gbW9kdWxlIGlkID0gNlxcbi8vIG1vZHVsZSBjaHVua3MgPSAwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi93YXJuaW5nLmpzP1wiKTtcblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCIvKlxcblxcdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXFxuXFx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxcbiovXFxudmFyIHN0eWxlc0luRG9tID0ge30sXFxuXFx0bWVtb2l6ZSA9IGZ1bmN0aW9uKGZuKSB7XFxuXFx0XFx0dmFyIG1lbW87XFxuXFx0XFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRpZiAodHlwZW9mIG1lbW8gPT09IFxcXCJ1bmRlZmluZWRcXFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG5cXHRcXHRcXHRyZXR1cm4gbWVtbztcXG5cXHRcXHR9O1xcblxcdH0sXFxuXFx0aXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24oKSB7XFxuXFx0XFx0Ly8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3NcXG5cXHRcXHQvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XFxuXFx0XFx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlciBcXG5cXHRcXHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcXG5cXHRcXHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcXG5cXHRcXHRyZXR1cm4gd2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2I7XFxuXFx0fSksXFxuXFx0Z2V0RWxlbWVudCA9IChmdW5jdGlvbihmbikge1xcblxcdFxcdHZhciBtZW1vID0ge307XFxuXFx0XFx0cmV0dXJuIGZ1bmN0aW9uKHNlbGVjdG9yKSB7XFxuXFx0XFx0XFx0aWYgKHR5cGVvZiBtZW1vW3NlbGVjdG9yXSA9PT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG5cXHRcXHRcXHRcXHRtZW1vW3NlbGVjdG9yXSA9IGZuLmNhbGwodGhpcywgc2VsZWN0b3IpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gbWVtb1tzZWxlY3Rvcl1cXG5cXHRcXHR9O1xcblxcdH0pKGZ1bmN0aW9uIChzdHlsZVRhcmdldCkge1xcblxcdFxcdHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHN0eWxlVGFyZ2V0KVxcblxcdH0pLFxcblxcdHNpbmdsZXRvbkVsZW1lbnQgPSBudWxsLFxcblxcdHNpbmdsZXRvbkNvdW50ZXIgPSAwLFxcblxcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wID0gW10sXFxuXFx0Zml4VXJscyA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xcblxcdGlmKHR5cGVvZiBERUJVRyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgJiYgREVCVUcpIHtcXG5cXHRcXHRpZih0eXBlb2YgZG9jdW1lbnQgIT09IFxcXCJvYmplY3RcXFwiKSB0aHJvdyBuZXcgRXJyb3IoXFxcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFxcXCIpO1xcblxcdH1cXG5cXG5cXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG5cXHRvcHRpb25zLmF0dHJzID0gdHlwZW9mIG9wdGlvbnMuYXR0cnMgPT09IFxcXCJvYmplY3RcXFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xcblxcblxcdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxcblxcdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcXG5cXHRpZiAodHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uID09PSBcXFwidW5kZWZpbmVkXFxcIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XFxuXFxuXFx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgPGhlYWQ+IGVsZW1lbnRcXG5cXHRpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0SW50byA9PT0gXFxcInVuZGVmaW5lZFxcXCIpIG9wdGlvbnMuaW5zZXJ0SW50byA9IFxcXCJoZWFkXFxcIjtcXG5cXG5cXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxcblxcdGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXFxcInVuZGVmaW5lZFxcXCIpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcXFwiYm90dG9tXFxcIjtcXG5cXG5cXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QsIG9wdGlvbnMpO1xcblxcdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XFxuXFxuXFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XFxuXFx0XFx0dmFyIG1heVJlbW92ZSA9IFtdO1xcblxcdFxcdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcXG5cXHRcXHRcXHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcXG5cXHRcXHRcXHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcXG5cXHRcXHRcXHRkb21TdHlsZS5yZWZzLS07XFxuXFx0XFx0XFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xcblxcdFxcdH1cXG5cXHRcXHRpZihuZXdMaXN0KSB7XFxuXFx0XFx0XFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0LCBvcHRpb25zKTtcXG5cXHRcXHRcXHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xcblxcdFxcdH1cXG5cXHRcXHRmb3IodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XFxuXFx0XFx0XFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xcblxcdFxcdFxcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcXG5cXHRcXHRcXHRcXHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspXFxuXFx0XFx0XFx0XFx0XFx0ZG9tU3R5bGUucGFydHNbal0oKTtcXG5cXHRcXHRcXHRcXHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fTtcXG59O1xcblxcbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucykge1xcblxcdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcXG5cXHRcXHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcXG5cXHRcXHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcXG5cXHRcXHRpZihkb21TdHlsZSkge1xcblxcdFxcdFxcdGRvbVN0eWxlLnJlZnMrKztcXG5cXHRcXHRcXHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcXG5cXHRcXHRcXHRcXHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcXG5cXHRcXHRcXHRcXHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHR2YXIgcGFydHMgPSBbXTtcXG5cXHRcXHRcXHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xcblxcdFxcdFxcdFxcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcXG5cXHRcXHR9XFxuXFx0fVxcbn1cXG5cXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucykge1xcblxcdHZhciBzdHlsZXMgPSBbXTtcXG5cXHR2YXIgbmV3U3R5bGVzID0ge307XFxuXFx0Zm9yKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcXG5cXHRcXHR2YXIgaXRlbSA9IGxpc3RbaV07XFxuXFx0XFx0dmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XFxuXFx0XFx0dmFyIGNzcyA9IGl0ZW1bMV07XFxuXFx0XFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcXG5cXHRcXHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcXG5cXHRcXHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XFxuXFx0XFx0aWYoIW5ld1N0eWxlc1tpZF0pXFxuXFx0XFx0XFx0c3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcXG5cXHRcXHRlbHNlXFxuXFx0XFx0XFx0bmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xcblxcdH1cXG5cXHRyZXR1cm4gc3R5bGVzO1xcbn1cXG5cXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGVFbGVtZW50KSB7XFxuXFx0dmFyIHN0eWxlVGFyZ2V0ID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8pXFxuXFx0aWYgKCFzdHlsZVRhcmdldCkge1xcblxcdFxcdHRocm93IG5ldyBFcnJvcihcXFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cXFwiKTtcXG5cXHR9XFxuXFx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3Bbc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XFxuXFx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFxcXCJ0b3BcXFwiKSB7XFxuXFx0XFx0aWYoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XFxuXFx0XFx0XFx0c3R5bGVUYXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgc3R5bGVUYXJnZXQuZmlyc3RDaGlsZCk7XFxuXFx0XFx0fSBlbHNlIGlmKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XFxuXFx0XFx0XFx0c3R5bGVUYXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0c3R5bGVUYXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcXG5cXHRcXHR9XFxuXFx0XFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AucHVzaChzdHlsZUVsZW1lbnQpO1xcblxcdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXFxcImJvdHRvbVxcXCIpIHtcXG5cXHRcXHRzdHlsZVRhcmdldC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xcblxcdH0gZWxzZSB7XFxuXFx0XFx0dGhyb3cgbmV3IEVycm9yKFxcXCJJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0Jy4gTXVzdCBiZSAndG9wJyBvciAnYm90dG9tJy5cXFwiKTtcXG5cXHR9XFxufVxcblxcbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcXG5cXHRzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xcblxcdHZhciBpZHggPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlRWxlbWVudCk7XFxuXFx0aWYoaWR4ID49IDApIHtcXG5cXHRcXHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcXG5cXHR9XFxufVxcblxcbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSB7XFxuXFx0dmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcInN0eWxlXFxcIik7XFxuXFx0b3B0aW9ucy5hdHRycy50eXBlID0gXFxcInRleHQvY3NzXFxcIjtcXG5cXG5cXHRhdHRhY2hUYWdBdHRycyhzdHlsZUVsZW1lbnQsIG9wdGlvbnMuYXR0cnMpO1xcblxcdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpO1xcblxcdHJldHVybiBzdHlsZUVsZW1lbnQ7XFxufVxcblxcbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpIHtcXG5cXHR2YXIgbGlua0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJsaW5rXFxcIik7XFxuXFx0b3B0aW9ucy5hdHRycy50eXBlID0gXFxcInRleHQvY3NzXFxcIjtcXG5cXHRvcHRpb25zLmF0dHJzLnJlbCA9IFxcXCJzdHlsZXNoZWV0XFxcIjtcXG5cXG5cXHRhdHRhY2hUYWdBdHRycyhsaW5rRWxlbWVudCwgb3B0aW9ucy5hdHRycyk7XFxuXFx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmtFbGVtZW50KTtcXG5cXHRyZXR1cm4gbGlua0VsZW1lbnQ7XFxufVxcblxcbmZ1bmN0aW9uIGF0dGFjaFRhZ0F0dHJzKGVsZW1lbnQsIGF0dHJzKSB7XFxuXFx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xcblxcdFxcdGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XFxuXFx0fSk7XFxufVxcblxcbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xcblxcdHZhciBzdHlsZUVsZW1lbnQsIHVwZGF0ZSwgcmVtb3ZlLCB0cmFuc2Zvcm1SZXN1bHQ7XFxuXFxuXFx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXFxuXFx0aWYgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9iai5jc3MpIHtcXG5cXHQgICAgdHJhbnNmb3JtUmVzdWx0ID0gb3B0aW9ucy50cmFuc2Zvcm0ob2JqLmNzcyk7XFxuXFx0ICAgIFxcblxcdCAgICBpZiAodHJhbnNmb3JtUmVzdWx0KSB7XFxuXFx0ICAgIFxcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cXG5cXHQgICAgXFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxcblxcdCAgICBcXHRvYmouY3NzID0gdHJhbnNmb3JtUmVzdWx0O1xcblxcdCAgICB9IGVsc2Uge1xcblxcdCAgICBcXHQvLyBJZiB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uIHJldHVybnMgYSBmYWxzeSB2YWx1ZSwgZG9uJ3QgYWRkIHRoaXMgY3NzLiBcXG5cXHQgICAgXFx0Ly8gVGhpcyBhbGxvd3MgY29uZGl0aW9uYWwgbG9hZGluZyBvZiBjc3NcXG5cXHQgICAgXFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xcblxcdCAgICBcXHRcXHQvLyBub29wXFxuXFx0ICAgIFxcdH07XFxuXFx0ICAgIH1cXG5cXHR9XFxuXFxuXFx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XFxuXFx0XFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XFxuXFx0XFx0c3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XFxuXFx0XFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpO1xcblxcdFxcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpO1xcblxcdH0gZWxzZSBpZihvYmouc291cmNlTWFwICYmXFxuXFx0XFx0dHlwZW9mIFVSTCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJlxcblxcdFxcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcXFwiZnVuY3Rpb25cXFwiICYmXFxuXFx0XFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFxcXCJmdW5jdGlvblxcXCIgJiZcXG5cXHRcXHR0eXBlb2YgQmxvYiA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJlxcblxcdFxcdHR5cGVvZiBidG9hID09PSBcXFwiZnVuY3Rpb25cXFwiKSB7XFxuXFx0XFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XFxuXFx0XFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgb3B0aW9ucyk7XFxuXFx0XFx0cmVtb3ZlID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XFxuXFx0XFx0XFx0aWYoc3R5bGVFbGVtZW50LmhyZWYpXFxuXFx0XFx0XFx0XFx0VVJMLnJldm9rZU9iamVjdFVSTChzdHlsZUVsZW1lbnQuaHJlZik7XFxuXFx0XFx0fTtcXG5cXHR9IGVsc2Uge1xcblxcdFxcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcXG5cXHRcXHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KTtcXG5cXHRcXHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcXG5cXHRcXHR9O1xcblxcdH1cXG5cXG5cXHR1cGRhdGUob2JqKTtcXG5cXG5cXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XFxuXFx0XFx0aWYobmV3T2JqKSB7XFxuXFx0XFx0XFx0aWYobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKVxcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR1cGRhdGUob2JqID0gbmV3T2JqKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHJlbW92ZSgpO1xcblxcdFxcdH1cXG5cXHR9O1xcbn1cXG5cXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xcblxcdHZhciB0ZXh0U3RvcmUgPSBbXTtcXG5cXG5cXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xcblxcdFxcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcXG5cXHRcXHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXFxcbicpO1xcblxcdH07XFxufSkoKTtcXG5cXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XFxuXFx0dmFyIGNzcyA9IHJlbW92ZSA/IFxcXCJcXFwiIDogb2JqLmNzcztcXG5cXG5cXHRpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcXG5cXHRcXHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XFxuXFx0fSBlbHNlIHtcXG5cXHRcXHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XFxuXFx0XFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZUVsZW1lbnQuY2hpbGROb2RlcztcXG5cXHRcXHRpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XFxuXFx0XFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XFxuXFx0XFx0XFx0c3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XFxuXFx0XFx0fVxcblxcdH1cXG59XFxuXFxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZUVsZW1lbnQsIG9iaikge1xcblxcdHZhciBjc3MgPSBvYmouY3NzO1xcblxcdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcXG5cXG5cXHRpZihtZWRpYSkge1xcblxcdFxcdHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXFxcIm1lZGlhXFxcIiwgbWVkaWEpXFxuXFx0fVxcblxcblxcdGlmKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XFxuXFx0XFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcXG5cXHR9IGVsc2Uge1xcblxcdFxcdHdoaWxlKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XFxuXFx0XFx0XFx0c3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcXG5cXHRcXHR9XFxuXFx0XFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xcblxcdH1cXG59XFxuXFxuZnVuY3Rpb24gdXBkYXRlTGluayhsaW5rRWxlbWVudCwgb3B0aW9ucywgb2JqKSB7XFxuXFx0dmFyIGNzcyA9IG9iai5jc3M7XFxuXFx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XFxuXFxuXFx0LyogSWYgY29udmVydFRvQWJzb2x1dGVVcmxzIGlzbid0IGRlZmluZWQsIGJ1dCBzb3VyY2VtYXBzIGFyZSBlbmFibGVkXFxuXFx0YW5kIHRoZXJlIGlzIG5vIHB1YmxpY1BhdGggZGVmaW5lZCB0aGVuIGxldHMgdHVybiBjb252ZXJ0VG9BYnNvbHV0ZVVybHNcXG5cXHRvbiBieSBkZWZhdWx0LiAgT3RoZXJ3aXNlIGRlZmF1bHQgdG8gdGhlIGNvbnZlcnRUb0Fic29sdXRlVXJscyBvcHRpb25cXG5cXHRkaXJlY3RseVxcblxcdCovXFxuXFx0dmFyIGF1dG9GaXhVcmxzID0gb3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgPT09IHVuZGVmaW5lZCAmJiBzb3VyY2VNYXA7XFxuXFxuXFx0aWYgKG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzIHx8IGF1dG9GaXhVcmxzKXtcXG5cXHRcXHRjc3MgPSBmaXhVcmxzKGNzcyk7XFxuXFx0fVxcblxcblxcdGlmKHNvdXJjZU1hcCkge1xcblxcdFxcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XFxuXFx0XFx0Y3NzICs9IFxcXCJcXFxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXFxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcXFwiICovXFxcIjtcXG5cXHR9XFxuXFxuXFx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcXFwidGV4dC9jc3NcXFwiIH0pO1xcblxcblxcdHZhciBvbGRTcmMgPSBsaW5rRWxlbWVudC5ocmVmO1xcblxcblxcdGxpbmtFbGVtZW50LmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xcblxcblxcdGlmKG9sZFNyYylcXG5cXHRcXHRVUkwucmV2b2tlT2JqZWN0VVJMKG9sZFNyYyk7XFxufVxcblxcblxcbi8vLy8vLy8vLy8vLy8vLy8vL1xcbi8vIFdFQlBBQ0sgRk9PVEVSXFxuLy8gLi9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcXG4vLyBtb2R1bGUgaWQgPSA3XFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanM/XCIpO1xuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcIi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihfX3dlYnBhY2tfcHJvdmlkZWRfd2luZG93X2RvdF9qUXVlcnksIGpRdWVyeSkgey8qKlxcbiAqIE93bCBDYXJvdXNlbCB2Mi4yLjBcXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE2IERhdmlkIERldXRzY2hcXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS9Pd2xDYXJvdXNlbDIvT3dsQ2Fyb3VzZWwyL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXFxuICovXFxuLyoqXFxuICogT3dsIGNhcm91c2VsXFxuICogQHZlcnNpb24gMi4xLjZcXG4gKiBAYXV0aG9yIEJhcnRvc3ogV29qY2llY2hvd3NraVxcbiAqIEBhdXRob3IgRGF2aWQgRGV1dHNjaFxcbiAqIEBsaWNlbnNlIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxcbiAqIEB0b2RvIExhenkgTG9hZCBJY29uXFxuICogQHRvZG8gcHJldmVudCBhbmltYXRpb25lbmQgYnVibGluZ1xcbiAqIEB0b2RvIGl0ZW1zU2NhbGVVcFxcbiAqIEB0b2RvIFRlc3QgWmVwdG9cXG4gKiBAdG9kbyBzdGFnZVBhZGRpbmcgY2FsY3VsYXRlIHdyb25nIGFjdGl2ZSBjbGFzc2VzXFxuICovXFxuOyhmdW5jdGlvbigkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcXG5cXG5cXHQvKipcXG5cXHQgKiBDcmVhdGVzIGEgY2Fyb3VzZWwuXFxuXFx0ICogQGNsYXNzIFRoZSBPd2wgQ2Fyb3VzZWwuXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8alF1ZXJ5fSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgdG8gY3JlYXRlIHRoZSBjYXJvdXNlbCBmb3IuXFxuXFx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zXFxuXFx0ICovXFxuXFx0ZnVuY3Rpb24gT3dsKGVsZW1lbnQsIG9wdGlvbnMpIHtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBDdXJyZW50IHNldHRpbmdzIGZvciB0aGUgY2Fyb3VzZWwuXFxuXFx0XFx0ICogQHB1YmxpY1xcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuc2V0dGluZ3MgPSBudWxsO1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIEN1cnJlbnQgb3B0aW9ucyBzZXQgYnkgdGhlIGNhbGxlciBpbmNsdWRpbmcgZGVmYXVsdHMuXFxuXFx0XFx0ICogQHB1YmxpY1xcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBPd2wuRGVmYXVsdHMsIG9wdGlvbnMpO1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIFBsdWdpbiBlbGVtZW50LlxcblxcdFxcdCAqIEBwdWJsaWNcXG5cXHRcXHQgKi9cXG5cXHRcXHR0aGlzLiRlbGVtZW50ID0gJChlbGVtZW50KTtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBQcm94aWVkIGV2ZW50IGhhbmRsZXJzLlxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKi9cXG5cXHRcXHR0aGlzLl9oYW5kbGVycyA9IHt9O1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIFJlZmVyZW5jZXMgdG8gdGhlIHJ1bm5pbmcgcGx1Z2lucyBvZiB0aGlzIGNhcm91c2VsLlxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKi9cXG5cXHRcXHR0aGlzLl9wbHVnaW5zID0ge307XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogQ3VycmVudGx5IHN1cHByZXNzZWQgZXZlbnRzIHRvIHByZXZlbnQgdGhlbSBmcm9tIGJlZWluZyByZXRyaWdnZXJlZC5cXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5fc3VwcmVzcyA9IHt9O1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIEFic29sdXRlIGN1cnJlbnQgcG9zaXRpb24uXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX2N1cnJlbnQgPSBudWxsO1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIEFuaW1hdGlvbiBzcGVlZCBpbiBtaWxsaXNlY29uZHMuXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX3NwZWVkID0gbnVsbDtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBDb29yZGluYXRlcyBvZiBhbGwgaXRlbXMgaW4gcGl4ZWwuXFxuXFx0XFx0ICogQHRvZG8gVGhlIG5hbWUgb2YgdGhpcyBtZW1iZXIgaXMgbWlzc2xlYWRpbmcuXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX2Nvb3JkaW5hdGVzID0gW107XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogQ3VycmVudCBicmVha3BvaW50LlxcblxcdFxcdCAqIEB0b2RvIFJlYWwgbWVkaWEgcXVlcmllcyB3b3VsZCBiZSBuaWNlLlxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKi9cXG5cXHRcXHR0aGlzLl9icmVha3BvaW50ID0gbnVsbDtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBDdXJyZW50IHdpZHRoIG9mIHRoZSBwbHVnaW4gZWxlbWVudC5cXG5cXHRcXHQgKi9cXG5cXHRcXHR0aGlzLl93aWR0aCA9IG51bGw7XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogQWxsIHJlYWwgaXRlbXMuXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX2l0ZW1zID0gW107XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogQWxsIGNsb25lZCBpdGVtcy5cXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5fY2xvbmVzID0gW107XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogTWVyZ2UgdmFsdWVzIG9mIGFsbCBpdGVtcy5cXG5cXHRcXHQgKiBAdG9kbyBNYXliZSB0aGlzIGNvdWxkIGJlIHBhcnQgb2YgYSBwbHVnaW4uXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX21lcmdlcnMgPSBbXTtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBXaWR0aHMgb2YgYWxsIGl0ZW1zLlxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX3dpZHRocyA9IFtdO1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIEludmFsaWRhdGVkIHBhcnRzIHdpdGhpbiB0aGUgdXBkYXRlIHByb2Nlc3MuXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX2ludmFsaWRhdGVkID0ge307XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogT3JkZXJlZCBsaXN0IG9mIHdvcmtlcnMgZm9yIHRoZSB1cGRhdGUgcHJvY2Vzcy5cXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5fcGlwZSA9IFtdO1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIEN1cnJlbnQgc3RhdGUgaW5mb3JtYXRpb24gZm9yIHRoZSBkcmFnIG9wZXJhdGlvbi5cXG5cXHRcXHQgKiBAdG9kbyAjMjYxXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX2RyYWcgPSB7XFxuXFx0XFx0XFx0dGltZTogbnVsbCxcXG5cXHRcXHRcXHR0YXJnZXQ6IG51bGwsXFxuXFx0XFx0XFx0cG9pbnRlcjogbnVsbCxcXG5cXHRcXHRcXHRzdGFnZToge1xcblxcdFxcdFxcdFxcdHN0YXJ0OiBudWxsLFxcblxcdFxcdFxcdFxcdGN1cnJlbnQ6IG51bGxcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdGRpcmVjdGlvbjogbnVsbFxcblxcdFxcdH07XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogQ3VycmVudCBzdGF0ZSBpbmZvcm1hdGlvbiBhbmQgdGhlaXIgdGFncy5cXG5cXHRcXHQgKiBAdHlwZSB7T2JqZWN0fVxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKi9cXG5cXHRcXHR0aGlzLl9zdGF0ZXMgPSB7XFxuXFx0XFx0XFx0Y3VycmVudDoge30sXFxuXFx0XFx0XFx0dGFnczoge1xcblxcdFxcdFxcdFxcdCdpbml0aWFsaXppbmcnOiBbICdidXN5JyBdLFxcblxcdFxcdFxcdFxcdCdhbmltYXRpbmcnOiBbICdidXN5JyBdLFxcblxcdFxcdFxcdFxcdCdkcmFnZ2luZyc6IFsgJ2ludGVyYWN0aW5nJyBdXFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFxuXFx0XFx0JC5lYWNoKFsgJ29uUmVzaXplJywgJ29uVGhyb3R0bGVkUmVzaXplJyBdLCAkLnByb3h5KGZ1bmN0aW9uKGksIGhhbmRsZXIpIHtcXG5cXHRcXHRcXHR0aGlzLl9oYW5kbGVyc1toYW5kbGVyXSA9ICQucHJveHkodGhpc1toYW5kbGVyXSwgdGhpcyk7XFxuXFx0XFx0fSwgdGhpcykpO1xcblxcblxcdFxcdCQuZWFjaChPd2wuUGx1Z2lucywgJC5wcm94eShmdW5jdGlvbihrZXksIHBsdWdpbikge1xcblxcdFxcdFxcdHRoaXMuX3BsdWdpbnNba2V5LmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsga2V5LnNsaWNlKDEpXVxcblxcdFxcdFxcdFxcdD0gbmV3IHBsdWdpbih0aGlzKTtcXG5cXHRcXHR9LCB0aGlzKSk7XFxuXFxuXFx0XFx0JC5lYWNoKE93bC5Xb3JrZXJzLCAkLnByb3h5KGZ1bmN0aW9uKHByaW9yaXR5LCB3b3JrZXIpIHtcXG5cXHRcXHRcXHR0aGlzLl9waXBlLnB1c2goe1xcblxcdFxcdFxcdFxcdCdmaWx0ZXInOiB3b3JrZXIuZmlsdGVyLFxcblxcdFxcdFxcdFxcdCdydW4nOiAkLnByb3h5KHdvcmtlci5ydW4sIHRoaXMpXFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fSwgdGhpcykpO1xcblxcblxcdFxcdHRoaXMuc2V0dXAoKTtcXG5cXHRcXHR0aGlzLmluaXRpYWxpemUoKTtcXG5cXHR9XFxuXFxuXFx0LyoqXFxuXFx0ICogRGVmYXVsdCBvcHRpb25zIGZvciB0aGUgY2Fyb3VzZWwuXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqL1xcblxcdE93bC5EZWZhdWx0cyA9IHtcXG5cXHRcXHRpdGVtczogMyxcXG5cXHRcXHRsb29wOiBmYWxzZSxcXG5cXHRcXHRjZW50ZXI6IGZhbHNlLFxcblxcdFxcdHJld2luZDogZmFsc2UsXFxuXFxuXFx0XFx0bW91c2VEcmFnOiB0cnVlLFxcblxcdFxcdHRvdWNoRHJhZzogdHJ1ZSxcXG5cXHRcXHRwdWxsRHJhZzogdHJ1ZSxcXG5cXHRcXHRmcmVlRHJhZzogZmFsc2UsXFxuXFxuXFx0XFx0bWFyZ2luOiAwLFxcblxcdFxcdHN0YWdlUGFkZGluZzogMCxcXG5cXG5cXHRcXHRtZXJnZTogZmFsc2UsXFxuXFx0XFx0bWVyZ2VGaXQ6IHRydWUsXFxuXFx0XFx0YXV0b1dpZHRoOiBmYWxzZSxcXG5cXG5cXHRcXHRzdGFydFBvc2l0aW9uOiAwLFxcblxcdFxcdHJ0bDogZmFsc2UsXFxuXFxuXFx0XFx0c21hcnRTcGVlZDogMjUwLFxcblxcdFxcdGZsdWlkU3BlZWQ6IGZhbHNlLFxcblxcdFxcdGRyYWdFbmRTcGVlZDogZmFsc2UsXFxuXFxuXFx0XFx0cmVzcG9uc2l2ZToge30sXFxuXFx0XFx0cmVzcG9uc2l2ZVJlZnJlc2hSYXRlOiAyMDAsXFxuXFx0XFx0cmVzcG9uc2l2ZUJhc2VFbGVtZW50OiB3aW5kb3csXFxuXFxuXFx0XFx0ZmFsbGJhY2tFYXNpbmc6ICdzd2luZycsXFxuXFxuXFx0XFx0aW5mbzogZmFsc2UsXFxuXFxuXFx0XFx0bmVzdGVkSXRlbVNlbGVjdG9yOiBmYWxzZSxcXG5cXHRcXHRpdGVtRWxlbWVudDogJ2RpdicsXFxuXFx0XFx0c3RhZ2VFbGVtZW50OiAnZGl2JyxcXG5cXG5cXHRcXHRyZWZyZXNoQ2xhc3M6ICdvd2wtcmVmcmVzaCcsXFxuXFx0XFx0bG9hZGVkQ2xhc3M6ICdvd2wtbG9hZGVkJyxcXG5cXHRcXHRsb2FkaW5nQ2xhc3M6ICdvd2wtbG9hZGluZycsXFxuXFx0XFx0cnRsQ2xhc3M6ICdvd2wtcnRsJyxcXG5cXHRcXHRyZXNwb25zaXZlQ2xhc3M6ICdvd2wtcmVzcG9uc2l2ZScsXFxuXFx0XFx0ZHJhZ0NsYXNzOiAnb3dsLWRyYWcnLFxcblxcdFxcdGl0ZW1DbGFzczogJ293bC1pdGVtJyxcXG5cXHRcXHRzdGFnZUNsYXNzOiAnb3dsLXN0YWdlJyxcXG5cXHRcXHRzdGFnZU91dGVyQ2xhc3M6ICdvd2wtc3RhZ2Utb3V0ZXInLFxcblxcdFxcdGdyYWJDbGFzczogJ293bC1ncmFiJ1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogRW51bWVyYXRpb24gZm9yIHdpZHRoLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKiBAcmVhZG9ubHlcXG5cXHQgKiBAZW51bSB7U3RyaW5nfVxcblxcdCAqL1xcblxcdE93bC5XaWR0aCA9IHtcXG5cXHRcXHREZWZhdWx0OiAnZGVmYXVsdCcsXFxuXFx0XFx0SW5uZXI6ICdpbm5lcicsXFxuXFx0XFx0T3V0ZXI6ICdvdXRlcidcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEVudW1lcmF0aW9uIGZvciB0eXBlcy5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICogQHJlYWRvbmx5XFxuXFx0ICogQGVudW0ge1N0cmluZ31cXG5cXHQgKi9cXG5cXHRPd2wuVHlwZSA9IHtcXG5cXHRcXHRFdmVudDogJ2V2ZW50JyxcXG5cXHRcXHRTdGF0ZTogJ3N0YXRlJ1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQ29udGFpbnMgYWxsIHJlZ2lzdGVyZWQgcGx1Z2lucy5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICovXFxuXFx0T3dsLlBsdWdpbnMgPSB7fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBMaXN0IG9mIHdvcmtlcnMgaW52b2x2ZWQgaW4gdGhlIHVwZGF0ZSBwcm9jZXNzLlxcblxcdCAqL1xcblxcdE93bC5Xb3JrZXJzID0gWyB7XFxuXFx0XFx0ZmlsdGVyOiBbICd3aWR0aCcsICdzZXR0aW5ncycgXSxcXG5cXHRcXHRydW46IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHRoaXMuX3dpZHRoID0gdGhpcy4kZWxlbWVudC53aWR0aCgpO1xcblxcdFxcdH1cXG5cXHR9LCB7XFxuXFx0XFx0ZmlsdGVyOiBbICd3aWR0aCcsICdpdGVtcycsICdzZXR0aW5ncycgXSxcXG5cXHRcXHRydW46IGZ1bmN0aW9uKGNhY2hlKSB7XFxuXFx0XFx0XFx0Y2FjaGUuY3VycmVudCA9IHRoaXMuX2l0ZW1zICYmIHRoaXMuX2l0ZW1zW3RoaXMucmVsYXRpdmUodGhpcy5fY3VycmVudCldO1xcblxcdFxcdH1cXG5cXHR9LCB7XFxuXFx0XFx0ZmlsdGVyOiBbICdpdGVtcycsICdzZXR0aW5ncycgXSxcXG5cXHRcXHRydW46IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHRoaXMuJHN0YWdlLmNoaWxkcmVuKCcuY2xvbmVkJykucmVtb3ZlKCk7XFxuXFx0XFx0fVxcblxcdH0sIHtcXG5cXHRcXHRmaWx0ZXI6IFsgJ3dpZHRoJywgJ2l0ZW1zJywgJ3NldHRpbmdzJyBdLFxcblxcdFxcdHJ1bjogZnVuY3Rpb24oY2FjaGUpIHtcXG5cXHRcXHRcXHR2YXIgbWFyZ2luID0gdGhpcy5zZXR0aW5ncy5tYXJnaW4gfHwgJycsXFxuXFx0XFx0XFx0XFx0Z3JpZCA9ICF0aGlzLnNldHRpbmdzLmF1dG9XaWR0aCxcXG5cXHRcXHRcXHRcXHRydGwgPSB0aGlzLnNldHRpbmdzLnJ0bCxcXG5cXHRcXHRcXHRcXHRjc3MgPSB7XFxuXFx0XFx0XFx0XFx0XFx0J3dpZHRoJzogJ2F1dG8nLFxcblxcdFxcdFxcdFxcdFxcdCdtYXJnaW4tbGVmdCc6IHJ0bCA/IG1hcmdpbiA6ICcnLFxcblxcdFxcdFxcdFxcdFxcdCdtYXJnaW4tcmlnaHQnOiBydGwgPyAnJyA6IG1hcmdpblxcblxcdFxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0IWdyaWQgJiYgdGhpcy4kc3RhZ2UuY2hpbGRyZW4oKS5jc3MoY3NzKTtcXG5cXG5cXHRcXHRcXHRjYWNoZS5jc3MgPSBjc3M7XFxuXFx0XFx0fVxcblxcdH0sIHtcXG5cXHRcXHRmaWx0ZXI6IFsgJ3dpZHRoJywgJ2l0ZW1zJywgJ3NldHRpbmdzJyBdLFxcblxcdFxcdHJ1bjogZnVuY3Rpb24oY2FjaGUpIHtcXG5cXHRcXHRcXHR2YXIgd2lkdGggPSAodGhpcy53aWR0aCgpIC8gdGhpcy5zZXR0aW5ncy5pdGVtcykudG9GaXhlZCgzKSAtIHRoaXMuc2V0dGluZ3MubWFyZ2luLFxcblxcdFxcdFxcdFxcdG1lcmdlID0gbnVsbCxcXG5cXHRcXHRcXHRcXHRpdGVyYXRvciA9IHRoaXMuX2l0ZW1zLmxlbmd0aCxcXG5cXHRcXHRcXHRcXHRncmlkID0gIXRoaXMuc2V0dGluZ3MuYXV0b1dpZHRoLFxcblxcdFxcdFxcdFxcdHdpZHRocyA9IFtdO1xcblxcblxcdFxcdFxcdGNhY2hlLml0ZW1zID0ge1xcblxcdFxcdFxcdFxcdG1lcmdlOiBmYWxzZSxcXG5cXHRcXHRcXHRcXHR3aWR0aDogd2lkdGhcXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdHdoaWxlIChpdGVyYXRvci0tKSB7XFxuXFx0XFx0XFx0XFx0bWVyZ2UgPSB0aGlzLl9tZXJnZXJzW2l0ZXJhdG9yXTtcXG5cXHRcXHRcXHRcXHRtZXJnZSA9IHRoaXMuc2V0dGluZ3MubWVyZ2VGaXQgJiYgTWF0aC5taW4obWVyZ2UsIHRoaXMuc2V0dGluZ3MuaXRlbXMpIHx8IG1lcmdlO1xcblxcblxcdFxcdFxcdFxcdGNhY2hlLml0ZW1zLm1lcmdlID0gbWVyZ2UgPiAxIHx8IGNhY2hlLml0ZW1zLm1lcmdlO1xcblxcblxcdFxcdFxcdFxcdHdpZHRoc1tpdGVyYXRvcl0gPSAhZ3JpZCA/IHRoaXMuX2l0ZW1zW2l0ZXJhdG9yXS53aWR0aCgpIDogd2lkdGggKiBtZXJnZTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5fd2lkdGhzID0gd2lkdGhzO1xcblxcdFxcdH1cXG5cXHR9LCB7XFxuXFx0XFx0ZmlsdGVyOiBbICdpdGVtcycsICdzZXR0aW5ncycgXSxcXG5cXHRcXHRydW46IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHZhciBjbG9uZXMgPSBbXSxcXG5cXHRcXHRcXHRcXHRpdGVtcyA9IHRoaXMuX2l0ZW1zLFxcblxcdFxcdFxcdFxcdHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncyxcXG5cXHRcXHRcXHRcXHR2aWV3ID0gTWF0aC5tYXgoc2V0dGluZ3MuaXRlbXMgKiAyLCA0KSxcXG5cXHRcXHRcXHRcXHRzaXplID0gTWF0aC5jZWlsKGl0ZW1zLmxlbmd0aCAvIDIpICogMixcXG5cXHRcXHRcXHRcXHRyZXBlYXQgPSBzZXR0aW5ncy5sb29wICYmIGl0ZW1zLmxlbmd0aCA/IHNldHRpbmdzLnJld2luZCA/IHZpZXcgOiBNYXRoLm1heCh2aWV3LCBzaXplKSA6IDAsXFxuXFx0XFx0XFx0XFx0YXBwZW5kID0gJycsXFxuXFx0XFx0XFx0XFx0cHJlcGVuZCA9ICcnO1xcblxcblxcdFxcdFxcdHJlcGVhdCAvPSAyO1xcblxcblxcdFxcdFxcdHdoaWxlIChyZXBlYXQtLSkge1xcblxcdFxcdFxcdFxcdGNsb25lcy5wdXNoKHRoaXMubm9ybWFsaXplKGNsb25lcy5sZW5ndGggLyAyLCB0cnVlKSk7XFxuXFx0XFx0XFx0XFx0YXBwZW5kID0gYXBwZW5kICsgaXRlbXNbY2xvbmVzW2Nsb25lcy5sZW5ndGggLSAxXV1bMF0ub3V0ZXJIVE1MO1xcblxcdFxcdFxcdFxcdGNsb25lcy5wdXNoKHRoaXMubm9ybWFsaXplKGl0ZW1zLmxlbmd0aCAtIDEgLSAoY2xvbmVzLmxlbmd0aCAtIDEpIC8gMiwgdHJ1ZSkpO1xcblxcdFxcdFxcdFxcdHByZXBlbmQgPSBpdGVtc1tjbG9uZXNbY2xvbmVzLmxlbmd0aCAtIDFdXVswXS5vdXRlckhUTUwgKyBwcmVwZW5kO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLl9jbG9uZXMgPSBjbG9uZXM7XFxuXFxuXFx0XFx0XFx0JChhcHBlbmQpLmFkZENsYXNzKCdjbG9uZWQnKS5hcHBlbmRUbyh0aGlzLiRzdGFnZSk7XFxuXFx0XFx0XFx0JChwcmVwZW5kKS5hZGRDbGFzcygnY2xvbmVkJykucHJlcGVuZFRvKHRoaXMuJHN0YWdlKTtcXG5cXHRcXHR9XFxuXFx0fSwge1xcblxcdFxcdGZpbHRlcjogWyAnd2lkdGgnLCAnaXRlbXMnLCAnc2V0dGluZ3MnIF0sXFxuXFx0XFx0cnVuOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHR2YXIgcnRsID0gdGhpcy5zZXR0aW5ncy5ydGwgPyAxIDogLTEsXFxuXFx0XFx0XFx0XFx0c2l6ZSA9IHRoaXMuX2Nsb25lcy5sZW5ndGggKyB0aGlzLl9pdGVtcy5sZW5ndGgsXFxuXFx0XFx0XFx0XFx0aXRlcmF0b3IgPSAtMSxcXG5cXHRcXHRcXHRcXHRwcmV2aW91cyA9IDAsXFxuXFx0XFx0XFx0XFx0Y3VycmVudCA9IDAsXFxuXFx0XFx0XFx0XFx0Y29vcmRpbmF0ZXMgPSBbXTtcXG5cXG5cXHRcXHRcXHR3aGlsZSAoKytpdGVyYXRvciA8IHNpemUpIHtcXG5cXHRcXHRcXHRcXHRwcmV2aW91cyA9IGNvb3JkaW5hdGVzW2l0ZXJhdG9yIC0gMV0gfHwgMDtcXG5cXHRcXHRcXHRcXHRjdXJyZW50ID0gdGhpcy5fd2lkdGhzW3RoaXMucmVsYXRpdmUoaXRlcmF0b3IpXSArIHRoaXMuc2V0dGluZ3MubWFyZ2luO1xcblxcdFxcdFxcdFxcdGNvb3JkaW5hdGVzLnB1c2gocHJldmlvdXMgKyBjdXJyZW50ICogcnRsKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5fY29vcmRpbmF0ZXMgPSBjb29yZGluYXRlcztcXG5cXHRcXHR9XFxuXFx0fSwge1xcblxcdFxcdGZpbHRlcjogWyAnd2lkdGgnLCAnaXRlbXMnLCAnc2V0dGluZ3MnIF0sXFxuXFx0XFx0cnVuOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHR2YXIgcGFkZGluZyA9IHRoaXMuc2V0dGluZ3Muc3RhZ2VQYWRkaW5nLFxcblxcdFxcdFxcdFxcdGNvb3JkaW5hdGVzID0gdGhpcy5fY29vcmRpbmF0ZXMsXFxuXFx0XFx0XFx0XFx0Y3NzID0ge1xcblxcdFxcdFxcdFxcdFxcdCd3aWR0aCc6IE1hdGguY2VpbChNYXRoLmFicyhjb29yZGluYXRlc1tjb29yZGluYXRlcy5sZW5ndGggLSAxXSkpICsgcGFkZGluZyAqIDIsXFxuXFx0XFx0XFx0XFx0XFx0J3BhZGRpbmctbGVmdCc6IHBhZGRpbmcgfHwgJycsXFxuXFx0XFx0XFx0XFx0XFx0J3BhZGRpbmctcmlnaHQnOiBwYWRkaW5nIHx8ICcnXFxuXFx0XFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHR0aGlzLiRzdGFnZS5jc3MoY3NzKTtcXG5cXHRcXHR9XFxuXFx0fSwge1xcblxcdFxcdGZpbHRlcjogWyAnd2lkdGgnLCAnaXRlbXMnLCAnc2V0dGluZ3MnIF0sXFxuXFx0XFx0cnVuOiBmdW5jdGlvbihjYWNoZSkge1xcblxcdFxcdFxcdHZhciBpdGVyYXRvciA9IHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aCxcXG5cXHRcXHRcXHRcXHRncmlkID0gIXRoaXMuc2V0dGluZ3MuYXV0b1dpZHRoLFxcblxcdFxcdFxcdFxcdGl0ZW1zID0gdGhpcy4kc3RhZ2UuY2hpbGRyZW4oKTtcXG5cXG5cXHRcXHRcXHRpZiAoZ3JpZCAmJiBjYWNoZS5pdGVtcy5tZXJnZSkge1xcblxcdFxcdFxcdFxcdHdoaWxlIChpdGVyYXRvci0tKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y2FjaGUuY3NzLndpZHRoID0gdGhpcy5fd2lkdGhzW3RoaXMucmVsYXRpdmUoaXRlcmF0b3IpXTtcXG5cXHRcXHRcXHRcXHRcXHRpdGVtcy5lcShpdGVyYXRvcikuY3NzKGNhY2hlLmNzcyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gZWxzZSBpZiAoZ3JpZCkge1xcblxcdFxcdFxcdFxcdGNhY2hlLmNzcy53aWR0aCA9IGNhY2hlLml0ZW1zLndpZHRoO1xcblxcdFxcdFxcdFxcdGl0ZW1zLmNzcyhjYWNoZS5jc3MpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fSwge1xcblxcdFxcdGZpbHRlcjogWyAnaXRlbXMnIF0sXFxuXFx0XFx0cnVuOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHR0aGlzLl9jb29yZGluYXRlcy5sZW5ndGggPCAxICYmIHRoaXMuJHN0YWdlLnJlbW92ZUF0dHIoJ3N0eWxlJyk7XFxuXFx0XFx0fVxcblxcdH0sIHtcXG5cXHRcXHRmaWx0ZXI6IFsgJ3dpZHRoJywgJ2l0ZW1zJywgJ3NldHRpbmdzJyBdLFxcblxcdFxcdHJ1bjogZnVuY3Rpb24oY2FjaGUpIHtcXG5cXHRcXHRcXHRjYWNoZS5jdXJyZW50ID0gY2FjaGUuY3VycmVudCA/IHRoaXMuJHN0YWdlLmNoaWxkcmVuKCkuaW5kZXgoY2FjaGUuY3VycmVudCkgOiAwO1xcblxcdFxcdFxcdGNhY2hlLmN1cnJlbnQgPSBNYXRoLm1heCh0aGlzLm1pbmltdW0oKSwgTWF0aC5taW4odGhpcy5tYXhpbXVtKCksIGNhY2hlLmN1cnJlbnQpKTtcXG5cXHRcXHRcXHR0aGlzLnJlc2V0KGNhY2hlLmN1cnJlbnQpO1xcblxcdFxcdH1cXG5cXHR9LCB7XFxuXFx0XFx0ZmlsdGVyOiBbICdwb3NpdGlvbicgXSxcXG5cXHRcXHRydW46IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHRoaXMuYW5pbWF0ZSh0aGlzLmNvb3JkaW5hdGVzKHRoaXMuX2N1cnJlbnQpKTtcXG5cXHRcXHR9XFxuXFx0fSwge1xcblxcdFxcdGZpbHRlcjogWyAnd2lkdGgnLCAncG9zaXRpb24nLCAnaXRlbXMnLCAnc2V0dGluZ3MnIF0sXFxuXFx0XFx0cnVuOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHR2YXIgcnRsID0gdGhpcy5zZXR0aW5ncy5ydGwgPyAxIDogLTEsXFxuXFx0XFx0XFx0XFx0cGFkZGluZyA9IHRoaXMuc2V0dGluZ3Muc3RhZ2VQYWRkaW5nICogMixcXG5cXHRcXHRcXHRcXHRiZWdpbiA9IHRoaXMuY29vcmRpbmF0ZXModGhpcy5jdXJyZW50KCkpICsgcGFkZGluZyxcXG5cXHRcXHRcXHRcXHRlbmQgPSBiZWdpbiArIHRoaXMud2lkdGgoKSAqIHJ0bCxcXG5cXHRcXHRcXHRcXHRpbm5lciwgb3V0ZXIsIG1hdGNoZXMgPSBbXSwgaSwgbjtcXG5cXG5cXHRcXHRcXHRmb3IgKGkgPSAwLCBuID0gdGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0aW5uZXIgPSB0aGlzLl9jb29yZGluYXRlc1tpIC0gMV0gfHwgMDtcXG5cXHRcXHRcXHRcXHRvdXRlciA9IE1hdGguYWJzKHRoaXMuX2Nvb3JkaW5hdGVzW2ldKSArIHBhZGRpbmcgKiBydGw7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCh0aGlzLm9wKGlubmVyLCAnPD0nLCBiZWdpbikgJiYgKHRoaXMub3AoaW5uZXIsICc+JywgZW5kKSkpXFxuXFx0XFx0XFx0XFx0XFx0fHwgKHRoaXMub3Aob3V0ZXIsICc8JywgYmVnaW4pICYmIHRoaXMub3Aob3V0ZXIsICc+JywgZW5kKSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRtYXRjaGVzLnB1c2goaSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLiRzdGFnZS5jaGlsZHJlbignLmFjdGl2ZScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcXG5cXHRcXHRcXHR0aGlzLiRzdGFnZS5jaGlsZHJlbignOmVxKCcgKyBtYXRjaGVzLmpvaW4oJyksIDplcSgnKSArICcpJykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xcblxcblxcdFxcdFxcdGlmICh0aGlzLnNldHRpbmdzLmNlbnRlcikge1xcblxcdFxcdFxcdFxcdHRoaXMuJHN0YWdlLmNoaWxkcmVuKCcuY2VudGVyJykucmVtb3ZlQ2xhc3MoJ2NlbnRlcicpO1xcblxcdFxcdFxcdFxcdHRoaXMuJHN0YWdlLmNoaWxkcmVuKCkuZXEodGhpcy5jdXJyZW50KCkpLmFkZENsYXNzKCdjZW50ZXInKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH0gXTtcXG5cXG5cXHQvKipcXG5cXHQgKiBJbml0aWFsaXplcyB0aGUgY2Fyb3VzZWwuXFxuXFx0ICogQHByb3RlY3RlZFxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdHRoaXMuZW50ZXIoJ2luaXRpYWxpemluZycpO1xcblxcdFxcdHRoaXMudHJpZ2dlcignaW5pdGlhbGl6ZScpO1xcblxcblxcdFxcdHRoaXMuJGVsZW1lbnQudG9nZ2xlQ2xhc3ModGhpcy5zZXR0aW5ncy5ydGxDbGFzcywgdGhpcy5zZXR0aW5ncy5ydGwpO1xcblxcblxcdFxcdGlmICh0aGlzLnNldHRpbmdzLmF1dG9XaWR0aCAmJiAhdGhpcy5pcygncHJlLWxvYWRpbmcnKSkge1xcblxcdFxcdFxcdHZhciBpbWdzLCBuZXN0ZWRTZWxlY3Rvciwgd2lkdGg7XFxuXFx0XFx0XFx0aW1ncyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnaW1nJyk7XFxuXFx0XFx0XFx0bmVzdGVkU2VsZWN0b3IgPSB0aGlzLnNldHRpbmdzLm5lc3RlZEl0ZW1TZWxlY3RvciA/ICcuJyArIHRoaXMuc2V0dGluZ3MubmVzdGVkSXRlbVNlbGVjdG9yIDogdW5kZWZpbmVkO1xcblxcdFxcdFxcdHdpZHRoID0gdGhpcy4kZWxlbWVudC5jaGlsZHJlbihuZXN0ZWRTZWxlY3Rvcikud2lkdGgoKTtcXG5cXG5cXHRcXHRcXHRpZiAoaW1ncy5sZW5ndGggJiYgd2lkdGggPD0gMCkge1xcblxcdFxcdFxcdFxcdHRoaXMucHJlbG9hZEF1dG9XaWR0aEltYWdlcyhpbWdzKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmxvYWRpbmdDbGFzcyk7XFxuXFxuXFx0XFx0Ly8gY3JlYXRlIHN0YWdlXFxuXFx0XFx0dGhpcy4kc3RhZ2UgPSAkKCc8JyArIHRoaXMuc2V0dGluZ3Muc3RhZ2VFbGVtZW50ICsgJyBjbGFzcz1cXFwiJyArIHRoaXMuc2V0dGluZ3Muc3RhZ2VDbGFzcyArICdcXFwiLz4nKVxcblxcdFxcdFxcdC53cmFwKCc8ZGl2IGNsYXNzPVxcXCInICsgdGhpcy5zZXR0aW5ncy5zdGFnZU91dGVyQ2xhc3MgKyAnXFxcIi8+Jyk7XFxuXFxuXFx0XFx0Ly8gYXBwZW5kIHN0YWdlXFxuXFx0XFx0dGhpcy4kZWxlbWVudC5hcHBlbmQodGhpcy4kc3RhZ2UucGFyZW50KCkpO1xcblxcblxcdFxcdC8vIGFwcGVuZCBjb250ZW50XFxuXFx0XFx0dGhpcy5yZXBsYWNlKHRoaXMuJGVsZW1lbnQuY2hpbGRyZW4oKS5ub3QodGhpcy4kc3RhZ2UucGFyZW50KCkpKTtcXG5cXG5cXHRcXHQvLyBjaGVjayB2aXNpYmlsaXR5XFxuXFx0XFx0aWYgKHRoaXMuJGVsZW1lbnQuaXMoJzp2aXNpYmxlJykpIHtcXG5cXHRcXHRcXHQvLyB1cGRhdGUgdmlld1xcblxcdFxcdFxcdHRoaXMucmVmcmVzaCgpO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0Ly8gaW52YWxpZGF0ZSB3aWR0aFxcblxcdFxcdFxcdHRoaXMuaW52YWxpZGF0ZSgnd2lkdGgnKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy4kZWxlbWVudFxcblxcdFxcdFxcdC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMubG9hZGluZ0NsYXNzKVxcblxcdFxcdFxcdC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMubG9hZGVkQ2xhc3MpO1xcblxcblxcdFxcdC8vIHJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJzXFxuXFx0XFx0dGhpcy5yZWdpc3RlckV2ZW50SGFuZGxlcnMoKTtcXG5cXG5cXHRcXHR0aGlzLmxlYXZlKCdpbml0aWFsaXppbmcnKTtcXG5cXHRcXHR0aGlzLnRyaWdnZXIoJ2luaXRpYWxpemVkJyk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBTZXR1cHMgdGhlIGN1cnJlbnQgc2V0dGluZ3MuXFxuXFx0ICogQHRvZG8gUmVtb3ZlIHJlc3BvbnNpdmUgY2xhc3Nlcy4gV2h5IHNob3VsZCBhZGFwdGl2ZSBkZXNpZ25zIGJlIGJyb3VnaHQgaW50byBJRTg/XFxuXFx0ICogQHRvZG8gU3VwcG9ydCBmb3IgbWVkaWEgcXVlcmllcyBieSB1c2luZyBgbWF0Y2hNZWRpYWAgd291bGQgYmUgbmljZS5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5zZXR1cCA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdHZhciB2aWV3cG9ydCA9IHRoaXMudmlld3BvcnQoKSxcXG5cXHRcXHRcXHRvdmVyd3JpdGVzID0gdGhpcy5vcHRpb25zLnJlc3BvbnNpdmUsXFxuXFx0XFx0XFx0bWF0Y2ggPSAtMSxcXG5cXHRcXHRcXHRzZXR0aW5ncyA9IG51bGw7XFxuXFxuXFx0XFx0aWYgKCFvdmVyd3JpdGVzKSB7XFxuXFx0XFx0XFx0c2V0dGluZ3MgPSAkLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdCQuZWFjaChvdmVyd3JpdGVzLCBmdW5jdGlvbihicmVha3BvaW50KSB7XFxuXFx0XFx0XFx0XFx0aWYgKGJyZWFrcG9pbnQgPD0gdmlld3BvcnQgJiYgYnJlYWtwb2ludCA+IG1hdGNoKSB7XFxuXFx0XFx0XFx0XFx0XFx0bWF0Y2ggPSBOdW1iZXIoYnJlYWtwb2ludCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdHNldHRpbmdzID0gJC5leHRlbmQoe30sIHRoaXMub3B0aW9ucywgb3ZlcndyaXRlc1ttYXRjaF0pO1xcblxcdFxcdFxcdGlmICh0eXBlb2Ygc2V0dGluZ3Muc3RhZ2VQYWRkaW5nID09PSAnZnVuY3Rpb24nKSB7XFxuXFx0XFx0XFx0XFx0c2V0dGluZ3Muc3RhZ2VQYWRkaW5nID0gc2V0dGluZ3Muc3RhZ2VQYWRkaW5nKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGRlbGV0ZSBzZXR0aW5ncy5yZXNwb25zaXZlO1xcblxcblxcdFxcdFxcdC8vIHJlc3BvbnNpdmUgY2xhc3NcXG5cXHRcXHRcXHRpZiAoc2V0dGluZ3MucmVzcG9uc2l2ZUNsYXNzKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy4kZWxlbWVudC5hdHRyKCdjbGFzcycsXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy4kZWxlbWVudC5hdHRyKCdjbGFzcycpLnJlcGxhY2UobmV3IFJlZ0V4cCgnKCcgKyB0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZUNsYXNzICsgJy0pXFxcXFxcXFxTK1xcXFxcXFxccycsICdnJyksICckMScgKyBtYXRjaClcXG5cXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy50cmlnZ2VyKCdjaGFuZ2UnLCB7IHByb3BlcnR5OiB7IG5hbWU6ICdzZXR0aW5ncycsIHZhbHVlOiBzZXR0aW5ncyB9IH0pO1xcblxcdFxcdHRoaXMuX2JyZWFrcG9pbnQgPSBtYXRjaDtcXG5cXHRcXHR0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XFxuXFx0XFx0dGhpcy5pbnZhbGlkYXRlKCdzZXR0aW5ncycpO1xcblxcdFxcdHRoaXMudHJpZ2dlcignY2hhbmdlZCcsIHsgcHJvcGVydHk6IHsgbmFtZTogJ3NldHRpbmdzJywgdmFsdWU6IHRoaXMuc2V0dGluZ3MgfSB9KTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFVwZGF0ZXMgb3B0aW9uIGxvZ2ljIGlmIG5lY2Vzc2VyeS5cXG5cXHQgKiBAcHJvdGVjdGVkXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5vcHRpb25zTG9naWMgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5hdXRvV2lkdGgpIHtcXG5cXHRcXHRcXHR0aGlzLnNldHRpbmdzLnN0YWdlUGFkZGluZyA9IGZhbHNlO1xcblxcdFxcdFxcdHRoaXMuc2V0dGluZ3MubWVyZ2UgPSBmYWxzZTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBQcmVwYXJlcyBhbiBpdGVtIGJlZm9yZSBhZGQuXFxuXFx0ICogQHRvZG8gUmVuYW1lIGV2ZW50IHBhcmFtZXRlciBgY29udGVudGAgdG8gYGl0ZW1gLlxcblxcdCAqIEBwcm90ZWN0ZWRcXG5cXHQgKiBAcmV0dXJucyB7alF1ZXJ5fEhUTUxFbGVtZW50fSAtIFRoZSBpdGVtIGNvbnRhaW5lci5cXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLnByZXBhcmUgPSBmdW5jdGlvbihpdGVtKSB7XFxuXFx0XFx0dmFyIGV2ZW50ID0gdGhpcy50cmlnZ2VyKCdwcmVwYXJlJywgeyBjb250ZW50OiBpdGVtIH0pO1xcblxcblxcdFxcdGlmICghZXZlbnQuZGF0YSkge1xcblxcdFxcdFxcdGV2ZW50LmRhdGEgPSAkKCc8JyArIHRoaXMuc2V0dGluZ3MuaXRlbUVsZW1lbnQgKyAnLz4nKVxcblxcdFxcdFxcdFxcdC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuaXRlbUNsYXNzKS5hcHBlbmQoaXRlbSlcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy50cmlnZ2VyKCdwcmVwYXJlZCcsIHsgY29udGVudDogZXZlbnQuZGF0YSB9KTtcXG5cXG5cXHRcXHRyZXR1cm4gZXZlbnQuZGF0YTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFVwZGF0ZXMgdGhlIHZpZXcuXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0dmFyIGkgPSAwLFxcblxcdFxcdFxcdG4gPSB0aGlzLl9waXBlLmxlbmd0aCxcXG5cXHRcXHRcXHRmaWx0ZXIgPSAkLnByb3h5KGZ1bmN0aW9uKHApIHsgcmV0dXJuIHRoaXNbcF0gfSwgdGhpcy5faW52YWxpZGF0ZWQpLFxcblxcdFxcdFxcdGNhY2hlID0ge307XFxuXFxuXFx0XFx0d2hpbGUgKGkgPCBuKSB7XFxuXFx0XFx0XFx0aWYgKHRoaXMuX2ludmFsaWRhdGVkLmFsbCB8fCAkLmdyZXAodGhpcy5fcGlwZVtpXS5maWx0ZXIsIGZpbHRlcikubGVuZ3RoID4gMCkge1xcblxcdFxcdFxcdFxcdHRoaXMuX3BpcGVbaV0ucnVuKGNhY2hlKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aSsrO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLl9pbnZhbGlkYXRlZCA9IHt9O1xcblxcblxcdFxcdCF0aGlzLmlzKCd2YWxpZCcpICYmIHRoaXMuZW50ZXIoJ3ZhbGlkJyk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBHZXRzIHRoZSB3aWR0aCBvZiB0aGUgdmlldy5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICogQHBhcmFtIHtPd2wuV2lkdGh9IFtkaW1lbnNpb249T3dsLldpZHRoLkRlZmF1bHRdIC0gVGhlIGRpbWVuc2lvbiB0byByZXR1cm4uXFxuXFx0ICogQHJldHVybnMge051bWJlcn0gLSBUaGUgd2lkdGggb2YgdGhlIHZpZXcgaW4gcGl4ZWwuXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uKGRpbWVuc2lvbikge1xcblxcdFxcdGRpbWVuc2lvbiA9IGRpbWVuc2lvbiB8fCBPd2wuV2lkdGguRGVmYXVsdDtcXG5cXHRcXHRzd2l0Y2ggKGRpbWVuc2lvbikge1xcblxcdFxcdFxcdGNhc2UgT3dsLldpZHRoLklubmVyOlxcblxcdFxcdFxcdGNhc2UgT3dsLldpZHRoLk91dGVyOlxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLl93aWR0aDtcXG5cXHRcXHRcXHRkZWZhdWx0OlxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLl93aWR0aCAtIHRoaXMuc2V0dGluZ3Muc3RhZ2VQYWRkaW5nICogMiArIHRoaXMuc2V0dGluZ3MubWFyZ2luO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFJlZnJlc2hlcyB0aGUgY2Fyb3VzZWwgcHJpbWFyaWx5IGZvciBhZGFwdGl2ZSBwdXJwb3Nlcy5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0dGhpcy5lbnRlcigncmVmcmVzaGluZycpO1xcblxcdFxcdHRoaXMudHJpZ2dlcigncmVmcmVzaCcpO1xcblxcblxcdFxcdHRoaXMuc2V0dXAoKTtcXG5cXG5cXHRcXHR0aGlzLm9wdGlvbnNMb2dpYygpO1xcblxcblxcdFxcdHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLnJlZnJlc2hDbGFzcyk7XFxuXFxuXFx0XFx0dGhpcy51cGRhdGUoKTtcXG5cXG5cXHRcXHR0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5yZWZyZXNoQ2xhc3MpO1xcblxcblxcdFxcdHRoaXMubGVhdmUoJ3JlZnJlc2hpbmcnKTtcXG5cXHRcXHR0aGlzLnRyaWdnZXIoJ3JlZnJlc2hlZCcpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQ2hlY2tzIHdpbmRvdyBgcmVzaXplYCBldmVudC5cXG5cXHQgKiBAcHJvdGVjdGVkXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5vblRocm90dGxlZFJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5yZXNpemVUaW1lcik7XFxuXFx0XFx0dGhpcy5yZXNpemVUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KHRoaXMuX2hhbmRsZXJzLm9uUmVzaXplLCB0aGlzLnNldHRpbmdzLnJlc3BvbnNpdmVSZWZyZXNoUmF0ZSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBDaGVja3Mgd2luZG93IGByZXNpemVgIGV2ZW50LlxcblxcdCAqIEBwcm90ZWN0ZWRcXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLm9uUmVzaXplID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0aWYgKCF0aGlzLl9pdGVtcy5sZW5ndGgpIHtcXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICh0aGlzLl93aWR0aCA9PT0gdGhpcy4kZWxlbWVudC53aWR0aCgpKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIXRoaXMuJGVsZW1lbnQuaXMoJzp2aXNpYmxlJykpIHtcXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuZW50ZXIoJ3Jlc2l6aW5nJyk7XFxuXFxuXFx0XFx0aWYgKHRoaXMudHJpZ2dlcigncmVzaXplJykuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcXG5cXHRcXHRcXHR0aGlzLmxlYXZlKCdyZXNpemluZycpO1xcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5pbnZhbGlkYXRlKCd3aWR0aCcpO1xcblxcblxcdFxcdHRoaXMucmVmcmVzaCgpO1xcblxcblxcdFxcdHRoaXMubGVhdmUoJ3Jlc2l6aW5nJyk7XFxuXFx0XFx0dGhpcy50cmlnZ2VyKCdyZXNpemVkJyk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBSZWdpc3RlcnMgZXZlbnQgaGFuZGxlcnMuXFxuXFx0ICogQHRvZG8gQ2hlY2sgYG1zUG9pbnRlckVuYWJsZWRgXFxuXFx0ICogQHRvZG8gIzI2MVxcblxcdCAqIEBwcm90ZWN0ZWRcXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLnJlZ2lzdGVyRXZlbnRIYW5kbGVycyA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdGlmICgkLnN1cHBvcnQudHJhbnNpdGlvbikge1xcblxcdFxcdFxcdHRoaXMuJHN0YWdlLm9uKCQuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCArICcub3dsLmNvcmUnLCAkLnByb3h5KHRoaXMub25UcmFuc2l0aW9uRW5kLCB0aGlzKSk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICh0aGlzLnNldHRpbmdzLnJlc3BvbnNpdmUgIT09IGZhbHNlKSB7XFxuXFx0XFx0XFx0dGhpcy5vbih3aW5kb3csICdyZXNpemUnLCB0aGlzLl9oYW5kbGVycy5vblRocm90dGxlZFJlc2l6ZSk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICh0aGlzLnNldHRpbmdzLm1vdXNlRHJhZykge1xcblxcdFxcdFxcdHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmRyYWdDbGFzcyk7XFxuXFx0XFx0XFx0dGhpcy4kc3RhZ2Uub24oJ21vdXNlZG93bi5vd2wuY29yZScsICQucHJveHkodGhpcy5vbkRyYWdTdGFydCwgdGhpcykpO1xcblxcdFxcdFxcdHRoaXMuJHN0YWdlLm9uKCdkcmFnc3RhcnQub3dsLmNvcmUgc2VsZWN0c3RhcnQub3dsLmNvcmUnLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlIH0pO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAodGhpcy5zZXR0aW5ncy50b3VjaERyYWcpe1xcblxcdFxcdFxcdHRoaXMuJHN0YWdlLm9uKCd0b3VjaHN0YXJ0Lm93bC5jb3JlJywgJC5wcm94eSh0aGlzLm9uRHJhZ1N0YXJ0LCB0aGlzKSk7XFxuXFx0XFx0XFx0dGhpcy4kc3RhZ2Uub24oJ3RvdWNoY2FuY2VsLm93bC5jb3JlJywgJC5wcm94eSh0aGlzLm9uRHJhZ0VuZCwgdGhpcykpO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEhhbmRsZXMgYHRvdWNoc3RhcnRgIGFuZCBgbW91c2Vkb3duYCBldmVudHMuXFxuXFx0ICogQHRvZG8gSG9yaXpvbnRhbCBzd2lwZSB0aHJlc2hvbGQgYXMgb3B0aW9uXFxuXFx0ICogQHRvZG8gIzI2MVxcblxcdCAqIEBwcm90ZWN0ZWRcXG5cXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBldmVudCBhcmd1bWVudHMuXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5vbkRyYWdTdGFydCA9IGZ1bmN0aW9uKGV2ZW50KSB7XFxuXFx0XFx0dmFyIHN0YWdlID0gbnVsbDtcXG5cXG5cXHRcXHRpZiAoZXZlbnQud2hpY2ggPT09IDMpIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICgkLnN1cHBvcnQudHJhbnNmb3JtKSB7XFxuXFx0XFx0XFx0c3RhZ2UgPSB0aGlzLiRzdGFnZS5jc3MoJ3RyYW5zZm9ybScpLnJlcGxhY2UoLy4qXFxcXCh8XFxcXCl8IC9nLCAnJykuc3BsaXQoJywnKTtcXG5cXHRcXHRcXHRzdGFnZSA9IHtcXG5cXHRcXHRcXHRcXHR4OiBzdGFnZVtzdGFnZS5sZW5ndGggPT09IDE2ID8gMTIgOiA0XSxcXG5cXHRcXHRcXHRcXHR5OiBzdGFnZVtzdGFnZS5sZW5ndGggPT09IDE2ID8gMTMgOiA1XVxcblxcdFxcdFxcdH07XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRzdGFnZSA9IHRoaXMuJHN0YWdlLnBvc2l0aW9uKCk7XFxuXFx0XFx0XFx0c3RhZ2UgPSB7XFxuXFx0XFx0XFx0XFx0eDogdGhpcy5zZXR0aW5ncy5ydGwgP1xcblxcdFxcdFxcdFxcdFxcdHN0YWdlLmxlZnQgKyB0aGlzLiRzdGFnZS53aWR0aCgpIC0gdGhpcy53aWR0aCgpICsgdGhpcy5zZXR0aW5ncy5tYXJnaW4gOlxcblxcdFxcdFxcdFxcdFxcdHN0YWdlLmxlZnQsXFxuXFx0XFx0XFx0XFx0eTogc3RhZ2UudG9wXFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKHRoaXMuaXMoJ2FuaW1hdGluZycpKSB7XFxuXFx0XFx0XFx0JC5zdXBwb3J0LnRyYW5zZm9ybSA/IHRoaXMuYW5pbWF0ZShzdGFnZS54KSA6IHRoaXMuJHN0YWdlLnN0b3AoKVxcblxcdFxcdFxcdHRoaXMuaW52YWxpZGF0ZSgncG9zaXRpb24nKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy4kZWxlbWVudC50b2dnbGVDbGFzcyh0aGlzLm9wdGlvbnMuZ3JhYkNsYXNzLCBldmVudC50eXBlID09PSAnbW91c2Vkb3duJyk7XFxuXFxuXFx0XFx0dGhpcy5zcGVlZCgwKTtcXG5cXG5cXHRcXHR0aGlzLl9kcmFnLnRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcXG5cXHRcXHR0aGlzLl9kcmFnLnRhcmdldCA9ICQoZXZlbnQudGFyZ2V0KTtcXG5cXHRcXHR0aGlzLl9kcmFnLnN0YWdlLnN0YXJ0ID0gc3RhZ2U7XFxuXFx0XFx0dGhpcy5fZHJhZy5zdGFnZS5jdXJyZW50ID0gc3RhZ2U7XFxuXFx0XFx0dGhpcy5fZHJhZy5wb2ludGVyID0gdGhpcy5wb2ludGVyKGV2ZW50KTtcXG5cXG5cXHRcXHQkKGRvY3VtZW50KS5vbignbW91c2V1cC5vd2wuY29yZSB0b3VjaGVuZC5vd2wuY29yZScsICQucHJveHkodGhpcy5vbkRyYWdFbmQsIHRoaXMpKTtcXG5cXG5cXHRcXHQkKGRvY3VtZW50KS5vbmUoJ21vdXNlbW92ZS5vd2wuY29yZSB0b3VjaG1vdmUub3dsLmNvcmUnLCAkLnByb3h5KGZ1bmN0aW9uKGV2ZW50KSB7XFxuXFx0XFx0XFx0dmFyIGRlbHRhID0gdGhpcy5kaWZmZXJlbmNlKHRoaXMuX2RyYWcucG9pbnRlciwgdGhpcy5wb2ludGVyKGV2ZW50KSk7XFxuXFxuXFx0XFx0XFx0JChkb2N1bWVudCkub24oJ21vdXNlbW92ZS5vd2wuY29yZSB0b3VjaG1vdmUub3dsLmNvcmUnLCAkLnByb3h5KHRoaXMub25EcmFnTW92ZSwgdGhpcykpO1xcblxcblxcdFxcdFxcdGlmIChNYXRoLmFicyhkZWx0YS54KSA8IE1hdGguYWJzKGRlbHRhLnkpICYmIHRoaXMuaXMoJ3ZhbGlkJykpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuXFxuXFx0XFx0XFx0dGhpcy5lbnRlcignZHJhZ2dpbmcnKTtcXG5cXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ2RyYWcnKTtcXG5cXHRcXHR9LCB0aGlzKSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBIYW5kbGVzIHRoZSBgdG91Y2htb3ZlYCBhbmQgYG1vdXNlbW92ZWAgZXZlbnRzLlxcblxcdCAqIEB0b2RvICMyNjFcXG5cXHQgKiBAcHJvdGVjdGVkXFxuXFx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgYXJndW1lbnRzLlxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUub25EcmFnTW92ZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XFxuXFx0XFx0dmFyIG1pbmltdW0gPSBudWxsLFxcblxcdFxcdFxcdG1heGltdW0gPSBudWxsLFxcblxcdFxcdFxcdHB1bGwgPSBudWxsLFxcblxcdFxcdFxcdGRlbHRhID0gdGhpcy5kaWZmZXJlbmNlKHRoaXMuX2RyYWcucG9pbnRlciwgdGhpcy5wb2ludGVyKGV2ZW50KSksXFxuXFx0XFx0XFx0c3RhZ2UgPSB0aGlzLmRpZmZlcmVuY2UodGhpcy5fZHJhZy5zdGFnZS5zdGFydCwgZGVsdGEpO1xcblxcblxcdFxcdGlmICghdGhpcy5pcygnZHJhZ2dpbmcnKSkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXG5cXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5sb29wKSB7XFxuXFx0XFx0XFx0bWluaW11bSA9IHRoaXMuY29vcmRpbmF0ZXModGhpcy5taW5pbXVtKCkpO1xcblxcdFxcdFxcdG1heGltdW0gPSB0aGlzLmNvb3JkaW5hdGVzKHRoaXMubWF4aW11bSgpICsgMSkgLSBtaW5pbXVtO1xcblxcdFxcdFxcdHN0YWdlLnggPSAoKChzdGFnZS54IC0gbWluaW11bSkgJSBtYXhpbXVtICsgbWF4aW11bSkgJSBtYXhpbXVtKSArIG1pbmltdW07XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRtaW5pbXVtID0gdGhpcy5zZXR0aW5ncy5ydGwgPyB0aGlzLmNvb3JkaW5hdGVzKHRoaXMubWF4aW11bSgpKSA6IHRoaXMuY29vcmRpbmF0ZXModGhpcy5taW5pbXVtKCkpO1xcblxcdFxcdFxcdG1heGltdW0gPSB0aGlzLnNldHRpbmdzLnJ0bCA/IHRoaXMuY29vcmRpbmF0ZXModGhpcy5taW5pbXVtKCkpIDogdGhpcy5jb29yZGluYXRlcyh0aGlzLm1heGltdW0oKSk7XFxuXFx0XFx0XFx0cHVsbCA9IHRoaXMuc2V0dGluZ3MucHVsbERyYWcgPyAtMSAqIGRlbHRhLnggLyA1IDogMDtcXG5cXHRcXHRcXHRzdGFnZS54ID0gTWF0aC5tYXgoTWF0aC5taW4oc3RhZ2UueCwgbWluaW11bSArIHB1bGwpLCBtYXhpbXVtICsgcHVsbCk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuX2RyYWcuc3RhZ2UuY3VycmVudCA9IHN0YWdlO1xcblxcblxcdFxcdHRoaXMuYW5pbWF0ZShzdGFnZS54KTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEhhbmRsZXMgdGhlIGB0b3VjaGVuZGAgYW5kIGBtb3VzZXVwYCBldmVudHMuXFxuXFx0ICogQHRvZG8gIzI2MVxcblxcdCAqIEB0b2RvIFRocmVzaG9sZCBmb3IgY2xpY2sgZXZlbnRcXG5cXHQgKiBAcHJvdGVjdGVkXFxuXFx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgYXJndW1lbnRzLlxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUub25EcmFnRW5kID0gZnVuY3Rpb24oZXZlbnQpIHtcXG5cXHRcXHR2YXIgZGVsdGEgPSB0aGlzLmRpZmZlcmVuY2UodGhpcy5fZHJhZy5wb2ludGVyLCB0aGlzLnBvaW50ZXIoZXZlbnQpKSxcXG5cXHRcXHRcXHRzdGFnZSA9IHRoaXMuX2RyYWcuc3RhZ2UuY3VycmVudCxcXG5cXHRcXHRcXHRkaXJlY3Rpb24gPSBkZWx0YS54ID4gMCBeIHRoaXMuc2V0dGluZ3MucnRsID8gJ2xlZnQnIDogJ3JpZ2h0JztcXG5cXG5cXHRcXHQkKGRvY3VtZW50KS5vZmYoJy5vd2wuY29yZScpO1xcblxcblxcdFxcdHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmdyYWJDbGFzcyk7XFxuXFxuXFx0XFx0aWYgKGRlbHRhLnggIT09IDAgJiYgdGhpcy5pcygnZHJhZ2dpbmcnKSB8fCAhdGhpcy5pcygndmFsaWQnKSkge1xcblxcdFxcdFxcdHRoaXMuc3BlZWQodGhpcy5zZXR0aW5ncy5kcmFnRW5kU3BlZWQgfHwgdGhpcy5zZXR0aW5ncy5zbWFydFNwZWVkKTtcXG5cXHRcXHRcXHR0aGlzLmN1cnJlbnQodGhpcy5jbG9zZXN0KHN0YWdlLngsIGRlbHRhLnggIT09IDAgPyBkaXJlY3Rpb24gOiB0aGlzLl9kcmFnLmRpcmVjdGlvbikpO1xcblxcdFxcdFxcdHRoaXMuaW52YWxpZGF0ZSgncG9zaXRpb24nKTtcXG5cXHRcXHRcXHR0aGlzLnVwZGF0ZSgpO1xcblxcblxcdFxcdFxcdHRoaXMuX2RyYWcuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xcblxcblxcdFxcdFxcdGlmIChNYXRoLmFicyhkZWx0YS54KSA+IDMgfHwgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLl9kcmFnLnRpbWUgPiAzMDApIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9kcmFnLnRhcmdldC5vbmUoJ2NsaWNrLm93bC5jb3JlJywgZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIXRoaXMuaXMoJ2RyYWdnaW5nJykpIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMubGVhdmUoJ2RyYWdnaW5nJyk7XFxuXFx0XFx0dGhpcy50cmlnZ2VyKCdkcmFnZ2VkJyk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBHZXRzIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBjbG9zZXN0IGl0ZW0gZm9yIGEgY29vcmRpbmF0ZS5cXG5cXHQgKiBAdG9kbyBTZXR0aW5nIGBmcmVlRHJhZ2AgbWFrZXMgYGNsb3Nlc3RgIG5vdCByZXVzYWJsZS4gU2VlICMxNjUuXFxuXFx0ICogQHByb3RlY3RlZFxcblxcdCAqIEBwYXJhbSB7TnVtYmVyfSBjb29yZGluYXRlIC0gVGhlIGNvb3JkaW5hdGUgaW4gcGl4ZWwuXFxuXFx0ICogQHBhcmFtIHtTdHJpbmd9IGRpcmVjdGlvbiAtIFRoZSBkaXJlY3Rpb24gdG8gY2hlY2sgZm9yIHRoZSBjbG9zZXN0IGl0ZW0uIEV0aGVyIGBsZWZ0YCBvciBgcmlnaHRgLlxcblxcdCAqIEByZXR1cm4ge051bWJlcn0gLSBUaGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIGNsb3Nlc3QgaXRlbS5cXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLmNsb3Nlc3QgPSBmdW5jdGlvbihjb29yZGluYXRlLCBkaXJlY3Rpb24pIHtcXG5cXHRcXHR2YXIgcG9zaXRpb24gPSAtMSxcXG5cXHRcXHRcXHRwdWxsID0gMzAsXFxuXFx0XFx0XFx0d2lkdGggPSB0aGlzLndpZHRoKCksXFxuXFx0XFx0XFx0Y29vcmRpbmF0ZXMgPSB0aGlzLmNvb3JkaW5hdGVzKCk7XFxuXFxuXFx0XFx0aWYgKCF0aGlzLnNldHRpbmdzLmZyZWVEcmFnKSB7XFxuXFx0XFx0XFx0Ly8gY2hlY2sgY2xvc2VzdCBpdGVtXFxuXFx0XFx0XFx0JC5lYWNoKGNvb3JkaW5hdGVzLCAkLnByb3h5KGZ1bmN0aW9uKGluZGV4LCB2YWx1ZSkge1xcblxcdFxcdFxcdFxcdC8vIG9uIGEgbGVmdCBwdWxsLCBjaGVjayBvbiBjdXJyZW50IGluZGV4XFxuXFx0XFx0XFx0XFx0aWYgKGRpcmVjdGlvbiA9PT0gJ2xlZnQnICYmIGNvb3JkaW5hdGUgPiB2YWx1ZSAtIHB1bGwgJiYgY29vcmRpbmF0ZSA8IHZhbHVlICsgcHVsbCkge1xcblxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uID0gaW5kZXg7XFxuXFx0XFx0XFx0XFx0Ly8gb24gYSByaWdodCBwdWxsLCBjaGVjayBvbiBwcmV2aW91cyBpbmRleFxcblxcdFxcdFxcdFxcdC8vIHRvIGRvIHNvLCBzdWJ0cmFjdCB3aWR0aCBmcm9tIHZhbHVlIGFuZCBzZXQgcG9zaXRpb24gPSBpbmRleCArIDFcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ3JpZ2h0JyAmJiBjb29yZGluYXRlID4gdmFsdWUgLSB3aWR0aCAtIHB1bGwgJiYgY29vcmRpbmF0ZSA8IHZhbHVlIC0gd2lkdGggKyBwdWxsKSB7XFxuXFx0XFx0XFx0XFx0XFx0cG9zaXRpb24gPSBpbmRleCArIDE7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICh0aGlzLm9wKGNvb3JkaW5hdGUsICc8JywgdmFsdWUpXFxuXFx0XFx0XFx0XFx0XFx0JiYgdGhpcy5vcChjb29yZGluYXRlLCAnPicsIGNvb3JkaW5hdGVzW2luZGV4ICsgMV0gfHwgdmFsdWUgLSB3aWR0aCkpIHtcXG5cXHRcXHRcXHRcXHRcXHRwb3NpdGlvbiA9IGRpcmVjdGlvbiA9PT0gJ2xlZnQnID8gaW5kZXggKyAxIDogaW5kZXg7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiBwb3NpdGlvbiA9PT0gLTE7XFxuXFx0XFx0XFx0fSwgdGhpcykpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIXRoaXMuc2V0dGluZ3MubG9vcCkge1xcblxcdFxcdFxcdC8vIG5vbiBsb29wIGJvdW5kcmllc1xcblxcdFxcdFxcdGlmICh0aGlzLm9wKGNvb3JkaW5hdGUsICc+JywgY29vcmRpbmF0ZXNbdGhpcy5taW5pbXVtKCldKSkge1xcblxcdFxcdFxcdFxcdHBvc2l0aW9uID0gY29vcmRpbmF0ZSA9IHRoaXMubWluaW11bSgpO1xcblxcdFxcdFxcdH0gZWxzZSBpZiAodGhpcy5vcChjb29yZGluYXRlLCAnPCcsIGNvb3JkaW5hdGVzW3RoaXMubWF4aW11bSgpXSkpIHtcXG5cXHRcXHRcXHRcXHRwb3NpdGlvbiA9IGNvb3JkaW5hdGUgPSB0aGlzLm1heGltdW0oKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBwb3NpdGlvbjtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEFuaW1hdGVzIHRoZSBzdGFnZS5cXG5cXHQgKiBAdG9kbyAjMjcwXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqIEBwYXJhbSB7TnVtYmVyfSBjb29yZGluYXRlIC0gVGhlIGNvb3JkaW5hdGUgaW4gcGl4ZWxzLlxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUuYW5pbWF0ZSA9IGZ1bmN0aW9uKGNvb3JkaW5hdGUpIHtcXG5cXHRcXHR2YXIgYW5pbWF0ZSA9IHRoaXMuc3BlZWQoKSA+IDA7XFxuXFxuXFx0XFx0dGhpcy5pcygnYW5pbWF0aW5nJykgJiYgdGhpcy5vblRyYW5zaXRpb25FbmQoKTtcXG5cXG5cXHRcXHRpZiAoYW5pbWF0ZSkge1xcblxcdFxcdFxcdHRoaXMuZW50ZXIoJ2FuaW1hdGluZycpO1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcigndHJhbnNsYXRlJyk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICgkLnN1cHBvcnQudHJhbnNmb3JtM2QgJiYgJC5zdXBwb3J0LnRyYW5zaXRpb24pIHtcXG5cXHRcXHRcXHR0aGlzLiRzdGFnZS5jc3Moe1xcblxcdFxcdFxcdFxcdHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKCcgKyBjb29yZGluYXRlICsgJ3B4LDBweCwwcHgpJyxcXG5cXHRcXHRcXHRcXHR0cmFuc2l0aW9uOiAodGhpcy5zcGVlZCgpIC8gMTAwMCkgKyAncydcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9IGVsc2UgaWYgKGFuaW1hdGUpIHtcXG5cXHRcXHRcXHR0aGlzLiRzdGFnZS5hbmltYXRlKHtcXG5cXHRcXHRcXHRcXHRsZWZ0OiBjb29yZGluYXRlICsgJ3B4J1xcblxcdFxcdFxcdH0sIHRoaXMuc3BlZWQoKSwgdGhpcy5zZXR0aW5ncy5mYWxsYmFja0Vhc2luZywgJC5wcm94eSh0aGlzLm9uVHJhbnNpdGlvbkVuZCwgdGhpcykpO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0dGhpcy4kc3RhZ2UuY3NzKHtcXG5cXHRcXHRcXHRcXHRsZWZ0OiBjb29yZGluYXRlICsgJ3B4J1xcblxcdFxcdFxcdH0pO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIENoZWNrcyB3aGV0aGVyIHRoZSBjYXJvdXNlbCBpcyBpbiBhIHNwZWNpZmljIHN0YXRlIG9yIG5vdC5cXG5cXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RhdGUgLSBUaGUgc3RhdGUgdG8gY2hlY2suXFxuXFx0ICogQHJldHVybnMge0Jvb2xlYW59IC0gVGhlIGZsYWcgd2hpY2ggaW5kaWNhdGVzIGlmIHRoZSBjYXJvdXNlbCBpcyBidXN5LlxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUuaXMgPSBmdW5jdGlvbihzdGF0ZSkge1xcblxcdFxcdHJldHVybiB0aGlzLl9zdGF0ZXMuY3VycmVudFtzdGF0ZV0gJiYgdGhpcy5fc3RhdGVzLmN1cnJlbnRbc3RhdGVdID4gMDtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFNldHMgdGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IGl0ZW0uXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqIEBwYXJhbSB7TnVtYmVyfSBbcG9zaXRpb25dIC0gVGhlIG5ldyBhYnNvbHV0ZSBwb3NpdGlvbiBvciBub3RoaW5nIHRvIGxlYXZlIGl0IHVuY2hhbmdlZC5cXG5cXHQgKiBAcmV0dXJucyB7TnVtYmVyfSAtIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCBpdGVtLlxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUuY3VycmVudCA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XFxuXFx0XFx0aWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5fY3VycmVudDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKHRoaXMuX2l0ZW1zLmxlbmd0aCA9PT0gMCkge1xcblxcdFxcdFxcdHJldHVybiB1bmRlZmluZWQ7XFxuXFx0XFx0fVxcblxcblxcdFxcdHBvc2l0aW9uID0gdGhpcy5ub3JtYWxpemUocG9zaXRpb24pO1xcblxcblxcdFxcdGlmICh0aGlzLl9jdXJyZW50ICE9PSBwb3NpdGlvbikge1xcblxcdFxcdFxcdHZhciBldmVudCA9IHRoaXMudHJpZ2dlcignY2hhbmdlJywgeyBwcm9wZXJ0eTogeyBuYW1lOiAncG9zaXRpb24nLCB2YWx1ZTogcG9zaXRpb24gfSB9KTtcXG5cXG5cXHRcXHRcXHRpZiAoZXZlbnQuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0XFx0cG9zaXRpb24gPSB0aGlzLm5vcm1hbGl6ZShldmVudC5kYXRhKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5fY3VycmVudCA9IHBvc2l0aW9uO1xcblxcblxcdFxcdFxcdHRoaXMuaW52YWxpZGF0ZSgncG9zaXRpb24nKTtcXG5cXG5cXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ2NoYW5nZWQnLCB7IHByb3BlcnR5OiB7IG5hbWU6ICdwb3NpdGlvbicsIHZhbHVlOiB0aGlzLl9jdXJyZW50IH0gfSk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB0aGlzLl9jdXJyZW50O1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogSW52YWxpZGF0ZXMgdGhlIGdpdmVuIHBhcnQgb2YgdGhlIHVwZGF0ZSByb3V0aW5lLlxcblxcdCAqIEBwYXJhbSB7U3RyaW5nfSBbcGFydF0gLSBUaGUgcGFydCB0byBpbnZhbGlkYXRlLlxcblxcdCAqIEByZXR1cm5zIHtBcnJheS48U3RyaW5nPn0gLSBUaGUgaW52YWxpZGF0ZWQgcGFydHMuXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24ocGFydCkge1xcblxcdFxcdGlmICgkLnR5cGUocGFydCkgPT09ICdzdHJpbmcnKSB7XFxuXFx0XFx0XFx0dGhpcy5faW52YWxpZGF0ZWRbcGFydF0gPSB0cnVlO1xcblxcdFxcdFxcdHRoaXMuaXMoJ3ZhbGlkJykgJiYgdGhpcy5sZWF2ZSgndmFsaWQnKTtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuICQubWFwKHRoaXMuX2ludmFsaWRhdGVkLCBmdW5jdGlvbih2LCBpKSB7IHJldHVybiBpIH0pO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogUmVzZXRzIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCBpdGVtLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gLSBUaGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIG5ldyBpdGVtLlxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbihwb3NpdGlvbikge1xcblxcdFxcdHBvc2l0aW9uID0gdGhpcy5ub3JtYWxpemUocG9zaXRpb24pO1xcblxcblxcdFxcdGlmIChwb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLl9zcGVlZCA9IDA7XFxuXFx0XFx0dGhpcy5fY3VycmVudCA9IHBvc2l0aW9uO1xcblxcblxcdFxcdHRoaXMuc3VwcHJlc3MoWyAndHJhbnNsYXRlJywgJ3RyYW5zbGF0ZWQnIF0pO1xcblxcblxcdFxcdHRoaXMuYW5pbWF0ZSh0aGlzLmNvb3JkaW5hdGVzKHBvc2l0aW9uKSk7XFxuXFxuXFx0XFx0dGhpcy5yZWxlYXNlKFsgJ3RyYW5zbGF0ZScsICd0cmFuc2xhdGVkJyBdKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIE5vcm1hbGl6ZXMgYW4gYWJzb2x1dGUgb3IgYSByZWxhdGl2ZSBwb3NpdGlvbiBvZiBhbiBpdGVtLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gLSBUaGUgYWJzb2x1dGUgb3IgcmVsYXRpdmUgcG9zaXRpb24gdG8gbm9ybWFsaXplLlxcblxcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JlbGF0aXZlPWZhbHNlXSAtIFdoZXRoZXIgdGhlIGdpdmVuIHBvc2l0aW9uIGlzIHJlbGF0aXZlIG9yIG5vdC5cXG5cXHQgKiBAcmV0dXJucyB7TnVtYmVyfSAtIFRoZSBub3JtYWxpemVkIHBvc2l0aW9uLlxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24ocG9zaXRpb24sIHJlbGF0aXZlKSB7XFxuXFx0XFx0dmFyIG4gPSB0aGlzLl9pdGVtcy5sZW5ndGgsXFxuXFx0XFx0XFx0bSA9IHJlbGF0aXZlID8gMCA6IHRoaXMuX2Nsb25lcy5sZW5ndGg7XFxuXFxuXFx0XFx0aWYgKCF0aGlzLmlzTnVtZXJpYyhwb3NpdGlvbikgfHwgbiA8IDEpIHtcXG5cXHRcXHRcXHRwb3NpdGlvbiA9IHVuZGVmaW5lZDtcXG5cXHRcXHR9IGVsc2UgaWYgKHBvc2l0aW9uIDwgMCB8fCBwb3NpdGlvbiA+PSBuICsgbSkge1xcblxcdFxcdFxcdHBvc2l0aW9uID0gKChwb3NpdGlvbiAtIG0gLyAyKSAlIG4gKyBuKSAlIG4gKyBtIC8gMjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHBvc2l0aW9uO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQ29udmVydHMgYW4gYWJzb2x1dGUgcG9zaXRpb24gb2YgYW4gaXRlbSBpbnRvIGEgcmVsYXRpdmUgb25lLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gLSBUaGUgYWJzb2x1dGUgcG9zaXRpb24gdG8gY29udmVydC5cXG5cXHQgKiBAcmV0dXJucyB7TnVtYmVyfSAtIFRoZSBjb252ZXJ0ZWQgcG9zaXRpb24uXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5yZWxhdGl2ZSA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XFxuXFx0XFx0cG9zaXRpb24gLT0gdGhpcy5fY2xvbmVzLmxlbmd0aCAvIDI7XFxuXFx0XFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKHBvc2l0aW9uLCB0cnVlKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEdldHMgdGhlIG1heGltdW0gcG9zaXRpb24gZm9yIHRoZSBjdXJyZW50IGl0ZW0uXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JlbGF0aXZlPWZhbHNlXSAtIFdoZXRoZXIgdG8gcmV0dXJuIGFuIGFic29sdXRlIHBvc2l0aW9uIG9yIGEgcmVsYXRpdmUgcG9zaXRpb24uXFxuXFx0ICogQHJldHVybnMge051bWJlcn1cXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLm1heGltdW0gPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xcblxcdFxcdHZhciBzZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3MsXFxuXFx0XFx0XFx0bWF4aW11bSA9IHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aCxcXG5cXHRcXHRcXHRpdGVyYXRvcixcXG5cXHRcXHRcXHRyZWNpcHJvY2FsSXRlbXNXaWR0aCxcXG5cXHRcXHRcXHRlbGVtZW50V2lkdGg7XFxuXFxuXFx0XFx0aWYgKHNldHRpbmdzLmxvb3ApIHtcXG5cXHRcXHRcXHRtYXhpbXVtID0gdGhpcy5fY2xvbmVzLmxlbmd0aCAvIDIgKyB0aGlzLl9pdGVtcy5sZW5ndGggLSAxO1xcblxcdFxcdH0gZWxzZSBpZiAoc2V0dGluZ3MuYXV0b1dpZHRoIHx8IHNldHRpbmdzLm1lcmdlKSB7XFxuXFx0XFx0XFx0aXRlcmF0b3IgPSB0aGlzLl9pdGVtcy5sZW5ndGg7XFxuXFx0XFx0XFx0cmVjaXByb2NhbEl0ZW1zV2lkdGggPSB0aGlzLl9pdGVtc1stLWl0ZXJhdG9yXS53aWR0aCgpO1xcblxcdFxcdFxcdGVsZW1lbnRXaWR0aCA9IHRoaXMuJGVsZW1lbnQud2lkdGgoKTtcXG5cXHRcXHRcXHR3aGlsZSAoaXRlcmF0b3ItLSkge1xcblxcdFxcdFxcdFxcdHJlY2lwcm9jYWxJdGVtc1dpZHRoICs9IHRoaXMuX2l0ZW1zW2l0ZXJhdG9yXS53aWR0aCgpICsgdGhpcy5zZXR0aW5ncy5tYXJnaW47XFxuXFx0XFx0XFx0XFx0aWYgKHJlY2lwcm9jYWxJdGVtc1dpZHRoID4gZWxlbWVudFdpZHRoKSB7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRtYXhpbXVtID0gaXRlcmF0b3IgKyAxO1xcblxcdFxcdH0gZWxzZSBpZiAoc2V0dGluZ3MuY2VudGVyKSB7XFxuXFx0XFx0XFx0bWF4aW11bSA9IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDE7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRtYXhpbXVtID0gdGhpcy5faXRlbXMubGVuZ3RoIC0gc2V0dGluZ3MuaXRlbXM7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmIChyZWxhdGl2ZSkge1xcblxcdFxcdFxcdG1heGltdW0gLT0gdGhpcy5fY2xvbmVzLmxlbmd0aCAvIDI7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBNYXRoLm1heChtYXhpbXVtLCAwKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEdldHMgdGhlIG1pbmltdW0gcG9zaXRpb24gZm9yIHRoZSBjdXJyZW50IGl0ZW0uXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JlbGF0aXZlPWZhbHNlXSAtIFdoZXRoZXIgdG8gcmV0dXJuIGFuIGFic29sdXRlIHBvc2l0aW9uIG9yIGEgcmVsYXRpdmUgcG9zaXRpb24uXFxuXFx0ICogQHJldHVybnMge051bWJlcn1cXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLm1pbmltdW0gPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xcblxcdFxcdHJldHVybiByZWxhdGl2ZSA/IDAgOiB0aGlzLl9jbG9uZXMubGVuZ3RoIC8gMjtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEdldHMgYW4gaXRlbSBhdCB0aGUgc3BlY2lmaWVkIHJlbGF0aXZlIHBvc2l0aW9uLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKiBAcGFyYW0ge051bWJlcn0gW3Bvc2l0aW9uXSAtIFRoZSByZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgaXRlbS5cXG5cXHQgKiBAcmV0dXJuIHtqUXVlcnl8QXJyYXkuPGpRdWVyeT59IC0gVGhlIGl0ZW0gYXQgdGhlIGdpdmVuIHBvc2l0aW9uIG9yIGFsbCBpdGVtcyBpZiBubyBwb3NpdGlvbiB3YXMgZ2l2ZW4uXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5pdGVtcyA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XFxuXFx0XFx0aWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5faXRlbXMuc2xpY2UoKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cG9zaXRpb24gPSB0aGlzLm5vcm1hbGl6ZShwb3NpdGlvbiwgdHJ1ZSk7XFxuXFx0XFx0cmV0dXJuIHRoaXMuX2l0ZW1zW3Bvc2l0aW9uXTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEdldHMgYW4gaXRlbSBhdCB0aGUgc3BlY2lmaWVkIHJlbGF0aXZlIHBvc2l0aW9uLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKiBAcGFyYW0ge051bWJlcn0gW3Bvc2l0aW9uXSAtIFRoZSByZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgaXRlbS5cXG5cXHQgKiBAcmV0dXJuIHtqUXVlcnl8QXJyYXkuPGpRdWVyeT59IC0gVGhlIGl0ZW0gYXQgdGhlIGdpdmVuIHBvc2l0aW9uIG9yIGFsbCBpdGVtcyBpZiBubyBwb3NpdGlvbiB3YXMgZ2l2ZW4uXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5tZXJnZXJzID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcXG5cXHRcXHRpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLl9tZXJnZXJzLnNsaWNlKCk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHBvc2l0aW9uID0gdGhpcy5ub3JtYWxpemUocG9zaXRpb24sIHRydWUpO1xcblxcdFxcdHJldHVybiB0aGlzLl9tZXJnZXJzW3Bvc2l0aW9uXTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEdldHMgdGhlIGFic29sdXRlIHBvc2l0aW9ucyBvZiBjbG9uZXMgZm9yIGFuIGl0ZW0uXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqIEBwYXJhbSB7TnVtYmVyfSBbcG9zaXRpb25dIC0gVGhlIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBpdGVtLlxcblxcdCAqIEByZXR1cm5zIHtBcnJheS48TnVtYmVyPn0gLSBUaGUgYWJzb2x1dGUgcG9zaXRpb25zIG9mIGNsb25lcyBmb3IgdGhlIGl0ZW0gb3IgYWxsIGlmIG5vIHBvc2l0aW9uIHdhcyBnaXZlbi5cXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLmNsb25lcyA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XFxuXFx0XFx0dmFyIG9kZCA9IHRoaXMuX2Nsb25lcy5sZW5ndGggLyAyLFxcblxcdFxcdFxcdGV2ZW4gPSBvZGQgKyB0aGlzLl9pdGVtcy5sZW5ndGgsXFxuXFx0XFx0XFx0bWFwID0gZnVuY3Rpb24oaW5kZXgpIHsgcmV0dXJuIGluZGV4ICUgMiA9PT0gMCA/IGV2ZW4gKyBpbmRleCAvIDIgOiBvZGQgLSAoaW5kZXggKyAxKSAvIDIgfTtcXG5cXG5cXHRcXHRpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdHJldHVybiAkLm1hcCh0aGlzLl9jbG9uZXMsIGZ1bmN0aW9uKHYsIGkpIHsgcmV0dXJuIG1hcChpKSB9KTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuICQubWFwKHRoaXMuX2Nsb25lcywgZnVuY3Rpb24odiwgaSkgeyByZXR1cm4gdiA9PT0gcG9zaXRpb24gPyBtYXAoaSkgOiBudWxsIH0pO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogU2V0cyB0aGUgY3VycmVudCBhbmltYXRpb24gc3BlZWQuXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqIEBwYXJhbSB7TnVtYmVyfSBbc3BlZWRdIC0gVGhlIGFuaW1hdGlvbiBzcGVlZCBpbiBtaWxsaXNlY29uZHMgb3Igbm90aGluZyB0byBsZWF2ZSBpdCB1bmNoYW5nZWQuXFxuXFx0ICogQHJldHVybnMge051bWJlcn0gLSBUaGUgY3VycmVudCBhbmltYXRpb24gc3BlZWQgaW4gbWlsbGlzZWNvbmRzLlxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUuc3BlZWQgPSBmdW5jdGlvbihzcGVlZCkge1xcblxcdFxcdGlmIChzcGVlZCAhPT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0dGhpcy5fc3BlZWQgPSBzcGVlZDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXMuX3NwZWVkO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogR2V0cyB0aGUgY29vcmRpbmF0ZSBvZiBhbiBpdGVtLlxcblxcdCAqIEB0b2RvIFRoZSBuYW1lIG9mIHRoaXMgbWV0aG9kIGlzIG1pc3NsZWFuZGluZy5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIC0gVGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBpdGVtIHdpdGhpbiBgbWluaW11bSgpYCBhbmQgYG1heGltdW0oKWAuXFxuXFx0ICogQHJldHVybnMge051bWJlcnxBcnJheS48TnVtYmVyPn0gLSBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgaXRlbSBpbiBwaXhlbCBvciBhbGwgY29vcmRpbmF0ZXMuXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5jb29yZGluYXRlcyA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XFxuXFx0XFx0dmFyIG11bHRpcGxpZXIgPSAxLFxcblxcdFxcdFxcdG5ld1Bvc2l0aW9uID0gcG9zaXRpb24gLSAxLFxcblxcdFxcdFxcdGNvb3JkaW5hdGU7XFxuXFxuXFx0XFx0aWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRyZXR1cm4gJC5tYXAodGhpcy5fY29vcmRpbmF0ZXMsICQucHJveHkoZnVuY3Rpb24oY29vcmRpbmF0ZSwgaW5kZXgpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5jb29yZGluYXRlcyhpbmRleCk7XFxuXFx0XFx0XFx0fSwgdGhpcykpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5jZW50ZXIpIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5ydGwpIHtcXG5cXHRcXHRcXHRcXHRtdWx0aXBsaWVyID0gLTE7XFxuXFx0XFx0XFx0XFx0bmV3UG9zaXRpb24gPSBwb3NpdGlvbiArIDE7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGNvb3JkaW5hdGUgPSB0aGlzLl9jb29yZGluYXRlc1twb3NpdGlvbl07XFxuXFx0XFx0XFx0Y29vcmRpbmF0ZSArPSAodGhpcy53aWR0aCgpIC0gY29vcmRpbmF0ZSArICh0aGlzLl9jb29yZGluYXRlc1tuZXdQb3NpdGlvbl0gfHwgMCkpIC8gMiAqIG11bHRpcGxpZXI7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRjb29yZGluYXRlID0gdGhpcy5fY29vcmRpbmF0ZXNbbmV3UG9zaXRpb25dIHx8IDA7XFxuXFx0XFx0fVxcblxcblxcdFxcdGNvb3JkaW5hdGUgPSBNYXRoLmNlaWwoY29vcmRpbmF0ZSk7XFxuXFxuXFx0XFx0cmV0dXJuIGNvb3JkaW5hdGU7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBDYWxjdWxhdGVzIHRoZSBzcGVlZCBmb3IgYSB0cmFuc2xhdGlvbi5cXG5cXHQgKiBAcHJvdGVjdGVkXFxuXFx0ICogQHBhcmFtIHtOdW1iZXJ9IGZyb20gLSBUaGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIHN0YXJ0IGl0ZW0uXFxuXFx0ICogQHBhcmFtIHtOdW1iZXJ9IHRvIC0gVGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSB0YXJnZXQgaXRlbS5cXG5cXHQgKiBAcGFyYW0ge051bWJlcn0gW2ZhY3Rvcj11bmRlZmluZWRdIC0gVGhlIHRpbWUgZmFjdG9yIGluIG1pbGxpc2Vjb25kcy5cXG5cXHQgKiBAcmV0dXJucyB7TnVtYmVyfSAtIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIHRyYW5zbGF0aW9uLlxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUuZHVyYXRpb24gPSBmdW5jdGlvbihmcm9tLCB0bywgZmFjdG9yKSB7XFxuXFx0XFx0aWYgKGZhY3RvciA9PT0gMCkge1xcblxcdFxcdFxcdHJldHVybiAwO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgoTWF0aC5hYnModG8gLSBmcm9tKSwgMSksIDYpICogTWF0aC5hYnMoKGZhY3RvciB8fCB0aGlzLnNldHRpbmdzLnNtYXJ0U3BlZWQpKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFNsaWRlcyB0byB0aGUgc3BlY2lmaWVkIGl0ZW0uXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgaXRlbS5cXG5cXHQgKiBAcGFyYW0ge051bWJlcn0gW3NwZWVkXSAtIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIHRyYW5zaXRpb24uXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS50byA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBzcGVlZCkge1xcblxcdFxcdHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50KCksXFxuXFx0XFx0XFx0cmV2ZXJ0ID0gbnVsbCxcXG5cXHRcXHRcXHRkaXN0YW5jZSA9IHBvc2l0aW9uIC0gdGhpcy5yZWxhdGl2ZShjdXJyZW50KSxcXG5cXHRcXHRcXHRkaXJlY3Rpb24gPSAoZGlzdGFuY2UgPiAwKSAtIChkaXN0YW5jZSA8IDApLFxcblxcdFxcdFxcdGl0ZW1zID0gdGhpcy5faXRlbXMubGVuZ3RoLFxcblxcdFxcdFxcdG1pbmltdW0gPSB0aGlzLm1pbmltdW0oKSxcXG5cXHRcXHRcXHRtYXhpbXVtID0gdGhpcy5tYXhpbXVtKCk7XFxuXFxuXFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MubG9vcCkge1xcblxcdFxcdFxcdGlmICghdGhpcy5zZXR0aW5ncy5yZXdpbmQgJiYgTWF0aC5hYnMoZGlzdGFuY2UpID4gaXRlbXMgLyAyKSB7XFxuXFx0XFx0XFx0XFx0ZGlzdGFuY2UgKz0gZGlyZWN0aW9uICogLTEgKiBpdGVtcztcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cG9zaXRpb24gPSBjdXJyZW50ICsgZGlzdGFuY2U7XFxuXFx0XFx0XFx0cmV2ZXJ0ID0gKChwb3NpdGlvbiAtIG1pbmltdW0pICUgaXRlbXMgKyBpdGVtcykgJSBpdGVtcyArIG1pbmltdW07XFxuXFxuXFx0XFx0XFx0aWYgKHJldmVydCAhPT0gcG9zaXRpb24gJiYgcmV2ZXJ0IC0gZGlzdGFuY2UgPD0gbWF4aW11bSAmJiByZXZlcnQgLSBkaXN0YW5jZSA+IDApIHtcXG5cXHRcXHRcXHRcXHRjdXJyZW50ID0gcmV2ZXJ0IC0gZGlzdGFuY2U7XFxuXFx0XFx0XFx0XFx0cG9zaXRpb24gPSByZXZlcnQ7XFxuXFx0XFx0XFx0XFx0dGhpcy5yZXNldChjdXJyZW50KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSBlbHNlIGlmICh0aGlzLnNldHRpbmdzLnJld2luZCkge1xcblxcdFxcdFxcdG1heGltdW0gKz0gMTtcXG5cXHRcXHRcXHRwb3NpdGlvbiA9IChwb3NpdGlvbiAlIG1heGltdW0gKyBtYXhpbXVtKSAlIG1heGltdW07XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRwb3NpdGlvbiA9IE1hdGgubWF4KG1pbmltdW0sIE1hdGgubWluKG1heGltdW0sIHBvc2l0aW9uKSk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuc3BlZWQodGhpcy5kdXJhdGlvbihjdXJyZW50LCBwb3NpdGlvbiwgc3BlZWQpKTtcXG5cXHRcXHR0aGlzLmN1cnJlbnQocG9zaXRpb24pO1xcblxcblxcdFxcdGlmICh0aGlzLiRlbGVtZW50LmlzKCc6dmlzaWJsZScpKSB7XFxuXFx0XFx0XFx0dGhpcy51cGRhdGUoKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBTbGlkZXMgdG8gdGhlIG5leHQgaXRlbS5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzcGVlZF0gLSBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSB0cmFuc2l0aW9uLlxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKHNwZWVkKSB7XFxuXFx0XFx0c3BlZWQgPSBzcGVlZCB8fCBmYWxzZTtcXG5cXHRcXHR0aGlzLnRvKHRoaXMucmVsYXRpdmUodGhpcy5jdXJyZW50KCkpICsgMSwgc3BlZWQpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogU2xpZGVzIHRvIHRoZSBwcmV2aW91cyBpdGVtLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKiBAcGFyYW0ge051bWJlcn0gW3NwZWVkXSAtIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIHRyYW5zaXRpb24uXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24oc3BlZWQpIHtcXG5cXHRcXHRzcGVlZCA9IHNwZWVkIHx8IGZhbHNlO1xcblxcdFxcdHRoaXMudG8odGhpcy5yZWxhdGl2ZSh0aGlzLmN1cnJlbnQoKSkgLSAxLCBzcGVlZCk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBIYW5kbGVzIHRoZSBlbmQgb2YgYW4gYW5pbWF0aW9uLlxcblxcdCAqIEBwcm90ZWN0ZWRcXG5cXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBldmVudCBhcmd1bWVudHMuXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5vblRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbihldmVudCkge1xcblxcblxcdFxcdC8vIGlmIGNzczIgYW5pbWF0aW9uIHRoZW4gZXZlbnQgb2JqZWN0IGlzIHVuZGVmaW5lZFxcblxcdFxcdGlmIChldmVudCAhPT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XFxuXFxuXFx0XFx0XFx0Ly8gQ2F0Y2ggb25seSBvd2wtc3RhZ2UgdHJhbnNpdGlvbkVuZCBldmVudFxcblxcdFxcdFxcdGlmICgoZXZlbnQudGFyZ2V0IHx8IGV2ZW50LnNyY0VsZW1lbnQgfHwgZXZlbnQub3JpZ2luYWxUYXJnZXQpICE9PSB0aGlzLiRzdGFnZS5nZXQoMCkpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLmxlYXZlKCdhbmltYXRpbmcnKTtcXG5cXHRcXHR0aGlzLnRyaWdnZXIoJ3RyYW5zbGF0ZWQnKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEdldHMgdmlld3BvcnQgd2lkdGguXFxuXFx0ICogQHByb3RlY3RlZFxcblxcdCAqIEByZXR1cm4ge051bWJlcn0gLSBUaGUgd2lkdGggaW4gcGl4ZWwuXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS52aWV3cG9ydCA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdHZhciB3aWR0aDtcXG5cXHRcXHRpZiAodGhpcy5vcHRpb25zLnJlc3BvbnNpdmVCYXNlRWxlbWVudCAhPT0gd2luZG93KSB7XFxuXFx0XFx0XFx0d2lkdGggPSAkKHRoaXMub3B0aW9ucy5yZXNwb25zaXZlQmFzZUVsZW1lbnQpLndpZHRoKCk7XFxuXFx0XFx0fSBlbHNlIGlmICh3aW5kb3cuaW5uZXJXaWR0aCkge1xcblxcdFxcdFxcdHdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XFxuXFx0XFx0fSBlbHNlIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoKSB7XFxuXFx0XFx0XFx0d2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHR0aHJvdyAnQ2FuIG5vdCBkZXRlY3Qgdmlld3BvcnQgd2lkdGguJztcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIHdpZHRoO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogUmVwbGFjZXMgdGhlIGN1cnJlbnQgY29udGVudC5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICogQHBhcmFtIHtIVE1MRWxlbWVudHxqUXVlcnl8U3RyaW5nfSBjb250ZW50IC0gVGhlIG5ldyBjb250ZW50LlxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uKGNvbnRlbnQpIHtcXG5cXHRcXHR0aGlzLiRzdGFnZS5lbXB0eSgpO1xcblxcdFxcdHRoaXMuX2l0ZW1zID0gW107XFxuXFxuXFx0XFx0aWYgKGNvbnRlbnQpIHtcXG5cXHRcXHRcXHRjb250ZW50ID0gKGNvbnRlbnQgaW5zdGFuY2VvZiBqUXVlcnkpID8gY29udGVudCA6ICQoY29udGVudCk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICh0aGlzLnNldHRpbmdzLm5lc3RlZEl0ZW1TZWxlY3Rvcikge1xcblxcdFxcdFxcdGNvbnRlbnQgPSBjb250ZW50LmZpbmQoJy4nICsgdGhpcy5zZXR0aW5ncy5uZXN0ZWRJdGVtU2VsZWN0b3IpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRjb250ZW50LmZpbHRlcihmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5ub2RlVHlwZSA9PT0gMTtcXG5cXHRcXHR9KS5lYWNoKCQucHJveHkoZnVuY3Rpb24oaW5kZXgsIGl0ZW0pIHtcXG5cXHRcXHRcXHRpdGVtID0gdGhpcy5wcmVwYXJlKGl0ZW0pO1xcblxcdFxcdFxcdHRoaXMuJHN0YWdlLmFwcGVuZChpdGVtKTtcXG5cXHRcXHRcXHR0aGlzLl9pdGVtcy5wdXNoKGl0ZW0pO1xcblxcdFxcdFxcdHRoaXMuX21lcmdlcnMucHVzaChpdGVtLmZpbmQoJ1tkYXRhLW1lcmdlXScpLmFkZEJhY2soJ1tkYXRhLW1lcmdlXScpLmF0dHIoJ2RhdGEtbWVyZ2UnKSAqIDEgfHwgMSk7XFxuXFx0XFx0fSwgdGhpcykpO1xcblxcblxcdFxcdHRoaXMucmVzZXQodGhpcy5pc051bWVyaWModGhpcy5zZXR0aW5ncy5zdGFydFBvc2l0aW9uKSA/IHRoaXMuc2V0dGluZ3Muc3RhcnRQb3NpdGlvbiA6IDApO1xcblxcblxcdFxcdHRoaXMuaW52YWxpZGF0ZSgnaXRlbXMnKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEFkZHMgYW4gaXRlbS5cXG5cXHQgKiBAdG9kbyBVc2UgYGl0ZW1gIGluc3RlYWQgb2YgYGNvbnRlbnRgIGZvciB0aGUgZXZlbnQgYXJndW1lbnRzLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fGpRdWVyeXxTdHJpbmd9IGNvbnRlbnQgLSBUaGUgaXRlbSBjb250ZW50IHRvIGFkZC5cXG5cXHQgKiBAcGFyYW0ge051bWJlcn0gW3Bvc2l0aW9uXSAtIFRoZSByZWxhdGl2ZSBwb3NpdGlvbiBhdCB3aGljaCB0byBpbnNlcnQgdGhlIGl0ZW0gb3RoZXJ3aXNlIHRoZSBpdGVtIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGVuZC5cXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGNvbnRlbnQsIHBvc2l0aW9uKSB7XFxuXFx0XFx0dmFyIGN1cnJlbnQgPSB0aGlzLnJlbGF0aXZlKHRoaXMuX2N1cnJlbnQpO1xcblxcblxcdFxcdHBvc2l0aW9uID0gcG9zaXRpb24gPT09IHVuZGVmaW5lZCA/IHRoaXMuX2l0ZW1zLmxlbmd0aCA6IHRoaXMubm9ybWFsaXplKHBvc2l0aW9uLCB0cnVlKTtcXG5cXHRcXHRjb250ZW50ID0gY29udGVudCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRlbnQgOiAkKGNvbnRlbnQpO1xcblxcblxcdFxcdHRoaXMudHJpZ2dlcignYWRkJywgeyBjb250ZW50OiBjb250ZW50LCBwb3NpdGlvbjogcG9zaXRpb24gfSk7XFxuXFxuXFx0XFx0Y29udGVudCA9IHRoaXMucHJlcGFyZShjb250ZW50KTtcXG5cXG5cXHRcXHRpZiAodGhpcy5faXRlbXMubGVuZ3RoID09PSAwIHx8IHBvc2l0aW9uID09PSB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcXG5cXHRcXHRcXHR0aGlzLl9pdGVtcy5sZW5ndGggPT09IDAgJiYgdGhpcy4kc3RhZ2UuYXBwZW5kKGNvbnRlbnQpO1xcblxcdFxcdFxcdHRoaXMuX2l0ZW1zLmxlbmd0aCAhPT0gMCAmJiB0aGlzLl9pdGVtc1twb3NpdGlvbiAtIDFdLmFmdGVyKGNvbnRlbnQpO1xcblxcdFxcdFxcdHRoaXMuX2l0ZW1zLnB1c2goY29udGVudCk7XFxuXFx0XFx0XFx0dGhpcy5fbWVyZ2Vycy5wdXNoKGNvbnRlbnQuZmluZCgnW2RhdGEtbWVyZ2VdJykuYWRkQmFjaygnW2RhdGEtbWVyZ2VdJykuYXR0cignZGF0YS1tZXJnZScpICogMSB8fCAxKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHRoaXMuX2l0ZW1zW3Bvc2l0aW9uXS5iZWZvcmUoY29udGVudCk7XFxuXFx0XFx0XFx0dGhpcy5faXRlbXMuc3BsaWNlKHBvc2l0aW9uLCAwLCBjb250ZW50KTtcXG5cXHRcXHRcXHR0aGlzLl9tZXJnZXJzLnNwbGljZShwb3NpdGlvbiwgMCwgY29udGVudC5maW5kKCdbZGF0YS1tZXJnZV0nKS5hZGRCYWNrKCdbZGF0YS1tZXJnZV0nKS5hdHRyKCdkYXRhLW1lcmdlJykgKiAxIHx8IDEpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLl9pdGVtc1tjdXJyZW50XSAmJiB0aGlzLnJlc2V0KHRoaXMuX2l0ZW1zW2N1cnJlbnRdLmluZGV4KCkpO1xcblxcblxcdFxcdHRoaXMuaW52YWxpZGF0ZSgnaXRlbXMnKTtcXG5cXG5cXHRcXHR0aGlzLnRyaWdnZXIoJ2FkZGVkJywgeyBjb250ZW50OiBjb250ZW50LCBwb3NpdGlvbjogcG9zaXRpb24gfSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBSZW1vdmVzIGFuIGl0ZW0gYnkgaXRzIHBvc2l0aW9uLlxcblxcdCAqIEB0b2RvIFVzZSBgaXRlbWAgaW5zdGVhZCBvZiBgY29udGVudGAgZm9yIHRoZSBldmVudCBhcmd1bWVudHMuXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiAtIFRoZSByZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgaXRlbSB0byByZW1vdmUuXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihwb3NpdGlvbikge1xcblxcdFxcdHBvc2l0aW9uID0gdGhpcy5ub3JtYWxpemUocG9zaXRpb24sIHRydWUpO1xcblxcblxcdFxcdGlmIChwb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLnRyaWdnZXIoJ3JlbW92ZScsIHsgY29udGVudDogdGhpcy5faXRlbXNbcG9zaXRpb25dLCBwb3NpdGlvbjogcG9zaXRpb24gfSk7XFxuXFxuXFx0XFx0dGhpcy5faXRlbXNbcG9zaXRpb25dLnJlbW92ZSgpO1xcblxcdFxcdHRoaXMuX2l0ZW1zLnNwbGljZShwb3NpdGlvbiwgMSk7XFxuXFx0XFx0dGhpcy5fbWVyZ2Vycy5zcGxpY2UocG9zaXRpb24sIDEpO1xcblxcblxcdFxcdHRoaXMuaW52YWxpZGF0ZSgnaXRlbXMnKTtcXG5cXG5cXHRcXHR0aGlzLnRyaWdnZXIoJ3JlbW92ZWQnLCB7IGNvbnRlbnQ6IG51bGwsIHBvc2l0aW9uOiBwb3NpdGlvbiB9KTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFByZWxvYWRzIGltYWdlcyB3aXRoIGF1dG8gd2lkdGguXFxuXFx0ICogQHRvZG8gUmVwbGFjZSBieSBhIG1vcmUgZ2VuZXJpYyBhcHByb2FjaFxcblxcdCAqIEBwcm90ZWN0ZWRcXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLnByZWxvYWRBdXRvV2lkdGhJbWFnZXMgPSBmdW5jdGlvbihpbWFnZXMpIHtcXG5cXHRcXHRpbWFnZXMuZWFjaCgkLnByb3h5KGZ1bmN0aW9uKGksIGVsZW1lbnQpIHtcXG5cXHRcXHRcXHR0aGlzLmVudGVyKCdwcmUtbG9hZGluZycpO1xcblxcdFxcdFxcdGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xcblxcdFxcdFxcdCQobmV3IEltYWdlKCkpLm9uZSgnbG9hZCcsICQucHJveHkoZnVuY3Rpb24oZSkge1xcblxcdFxcdFxcdFxcdGVsZW1lbnQuYXR0cignc3JjJywgZS50YXJnZXQuc3JjKTtcXG5cXHRcXHRcXHRcXHRlbGVtZW50LmNzcygnb3BhY2l0eScsIDEpO1xcblxcdFxcdFxcdFxcdHRoaXMubGVhdmUoJ3ByZS1sb2FkaW5nJyk7XFxuXFx0XFx0XFx0XFx0IXRoaXMuaXMoJ3ByZS1sb2FkaW5nJykgJiYgIXRoaXMuaXMoJ2luaXRpYWxpemluZycpICYmIHRoaXMucmVmcmVzaCgpO1xcblxcdFxcdFxcdH0sIHRoaXMpKS5hdHRyKCdzcmMnLCBlbGVtZW50LmF0dHIoJ3NyYycpIHx8IGVsZW1lbnQuYXR0cignZGF0YS1zcmMnKSB8fCBlbGVtZW50LmF0dHIoJ2RhdGEtc3JjLXJldGluYScpKTtcXG5cXHRcXHR9LCB0aGlzKSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBEZXN0cm95cyB0aGUgY2Fyb3VzZWwuXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xcblxcblxcdFxcdHRoaXMuJGVsZW1lbnQub2ZmKCcub3dsLmNvcmUnKTtcXG5cXHRcXHR0aGlzLiRzdGFnZS5vZmYoJy5vd2wuY29yZScpO1xcblxcdFxcdCQoZG9jdW1lbnQpLm9mZignLm93bC5jb3JlJyk7XFxuXFxuXFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MucmVzcG9uc2l2ZSAhPT0gZmFsc2UpIHtcXG5cXHRcXHRcXHR3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMucmVzaXplVGltZXIpO1xcblxcdFxcdFxcdHRoaXMub2ZmKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX2hhbmRsZXJzLm9uVGhyb3R0bGVkUmVzaXplKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9wbHVnaW5zKSB7XFxuXFx0XFx0XFx0dGhpcy5fcGx1Z2luc1tpXS5kZXN0cm95KCk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuJHN0YWdlLmNoaWxkcmVuKCcuY2xvbmVkJykucmVtb3ZlKCk7XFxuXFxuXFx0XFx0dGhpcy4kc3RhZ2UudW53cmFwKCk7XFxuXFx0XFx0dGhpcy4kc3RhZ2UuY2hpbGRyZW4oKS5jb250ZW50cygpLnVud3JhcCgpO1xcblxcdFxcdHRoaXMuJHN0YWdlLmNoaWxkcmVuKCkudW53cmFwKCk7XFxuXFxuXFx0XFx0dGhpcy4kZWxlbWVudFxcblxcdFxcdFxcdC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMucmVmcmVzaENsYXNzKVxcblxcdFxcdFxcdC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMubG9hZGluZ0NsYXNzKVxcblxcdFxcdFxcdC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMubG9hZGVkQ2xhc3MpXFxuXFx0XFx0XFx0LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5ydGxDbGFzcylcXG5cXHRcXHRcXHQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmRyYWdDbGFzcylcXG5cXHRcXHRcXHQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmdyYWJDbGFzcylcXG5cXHRcXHRcXHQuYXR0cignY2xhc3MnLCB0aGlzLiRlbGVtZW50LmF0dHIoJ2NsYXNzJykucmVwbGFjZShuZXcgUmVnRXhwKHRoaXMub3B0aW9ucy5yZXNwb25zaXZlQ2xhc3MgKyAnLVxcXFxcXFxcUytcXFxcXFxcXHMnLCAnZycpLCAnJykpXFxuXFx0XFx0XFx0LnJlbW92ZURhdGEoJ293bC5jYXJvdXNlbCcpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogT3BlcmF0b3JzIHRvIGNhbGN1bGF0ZSByaWdodC10by1sZWZ0IGFuZCBsZWZ0LXRvLXJpZ2h0LlxcblxcdCAqIEBwcm90ZWN0ZWRcXG5cXHQgKiBAcGFyYW0ge051bWJlcn0gW2FdIC0gVGhlIGxlZnQgc2lkZSBvcGVyYW5kLlxcblxcdCAqIEBwYXJhbSB7U3RyaW5nfSBbb10gLSBUaGUgb3BlcmF0b3IuXFxuXFx0ICogQHBhcmFtIHtOdW1iZXJ9IFtiXSAtIFRoZSByaWdodCBzaWRlIG9wZXJhbmQuXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5vcCA9IGZ1bmN0aW9uKGEsIG8sIGIpIHtcXG5cXHRcXHR2YXIgcnRsID0gdGhpcy5zZXR0aW5ncy5ydGw7XFxuXFx0XFx0c3dpdGNoIChvKSB7XFxuXFx0XFx0XFx0Y2FzZSAnPCc6XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJ0bCA/IGEgPiBiIDogYSA8IGI7XFxuXFx0XFx0XFx0Y2FzZSAnPic6XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJ0bCA/IGEgPCBiIDogYSA+IGI7XFxuXFx0XFx0XFx0Y2FzZSAnPj0nOlxcblxcdFxcdFxcdFxcdHJldHVybiBydGwgPyBhIDw9IGIgOiBhID49IGI7XFxuXFx0XFx0XFx0Y2FzZSAnPD0nOlxcblxcdFxcdFxcdFxcdHJldHVybiBydGwgPyBhID49IGIgOiBhIDw9IGI7XFxuXFx0XFx0XFx0ZGVmYXVsdDpcXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBBdHRhY2hlcyB0byBhbiBpbnRlcm5hbCBldmVudC5cXG5cXHQgKiBAcHJvdGVjdGVkXFxuXFx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIFRoZSBldmVudCBzb3VyY2UuXFxuXFx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IC0gVGhlIGV2ZW50IG5hbWUuXFxuXFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgLSBUaGUgZXZlbnQgaGFuZGxlciB0byBhdHRhY2guXFxuXFx0ICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlIC0gV2V0aGVyIHRoZSBldmVudCBzaG91bGQgYmUgaGFuZGxlZCBhdCB0aGUgY2FwdHVyaW5nIHBoYXNlIG9yIG5vdC5cXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZWxlbWVudCwgZXZlbnQsIGxpc3RlbmVyLCBjYXB0dXJlKSB7XFxuXFx0XFx0aWYgKGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xcblxcdFxcdFxcdGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGNhcHR1cmUpO1xcblxcdFxcdH0gZWxzZSBpZiAoZWxlbWVudC5hdHRhY2hFdmVudCkge1xcblxcdFxcdFxcdGVsZW1lbnQuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogRGV0YWNoZXMgZnJvbSBhbiBpbnRlcm5hbCBldmVudC5cXG5cXHQgKiBAcHJvdGVjdGVkXFxuXFx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIFRoZSBldmVudCBzb3VyY2UuXFxuXFx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IC0gVGhlIGV2ZW50IG5hbWUuXFxuXFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgLSBUaGUgYXR0YWNoZWQgZXZlbnQgaGFuZGxlciB0byBkZXRhY2guXFxuXFx0ICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlIC0gV2V0aGVyIHRoZSBhdHRhY2hlZCBldmVudCBoYW5kbGVyIHdhcyByZWdpc3RlcmVkIGFzIGEgY2FwdHVyaW5nIGxpc3RlbmVyIG9yIG5vdC5cXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKGVsZW1lbnQsIGV2ZW50LCBsaXN0ZW5lciwgY2FwdHVyZSkge1xcblxcdFxcdGlmIChlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcXG5cXHRcXHRcXHRlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBjYXB0dXJlKTtcXG5cXHRcXHR9IGVsc2UgaWYgKGVsZW1lbnQuZGV0YWNoRXZlbnQpIHtcXG5cXHRcXHRcXHRlbGVtZW50LmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFRyaWdnZXJzIGEgcHVibGljIGV2ZW50LlxcblxcdCAqIEB0b2RvIFJlbW92ZSBgc3RhdHVzYCwgYHJlbGF0ZWRUYXJnZXRgIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXFxuXFx0ICogQHByb3RlY3RlZFxcblxcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gVGhlIGV2ZW50IG5hbWUuXFxuXFx0ICogQHBhcmFtIHsqfSBbZGF0YT1udWxsXSAtIFRoZSBldmVudCBkYXRhLlxcblxcdCAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZXNwYWNlPWNhcm91c2VsXSAtIFRoZSBldmVudCBuYW1lc3BhY2UuXFxuXFx0ICogQHBhcmFtIHtTdHJpbmd9IFtzdGF0ZV0gLSBUaGUgc3RhdGUgd2hpY2ggaXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBldmVudC5cXG5cXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtlbnRlcj1mYWxzZV0gLSBJbmRpY2F0ZXMgaWYgdGhlIGNhbGwgZW50ZXJzIHRoZSBzcGVjaWZpZWQgc3RhdGUgb3Igbm90LlxcblxcdCAqIEByZXR1cm5zIHtFdmVudH0gLSBUaGUgZXZlbnQgYXJndW1lbnRzLlxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uKG5hbWUsIGRhdGEsIG5hbWVzcGFjZSwgc3RhdGUsIGVudGVyKSB7XFxuXFx0XFx0dmFyIHN0YXR1cyA9IHtcXG5cXHRcXHRcXHRpdGVtOiB7IGNvdW50OiB0aGlzLl9pdGVtcy5sZW5ndGgsIGluZGV4OiB0aGlzLmN1cnJlbnQoKSB9XFxuXFx0XFx0fSwgaGFuZGxlciA9ICQuY2FtZWxDYXNlKFxcblxcdFxcdFxcdCQuZ3JlcChbICdvbicsIG5hbWUsIG5hbWVzcGFjZSBdLCBmdW5jdGlvbih2KSB7IHJldHVybiB2IH0pXFxuXFx0XFx0XFx0XFx0LmpvaW4oJy0nKS50b0xvd2VyQ2FzZSgpXFxuXFx0XFx0KSwgZXZlbnQgPSAkLkV2ZW50KFxcblxcdFxcdFxcdFsgbmFtZSwgJ293bCcsIG5hbWVzcGFjZSB8fCAnY2Fyb3VzZWwnIF0uam9pbignLicpLnRvTG93ZXJDYXNlKCksXFxuXFx0XFx0XFx0JC5leHRlbmQoeyByZWxhdGVkVGFyZ2V0OiB0aGlzIH0sIHN0YXR1cywgZGF0YSlcXG5cXHRcXHQpO1xcblxcblxcdFxcdGlmICghdGhpcy5fc3VwcmVzc1tuYW1lXSkge1xcblxcdFxcdFxcdCQuZWFjaCh0aGlzLl9wbHVnaW5zLCBmdW5jdGlvbihuYW1lLCBwbHVnaW4pIHtcXG5cXHRcXHRcXHRcXHRpZiAocGx1Z2luLm9uVHJpZ2dlcikge1xcblxcdFxcdFxcdFxcdFxcdHBsdWdpbi5vblRyaWdnZXIoZXZlbnQpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHR0aGlzLnJlZ2lzdGVyKHsgdHlwZTogT3dsLlR5cGUuRXZlbnQsIG5hbWU6IG5hbWUgfSk7XFxuXFx0XFx0XFx0dGhpcy4kZWxlbWVudC50cmlnZ2VyKGV2ZW50KTtcXG5cXG5cXHRcXHRcXHRpZiAodGhpcy5zZXR0aW5ncyAmJiB0eXBlb2YgdGhpcy5zZXR0aW5nc1toYW5kbGVyXSA9PT0gJ2Z1bmN0aW9uJykge1xcblxcdFxcdFxcdFxcdHRoaXMuc2V0dGluZ3NbaGFuZGxlcl0uY2FsbCh0aGlzLCBldmVudCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gZXZlbnQ7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBFbnRlcnMgYSBzdGF0ZS5cXG5cXHQgKiBAcGFyYW0gbmFtZSAtIFRoZSBzdGF0ZSBuYW1lLlxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUuZW50ZXIgPSBmdW5jdGlvbihuYW1lKSB7XFxuXFx0XFx0JC5lYWNoKFsgbmFtZSBdLmNvbmNhdCh0aGlzLl9zdGF0ZXMudGFnc1tuYW1lXSB8fCBbXSksICQucHJveHkoZnVuY3Rpb24oaSwgbmFtZSkge1xcblxcdFxcdFxcdGlmICh0aGlzLl9zdGF0ZXMuY3VycmVudFtuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fc3RhdGVzLmN1cnJlbnRbbmFtZV0gPSAwO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLl9zdGF0ZXMuY3VycmVudFtuYW1lXSsrO1xcblxcdFxcdH0sIHRoaXMpKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIExlYXZlcyBhIHN0YXRlLlxcblxcdCAqIEBwYXJhbSBuYW1lIC0gVGhlIHN0YXRlIG5hbWUuXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5sZWF2ZSA9IGZ1bmN0aW9uKG5hbWUpIHtcXG5cXHRcXHQkLmVhY2goWyBuYW1lIF0uY29uY2F0KHRoaXMuX3N0YXRlcy50YWdzW25hbWVdIHx8IFtdKSwgJC5wcm94eShmdW5jdGlvbihpLCBuYW1lKSB7XFxuXFx0XFx0XFx0dGhpcy5fc3RhdGVzLmN1cnJlbnRbbmFtZV0tLTtcXG5cXHRcXHR9LCB0aGlzKSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBSZWdpc3RlcnMgYW4gZXZlbnQgb3Igc3RhdGUuXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBUaGUgZXZlbnQgb3Igc3RhdGUgdG8gcmVnaXN0ZXIuXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uKG9iamVjdCkge1xcblxcdFxcdGlmIChvYmplY3QudHlwZSA9PT0gT3dsLlR5cGUuRXZlbnQpIHtcXG5cXHRcXHRcXHRpZiAoISQuZXZlbnQuc3BlY2lhbFtvYmplY3QubmFtZV0pIHtcXG5cXHRcXHRcXHRcXHQkLmV2ZW50LnNwZWNpYWxbb2JqZWN0Lm5hbWVdID0ge307XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICghJC5ldmVudC5zcGVjaWFsW29iamVjdC5uYW1lXS5vd2wpIHtcXG5cXHRcXHRcXHRcXHR2YXIgX2RlZmF1bHQgPSAkLmV2ZW50LnNwZWNpYWxbb2JqZWN0Lm5hbWVdLl9kZWZhdWx0O1xcblxcdFxcdFxcdFxcdCQuZXZlbnQuc3BlY2lhbFtvYmplY3QubmFtZV0uX2RlZmF1bHQgPSBmdW5jdGlvbihlKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKF9kZWZhdWx0ICYmIF9kZWZhdWx0LmFwcGx5ICYmICghZS5uYW1lc3BhY2UgfHwgZS5uYW1lc3BhY2UuaW5kZXhPZignb3dsJykgPT09IC0xKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBfZGVmYXVsdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZS5uYW1lc3BhY2UgJiYgZS5uYW1lc3BhY2UuaW5kZXhPZignb3dsJykgPiAtMTtcXG5cXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdCQuZXZlbnQuc3BlY2lhbFtvYmplY3QubmFtZV0ub3dsID0gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSBlbHNlIGlmIChvYmplY3QudHlwZSA9PT0gT3dsLlR5cGUuU3RhdGUpIHtcXG5cXHRcXHRcXHRpZiAoIXRoaXMuX3N0YXRlcy50YWdzW29iamVjdC5uYW1lXSkge1xcblxcdFxcdFxcdFxcdHRoaXMuX3N0YXRlcy50YWdzW29iamVjdC5uYW1lXSA9IG9iamVjdC50YWdzO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fc3RhdGVzLnRhZ3Nbb2JqZWN0Lm5hbWVdID0gdGhpcy5fc3RhdGVzLnRhZ3Nbb2JqZWN0Lm5hbWVdLmNvbmNhdChvYmplY3QudGFncyk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuX3N0YXRlcy50YWdzW29iamVjdC5uYW1lXSA9ICQuZ3JlcCh0aGlzLl9zdGF0ZXMudGFnc1tvYmplY3QubmFtZV0sICQucHJveHkoZnVuY3Rpb24odGFnLCBpKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuICQuaW5BcnJheSh0YWcsIHRoaXMuX3N0YXRlcy50YWdzW29iamVjdC5uYW1lXSkgPT09IGk7XFxuXFx0XFx0XFx0fSwgdGhpcykpO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFN1cHByZXNzZXMgZXZlbnRzLlxcblxcdCAqIEBwcm90ZWN0ZWRcXG5cXHQgKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSBldmVudHMgLSBUaGUgZXZlbnRzIHRvIHN1cHByZXNzLlxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUuc3VwcHJlc3MgPSBmdW5jdGlvbihldmVudHMpIHtcXG5cXHRcXHQkLmVhY2goZXZlbnRzLCAkLnByb3h5KGZ1bmN0aW9uKGluZGV4LCBldmVudCkge1xcblxcdFxcdFxcdHRoaXMuX3N1cHJlc3NbZXZlbnRdID0gdHJ1ZTtcXG5cXHRcXHR9LCB0aGlzKSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBSZWxlYXNlcyBzdXBwcmVzc2VkIGV2ZW50cy5cXG5cXHQgKiBAcHJvdGVjdGVkXFxuXFx0ICogQHBhcmFtIHtBcnJheS48U3RyaW5nPn0gZXZlbnRzIC0gVGhlIGV2ZW50cyB0byByZWxlYXNlLlxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uKGV2ZW50cykge1xcblxcdFxcdCQuZWFjaChldmVudHMsICQucHJveHkoZnVuY3Rpb24oaW5kZXgsIGV2ZW50KSB7XFxuXFx0XFx0XFx0ZGVsZXRlIHRoaXMuX3N1cHJlc3NbZXZlbnRdO1xcblxcdFxcdH0sIHRoaXMpKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEdldHMgdW5pZmllZCBwb2ludGVyIGNvb3JkaW5hdGVzIGZyb20gZXZlbnQuXFxuXFx0ICogQHRvZG8gIzI2MVxcblxcdCAqIEBwcm90ZWN0ZWRcXG5cXHQgKiBAcGFyYW0ge0V2ZW50fSAtIFRoZSBgbW91c2Vkb3duYCBvciBgdG91Y2hzdGFydGAgZXZlbnQuXFxuXFx0ICogQHJldHVybnMge09iamVjdH0gLSBDb250YWlucyBgeGAgYW5kIGB5YCBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBvaW50ZXIgcG9zaXRpb24uXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5wb2ludGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcXG5cXHRcXHR2YXIgcmVzdWx0ID0geyB4OiBudWxsLCB5OiBudWxsIH07XFxuXFxuXFx0XFx0ZXZlbnQgPSBldmVudC5vcmlnaW5hbEV2ZW50IHx8IGV2ZW50IHx8IHdpbmRvdy5ldmVudDtcXG5cXG5cXHRcXHRldmVudCA9IGV2ZW50LnRvdWNoZXMgJiYgZXZlbnQudG91Y2hlcy5sZW5ndGggP1xcblxcdFxcdFxcdGV2ZW50LnRvdWNoZXNbMF0gOiBldmVudC5jaGFuZ2VkVG91Y2hlcyAmJiBldmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggP1xcblxcdFxcdFxcdFxcdGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdIDogZXZlbnQ7XFxuXFxuXFx0XFx0aWYgKGV2ZW50LnBhZ2VYKSB7XFxuXFx0XFx0XFx0cmVzdWx0LnggPSBldmVudC5wYWdlWDtcXG5cXHRcXHRcXHRyZXN1bHQueSA9IGV2ZW50LnBhZ2VZO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0cmVzdWx0LnggPSBldmVudC5jbGllbnRYO1xcblxcdFxcdFxcdHJlc3VsdC55ID0gZXZlbnQuY2xpZW50WTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHJlc3VsdDtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIERldGVybWluZXMgaWYgdGhlIGlucHV0IGlzIGEgTnVtYmVyIG9yIHNvbWV0aGluZyB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIGEgTnVtYmVyXFxuXFx0ICogQHByb3RlY3RlZFxcblxcdCAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xPYmplY3R8QXJyYXl8Qm9vbGVhbnxSZWdFeHB8RnVuY3Rpb258U3ltYm9sfSAtIFRoZSBpbnB1dCB0byBiZSB0ZXN0ZWRcXG5cXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSBBbiBpbmRpY2F0aW9uIGlmIHRoZSBpbnB1dCBpcyBhIE51bWJlciBvciBjYW4gYmUgY29lcmNlZCB0byBhIE51bWJlclxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUuaXNOdW1lcmljID0gZnVuY3Rpb24obnVtYmVyKSB7XFxuXFx0XFx0cmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG51bWJlcikpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogR2V0cyB0aGUgZGlmZmVyZW5jZSBvZiB0d28gdmVjdG9ycy5cXG5cXHQgKiBAdG9kbyAjMjYxXFxuXFx0ICogQHByb3RlY3RlZFxcblxcdCAqIEBwYXJhbSB7T2JqZWN0fSAtIFRoZSBmaXJzdCB2ZWN0b3IuXFxuXFx0ICogQHBhcmFtIHtPYmplY3R9IC0gVGhlIHNlY29uZCB2ZWN0b3IuXFxuXFx0ICogQHJldHVybnMge09iamVjdH0gLSBUaGUgZGlmZmVyZW5jZS5cXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLmRpZmZlcmVuY2UgPSBmdW5jdGlvbihmaXJzdCwgc2Vjb25kKSB7XFxuXFx0XFx0cmV0dXJuIHtcXG5cXHRcXHRcXHR4OiBmaXJzdC54IC0gc2Vjb25kLngsXFxuXFx0XFx0XFx0eTogZmlyc3QueSAtIHNlY29uZC55XFxuXFx0XFx0fTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFRoZSBqUXVlcnkgUGx1Z2luIGZvciB0aGUgT3dsIENhcm91c2VsXFxuXFx0ICogQHRvZG8gTmF2aWdhdGlvbiBwbHVnaW4gYG5leHRgIGFuZCBgcHJldmBcXG5cXHQgKiBAcHVibGljXFxuXFx0ICovXFxuXFx0JC5mbi5vd2xDYXJvdXNlbCA9IGZ1bmN0aW9uKG9wdGlvbikge1xcblxcdFxcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcXG5cXG5cXHRcXHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHZhciAkdGhpcyA9ICQodGhpcyksXFxuXFx0XFx0XFx0XFx0ZGF0YSA9ICR0aGlzLmRhdGEoJ293bC5jYXJvdXNlbCcpO1xcblxcblxcdFxcdFxcdGlmICghZGF0YSkge1xcblxcdFxcdFxcdFxcdGRhdGEgPSBuZXcgT3dsKHRoaXMsIHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uKTtcXG5cXHRcXHRcXHRcXHQkdGhpcy5kYXRhKCdvd2wuY2Fyb3VzZWwnLCBkYXRhKTtcXG5cXG5cXHRcXHRcXHRcXHQkLmVhY2goW1xcblxcdFxcdFxcdFxcdFxcdCduZXh0JywgJ3ByZXYnLCAndG8nLCAnZGVzdHJveScsICdyZWZyZXNoJywgJ3JlcGxhY2UnLCAnYWRkJywgJ3JlbW92ZSdcXG5cXHRcXHRcXHRcXHRdLCBmdW5jdGlvbihpLCBldmVudCkge1xcblxcdFxcdFxcdFxcdFxcdGRhdGEucmVnaXN0ZXIoeyB0eXBlOiBPd2wuVHlwZS5FdmVudCwgbmFtZTogZXZlbnQgfSk7XFxuXFx0XFx0XFx0XFx0XFx0ZGF0YS4kZWxlbWVudC5vbihldmVudCArICcub3dsLmNhcm91c2VsLmNvcmUnLCAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgZS5yZWxhdGVkVGFyZ2V0ICE9PSB0aGlzKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5zdXBwcmVzcyhbIGV2ZW50IF0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGFbZXZlbnRdLmFwcGx5KHRoaXMsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5yZWxlYXNlKFsgZXZlbnQgXSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH0sIGRhdGEpKTtcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycgJiYgb3B0aW9uLmNoYXJBdCgwKSAhPT0gJ18nKSB7XFxuXFx0XFx0XFx0XFx0ZGF0YVtvcHRpb25dLmFwcGx5KGRhdGEsIGFyZ3MpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9KTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFRoZSBjb25zdHJ1Y3RvciBmb3IgdGhlIGpRdWVyeSBQbHVnaW5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICovXFxuXFx0JC5mbi5vd2xDYXJvdXNlbC5Db25zdHJ1Y3RvciA9IE93bDtcXG5cXG59KSh3aW5kb3cuWmVwdG8gfHwgX193ZWJwYWNrX3Byb3ZpZGVkX3dpbmRvd19kb3RfalF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50KTtcXG5cXG4vKipcXG4gKiBBdXRvUmVmcmVzaCBQbHVnaW5cXG4gKiBAdmVyc2lvbiAyLjEuMFxcbiAqIEBhdXRob3IgQXJ0dXMgS29sYW5vd3NraVxcbiAqIEBhdXRob3IgRGF2aWQgRGV1dHNjaFxcbiAqIEBsaWNlbnNlIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxcbiAqL1xcbjsoZnVuY3Rpb24oJCwgd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XFxuXFxuXFx0LyoqXFxuXFx0ICogQ3JlYXRlcyB0aGUgYXV0byByZWZyZXNoIHBsdWdpbi5cXG5cXHQgKiBAY2xhc3MgVGhlIEF1dG8gUmVmcmVzaCBQbHVnaW5cXG5cXHQgKiBAcGFyYW0ge093bH0gY2Fyb3VzZWwgLSBUaGUgT3dsIENhcm91c2VsXFxuXFx0ICovXFxuXFx0dmFyIEF1dG9SZWZyZXNoID0gZnVuY3Rpb24oY2Fyb3VzZWwpIHtcXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBSZWZlcmVuY2UgdG8gdGhlIGNvcmUuXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqIEB0eXBlIHtPd2x9XFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5fY29yZSA9IGNhcm91c2VsO1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIFJlZnJlc2ggaW50ZXJ2YWwuXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqIEB0eXBlIHtudW1iZXJ9XFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5faW50ZXJ2YWwgPSBudWxsO1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIFdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgY3VycmVudGx5IHZpc2libGUgb3Igbm90LlxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKiBAdHlwZSB7Qm9vbGVhbn1cXG5cXHRcXHQgKi9cXG5cXHRcXHR0aGlzLl92aXNpYmxlID0gbnVsbDtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBBbGwgZXZlbnQgaGFuZGxlcnMuXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqIEB0eXBlIHtPYmplY3R9XFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5faGFuZGxlcnMgPSB7XFxuXFx0XFx0XFx0J2luaXRpYWxpemVkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLm5hbWVzcGFjZSAmJiB0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9SZWZyZXNoKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy53YXRjaCgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKVxcblxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gc2V0IGRlZmF1bHQgb3B0aW9uc1xcblxcdFxcdHRoaXMuX2NvcmUub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBBdXRvUmVmcmVzaC5EZWZhdWx0cywgdGhpcy5fY29yZS5vcHRpb25zKTtcXG5cXG5cXHRcXHQvLyByZWdpc3RlciBldmVudCBoYW5kbGVyc1xcblxcdFxcdHRoaXMuX2NvcmUuJGVsZW1lbnQub24odGhpcy5faGFuZGxlcnMpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogRGVmYXVsdCBvcHRpb25zLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKi9cXG5cXHRBdXRvUmVmcmVzaC5EZWZhdWx0cyA9IHtcXG5cXHRcXHRhdXRvUmVmcmVzaDogdHJ1ZSxcXG5cXHRcXHRhdXRvUmVmcmVzaEludGVydmFsOiA1MDBcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFdhdGNoZXMgdGhlIGVsZW1lbnQuXFxuXFx0ICovXFxuXFx0QXV0b1JlZnJlc2gucHJvdG90eXBlLndhdGNoID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0aWYgKHRoaXMuX2ludGVydmFsKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLl92aXNpYmxlID0gdGhpcy5fY29yZS4kZWxlbWVudC5pcygnOnZpc2libGUnKTtcXG5cXHRcXHR0aGlzLl9pbnRlcnZhbCA9IHdpbmRvdy5zZXRJbnRlcnZhbCgkLnByb3h5KHRoaXMucmVmcmVzaCwgdGhpcyksIHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b1JlZnJlc2hJbnRlcnZhbCk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBSZWZyZXNoZXMgdGhlIGVsZW1lbnQuXFxuXFx0ICovXFxuXFx0QXV0b1JlZnJlc2gucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRpZiAodGhpcy5fY29yZS4kZWxlbWVudC5pcygnOnZpc2libGUnKSA9PT0gdGhpcy5fdmlzaWJsZSkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5fdmlzaWJsZSA9ICF0aGlzLl92aXNpYmxlO1xcblxcblxcdFxcdHRoaXMuX2NvcmUuJGVsZW1lbnQudG9nZ2xlQ2xhc3MoJ293bC1oaWRkZW4nLCAhdGhpcy5fdmlzaWJsZSk7XFxuXFxuXFx0XFx0dGhpcy5fdmlzaWJsZSAmJiAodGhpcy5fY29yZS5pbnZhbGlkYXRlKCd3aWR0aCcpICYmIHRoaXMuX2NvcmUucmVmcmVzaCgpKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIERlc3Ryb3lzIHRoZSBwbHVnaW4uXFxuXFx0ICovXFxuXFx0QXV0b1JlZnJlc2gucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHR2YXIgaGFuZGxlciwgcHJvcGVydHk7XFxuXFxuXFx0XFx0d2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpO1xcblxcblxcdFxcdGZvciAoaGFuZGxlciBpbiB0aGlzLl9oYW5kbGVycykge1xcblxcdFxcdFxcdHRoaXMuX2NvcmUuJGVsZW1lbnQub2ZmKGhhbmRsZXIsIHRoaXMuX2hhbmRsZXJzW2hhbmRsZXJdKTtcXG5cXHRcXHR9XFxuXFx0XFx0Zm9yIChwcm9wZXJ0eSBpbiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSkge1xcblxcdFxcdFxcdHR5cGVvZiB0aGlzW3Byb3BlcnR5XSAhPSAnZnVuY3Rpb24nICYmICh0aGlzW3Byb3BlcnR5XSA9IG51bGwpO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdCQuZm4ub3dsQ2Fyb3VzZWwuQ29uc3RydWN0b3IuUGx1Z2lucy5BdXRvUmVmcmVzaCA9IEF1dG9SZWZyZXNoO1xcblxcbn0pKHdpbmRvdy5aZXB0byB8fCBfX3dlYnBhY2tfcHJvdmlkZWRfd2luZG93X2RvdF9qUXVlcnksIHdpbmRvdywgZG9jdW1lbnQpO1xcblxcbi8qKlxcbiAqIExhenkgUGx1Z2luXFxuICogQHZlcnNpb24gMi4xLjBcXG4gKiBAYXV0aG9yIEJhcnRvc3ogV29qY2llY2hvd3NraVxcbiAqIEBhdXRob3IgRGF2aWQgRGV1dHNjaFxcbiAqIEBsaWNlbnNlIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxcbiAqL1xcbjsoZnVuY3Rpb24oJCwgd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XFxuXFxuXFx0LyoqXFxuXFx0ICogQ3JlYXRlcyB0aGUgbGF6eSBwbHVnaW4uXFxuXFx0ICogQGNsYXNzIFRoZSBMYXp5IFBsdWdpblxcblxcdCAqIEBwYXJhbSB7T3dsfSBjYXJvdXNlbCAtIFRoZSBPd2wgQ2Fyb3VzZWxcXG5cXHQgKi9cXG5cXHR2YXIgTGF6eSA9IGZ1bmN0aW9uKGNhcm91c2VsKSB7XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogUmVmZXJlbmNlIHRvIHRoZSBjb3JlLlxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKiBAdHlwZSB7T3dsfVxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX2NvcmUgPSBjYXJvdXNlbDtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBBbHJlYWR5IGxvYWRlZCBpdGVtcy5cXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICogQHR5cGUge0FycmF5LjxqUXVlcnk+fVxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX2xvYWRlZCA9IFtdO1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIEV2ZW50IGhhbmRsZXJzLlxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKiBAdHlwZSB7T2JqZWN0fVxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX2hhbmRsZXJzID0ge1xcblxcdFxcdFxcdCdpbml0aWFsaXplZC5vd2wuY2Fyb3VzZWwgY2hhbmdlLm93bC5jYXJvdXNlbCByZXNpemVkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xcblxcdFxcdFxcdFxcdGlmICghZS5uYW1lc3BhY2UpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICghdGhpcy5fY29yZS5zZXR0aW5ncyB8fCAhdGhpcy5fY29yZS5zZXR0aW5ncy5sYXp5TG9hZCkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKChlLnByb3BlcnR5ICYmIGUucHJvcGVydHkubmFtZSA9PSAncG9zaXRpb24nKSB8fCBlLnR5cGUgPT0gJ2luaXRpYWxpemVkJykge1xcblxcdFxcdFxcdFxcdFxcdHZhciBzZXR0aW5ncyA9IHRoaXMuX2NvcmUuc2V0dGluZ3MsXFxuXFx0XFx0XFx0XFx0XFx0XFx0biA9IChzZXR0aW5ncy5jZW50ZXIgJiYgTWF0aC5jZWlsKHNldHRpbmdzLml0ZW1zIC8gMikgfHwgc2V0dGluZ3MuaXRlbXMpLFxcblxcdFxcdFxcdFxcdFxcdFxcdGkgPSAoKHNldHRpbmdzLmNlbnRlciAmJiBuICogLTEpIHx8IDApLFxcblxcdFxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uID0gKGUucHJvcGVydHkgJiYgZS5wcm9wZXJ0eS52YWx1ZSAhPT0gdW5kZWZpbmVkID8gZS5wcm9wZXJ0eS52YWx1ZSA6IHRoaXMuX2NvcmUuY3VycmVudCgpKSArIGksXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2xvbmVzID0gdGhpcy5fY29yZS5jbG9uZXMoKS5sZW5ndGgsXFxuXFx0XFx0XFx0XFx0XFx0XFx0bG9hZCA9ICQucHJveHkoZnVuY3Rpb24oaSwgdikgeyB0aGlzLmxvYWQodikgfSwgdGhpcyk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKGkrKyA8IG4pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmxvYWQoY2xvbmVzIC8gMiArIHRoaXMuX2NvcmUucmVsYXRpdmUocG9zaXRpb24pKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjbG9uZXMgJiYgJC5lYWNoKHRoaXMuX2NvcmUuY2xvbmVzKHRoaXMuX2NvcmUucmVsYXRpdmUocG9zaXRpb24pKSwgbG9hZCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cG9zaXRpb24rKztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBzZXQgdGhlIGRlZmF1bHQgb3B0aW9uc1xcblxcdFxcdHRoaXMuX2NvcmUub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBMYXp5LkRlZmF1bHRzLCB0aGlzLl9jb3JlLm9wdGlvbnMpO1xcblxcblxcdFxcdC8vIHJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJcXG5cXHRcXHR0aGlzLl9jb3JlLiRlbGVtZW50Lm9uKHRoaXMuX2hhbmRsZXJzKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIERlZmF1bHQgb3B0aW9ucy5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICovXFxuXFx0TGF6eS5EZWZhdWx0cyA9IHtcXG5cXHRcXHRsYXp5TG9hZDogZmFsc2VcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIExvYWRzIGFsbCByZXNvdXJjZXMgb2YgYW4gaXRlbSBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLlxcblxcdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiAtIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgaXRlbS5cXG5cXHQgKiBAcHJvdGVjdGVkXFxuXFx0ICovXFxuXFx0TGF6eS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XFxuXFx0XFx0dmFyICRpdGVtID0gdGhpcy5fY29yZS4kc3RhZ2UuY2hpbGRyZW4oKS5lcShwb3NpdGlvbiksXFxuXFx0XFx0XFx0JGVsZW1lbnRzID0gJGl0ZW0gJiYgJGl0ZW0uZmluZCgnLm93bC1sYXp5Jyk7XFxuXFxuXFx0XFx0aWYgKCEkZWxlbWVudHMgfHwgJC5pbkFycmF5KCRpdGVtLmdldCgwKSwgdGhpcy5fbG9hZGVkKSA+IC0xKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQkZWxlbWVudHMuZWFjaCgkLnByb3h5KGZ1bmN0aW9uKGluZGV4LCBlbGVtZW50KSB7XFxuXFx0XFx0XFx0dmFyICRlbGVtZW50ID0gJChlbGVtZW50KSwgaW1hZ2UsXFxuXFx0XFx0XFx0XFx0dXJsID0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvID4gMSAmJiAkZWxlbWVudC5hdHRyKCdkYXRhLXNyYy1yZXRpbmEnKSkgfHwgJGVsZW1lbnQuYXR0cignZGF0YS1zcmMnKTtcXG5cXG5cXHRcXHRcXHR0aGlzLl9jb3JlLnRyaWdnZXIoJ2xvYWQnLCB7IGVsZW1lbnQ6ICRlbGVtZW50LCB1cmw6IHVybCB9LCAnbGF6eScpO1xcblxcblxcdFxcdFxcdGlmICgkZWxlbWVudC5pcygnaW1nJykpIHtcXG5cXHRcXHRcXHRcXHQkZWxlbWVudC5vbmUoJ2xvYWQub3dsLmxhenknLCAkLnByb3h5KGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdFxcdCRlbGVtZW50LmNzcygnb3BhY2l0eScsIDEpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2NvcmUudHJpZ2dlcignbG9hZGVkJywgeyBlbGVtZW50OiAkZWxlbWVudCwgdXJsOiB1cmwgfSwgJ2xhenknKTtcXG5cXHRcXHRcXHRcXHR9LCB0aGlzKSkuYXR0cignc3JjJywgdXJsKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGltYWdlID0gbmV3IEltYWdlKCk7XFxuXFx0XFx0XFx0XFx0aW1hZ2Uub25sb2FkID0gJC5wcm94eShmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHQkZWxlbWVudC5jc3Moe1xcblxcdFxcdFxcdFxcdFxcdFxcdCdiYWNrZ3JvdW5kLWltYWdlJzogJ3VybCgnICsgdXJsICsgJyknLFxcblxcdFxcdFxcdFxcdFxcdFxcdCdvcGFjaXR5JzogJzEnXFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fY29yZS50cmlnZ2VyKCdsb2FkZWQnLCB7IGVsZW1lbnQ6ICRlbGVtZW50LCB1cmw6IHVybCB9LCAnbGF6eScpO1xcblxcdFxcdFxcdFxcdH0sIHRoaXMpO1xcblxcdFxcdFxcdFxcdGltYWdlLnNyYyA9IHVybDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSwgdGhpcykpO1xcblxcblxcdFxcdHRoaXMuX2xvYWRlZC5wdXNoKCRpdGVtLmdldCgwKSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBEZXN0cm95cyB0aGUgcGx1Z2luLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKi9cXG5cXHRMYXp5LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0dmFyIGhhbmRsZXIsIHByb3BlcnR5O1xcblxcblxcdFxcdGZvciAoaGFuZGxlciBpbiB0aGlzLmhhbmRsZXJzKSB7XFxuXFx0XFx0XFx0dGhpcy5fY29yZS4kZWxlbWVudC5vZmYoaGFuZGxlciwgdGhpcy5oYW5kbGVyc1toYW5kbGVyXSk7XFxuXFx0XFx0fVxcblxcdFxcdGZvciAocHJvcGVydHkgaW4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykpIHtcXG5cXHRcXHRcXHR0eXBlb2YgdGhpc1twcm9wZXJ0eV0gIT0gJ2Z1bmN0aW9uJyAmJiAodGhpc1twcm9wZXJ0eV0gPSBudWxsKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQkLmZuLm93bENhcm91c2VsLkNvbnN0cnVjdG9yLlBsdWdpbnMuTGF6eSA9IExhenk7XFxuXFxufSkod2luZG93LlplcHRvIHx8IF9fd2VicGFja19wcm92aWRlZF93aW5kb3dfZG90X2pRdWVyeSwgd2luZG93LCBkb2N1bWVudCk7XFxuXFxuLyoqXFxuICogQXV0b0hlaWdodCBQbHVnaW5cXG4gKiBAdmVyc2lvbiAyLjEuMFxcbiAqIEBhdXRob3IgQmFydG9zeiBXb2pjaWVjaG93c2tpXFxuICogQGF1dGhvciBEYXZpZCBEZXV0c2NoXFxuICogQGxpY2Vuc2UgVGhlIE1JVCBMaWNlbnNlIChNSVQpXFxuICovXFxuOyhmdW5jdGlvbigkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcXG5cXG5cXHQvKipcXG5cXHQgKiBDcmVhdGVzIHRoZSBhdXRvIGhlaWdodCBwbHVnaW4uXFxuXFx0ICogQGNsYXNzIFRoZSBBdXRvIEhlaWdodCBQbHVnaW5cXG5cXHQgKiBAcGFyYW0ge093bH0gY2Fyb3VzZWwgLSBUaGUgT3dsIENhcm91c2VsXFxuXFx0ICovXFxuXFx0dmFyIEF1dG9IZWlnaHQgPSBmdW5jdGlvbihjYXJvdXNlbCkge1xcblxcdFxcdC8qKlxcblxcdFxcdCAqIFJlZmVyZW5jZSB0byB0aGUgY29yZS5cXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICogQHR5cGUge093bH1cXG5cXHRcXHQgKi9cXG5cXHRcXHR0aGlzLl9jb3JlID0gY2Fyb3VzZWw7XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogQWxsIGV2ZW50IGhhbmRsZXJzLlxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKiBAdHlwZSB7T2JqZWN0fVxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX2hhbmRsZXJzID0ge1xcblxcdFxcdFxcdCdpbml0aWFsaXplZC5vd2wuY2Fyb3VzZWwgcmVmcmVzaGVkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLm5hbWVzcGFjZSAmJiB0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9IZWlnaHQpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnVwZGF0ZSgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHQnY2hhbmdlZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgdGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvSGVpZ2h0ICYmIGUucHJvcGVydHkubmFtZSA9PSAncG9zaXRpb24nKXtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnVwZGF0ZSgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHQnbG9hZGVkLm93bC5sYXp5JzogJC5wcm94eShmdW5jdGlvbihlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlICYmIHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b0hlaWdodFxcblxcdFxcdFxcdFxcdFxcdCYmIGUuZWxlbWVudC5jbG9zZXN0KCcuJyArIHRoaXMuX2NvcmUuc2V0dGluZ3MuaXRlbUNsYXNzKS5pbmRleCgpID09PSB0aGlzLl9jb3JlLmN1cnJlbnQoKSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMudXBkYXRlKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBzZXQgZGVmYXVsdCBvcHRpb25zXFxuXFx0XFx0dGhpcy5fY29yZS5vcHRpb25zID0gJC5leHRlbmQoe30sIEF1dG9IZWlnaHQuRGVmYXVsdHMsIHRoaXMuX2NvcmUub3B0aW9ucyk7XFxuXFxuXFx0XFx0Ly8gcmVnaXN0ZXIgZXZlbnQgaGFuZGxlcnNcXG5cXHRcXHR0aGlzLl9jb3JlLiRlbGVtZW50Lm9uKHRoaXMuX2hhbmRsZXJzKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIERlZmF1bHQgb3B0aW9ucy5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICovXFxuXFx0QXV0b0hlaWdodC5EZWZhdWx0cyA9IHtcXG5cXHRcXHRhdXRvSGVpZ2h0OiBmYWxzZSxcXG5cXHRcXHRhdXRvSGVpZ2h0Q2xhc3M6ICdvd2wtaGVpZ2h0J1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogVXBkYXRlcyB0aGUgdmlldy5cXG5cXHQgKi9cXG5cXHRBdXRvSGVpZ2h0LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHR2YXIgc3RhcnQgPSB0aGlzLl9jb3JlLl9jdXJyZW50LFxcblxcdFxcdFxcdGVuZCA9IHN0YXJ0ICsgdGhpcy5fY29yZS5zZXR0aW5ncy5pdGVtcyxcXG5cXHRcXHRcXHR2aXNpYmxlID0gdGhpcy5fY29yZS4kc3RhZ2UuY2hpbGRyZW4oKS50b0FycmF5KCkuc2xpY2Uoc3RhcnQsIGVuZCksXFxuXFx0XFx0XFx0aGVpZ2h0cyA9IFtdLFxcblxcdFxcdFxcdG1heGhlaWdodCA9IDA7XFxuXFxuXFx0XFx0JC5lYWNoKHZpc2libGUsIGZ1bmN0aW9uKGluZGV4LCBpdGVtKSB7XFxuXFx0XFx0XFx0aGVpZ2h0cy5wdXNoKCQoaXRlbSkuaGVpZ2h0KCkpO1xcblxcdFxcdH0pO1xcblxcblxcdFxcdG1heGhlaWdodCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIGhlaWdodHMpO1xcblxcblxcdFxcdHRoaXMuX2NvcmUuJHN0YWdlLnBhcmVudCgpXFxuXFx0XFx0XFx0LmhlaWdodChtYXhoZWlnaHQpXFxuXFx0XFx0XFx0LmFkZENsYXNzKHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b0hlaWdodENsYXNzKTtcXG5cXHR9O1xcblxcblxcdEF1dG9IZWlnaHQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHR2YXIgaGFuZGxlciwgcHJvcGVydHk7XFxuXFxuXFx0XFx0Zm9yIChoYW5kbGVyIGluIHRoaXMuX2hhbmRsZXJzKSB7XFxuXFx0XFx0XFx0dGhpcy5fY29yZS4kZWxlbWVudC5vZmYoaGFuZGxlciwgdGhpcy5faGFuZGxlcnNbaGFuZGxlcl0pO1xcblxcdFxcdH1cXG5cXHRcXHRmb3IgKHByb3BlcnR5IGluIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKSB7XFxuXFx0XFx0XFx0dHlwZW9mIHRoaXNbcHJvcGVydHldICE9ICdmdW5jdGlvbicgJiYgKHRoaXNbcHJvcGVydHldID0gbnVsbCk7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0JC5mbi5vd2xDYXJvdXNlbC5Db25zdHJ1Y3Rvci5QbHVnaW5zLkF1dG9IZWlnaHQgPSBBdXRvSGVpZ2h0O1xcblxcbn0pKHdpbmRvdy5aZXB0byB8fCBfX3dlYnBhY2tfcHJvdmlkZWRfd2luZG93X2RvdF9qUXVlcnksIHdpbmRvdywgZG9jdW1lbnQpO1xcblxcbi8qKlxcbiAqIFZpZGVvIFBsdWdpblxcbiAqIEB2ZXJzaW9uIDIuMS4wXFxuICogQGF1dGhvciBCYXJ0b3N6IFdvamNpZWNob3dza2lcXG4gKiBAYXV0aG9yIERhdmlkIERldXRzY2hcXG4gKiBAbGljZW5zZSBUaGUgTUlUIExpY2Vuc2UgKE1JVClcXG4gKi9cXG47KGZ1bmN0aW9uKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xcblxcblxcdC8qKlxcblxcdCAqIENyZWF0ZXMgdGhlIHZpZGVvIHBsdWdpbi5cXG5cXHQgKiBAY2xhc3MgVGhlIFZpZGVvIFBsdWdpblxcblxcdCAqIEBwYXJhbSB7T3dsfSBjYXJvdXNlbCAtIFRoZSBPd2wgQ2Fyb3VzZWxcXG5cXHQgKi9cXG5cXHR2YXIgVmlkZW8gPSBmdW5jdGlvbihjYXJvdXNlbCkge1xcblxcdFxcdC8qKlxcblxcdFxcdCAqIFJlZmVyZW5jZSB0byB0aGUgY29yZS5cXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICogQHR5cGUge093bH1cXG5cXHRcXHQgKi9cXG5cXHRcXHR0aGlzLl9jb3JlID0gY2Fyb3VzZWw7XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogQ2FjaGUgYWxsIHZpZGVvIFVSTHMuXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqIEB0eXBlIHtPYmplY3R9XFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5fdmlkZW9zID0ge307XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogQ3VycmVudCBwbGF5aW5nIGl0ZW0uXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqIEB0eXBlIHtqUXVlcnl9XFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5fcGxheWluZyA9IG51bGw7XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogQWxsIGV2ZW50IGhhbmRsZXJzLlxcblxcdFxcdCAqIEB0b2RvIFRoZSBjbG9uZWQgY29udGVudCByZW1vdmFsZSBpcyB0b28gbGF0ZVxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKiBAdHlwZSB7T2JqZWN0fVxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX2hhbmRsZXJzID0ge1xcblxcdFxcdFxcdCdpbml0aWFsaXplZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9jb3JlLnJlZ2lzdGVyKHsgdHlwZTogJ3N0YXRlJywgbmFtZTogJ3BsYXlpbmcnLCB0YWdzOiBbICdpbnRlcmFjdGluZycgXSB9KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcyksXFxuXFx0XFx0XFx0J3Jlc2l6ZS5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgdGhpcy5fY29yZS5zZXR0aW5ncy52aWRlbyAmJiB0aGlzLmlzSW5GdWxsU2NyZWVuKCkpIHtcXG5cXHRcXHRcXHRcXHRcXHRlLnByZXZlbnREZWZhdWx0KCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCdyZWZyZXNoZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbihlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlICYmIHRoaXMuX2NvcmUuaXMoJ3Jlc2l6aW5nJykpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9jb3JlLiRzdGFnZS5maW5kKCcuY2xvbmVkIC5vd2wtdmlkZW8tZnJhbWUnKS5yZW1vdmUoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcyksXFxuXFx0XFx0XFx0J2NoYW5nZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbihlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlICYmIGUucHJvcGVydHkubmFtZSA9PT0gJ3Bvc2l0aW9uJyAmJiB0aGlzLl9wbGF5aW5nKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5zdG9wKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCdwcmVwYXJlZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoIWUubmFtZXNwYWNlKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR2YXIgJGVsZW1lbnQgPSAkKGUuY29udGVudCkuZmluZCgnLm93bC12aWRlbycpO1xcblxcblxcdFxcdFxcdFxcdGlmICgkZWxlbWVudC5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHQkZWxlbWVudC5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuZmV0Y2goJGVsZW1lbnQsICQoZS5jb250ZW50KSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBzZXQgZGVmYXVsdCBvcHRpb25zXFxuXFx0XFx0dGhpcy5fY29yZS5vcHRpb25zID0gJC5leHRlbmQoe30sIFZpZGVvLkRlZmF1bHRzLCB0aGlzLl9jb3JlLm9wdGlvbnMpO1xcblxcblxcdFxcdC8vIHJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJzXFxuXFx0XFx0dGhpcy5fY29yZS4kZWxlbWVudC5vbih0aGlzLl9oYW5kbGVycyk7XFxuXFxuXFx0XFx0dGhpcy5fY29yZS4kZWxlbWVudC5vbignY2xpY2sub3dsLnZpZGVvJywgJy5vd2wtdmlkZW8tcGxheS1pY29uJywgJC5wcm94eShmdW5jdGlvbihlKSB7XFxuXFx0XFx0XFx0dGhpcy5wbGF5KGUpO1xcblxcdFxcdH0sIHRoaXMpKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIERlZmF1bHQgb3B0aW9ucy5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICovXFxuXFx0VmlkZW8uRGVmYXVsdHMgPSB7XFxuXFx0XFx0dmlkZW86IGZhbHNlLFxcblxcdFxcdHZpZGVvSGVpZ2h0OiBmYWxzZSxcXG5cXHRcXHR2aWRlb1dpZHRoOiBmYWxzZVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogR2V0cyB0aGUgdmlkZW8gSUQgYW5kIHRoZSB0eXBlIChZb3VUdWJlL1ZpbWVvL3Z6YWFyIG9ubHkpLlxcblxcdCAqIEBwcm90ZWN0ZWRcXG5cXHQgKiBAcGFyYW0ge2pRdWVyeX0gdGFyZ2V0IC0gVGhlIHRhcmdldCBjb250YWluaW5nIHRoZSB2aWRlbyBkYXRhLlxcblxcdCAqIEBwYXJhbSB7alF1ZXJ5fSBpdGVtIC0gVGhlIGl0ZW0gY29udGFpbmluZyB0aGUgdmlkZW8uXFxuXFx0ICovXFxuXFx0VmlkZW8ucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24odGFyZ2V0LCBpdGVtKSB7XFxuXFx0XFx0XFx0dmFyIHR5cGUgPSAoZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRhcmdldC5hdHRyKCdkYXRhLXZpbWVvLWlkJykpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gJ3ZpbWVvJztcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKHRhcmdldC5hdHRyKCdkYXRhLXZ6YWFyLWlkJykpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gJ3Z6YWFyJ1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuICd5b3V0dWJlJztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSkoKSxcXG5cXHRcXHRcXHRcXHRpZCA9IHRhcmdldC5hdHRyKCdkYXRhLXZpbWVvLWlkJykgfHwgdGFyZ2V0LmF0dHIoJ2RhdGEteW91dHViZS1pZCcpIHx8IHRhcmdldC5hdHRyKCdkYXRhLXZ6YWFyLWlkJyksXFxuXFx0XFx0XFx0XFx0d2lkdGggPSB0YXJnZXQuYXR0cignZGF0YS13aWR0aCcpIHx8IHRoaXMuX2NvcmUuc2V0dGluZ3MudmlkZW9XaWR0aCxcXG5cXHRcXHRcXHRcXHRoZWlnaHQgPSB0YXJnZXQuYXR0cignZGF0YS1oZWlnaHQnKSB8fCB0aGlzLl9jb3JlLnNldHRpbmdzLnZpZGVvSGVpZ2h0LFxcblxcdFxcdFxcdFxcdHVybCA9IHRhcmdldC5hdHRyKCdocmVmJyk7XFxuXFxuXFx0XFx0aWYgKHVybCkge1xcblxcblxcdFxcdFxcdC8qXFxuXFx0XFx0XFx0XFx0XFx0UGFyc2VzIHRoZSBpZCdzIG91dCBvZiB0aGUgZm9sbG93aW5nIHVybHMgKGFuZCBwcm9iYWJseSBtb3JlKTpcXG5cXHRcXHRcXHRcXHRcXHRodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PTppZFxcblxcdFxcdFxcdFxcdFxcdGh0dHBzOi8veW91dHUuYmUvOmlkXFxuXFx0XFx0XFx0XFx0XFx0aHR0cHM6Ly92aW1lby5jb20vOmlkXFxuXFx0XFx0XFx0XFx0XFx0aHR0cHM6Ly92aW1lby5jb20vY2hhbm5lbHMvOmNoYW5uZWwvOmlkXFxuXFx0XFx0XFx0XFx0XFx0aHR0cHM6Ly92aW1lby5jb20vZ3JvdXBzLzpncm91cC92aWRlb3MvOmlkXFxuXFx0XFx0XFx0XFx0XFx0aHR0cHM6Ly9hcHAudnphYXIuY29tL3ZpZGVvcy86aWRcXG5cXG5cXHRcXHRcXHRcXHRcXHRWaXN1YWwgZXhhbXBsZTogaHR0cHM6Ly9yZWdleHBlci5jb20vIyhodHRwJTNBJTdDaHR0cHMlM0ElN0MpJTVDJTJGJTVDJTJGKHBsYXllci4lN0N3d3cuJTdDYXBwLiklM0YodmltZW8lNUMuY29tJTdDeW91dHUoYmUlNUMuY29tJTdDJTVDLmJlJTdDYmUlNUMuZ29vZ2xlYXBpcyU1Qy5jb20pJTdDdnphYXIlNUMuY29tKSU1QyUyRih2aWRlbyU1QyUyRiU3Q3ZpZGVvcyU1QyUyRiU3Q2VtYmVkJTVDJTJGJTdDY2hhbm5lbHMlNUMlMkYuJTJCJTVDJTJGJTdDZ3JvdXBzJTVDJTJGLiUyQiU1QyUyRiU3Q3dhdGNoJTVDJTNGdiUzRCU3Q3YlNUMlMkYpJTNGKCU1QkEtWmEtejAtOS5fJTI1LSU1RCopKCU1QyUyNiU1Q1MlMkIpJTNGXFxuXFx0XFx0XFx0Ki9cXG5cXG5cXHRcXHRcXHRpZCA9IHVybC5tYXRjaCgvKGh0dHA6fGh0dHBzOnwpXFxcXC9cXFxcLyhwbGF5ZXIufHd3dy58YXBwLik/KHZpbWVvXFxcXC5jb218eW91dHUoYmVcXFxcLmNvbXxcXFxcLmJlfGJlXFxcXC5nb29nbGVhcGlzXFxcXC5jb20pfHZ6YWFyXFxcXC5jb20pXFxcXC8odmlkZW9cXFxcL3x2aWRlb3NcXFxcL3xlbWJlZFxcXFwvfGNoYW5uZWxzXFxcXC8uK1xcXFwvfGdyb3Vwc1xcXFwvLitcXFxcL3x3YXRjaFxcXFw/dj18dlxcXFwvKT8oW0EtWmEtejAtOS5fJS1dKikoXFxcXCZcXFxcUyspPy8pO1xcblxcblxcdFxcdFxcdGlmIChpZFszXS5pbmRleE9mKCd5b3V0dScpID4gLTEpIHtcXG5cXHRcXHRcXHRcXHR0eXBlID0gJ3lvdXR1YmUnO1xcblxcdFxcdFxcdH0gZWxzZSBpZiAoaWRbM10uaW5kZXhPZigndmltZW8nKSA+IC0xKSB7XFxuXFx0XFx0XFx0XFx0dHlwZSA9ICd2aW1lbyc7XFxuXFx0XFx0XFx0fSBlbHNlIGlmIChpZFszXS5pbmRleE9mKCd2emFhcicpID4gLTEpIHtcXG5cXHRcXHRcXHRcXHR0eXBlID0gJ3Z6YWFyJztcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHRocm93IG5ldyBFcnJvcignVmlkZW8gVVJMIG5vdCBzdXBwb3J0ZWQuJyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlkID0gaWRbNl07XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHR0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgdmlkZW8gVVJMLicpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLl92aWRlb3NbdXJsXSA9IHtcXG5cXHRcXHRcXHR0eXBlOiB0eXBlLFxcblxcdFxcdFxcdGlkOiBpZCxcXG5cXHRcXHRcXHR3aWR0aDogd2lkdGgsXFxuXFx0XFx0XFx0aGVpZ2h0OiBoZWlnaHRcXG5cXHRcXHR9O1xcblxcblxcdFxcdGl0ZW0uYXR0cignZGF0YS12aWRlbycsIHVybCk7XFxuXFxuXFx0XFx0dGhpcy50aHVtYm5haWwodGFyZ2V0LCB0aGlzLl92aWRlb3NbdXJsXSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBDcmVhdGVzIHZpZGVvIHRodW1ibmFpbC5cXG5cXHQgKiBAcHJvdGVjdGVkXFxuXFx0ICogQHBhcmFtIHtqUXVlcnl9IHRhcmdldCAtIFRoZSB0YXJnZXQgY29udGFpbmluZyB0aGUgdmlkZW8gZGF0YS5cXG5cXHQgKiBAcGFyYW0ge09iamVjdH0gaW5mbyAtIFRoZSB2aWRlbyBpbmZvIG9iamVjdC5cXG5cXHQgKiBAc2VlIGBmZXRjaGBcXG5cXHQgKi9cXG5cXHRWaWRlby5wcm90b3R5cGUudGh1bWJuYWlsID0gZnVuY3Rpb24odGFyZ2V0LCB2aWRlbykge1xcblxcdFxcdHZhciB0bkxpbmssXFxuXFx0XFx0XFx0aWNvbixcXG5cXHRcXHRcXHRwYXRoLFxcblxcdFxcdFxcdGRpbWVuc2lvbnMgPSB2aWRlby53aWR0aCAmJiB2aWRlby5oZWlnaHQgPyAnc3R5bGU9XFxcIndpZHRoOicgKyB2aWRlby53aWR0aCArICdweDtoZWlnaHQ6JyArIHZpZGVvLmhlaWdodCArICdweDtcXFwiJyA6ICcnLFxcblxcdFxcdFxcdGN1c3RvbVRuID0gdGFyZ2V0LmZpbmQoJ2ltZycpLFxcblxcdFxcdFxcdHNyY1R5cGUgPSAnc3JjJyxcXG5cXHRcXHRcXHRsYXp5Q2xhc3MgPSAnJyxcXG5cXHRcXHRcXHRzZXR0aW5ncyA9IHRoaXMuX2NvcmUuc2V0dGluZ3MsXFxuXFx0XFx0XFx0Y3JlYXRlID0gZnVuY3Rpb24ocGF0aCkge1xcblxcdFxcdFxcdFxcdGljb24gPSAnPGRpdiBjbGFzcz1cXFwib3dsLXZpZGVvLXBsYXktaWNvblxcXCI+PC9kaXY+JztcXG5cXG5cXHRcXHRcXHRcXHRpZiAoc2V0dGluZ3MubGF6eUxvYWQpIHtcXG5cXHRcXHRcXHRcXHRcXHR0bkxpbmsgPSAnPGRpdiBjbGFzcz1cXFwib3dsLXZpZGVvLXRuICcgKyBsYXp5Q2xhc3MgKyAnXFxcIiAnICsgc3JjVHlwZSArICc9XFxcIicgKyBwYXRoICsgJ1xcXCI+PC9kaXY+JztcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHRuTGluayA9ICc8ZGl2IGNsYXNzPVxcXCJvd2wtdmlkZW8tdG5cXFwiIHN0eWxlPVxcXCJvcGFjaXR5OjE7YmFja2dyb3VuZC1pbWFnZTp1cmwoJyArIHBhdGggKyAnKVxcXCI+PC9kaXY+JztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0dGFyZ2V0LmFmdGVyKHRuTGluayk7XFxuXFx0XFx0XFx0XFx0dGFyZ2V0LmFmdGVyKGljb24pO1xcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gd3JhcCB2aWRlbyBjb250ZW50IGludG8gb3dsLXZpZGVvLXdyYXBwZXIgZGl2XFxuXFx0XFx0dGFyZ2V0LndyYXAoJzxkaXYgY2xhc3M9XFxcIm93bC12aWRlby13cmFwcGVyXFxcIicgKyBkaW1lbnNpb25zICsgJz48L2Rpdj4nKTtcXG5cXG5cXHRcXHRpZiAodGhpcy5fY29yZS5zZXR0aW5ncy5sYXp5TG9hZCkge1xcblxcdFxcdFxcdHNyY1R5cGUgPSAnZGF0YS1zcmMnO1xcblxcdFxcdFxcdGxhenlDbGFzcyA9ICdvd2wtbGF6eSc7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIGN1c3RvbSB0aHVtYm5haWxcXG5cXHRcXHRpZiAoY3VzdG9tVG4ubGVuZ3RoKSB7XFxuXFx0XFx0XFx0Y3JlYXRlKGN1c3RvbVRuLmF0dHIoc3JjVHlwZSkpO1xcblxcdFxcdFxcdGN1c3RvbVRuLnJlbW92ZSgpO1xcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKHZpZGVvLnR5cGUgPT09ICd5b3V0dWJlJykge1xcblxcdFxcdFxcdHBhdGggPSBcXFwiLy9pbWcueW91dHViZS5jb20vdmkvXFxcIiArIHZpZGVvLmlkICsgXFxcIi9ocWRlZmF1bHQuanBnXFxcIjtcXG5cXHRcXHRcXHRjcmVhdGUocGF0aCk7XFxuXFx0XFx0fSBlbHNlIGlmICh2aWRlby50eXBlID09PSAndmltZW8nKSB7XFxuXFx0XFx0XFx0JC5hamF4KHtcXG5cXHRcXHRcXHRcXHR0eXBlOiAnR0VUJyxcXG5cXHRcXHRcXHRcXHR1cmw6ICcvL3ZpbWVvLmNvbS9hcGkvdjIvdmlkZW8vJyArIHZpZGVvLmlkICsgJy5qc29uJyxcXG5cXHRcXHRcXHRcXHRqc29ucDogJ2NhbGxiYWNrJyxcXG5cXHRcXHRcXHRcXHRkYXRhVHlwZTogJ2pzb25wJyxcXG5cXHRcXHRcXHRcXHRzdWNjZXNzOiBmdW5jdGlvbihkYXRhKSB7XFxuXFx0XFx0XFx0XFx0XFx0cGF0aCA9IGRhdGFbMF0udGh1bWJuYWlsX2xhcmdlO1xcblxcdFxcdFxcdFxcdFxcdGNyZWF0ZShwYXRoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fSBlbHNlIGlmICh2aWRlby50eXBlID09PSAndnphYXInKSB7XFxuXFx0XFx0XFx0JC5hamF4KHtcXG5cXHRcXHRcXHRcXHR0eXBlOiAnR0VUJyxcXG5cXHRcXHRcXHRcXHR1cmw6ICcvL3Z6YWFyLmNvbS9hcGkvdmlkZW9zLycgKyB2aWRlby5pZCArICcuanNvbicsXFxuXFx0XFx0XFx0XFx0anNvbnA6ICdjYWxsYmFjaycsXFxuXFx0XFx0XFx0XFx0ZGF0YVR5cGU6ICdqc29ucCcsXFxuXFx0XFx0XFx0XFx0c3VjY2VzczogZnVuY3Rpb24oZGF0YSkge1xcblxcdFxcdFxcdFxcdFxcdHBhdGggPSBkYXRhLmZyYW1lZ3JhYl91cmw7XFxuXFx0XFx0XFx0XFx0XFx0Y3JlYXRlKHBhdGgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBTdG9wcyB0aGUgY3VycmVudCB2aWRlby5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICovXFxuXFx0VmlkZW8ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHR0aGlzLl9jb3JlLnRyaWdnZXIoJ3N0b3AnLCBudWxsLCAndmlkZW8nKTtcXG5cXHRcXHR0aGlzLl9wbGF5aW5nLmZpbmQoJy5vd2wtdmlkZW8tZnJhbWUnKS5yZW1vdmUoKTtcXG5cXHRcXHR0aGlzLl9wbGF5aW5nLnJlbW92ZUNsYXNzKCdvd2wtdmlkZW8tcGxheWluZycpO1xcblxcdFxcdHRoaXMuX3BsYXlpbmcgPSBudWxsO1xcblxcdFxcdHRoaXMuX2NvcmUubGVhdmUoJ3BsYXlpbmcnKTtcXG5cXHRcXHR0aGlzLl9jb3JlLnRyaWdnZXIoJ3N0b3BwZWQnLCBudWxsLCAndmlkZW8nKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFN0YXJ0cyB0aGUgY3VycmVudCB2aWRlby5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgYXJndW1lbnRzLlxcblxcdCAqL1xcblxcdFZpZGVvLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24oZXZlbnQpIHtcXG5cXHRcXHR2YXIgdGFyZ2V0ID0gJChldmVudC50YXJnZXQpLFxcblxcdFxcdFxcdGl0ZW0gPSB0YXJnZXQuY2xvc2VzdCgnLicgKyB0aGlzLl9jb3JlLnNldHRpbmdzLml0ZW1DbGFzcyksXFxuXFx0XFx0XFx0dmlkZW8gPSB0aGlzLl92aWRlb3NbaXRlbS5hdHRyKCdkYXRhLXZpZGVvJyldLFxcblxcdFxcdFxcdHdpZHRoID0gdmlkZW8ud2lkdGggfHwgJzEwMCUnLFxcblxcdFxcdFxcdGhlaWdodCA9IHZpZGVvLmhlaWdodCB8fCB0aGlzLl9jb3JlLiRzdGFnZS5oZWlnaHQoKSxcXG5cXHRcXHRcXHRodG1sO1xcblxcblxcdFxcdGlmICh0aGlzLl9wbGF5aW5nKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLl9jb3JlLmVudGVyKCdwbGF5aW5nJyk7XFxuXFx0XFx0dGhpcy5fY29yZS50cmlnZ2VyKCdwbGF5JywgbnVsbCwgJ3ZpZGVvJyk7XFxuXFxuXFx0XFx0aXRlbSA9IHRoaXMuX2NvcmUuaXRlbXModGhpcy5fY29yZS5yZWxhdGl2ZShpdGVtLmluZGV4KCkpKTtcXG5cXG5cXHRcXHR0aGlzLl9jb3JlLnJlc2V0KGl0ZW0uaW5kZXgoKSk7XFxuXFxuXFx0XFx0aWYgKHZpZGVvLnR5cGUgPT09ICd5b3V0dWJlJykge1xcblxcdFxcdFxcdGh0bWwgPSAnPGlmcmFtZSB3aWR0aD1cXFwiJyArIHdpZHRoICsgJ1xcXCIgaGVpZ2h0PVxcXCInICsgaGVpZ2h0ICsgJ1xcXCIgc3JjPVxcXCIvL3d3dy55b3V0dWJlLmNvbS9lbWJlZC8nICtcXG5cXHRcXHRcXHRcXHR2aWRlby5pZCArICc/YXV0b3BsYXk9MSZ2PScgKyB2aWRlby5pZCArICdcXFwiIGZyYW1lYm9yZGVyPVxcXCIwXFxcIiBhbGxvd2Z1bGxzY3JlZW4+PC9pZnJhbWU+JztcXG5cXHRcXHR9IGVsc2UgaWYgKHZpZGVvLnR5cGUgPT09ICd2aW1lbycpIHtcXG5cXHRcXHRcXHRodG1sID0gJzxpZnJhbWUgc3JjPVxcXCIvL3BsYXllci52aW1lby5jb20vdmlkZW8vJyArIHZpZGVvLmlkICtcXG5cXHRcXHRcXHRcXHQnP2F1dG9wbGF5PTFcXFwiIHdpZHRoPVxcXCInICsgd2lkdGggKyAnXFxcIiBoZWlnaHQ9XFxcIicgKyBoZWlnaHQgK1xcblxcdFxcdFxcdFxcdCdcXFwiIGZyYW1lYm9yZGVyPVxcXCIwXFxcIiB3ZWJraXRhbGxvd2Z1bGxzY3JlZW4gbW96YWxsb3dmdWxsc2NyZWVuIGFsbG93ZnVsbHNjcmVlbj48L2lmcmFtZT4nO1xcblxcdFxcdH0gZWxzZSBpZiAodmlkZW8udHlwZSA9PT0gJ3Z6YWFyJykge1xcblxcdFxcdFxcdGh0bWwgPSAnPGlmcmFtZSBmcmFtZWJvcmRlcj1cXFwiMFxcXCInICsgJ2hlaWdodD1cXFwiJyArIGhlaWdodCArICdcXFwiJyArICd3aWR0aD1cXFwiJyArIHdpZHRoICtcXG5cXHRcXHRcXHRcXHQnXFxcIiBhbGxvd2Z1bGxzY3JlZW4gbW96YWxsb3dmdWxsc2NyZWVuIHdlYmtpdEFsbG93RnVsbFNjcmVlbiAnICtcXG5cXHRcXHRcXHRcXHQnc3JjPVxcXCIvL3ZpZXcudnphYXIuY29tLycgKyB2aWRlby5pZCArICcvcGxheWVyP2F1dG9wbGF5PXRydWVcXFwiPjwvaWZyYW1lPic7XFxuXFx0XFx0fVxcblxcblxcdFxcdCQoJzxkaXYgY2xhc3M9XFxcIm93bC12aWRlby1mcmFtZVxcXCI+JyArIGh0bWwgKyAnPC9kaXY+JykuaW5zZXJ0QWZ0ZXIoaXRlbS5maW5kKCcub3dsLXZpZGVvJykpO1xcblxcblxcdFxcdHRoaXMuX3BsYXlpbmcgPSBpdGVtLmFkZENsYXNzKCdvd2wtdmlkZW8tcGxheWluZycpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQ2hlY2tzIHdoZXRoZXIgYW4gdmlkZW8gaXMgY3VycmVudGx5IGluIGZ1bGwgc2NyZWVuIG1vZGUgb3Igbm90LlxcblxcdCAqIEB0b2RvIEJhZCBzdHlsZSBiZWNhdXNlIGxvb2tzIGxpa2UgYSByZWFkb25seSBtZXRob2QgYnV0IGNoYW5nZXMgbWVtYmVycy5cXG5cXHQgKiBAcHJvdGVjdGVkXFxuXFx0ICogQHJldHVybnMge0Jvb2xlYW59XFxuXFx0ICovXFxuXFx0VmlkZW8ucHJvdG90eXBlLmlzSW5GdWxsU2NyZWVuID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0dmFyIGVsZW1lbnQgPSBkb2N1bWVudC5mdWxsc2NyZWVuRWxlbWVudCB8fCBkb2N1bWVudC5tb3pGdWxsU2NyZWVuRWxlbWVudCB8fFxcblxcdFxcdFxcdFxcdGRvY3VtZW50LndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50O1xcblxcblxcdFxcdHJldHVybiBlbGVtZW50ICYmICQoZWxlbWVudCkucGFyZW50KCkuaGFzQ2xhc3MoJ293bC12aWRlby1mcmFtZScpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogRGVzdHJveXMgdGhlIHBsdWdpbi5cXG5cXHQgKi9cXG5cXHRWaWRlby5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdHZhciBoYW5kbGVyLCBwcm9wZXJ0eTtcXG5cXG5cXHRcXHR0aGlzLl9jb3JlLiRlbGVtZW50Lm9mZignY2xpY2sub3dsLnZpZGVvJyk7XFxuXFxuXFx0XFx0Zm9yIChoYW5kbGVyIGluIHRoaXMuX2hhbmRsZXJzKSB7XFxuXFx0XFx0XFx0dGhpcy5fY29yZS4kZWxlbWVudC5vZmYoaGFuZGxlciwgdGhpcy5faGFuZGxlcnNbaGFuZGxlcl0pO1xcblxcdFxcdH1cXG5cXHRcXHRmb3IgKHByb3BlcnR5IGluIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKSB7XFxuXFx0XFx0XFx0dHlwZW9mIHRoaXNbcHJvcGVydHldICE9ICdmdW5jdGlvbicgJiYgKHRoaXNbcHJvcGVydHldID0gbnVsbCk7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0JC5mbi5vd2xDYXJvdXNlbC5Db25zdHJ1Y3Rvci5QbHVnaW5zLlZpZGVvID0gVmlkZW87XFxuXFxufSkod2luZG93LlplcHRvIHx8IF9fd2VicGFja19wcm92aWRlZF93aW5kb3dfZG90X2pRdWVyeSwgd2luZG93LCBkb2N1bWVudCk7XFxuXFxuLyoqXFxuICogQW5pbWF0ZSBQbHVnaW5cXG4gKiBAdmVyc2lvbiAyLjEuMFxcbiAqIEBhdXRob3IgQmFydG9zeiBXb2pjaWVjaG93c2tpXFxuICogQGF1dGhvciBEYXZpZCBEZXV0c2NoXFxuICogQGxpY2Vuc2UgVGhlIE1JVCBMaWNlbnNlIChNSVQpXFxuICovXFxuOyhmdW5jdGlvbigkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcXG5cXG5cXHQvKipcXG5cXHQgKiBDcmVhdGVzIHRoZSBhbmltYXRlIHBsdWdpbi5cXG5cXHQgKiBAY2xhc3MgVGhlIE5hdmlnYXRpb24gUGx1Z2luXFxuXFx0ICogQHBhcmFtIHtPd2x9IHNjb3BlIC0gVGhlIE93bCBDYXJvdXNlbFxcblxcdCAqL1xcblxcdHZhciBBbmltYXRlID0gZnVuY3Rpb24oc2NvcGUpIHtcXG5cXHRcXHR0aGlzLmNvcmUgPSBzY29wZTtcXG5cXHRcXHR0aGlzLmNvcmUub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBBbmltYXRlLkRlZmF1bHRzLCB0aGlzLmNvcmUub3B0aW9ucyk7XFxuXFx0XFx0dGhpcy5zd2FwcGluZyA9IHRydWU7XFxuXFx0XFx0dGhpcy5wcmV2aW91cyA9IHVuZGVmaW5lZDtcXG5cXHRcXHR0aGlzLm5leHQgPSB1bmRlZmluZWQ7XFxuXFxuXFx0XFx0dGhpcy5oYW5kbGVycyA9IHtcXG5cXHRcXHRcXHQnY2hhbmdlLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLm5hbWVzcGFjZSAmJiBlLnByb3BlcnR5Lm5hbWUgPT0gJ3Bvc2l0aW9uJykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMucHJldmlvdXMgPSB0aGlzLmNvcmUuY3VycmVudCgpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMubmV4dCA9IGUucHJvcGVydHkudmFsdWU7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCdkcmFnLm93bC5jYXJvdXNlbCBkcmFnZ2VkLm93bC5jYXJvdXNlbCB0cmFuc2xhdGVkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLm5hbWVzcGFjZSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuc3dhcHBpbmcgPSBlLnR5cGUgPT0gJ3RyYW5zbGF0ZWQnO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHQndHJhbnNsYXRlLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLm5hbWVzcGFjZSAmJiB0aGlzLnN3YXBwaW5nICYmICh0aGlzLmNvcmUub3B0aW9ucy5hbmltYXRlT3V0IHx8IHRoaXMuY29yZS5vcHRpb25zLmFuaW1hdGVJbikpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnN3YXAoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcylcXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuY29yZS4kZWxlbWVudC5vbih0aGlzLmhhbmRsZXJzKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIERlZmF1bHQgb3B0aW9ucy5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICovXFxuXFx0QW5pbWF0ZS5EZWZhdWx0cyA9IHtcXG5cXHRcXHRhbmltYXRlT3V0OiBmYWxzZSxcXG5cXHRcXHRhbmltYXRlSW46IGZhbHNlXFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBUb2dnbGVzIHRoZSBhbmltYXRpb24gY2xhc3NlcyB3aGVuZXZlciBhbiB0cmFuc2xhdGlvbnMgc3RhcnRzLlxcblxcdCAqIEBwcm90ZWN0ZWRcXG5cXHQgKiBAcmV0dXJucyB7Qm9vbGVhbnx1bmRlZmluZWR9XFxuXFx0ICovXFxuXFx0QW5pbWF0ZS5wcm90b3R5cGUuc3dhcCA9IGZ1bmN0aW9uKCkge1xcblxcblxcdFxcdGlmICh0aGlzLmNvcmUuc2V0dGluZ3MuaXRlbXMgIT09IDEpIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICghJC5zdXBwb3J0LmFuaW1hdGlvbiB8fCAhJC5zdXBwb3J0LnRyYW5zaXRpb24pIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuY29yZS5zcGVlZCgwKTtcXG5cXG5cXHRcXHR2YXIgbGVmdCxcXG5cXHRcXHRcXHRjbGVhciA9ICQucHJveHkodGhpcy5jbGVhciwgdGhpcyksXFxuXFx0XFx0XFx0cHJldmlvdXMgPSB0aGlzLmNvcmUuJHN0YWdlLmNoaWxkcmVuKCkuZXEodGhpcy5wcmV2aW91cyksXFxuXFx0XFx0XFx0bmV4dCA9IHRoaXMuY29yZS4kc3RhZ2UuY2hpbGRyZW4oKS5lcSh0aGlzLm5leHQpLFxcblxcdFxcdFxcdGluY29taW5nID0gdGhpcy5jb3JlLnNldHRpbmdzLmFuaW1hdGVJbixcXG5cXHRcXHRcXHRvdXRnb2luZyA9IHRoaXMuY29yZS5zZXR0aW5ncy5hbmltYXRlT3V0O1xcblxcblxcdFxcdGlmICh0aGlzLmNvcmUuY3VycmVudCgpID09PSB0aGlzLnByZXZpb3VzKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAob3V0Z29pbmcpIHtcXG5cXHRcXHRcXHRsZWZ0ID0gdGhpcy5jb3JlLmNvb3JkaW5hdGVzKHRoaXMucHJldmlvdXMpIC0gdGhpcy5jb3JlLmNvb3JkaW5hdGVzKHRoaXMubmV4dCk7XFxuXFx0XFx0XFx0cHJldmlvdXMub25lKCQuc3VwcG9ydC5hbmltYXRpb24uZW5kLCBjbGVhcilcXG5cXHRcXHRcXHRcXHQuY3NzKCB7ICdsZWZ0JzogbGVmdCArICdweCcgfSApXFxuXFx0XFx0XFx0XFx0LmFkZENsYXNzKCdhbmltYXRlZCBvd2wtYW5pbWF0ZWQtb3V0JylcXG5cXHRcXHRcXHRcXHQuYWRkQ2xhc3Mob3V0Z29pbmcpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoaW5jb21pbmcpIHtcXG5cXHRcXHRcXHRuZXh0Lm9uZSgkLnN1cHBvcnQuYW5pbWF0aW9uLmVuZCwgY2xlYXIpXFxuXFx0XFx0XFx0XFx0LmFkZENsYXNzKCdhbmltYXRlZCBvd2wtYW5pbWF0ZWQtaW4nKVxcblxcdFxcdFxcdFxcdC5hZGRDbGFzcyhpbmNvbWluZyk7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0QW5pbWF0ZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbihlKSB7XFxuXFx0XFx0JChlLnRhcmdldCkuY3NzKCB7ICdsZWZ0JzogJycgfSApXFxuXFx0XFx0XFx0LnJlbW92ZUNsYXNzKCdhbmltYXRlZCBvd2wtYW5pbWF0ZWQtb3V0IG93bC1hbmltYXRlZC1pbicpXFxuXFx0XFx0XFx0LnJlbW92ZUNsYXNzKHRoaXMuY29yZS5zZXR0aW5ncy5hbmltYXRlSW4pXFxuXFx0XFx0XFx0LnJlbW92ZUNsYXNzKHRoaXMuY29yZS5zZXR0aW5ncy5hbmltYXRlT3V0KTtcXG5cXHRcXHR0aGlzLmNvcmUub25UcmFuc2l0aW9uRW5kKCk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBEZXN0cm95cyB0aGUgcGx1Z2luLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKi9cXG5cXHRBbmltYXRlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0dmFyIGhhbmRsZXIsIHByb3BlcnR5O1xcblxcblxcdFxcdGZvciAoaGFuZGxlciBpbiB0aGlzLmhhbmRsZXJzKSB7XFxuXFx0XFx0XFx0dGhpcy5jb3JlLiRlbGVtZW50Lm9mZihoYW5kbGVyLCB0aGlzLmhhbmRsZXJzW2hhbmRsZXJdKTtcXG5cXHRcXHR9XFxuXFx0XFx0Zm9yIChwcm9wZXJ0eSBpbiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSkge1xcblxcdFxcdFxcdHR5cGVvZiB0aGlzW3Byb3BlcnR5XSAhPSAnZnVuY3Rpb24nICYmICh0aGlzW3Byb3BlcnR5XSA9IG51bGwpO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdCQuZm4ub3dsQ2Fyb3VzZWwuQ29uc3RydWN0b3IuUGx1Z2lucy5BbmltYXRlID0gQW5pbWF0ZTtcXG5cXG59KSh3aW5kb3cuWmVwdG8gfHwgX193ZWJwYWNrX3Byb3ZpZGVkX3dpbmRvd19kb3RfalF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50KTtcXG5cXG4vKipcXG4gKiBBdXRvcGxheSBQbHVnaW5cXG4gKiBAdmVyc2lvbiAyLjEuMFxcbiAqIEBhdXRob3IgQmFydG9zeiBXb2pjaWVjaG93c2tpXFxuICogQGF1dGhvciBBcnR1cyBLb2xhbm93c2tpXFxuICogQGF1dGhvciBEYXZpZCBEZXV0c2NoXFxuICogQGxpY2Vuc2UgVGhlIE1JVCBMaWNlbnNlIChNSVQpXFxuICovXFxuOyhmdW5jdGlvbigkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcXG5cXG5cXHQvKipcXG5cXHQgKiBDcmVhdGVzIHRoZSBhdXRvcGxheSBwbHVnaW4uXFxuXFx0ICogQGNsYXNzIFRoZSBBdXRvcGxheSBQbHVnaW5cXG5cXHQgKiBAcGFyYW0ge093bH0gc2NvcGUgLSBUaGUgT3dsIENhcm91c2VsXFxuXFx0ICovXFxuXFx0dmFyIEF1dG9wbGF5ID0gZnVuY3Rpb24oY2Fyb3VzZWwpIHtcXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBSZWZlcmVuY2UgdG8gdGhlIGNvcmUuXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqIEB0eXBlIHtPd2x9XFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5fY29yZSA9IGNhcm91c2VsO1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIFRoZSBhdXRvcGxheSB0aW1lb3V0LlxcblxcdFxcdCAqIEB0eXBlIHtUaW1lb3V0fVxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX3RpbWVvdXQgPSBudWxsO1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIEluZGljYXRlcyB3aGVuZXZlciB0aGUgYXV0b3BsYXkgaXMgcGF1c2VkLlxcblxcdFxcdCAqIEB0eXBlIHtCb29sZWFufVxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIEFsbCBldmVudCBoYW5kbGVycy5cXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICogQHR5cGUge09iamVjdH1cXG5cXHRcXHQgKi9cXG5cXHRcXHR0aGlzLl9oYW5kbGVycyA9IHtcXG5cXHRcXHRcXHQnY2hhbmdlZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgZS5wcm9wZXJ0eS5uYW1lID09PSAnc2V0dGluZ3MnKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b3BsYXkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnBsYXkoKTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuc3RvcCgpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGUubmFtZXNwYWNlICYmIGUucHJvcGVydHkubmFtZSA9PT0gJ3Bvc2l0aW9uJykge1xcblxcdFxcdFxcdFxcdFxcdC8vY29uc29sZS5sb2coJ3BsYXk/JywgZSk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b3BsYXkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9zZXRBdXRvUGxheUludGVydmFsKCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHQnaW5pdGlhbGl6ZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbihlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlICYmIHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b3BsYXkpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnBsYXkoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcyksXFxuXFx0XFx0XFx0J3BsYXkub3dsLmF1dG9wbGF5JzogJC5wcm94eShmdW5jdGlvbihlLCB0LCBzKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5wbGF5KHQsIHMpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHQnc3RvcC5vd2wuYXV0b3BsYXknOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnN0b3AoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcyksXFxuXFx0XFx0XFx0J21vdXNlb3Zlci5vd2wuYXV0b3BsYXknOiAkLnByb3h5KGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdGlmICh0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9wbGF5SG92ZXJQYXVzZSAmJiB0aGlzLl9jb3JlLmlzKCdyb3RhdGluZycpKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5wYXVzZSgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHQnbW91c2VsZWF2ZS5vd2wuYXV0b3BsYXknOiAkLnByb3h5KGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdGlmICh0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9wbGF5SG92ZXJQYXVzZSAmJiB0aGlzLl9jb3JlLmlzKCdyb3RhdGluZycpKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5wbGF5KCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCd0b3VjaHN0YXJ0Lm93bC5jb3JlJzogJC5wcm94eShmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvcGxheUhvdmVyUGF1c2UgJiYgdGhpcy5fY29yZS5pcygncm90YXRpbmcnKSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMucGF1c2UoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcyksXFxuXFx0XFx0XFx0J3RvdWNoZW5kLm93bC5jb3JlJzogJC5wcm94eShmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvcGxheUhvdmVyUGF1c2UpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnBsYXkoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcylcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIHJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJzXFxuXFx0XFx0dGhpcy5fY29yZS4kZWxlbWVudC5vbih0aGlzLl9oYW5kbGVycyk7XFxuXFxuXFx0XFx0Ly8gc2V0IGRlZmF1bHQgb3B0aW9uc1xcblxcdFxcdHRoaXMuX2NvcmUub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBBdXRvcGxheS5EZWZhdWx0cywgdGhpcy5fY29yZS5vcHRpb25zKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIERlZmF1bHQgb3B0aW9ucy5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICovXFxuXFx0QXV0b3BsYXkuRGVmYXVsdHMgPSB7XFxuXFx0XFx0YXV0b3BsYXk6IGZhbHNlLFxcblxcdFxcdGF1dG9wbGF5VGltZW91dDogNTAwMCxcXG5cXHRcXHRhdXRvcGxheUhvdmVyUGF1c2U6IGZhbHNlLFxcblxcdFxcdGF1dG9wbGF5U3BlZWQ6IGZhbHNlXFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBTdGFydHMgdGhlIGF1dG9wbGF5LlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKiBAcGFyYW0ge051bWJlcn0gW3RpbWVvdXRdIC0gVGhlIGludGVydmFsIGJlZm9yZSB0aGUgbmV4dCBhbmltYXRpb24gc3RhcnRzLlxcblxcdCAqIEBwYXJhbSB7TnVtYmVyfSBbc3BlZWRdIC0gVGhlIGFuaW1hdGlvbiBzcGVlZCBmb3IgdGhlIGFuaW1hdGlvbnMuXFxuXFx0ICovXFxuXFx0QXV0b3BsYXkucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbih0aW1lb3V0LCBzcGVlZCkge1xcblxcdFxcdHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xcblxcblxcdFxcdGlmICh0aGlzLl9jb3JlLmlzKCdyb3RhdGluZycpKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLl9jb3JlLmVudGVyKCdyb3RhdGluZycpO1xcblxcblxcdFxcdHRoaXMuX3NldEF1dG9QbGF5SW50ZXJ2YWwoKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEdldHMgYSBuZXcgdGltZW91dFxcblxcdCAqIEBwcml2YXRlXFxuXFx0ICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lb3V0XSAtIFRoZSBpbnRlcnZhbCBiZWZvcmUgdGhlIG5leHQgYW5pbWF0aW9uIHN0YXJ0cy5cXG5cXHQgKiBAcGFyYW0ge051bWJlcn0gW3NwZWVkXSAtIFRoZSBhbmltYXRpb24gc3BlZWQgZm9yIHRoZSBhbmltYXRpb25zLlxcblxcdCAqIEByZXR1cm4ge1RpbWVvdXR9XFxuXFx0ICovXFxuXFx0QXV0b3BsYXkucHJvdG90eXBlLl9nZXROZXh0VGltZW91dCA9IGZ1bmN0aW9uKHRpbWVvdXQsIHNwZWVkKSB7XFxuXFx0XFx0aWYgKCB0aGlzLl90aW1lb3V0ICkge1xcblxcdFxcdFxcdHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiB3aW5kb3cuc2V0VGltZW91dCgkLnByb3h5KGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdGlmICh0aGlzLl9wYXVzZWQgfHwgdGhpcy5fY29yZS5pcygnYnVzeScpIHx8IHRoaXMuX2NvcmUuaXMoJ2ludGVyYWN0aW5nJykgfHwgZG9jdW1lbnQuaGlkZGVuKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0aGlzLl9jb3JlLm5leHQoc3BlZWQgfHwgdGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvcGxheVNwZWVkKTtcXG5cXHRcXHR9LCB0aGlzKSwgdGltZW91dCB8fCB0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9wbGF5VGltZW91dCk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBTZXRzIGF1dG9wbGF5IGluIG1vdGlvbi5cXG5cXHQgKiBAcHJpdmF0ZVxcblxcdCAqL1xcblxcdEF1dG9wbGF5LnByb3RvdHlwZS5fc2V0QXV0b1BsYXlJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdHRoaXMuX3RpbWVvdXQgPSB0aGlzLl9nZXROZXh0VGltZW91dCgpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogU3RvcHMgdGhlIGF1dG9wbGF5LlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKi9cXG5cXHRBdXRvcGxheS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdGlmICghdGhpcy5fY29yZS5pcygncm90YXRpbmcnKSkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0d2luZG93LmNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcXG5cXHRcXHR0aGlzLl9jb3JlLmxlYXZlKCdyb3RhdGluZycpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogU3RvcHMgdGhlIGF1dG9wbGF5LlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKi9cXG5cXHRBdXRvcGxheS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRpZiAoIXRoaXMuX2NvcmUuaXMoJ3JvdGF0aW5nJykpIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuX3BhdXNlZCA9IHRydWU7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBEZXN0cm95cyB0aGUgcGx1Z2luLlxcblxcdCAqL1xcblxcdEF1dG9wbGF5LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0dmFyIGhhbmRsZXIsIHByb3BlcnR5O1xcblxcblxcdFxcdHRoaXMuc3RvcCgpO1xcblxcblxcdFxcdGZvciAoaGFuZGxlciBpbiB0aGlzLl9oYW5kbGVycykge1xcblxcdFxcdFxcdHRoaXMuX2NvcmUuJGVsZW1lbnQub2ZmKGhhbmRsZXIsIHRoaXMuX2hhbmRsZXJzW2hhbmRsZXJdKTtcXG5cXHRcXHR9XFxuXFx0XFx0Zm9yIChwcm9wZXJ0eSBpbiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSkge1xcblxcdFxcdFxcdHR5cGVvZiB0aGlzW3Byb3BlcnR5XSAhPSAnZnVuY3Rpb24nICYmICh0aGlzW3Byb3BlcnR5XSA9IG51bGwpO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdCQuZm4ub3dsQ2Fyb3VzZWwuQ29uc3RydWN0b3IuUGx1Z2lucy5hdXRvcGxheSA9IEF1dG9wbGF5O1xcblxcbn0pKHdpbmRvdy5aZXB0byB8fCBfX3dlYnBhY2tfcHJvdmlkZWRfd2luZG93X2RvdF9qUXVlcnksIHdpbmRvdywgZG9jdW1lbnQpO1xcblxcbi8qKlxcbiAqIE5hdmlnYXRpb24gUGx1Z2luXFxuICogQHZlcnNpb24gMi4xLjBcXG4gKiBAYXV0aG9yIEFydHVzIEtvbGFub3dza2lcXG4gKiBAYXV0aG9yIERhdmlkIERldXRzY2hcXG4gKiBAbGljZW5zZSBUaGUgTUlUIExpY2Vuc2UgKE1JVClcXG4gKi9cXG47KGZ1bmN0aW9uKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xcblxcdCd1c2Ugc3RyaWN0JztcXG5cXG5cXHQvKipcXG5cXHQgKiBDcmVhdGVzIHRoZSBuYXZpZ2F0aW9uIHBsdWdpbi5cXG5cXHQgKiBAY2xhc3MgVGhlIE5hdmlnYXRpb24gUGx1Z2luXFxuXFx0ICogQHBhcmFtIHtPd2x9IGNhcm91c2VsIC0gVGhlIE93bCBDYXJvdXNlbC5cXG5cXHQgKi9cXG5cXHR2YXIgTmF2aWdhdGlvbiA9IGZ1bmN0aW9uKGNhcm91c2VsKSB7XFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogUmVmZXJlbmNlIHRvIHRoZSBjb3JlLlxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKiBAdHlwZSB7T3dsfVxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX2NvcmUgPSBjYXJvdXNlbDtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgcGx1Z2luIGlzIGluaXRpYWxpemVkIG9yIG5vdC5cXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICogQHR5cGUge0Jvb2xlYW59XFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBUaGUgY3VycmVudCBwYWdpbmcgaW5kZXhlcy5cXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICogQHR5cGUge0FycmF5fVxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX3BhZ2VzID0gW107XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogQWxsIERPTSBlbGVtZW50cyBvZiB0aGUgdXNlciBpbnRlcmZhY2UuXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqIEB0eXBlIHtPYmplY3R9XFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5fY29udHJvbHMgPSB7fTtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBNYXJrdXAgZm9yIGFuIGluZGljYXRvci5cXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICogQHR5cGUge0FycmF5LjxTdHJpbmc+fVxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX3RlbXBsYXRlcyA9IFtdO1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIFRoZSBjYXJvdXNlbCBlbGVtZW50LlxcblxcdFxcdCAqIEB0eXBlIHtqUXVlcnl9XFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy4kZWxlbWVudCA9IHRoaXMuX2NvcmUuJGVsZW1lbnQ7XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogT3ZlcnJpZGRlbiBtZXRob2RzIG9mIHRoZSBjYXJvdXNlbC5cXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICogQHR5cGUge09iamVjdH1cXG5cXHRcXHQgKi9cXG5cXHRcXHR0aGlzLl9vdmVycmlkZXMgPSB7XFxuXFx0XFx0XFx0bmV4dDogdGhpcy5fY29yZS5uZXh0LFxcblxcdFxcdFxcdHByZXY6IHRoaXMuX2NvcmUucHJldixcXG5cXHRcXHRcXHR0bzogdGhpcy5fY29yZS50b1xcblxcdFxcdH07XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogQWxsIGV2ZW50IGhhbmRsZXJzLlxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKiBAdHlwZSB7T2JqZWN0fVxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX2hhbmRsZXJzID0ge1xcblxcdFxcdFxcdCdwcmVwYXJlZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgdGhpcy5fY29yZS5zZXR0aW5ncy5kb3RzRGF0YSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3RlbXBsYXRlcy5wdXNoKCc8ZGl2IGNsYXNzPVxcXCInICsgdGhpcy5fY29yZS5zZXR0aW5ncy5kb3RDbGFzcyArICdcXFwiPicgK1xcblxcdFxcdFxcdFxcdFxcdFxcdCQoZS5jb250ZW50KS5maW5kKCdbZGF0YS1kb3RdJykuYWRkQmFjaygnW2RhdGEtZG90XScpLmF0dHIoJ2RhdGEtZG90JykgKyAnPC9kaXY+Jyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCdhZGRlZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgdGhpcy5fY29yZS5zZXR0aW5ncy5kb3RzRGF0YSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3RlbXBsYXRlcy5zcGxpY2UoZS5wb3NpdGlvbiwgMCwgdGhpcy5fdGVtcGxhdGVzLnBvcCgpKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcyksXFxuXFx0XFx0XFx0J3JlbW92ZS5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgdGhpcy5fY29yZS5zZXR0aW5ncy5kb3RzRGF0YSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3RlbXBsYXRlcy5zcGxpY2UoZS5wb3NpdGlvbiwgMSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCdjaGFuZ2VkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLm5hbWVzcGFjZSAmJiBlLnByb3BlcnR5Lm5hbWUgPT0gJ3Bvc2l0aW9uJykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuZHJhdygpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHQnaW5pdGlhbGl6ZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbihlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlICYmICF0aGlzLl9pbml0aWFsaXplZCkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2NvcmUudHJpZ2dlcignaW5pdGlhbGl6ZScsIG51bGwsICduYXZpZ2F0aW9uJyk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5pbml0aWFsaXplKCk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy51cGRhdGUoKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmRyYXcoKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fY29yZS50cmlnZ2VyKCdpbml0aWFsaXplZCcsIG51bGwsICduYXZpZ2F0aW9uJyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCdyZWZyZXNoZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbihlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlICYmIHRoaXMuX2luaXRpYWxpemVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fY29yZS50cmlnZ2VyKCdyZWZyZXNoJywgbnVsbCwgJ25hdmlnYXRpb24nKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnVwZGF0ZSgpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuZHJhdygpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2NvcmUudHJpZ2dlcigncmVmcmVzaGVkJywgbnVsbCwgJ25hdmlnYXRpb24nKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcylcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcXG5cXHRcXHR0aGlzLl9jb3JlLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgTmF2aWdhdGlvbi5EZWZhdWx0cywgdGhpcy5fY29yZS5vcHRpb25zKTtcXG5cXG5cXHRcXHQvLyByZWdpc3RlciBldmVudCBoYW5kbGVyc1xcblxcdFxcdHRoaXMuJGVsZW1lbnQub24odGhpcy5faGFuZGxlcnMpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogRGVmYXVsdCBvcHRpb25zLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKiBAdG9kbyBSZW5hbWUgYHNsaWRlQnlgIHRvIGBuYXZCeWBcXG5cXHQgKi9cXG5cXHROYXZpZ2F0aW9uLkRlZmF1bHRzID0ge1xcblxcdFxcdG5hdjogZmFsc2UsXFxuXFx0XFx0bmF2VGV4dDogWyAncHJldicsICduZXh0JyBdLFxcblxcdFxcdG5hdlNwZWVkOiBmYWxzZSxcXG5cXHRcXHRuYXZFbGVtZW50OiAnZGl2JyxcXG5cXHRcXHRuYXZDb250YWluZXI6IGZhbHNlLFxcblxcdFxcdG5hdkNvbnRhaW5lckNsYXNzOiAnb3dsLW5hdicsXFxuXFx0XFx0bmF2Q2xhc3M6IFsgJ293bC1wcmV2JywgJ293bC1uZXh0JyBdLFxcblxcdFxcdHNsaWRlQnk6IDEsXFxuXFx0XFx0ZG90Q2xhc3M6ICdvd2wtZG90JyxcXG5cXHRcXHRkb3RzQ2xhc3M6ICdvd2wtZG90cycsXFxuXFx0XFx0ZG90czogdHJ1ZSxcXG5cXHRcXHRkb3RzRWFjaDogZmFsc2UsXFxuXFx0XFx0ZG90c0RhdGE6IGZhbHNlLFxcblxcdFxcdGRvdHNTcGVlZDogZmFsc2UsXFxuXFx0XFx0ZG90c0NvbnRhaW5lcjogZmFsc2VcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEluaXRpYWxpemVzIHRoZSBsYXlvdXQgb2YgdGhlIHBsdWdpbiBhbmQgZXh0ZW5kcyB0aGUgY2Fyb3VzZWwuXFxuXFx0ICogQHByb3RlY3RlZFxcblxcdCAqL1xcblxcdE5hdmlnYXRpb24ucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHR2YXIgb3ZlcnJpZGUsXFxuXFx0XFx0XFx0c2V0dGluZ3MgPSB0aGlzLl9jb3JlLnNldHRpbmdzO1xcblxcblxcdFxcdC8vIGNyZWF0ZSBET00gc3RydWN0dXJlIGZvciByZWxhdGl2ZSBuYXZpZ2F0aW9uXFxuXFx0XFx0dGhpcy5fY29udHJvbHMuJHJlbGF0aXZlID0gKHNldHRpbmdzLm5hdkNvbnRhaW5lciA/ICQoc2V0dGluZ3MubmF2Q29udGFpbmVyKVxcblxcdFxcdFxcdDogJCgnPGRpdj4nKS5hZGRDbGFzcyhzZXR0aW5ncy5uYXZDb250YWluZXJDbGFzcykuYXBwZW5kVG8odGhpcy4kZWxlbWVudCkpLmFkZENsYXNzKCdkaXNhYmxlZCcpO1xcblxcblxcdFxcdHRoaXMuX2NvbnRyb2xzLiRwcmV2aW91cyA9ICQoJzwnICsgc2V0dGluZ3MubmF2RWxlbWVudCArICc+JylcXG5cXHRcXHRcXHQuYWRkQ2xhc3Moc2V0dGluZ3MubmF2Q2xhc3NbMF0pXFxuXFx0XFx0XFx0Lmh0bWwoc2V0dGluZ3MubmF2VGV4dFswXSlcXG5cXHRcXHRcXHQucHJlcGVuZFRvKHRoaXMuX2NvbnRyb2xzLiRyZWxhdGl2ZSlcXG5cXHRcXHRcXHQub24oJ2NsaWNrJywgJC5wcm94eShmdW5jdGlvbihlKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5wcmV2KHNldHRpbmdzLm5hdlNwZWVkKTtcXG5cXHRcXHRcXHR9LCB0aGlzKSk7XFxuXFx0XFx0dGhpcy5fY29udHJvbHMuJG5leHQgPSAkKCc8JyArIHNldHRpbmdzLm5hdkVsZW1lbnQgKyAnPicpXFxuXFx0XFx0XFx0LmFkZENsYXNzKHNldHRpbmdzLm5hdkNsYXNzWzFdKVxcblxcdFxcdFxcdC5odG1sKHNldHRpbmdzLm5hdlRleHRbMV0pXFxuXFx0XFx0XFx0LmFwcGVuZFRvKHRoaXMuX2NvbnRyb2xzLiRyZWxhdGl2ZSlcXG5cXHRcXHRcXHQub24oJ2NsaWNrJywgJC5wcm94eShmdW5jdGlvbihlKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5uZXh0KHNldHRpbmdzLm5hdlNwZWVkKTtcXG5cXHRcXHRcXHR9LCB0aGlzKSk7XFxuXFxuXFx0XFx0Ly8gY3JlYXRlIERPTSBzdHJ1Y3R1cmUgZm9yIGFic29sdXRlIG5hdmlnYXRpb25cXG5cXHRcXHRpZiAoIXNldHRpbmdzLmRvdHNEYXRhKSB7XFxuXFx0XFx0XFx0dGhpcy5fdGVtcGxhdGVzID0gWyAkKCc8ZGl2PicpXFxuXFx0XFx0XFx0XFx0LmFkZENsYXNzKHNldHRpbmdzLmRvdENsYXNzKVxcblxcdFxcdFxcdFxcdC5hcHBlbmQoJCgnPHNwYW4+JykpXFxuXFx0XFx0XFx0XFx0LnByb3AoJ291dGVySFRNTCcpIF07XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuX2NvbnRyb2xzLiRhYnNvbHV0ZSA9IChzZXR0aW5ncy5kb3RzQ29udGFpbmVyID8gJChzZXR0aW5ncy5kb3RzQ29udGFpbmVyKVxcblxcdFxcdFxcdDogJCgnPGRpdj4nKS5hZGRDbGFzcyhzZXR0aW5ncy5kb3RzQ2xhc3MpLmFwcGVuZFRvKHRoaXMuJGVsZW1lbnQpKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcXG5cXG5cXHRcXHR0aGlzLl9jb250cm9scy4kYWJzb2x1dGUub24oJ2NsaWNrJywgJ2RpdicsICQucHJveHkoZnVuY3Rpb24oZSkge1xcblxcdFxcdFxcdHZhciBpbmRleCA9ICQoZS50YXJnZXQpLnBhcmVudCgpLmlzKHRoaXMuX2NvbnRyb2xzLiRhYnNvbHV0ZSlcXG5cXHRcXHRcXHRcXHQ/ICQoZS50YXJnZXQpLmluZGV4KCkgOiAkKGUudGFyZ2V0KS5wYXJlbnQoKS5pbmRleCgpO1xcblxcblxcdFxcdFxcdGUucHJldmVudERlZmF1bHQoKTtcXG5cXG5cXHRcXHRcXHR0aGlzLnRvKGluZGV4LCBzZXR0aW5ncy5kb3RzU3BlZWQpO1xcblxcdFxcdH0sIHRoaXMpKTtcXG5cXG5cXHRcXHQvLyBvdmVycmlkZSBwdWJsaWMgbWV0aG9kcyBvZiB0aGUgY2Fyb3VzZWxcXG5cXHRcXHRmb3IgKG92ZXJyaWRlIGluIHRoaXMuX292ZXJyaWRlcykge1xcblxcdFxcdFxcdHRoaXMuX2NvcmVbb3ZlcnJpZGVdID0gJC5wcm94eSh0aGlzW292ZXJyaWRlXSwgdGhpcyk7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogRGVzdHJveXMgdGhlIHBsdWdpbi5cXG5cXHQgKiBAcHJvdGVjdGVkXFxuXFx0ICovXFxuXFx0TmF2aWdhdGlvbi5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdHZhciBoYW5kbGVyLCBjb250cm9sLCBwcm9wZXJ0eSwgb3ZlcnJpZGU7XFxuXFxuXFx0XFx0Zm9yIChoYW5kbGVyIGluIHRoaXMuX2hhbmRsZXJzKSB7XFxuXFx0XFx0XFx0dGhpcy4kZWxlbWVudC5vZmYoaGFuZGxlciwgdGhpcy5faGFuZGxlcnNbaGFuZGxlcl0pO1xcblxcdFxcdH1cXG5cXHRcXHRmb3IgKGNvbnRyb2wgaW4gdGhpcy5fY29udHJvbHMpIHtcXG5cXHRcXHRcXHR0aGlzLl9jb250cm9sc1tjb250cm9sXS5yZW1vdmUoKTtcXG5cXHRcXHR9XFxuXFx0XFx0Zm9yIChvdmVycmlkZSBpbiB0aGlzLm92ZXJpZGVzKSB7XFxuXFx0XFx0XFx0dGhpcy5fY29yZVtvdmVycmlkZV0gPSB0aGlzLl9vdmVycmlkZXNbb3ZlcnJpZGVdO1xcblxcdFxcdH1cXG5cXHRcXHRmb3IgKHByb3BlcnR5IGluIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKSB7XFxuXFx0XFx0XFx0dHlwZW9mIHRoaXNbcHJvcGVydHldICE9ICdmdW5jdGlvbicgJiYgKHRoaXNbcHJvcGVydHldID0gbnVsbCk7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogVXBkYXRlcyB0aGUgaW50ZXJuYWwgc3RhdGUuXFxuXFx0ICogQHByb3RlY3RlZFxcblxcdCAqL1xcblxcdE5hdmlnYXRpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdHZhciBpLCBqLCBrLFxcblxcdFxcdFxcdGxvd2VyID0gdGhpcy5fY29yZS5jbG9uZXMoKS5sZW5ndGggLyAyLFxcblxcdFxcdFxcdHVwcGVyID0gbG93ZXIgKyB0aGlzLl9jb3JlLml0ZW1zKCkubGVuZ3RoLFxcblxcdFxcdFxcdG1heGltdW0gPSB0aGlzLl9jb3JlLm1heGltdW0odHJ1ZSksXFxuXFx0XFx0XFx0c2V0dGluZ3MgPSB0aGlzLl9jb3JlLnNldHRpbmdzLFxcblxcdFxcdFxcdHNpemUgPSBzZXR0aW5ncy5jZW50ZXIgfHwgc2V0dGluZ3MuYXV0b1dpZHRoIHx8IHNldHRpbmdzLmRvdHNEYXRhXFxuXFx0XFx0XFx0XFx0PyAxIDogc2V0dGluZ3MuZG90c0VhY2ggfHwgc2V0dGluZ3MuaXRlbXM7XFxuXFxuXFx0XFx0aWYgKHNldHRpbmdzLnNsaWRlQnkgIT09ICdwYWdlJykge1xcblxcdFxcdFxcdHNldHRpbmdzLnNsaWRlQnkgPSBNYXRoLm1pbihzZXR0aW5ncy5zbGlkZUJ5LCBzZXR0aW5ncy5pdGVtcyk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmIChzZXR0aW5ncy5kb3RzIHx8IHNldHRpbmdzLnNsaWRlQnkgPT0gJ3BhZ2UnKSB7XFxuXFx0XFx0XFx0dGhpcy5fcGFnZXMgPSBbXTtcXG5cXG5cXHRcXHRcXHRmb3IgKGkgPSBsb3dlciwgaiA9IDAsIGsgPSAwOyBpIDwgdXBwZXI7IGkrKykge1xcblxcdFxcdFxcdFxcdGlmIChqID49IHNpemUgfHwgaiA9PT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3BhZ2VzLnB1c2goe1xcblxcdFxcdFxcdFxcdFxcdFxcdHN0YXJ0OiBNYXRoLm1pbihtYXhpbXVtLCBpIC0gbG93ZXIpLFxcblxcdFxcdFxcdFxcdFxcdFxcdGVuZDogaSAtIGxvd2VyICsgc2l6ZSAtIDFcXG5cXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoTWF0aC5taW4obWF4aW11bSwgaSAtIGxvd2VyKSA9PT0gbWF4aW11bSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRqID0gMCwgKytrO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRqICs9IHRoaXMuX2NvcmUubWVyZ2Vycyh0aGlzLl9jb3JlLnJlbGF0aXZlKGkpKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogRHJhd3MgdGhlIHVzZXIgaW50ZXJmYWNlLlxcblxcdCAqIEB0b2RvIFRoZSBvcHRpb24gYGRvdHNEYXRhYCB3b250IHdvcmsuXFxuXFx0ICogQHByb3RlY3RlZFxcblxcdCAqL1xcblxcdE5hdmlnYXRpb24ucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHR2YXIgZGlmZmVyZW5jZSxcXG5cXHRcXHRcXHRzZXR0aW5ncyA9IHRoaXMuX2NvcmUuc2V0dGluZ3MsXFxuXFx0XFx0XFx0ZGlzYWJsZWQgPSB0aGlzLl9jb3JlLml0ZW1zKCkubGVuZ3RoIDw9IHNldHRpbmdzLml0ZW1zLFxcblxcdFxcdFxcdGluZGV4ID0gdGhpcy5fY29yZS5yZWxhdGl2ZSh0aGlzLl9jb3JlLmN1cnJlbnQoKSksXFxuXFx0XFx0XFx0bG9vcCA9IHNldHRpbmdzLmxvb3AgfHwgc2V0dGluZ3MucmV3aW5kO1xcblxcblxcdFxcdHRoaXMuX2NvbnRyb2xzLiRyZWxhdGl2ZS50b2dnbGVDbGFzcygnZGlzYWJsZWQnLCAhc2V0dGluZ3MubmF2IHx8IGRpc2FibGVkKTtcXG5cXG5cXHRcXHRpZiAoc2V0dGluZ3MubmF2KSB7XFxuXFx0XFx0XFx0dGhpcy5fY29udHJvbHMuJHByZXZpb3VzLnRvZ2dsZUNsYXNzKCdkaXNhYmxlZCcsICFsb29wICYmIGluZGV4IDw9IHRoaXMuX2NvcmUubWluaW11bSh0cnVlKSk7XFxuXFx0XFx0XFx0dGhpcy5fY29udHJvbHMuJG5leHQudG9nZ2xlQ2xhc3MoJ2Rpc2FibGVkJywgIWxvb3AgJiYgaW5kZXggPj0gdGhpcy5fY29yZS5tYXhpbXVtKHRydWUpKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5fY29udHJvbHMuJGFic29sdXRlLnRvZ2dsZUNsYXNzKCdkaXNhYmxlZCcsICFzZXR0aW5ncy5kb3RzIHx8IGRpc2FibGVkKTtcXG5cXG5cXHRcXHRpZiAoc2V0dGluZ3MuZG90cykge1xcblxcdFxcdFxcdGRpZmZlcmVuY2UgPSB0aGlzLl9wYWdlcy5sZW5ndGggLSB0aGlzLl9jb250cm9scy4kYWJzb2x1dGUuY2hpbGRyZW4oKS5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0aWYgKHNldHRpbmdzLmRvdHNEYXRhICYmIGRpZmZlcmVuY2UgIT09IDApIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9jb250cm9scy4kYWJzb2x1dGUuaHRtbCh0aGlzLl90ZW1wbGF0ZXMuam9pbignJykpO1xcblxcdFxcdFxcdH0gZWxzZSBpZiAoZGlmZmVyZW5jZSA+IDApIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9jb250cm9scy4kYWJzb2x1dGUuYXBwZW5kKG5ldyBBcnJheShkaWZmZXJlbmNlICsgMSkuam9pbih0aGlzLl90ZW1wbGF0ZXNbMF0pKTtcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKGRpZmZlcmVuY2UgPCAwKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fY29udHJvbHMuJGFic29sdXRlLmNoaWxkcmVuKCkuc2xpY2UoZGlmZmVyZW5jZSkucmVtb3ZlKCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuX2NvbnRyb2xzLiRhYnNvbHV0ZS5maW5kKCcuYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xcblxcdFxcdFxcdHRoaXMuX2NvbnRyb2xzLiRhYnNvbHV0ZS5jaGlsZHJlbigpLmVxKCQuaW5BcnJheSh0aGlzLmN1cnJlbnQoKSwgdGhpcy5fcGFnZXMpKS5hZGRDbGFzcygnYWN0aXZlJyk7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogRXh0ZW5kcyBldmVudCBkYXRhLlxcblxcdCAqIEBwcm90ZWN0ZWRcXG5cXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBldmVudCBvYmplY3Qgd2hpY2ggZ2V0cyB0aHJvd24uXFxuXFx0ICovXFxuXFx0TmF2aWdhdGlvbi5wcm90b3R5cGUub25UcmlnZ2VyID0gZnVuY3Rpb24oZXZlbnQpIHtcXG5cXHRcXHR2YXIgc2V0dGluZ3MgPSB0aGlzLl9jb3JlLnNldHRpbmdzO1xcblxcblxcdFxcdGV2ZW50LnBhZ2UgPSB7XFxuXFx0XFx0XFx0aW5kZXg6ICQuaW5BcnJheSh0aGlzLmN1cnJlbnQoKSwgdGhpcy5fcGFnZXMpLFxcblxcdFxcdFxcdGNvdW50OiB0aGlzLl9wYWdlcy5sZW5ndGgsXFxuXFx0XFx0XFx0c2l6ZTogc2V0dGluZ3MgJiYgKHNldHRpbmdzLmNlbnRlciB8fCBzZXR0aW5ncy5hdXRvV2lkdGggfHwgc2V0dGluZ3MuZG90c0RhdGFcXG5cXHRcXHRcXHRcXHQ/IDEgOiBzZXR0aW5ncy5kb3RzRWFjaCB8fCBzZXR0aW5ncy5pdGVtcylcXG5cXHRcXHR9O1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogR2V0cyB0aGUgY3VycmVudCBwYWdlIHBvc2l0aW9uIG9mIHRoZSBjYXJvdXNlbC5cXG5cXHQgKiBAcHJvdGVjdGVkXFxuXFx0ICogQHJldHVybnMge051bWJlcn1cXG5cXHQgKi9cXG5cXHROYXZpZ2F0aW9uLnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0dmFyIGN1cnJlbnQgPSB0aGlzLl9jb3JlLnJlbGF0aXZlKHRoaXMuX2NvcmUuY3VycmVudCgpKTtcXG5cXHRcXHRyZXR1cm4gJC5ncmVwKHRoaXMuX3BhZ2VzLCAkLnByb3h5KGZ1bmN0aW9uKHBhZ2UsIGluZGV4KSB7XFxuXFx0XFx0XFx0cmV0dXJuIHBhZ2Uuc3RhcnQgPD0gY3VycmVudCAmJiBwYWdlLmVuZCA+PSBjdXJyZW50O1xcblxcdFxcdH0sIHRoaXMpKS5wb3AoKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEdldHMgdGhlIGN1cnJlbnQgc3VjY2Vzb3IvcHJlZGVjZXNzb3IgcG9zaXRpb24uXFxuXFx0ICogQHByb3RlY3RlZFxcblxcdCAqIEByZXR1cm5zIHtOdW1iZXJ9XFxuXFx0ICovXFxuXFx0TmF2aWdhdGlvbi5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbihzdWNjZXNzb3IpIHtcXG5cXHRcXHR2YXIgcG9zaXRpb24sIGxlbmd0aCxcXG5cXHRcXHRcXHRzZXR0aW5ncyA9IHRoaXMuX2NvcmUuc2V0dGluZ3M7XFxuXFxuXFx0XFx0aWYgKHNldHRpbmdzLnNsaWRlQnkgPT0gJ3BhZ2UnKSB7XFxuXFx0XFx0XFx0cG9zaXRpb24gPSAkLmluQXJyYXkodGhpcy5jdXJyZW50KCksIHRoaXMuX3BhZ2VzKTtcXG5cXHRcXHRcXHRsZW5ndGggPSB0aGlzLl9wYWdlcy5sZW5ndGg7XFxuXFx0XFx0XFx0c3VjY2Vzc29yID8gKytwb3NpdGlvbiA6IC0tcG9zaXRpb247XFxuXFx0XFx0XFx0cG9zaXRpb24gPSB0aGlzLl9wYWdlc1soKHBvc2l0aW9uICUgbGVuZ3RoKSArIGxlbmd0aCkgJSBsZW5ndGhdLnN0YXJ0O1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0cG9zaXRpb24gPSB0aGlzLl9jb3JlLnJlbGF0aXZlKHRoaXMuX2NvcmUuY3VycmVudCgpKTtcXG5cXHRcXHRcXHRsZW5ndGggPSB0aGlzLl9jb3JlLml0ZW1zKCkubGVuZ3RoO1xcblxcdFxcdFxcdHN1Y2Nlc3NvciA/IHBvc2l0aW9uICs9IHNldHRpbmdzLnNsaWRlQnkgOiBwb3NpdGlvbiAtPSBzZXR0aW5ncy5zbGlkZUJ5O1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gcG9zaXRpb247XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBTbGlkZXMgdG8gdGhlIG5leHQgaXRlbSBvciBwYWdlLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKiBAcGFyYW0ge051bWJlcn0gW3NwZWVkPWZhbHNlXSAtIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIHRyYW5zaXRpb24uXFxuXFx0ICovXFxuXFx0TmF2aWdhdGlvbi5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKHNwZWVkKSB7XFxuXFx0XFx0JC5wcm94eSh0aGlzLl9vdmVycmlkZXMudG8sIHRoaXMuX2NvcmUpKHRoaXMuZ2V0UG9zaXRpb24odHJ1ZSksIHNwZWVkKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFNsaWRlcyB0byB0aGUgcHJldmlvdXMgaXRlbSBvciBwYWdlLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKiBAcGFyYW0ge051bWJlcn0gW3NwZWVkPWZhbHNlXSAtIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIHRyYW5zaXRpb24uXFxuXFx0ICovXFxuXFx0TmF2aWdhdGlvbi5wcm90b3R5cGUucHJldiA9IGZ1bmN0aW9uKHNwZWVkKSB7XFxuXFx0XFx0JC5wcm94eSh0aGlzLl9vdmVycmlkZXMudG8sIHRoaXMuX2NvcmUpKHRoaXMuZ2V0UG9zaXRpb24oZmFsc2UpLCBzcGVlZCk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBTbGlkZXMgdG8gdGhlIHNwZWNpZmllZCBpdGVtIG9yIHBhZ2UuXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgaXRlbSBvciBwYWdlLlxcblxcdCAqIEBwYXJhbSB7TnVtYmVyfSBbc3BlZWRdIC0gVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgdHJhbnNpdGlvbi5cXG5cXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtzdGFuZGFyZD1mYWxzZV0gLSBXaGV0aGVyIHRvIHVzZSB0aGUgc3RhbmRhcmQgYmVoYXZpb3VyIG9yIG5vdC5cXG5cXHQgKi9cXG5cXHROYXZpZ2F0aW9uLnByb3RvdHlwZS50byA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBzcGVlZCwgc3RhbmRhcmQpIHtcXG5cXHRcXHR2YXIgbGVuZ3RoO1xcblxcblxcdFxcdGlmICghc3RhbmRhcmQgJiYgdGhpcy5fcGFnZXMubGVuZ3RoKSB7XFxuXFx0XFx0XFx0bGVuZ3RoID0gdGhpcy5fcGFnZXMubGVuZ3RoO1xcblxcdFxcdFxcdCQucHJveHkodGhpcy5fb3ZlcnJpZGVzLnRvLCB0aGlzLl9jb3JlKSh0aGlzLl9wYWdlc1soKHBvc2l0aW9uICUgbGVuZ3RoKSArIGxlbmd0aCkgJSBsZW5ndGhdLnN0YXJ0LCBzcGVlZCk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHQkLnByb3h5KHRoaXMuX292ZXJyaWRlcy50bywgdGhpcy5fY29yZSkocG9zaXRpb24sIHNwZWVkKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQkLmZuLm93bENhcm91c2VsLkNvbnN0cnVjdG9yLlBsdWdpbnMuTmF2aWdhdGlvbiA9IE5hdmlnYXRpb247XFxuXFxufSkod2luZG93LlplcHRvIHx8IF9fd2VicGFja19wcm92aWRlZF93aW5kb3dfZG90X2pRdWVyeSwgd2luZG93LCBkb2N1bWVudCk7XFxuXFxuLyoqXFxuICogSGFzaCBQbHVnaW5cXG4gKiBAdmVyc2lvbiAyLjEuMFxcbiAqIEBhdXRob3IgQXJ0dXMgS29sYW5vd3NraVxcbiAqIEBhdXRob3IgRGF2aWQgRGV1dHNjaFxcbiAqIEBsaWNlbnNlIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxcbiAqL1xcbjsoZnVuY3Rpb24oJCwgd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XFxuXFx0J3VzZSBzdHJpY3QnO1xcblxcblxcdC8qKlxcblxcdCAqIENyZWF0ZXMgdGhlIGhhc2ggcGx1Z2luLlxcblxcdCAqIEBjbGFzcyBUaGUgSGFzaCBQbHVnaW5cXG5cXHQgKiBAcGFyYW0ge093bH0gY2Fyb3VzZWwgLSBUaGUgT3dsIENhcm91c2VsXFxuXFx0ICovXFxuXFx0dmFyIEhhc2ggPSBmdW5jdGlvbihjYXJvdXNlbCkge1xcblxcdFxcdC8qKlxcblxcdFxcdCAqIFJlZmVyZW5jZSB0byB0aGUgY29yZS5cXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICogQHR5cGUge093bH1cXG5cXHRcXHQgKi9cXG5cXHRcXHR0aGlzLl9jb3JlID0gY2Fyb3VzZWw7XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogSGFzaCBpbmRleCBmb3IgdGhlIGl0ZW1zLlxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKiBAdHlwZSB7T2JqZWN0fVxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX2hhc2hlcyA9IHt9O1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIFRoZSBjYXJvdXNlbCBlbGVtZW50LlxcblxcdFxcdCAqIEB0eXBlIHtqUXVlcnl9XFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy4kZWxlbWVudCA9IHRoaXMuX2NvcmUuJGVsZW1lbnQ7XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogQWxsIGV2ZW50IGhhbmRsZXJzLlxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKiBAdHlwZSB7T2JqZWN0fVxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX2hhbmRsZXJzID0ge1xcblxcdFxcdFxcdCdpbml0aWFsaXplZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgdGhpcy5fY29yZS5zZXR0aW5ncy5zdGFydFBvc2l0aW9uID09PSAnVVJMSGFzaCcpIHtcXG5cXHRcXHRcXHRcXHRcXHQkKHdpbmRvdykudHJpZ2dlcignaGFzaGNoYW5nZS5vd2wubmF2aWdhdGlvbicpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHQncHJlcGFyZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbihlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGhhc2ggPSAkKGUuY29udGVudCkuZmluZCgnW2RhdGEtaGFzaF0nKS5hZGRCYWNrKCdbZGF0YS1oYXNoXScpLmF0dHIoJ2RhdGEtaGFzaCcpO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICghaGFzaCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5faGFzaGVzW2hhc2hdID0gZS5jb250ZW50O1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHQnY2hhbmdlZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgZS5wcm9wZXJ0eS5uYW1lID09PSAncG9zaXRpb24nKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGN1cnJlbnQgPSB0aGlzLl9jb3JlLml0ZW1zKHRoaXMuX2NvcmUucmVsYXRpdmUodGhpcy5fY29yZS5jdXJyZW50KCkpKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRoYXNoID0gJC5tYXAodGhpcy5faGFzaGVzLCBmdW5jdGlvbihpdGVtLCBoYXNoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGl0ZW0gPT09IGN1cnJlbnQgPyBoYXNoIDogbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9KS5qb2luKCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFoYXNoIHx8IHdpbmRvdy5sb2NhdGlvbi5oYXNoLnNsaWNlKDEpID09PSBoYXNoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR3aW5kb3cubG9jYXRpb24uaGFzaCA9IGhhc2g7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBzZXQgZGVmYXVsdCBvcHRpb25zXFxuXFx0XFx0dGhpcy5fY29yZS5vcHRpb25zID0gJC5leHRlbmQoe30sIEhhc2guRGVmYXVsdHMsIHRoaXMuX2NvcmUub3B0aW9ucyk7XFxuXFxuXFx0XFx0Ly8gcmVnaXN0ZXIgdGhlIGV2ZW50IGhhbmRsZXJzXFxuXFx0XFx0dGhpcy4kZWxlbWVudC5vbih0aGlzLl9oYW5kbGVycyk7XFxuXFxuXFx0XFx0Ly8gcmVnaXN0ZXIgZXZlbnQgbGlzdGVuZXIgZm9yIGhhc2ggbmF2aWdhdGlvblxcblxcdFxcdCQod2luZG93KS5vbignaGFzaGNoYW5nZS5vd2wubmF2aWdhdGlvbicsICQucHJveHkoZnVuY3Rpb24oZSkge1xcblxcdFxcdFxcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uLmhhc2guc3Vic3RyaW5nKDEpLFxcblxcdFxcdFxcdFxcdGl0ZW1zID0gdGhpcy5fY29yZS4kc3RhZ2UuY2hpbGRyZW4oKSxcXG5cXHRcXHRcXHRcXHRwb3NpdGlvbiA9IHRoaXMuX2hhc2hlc1toYXNoXSAmJiBpdGVtcy5pbmRleCh0aGlzLl9oYXNoZXNbaGFzaF0pO1xcblxcblxcdFxcdFxcdGlmIChwb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHBvc2l0aW9uID09PSB0aGlzLl9jb3JlLmN1cnJlbnQoKSkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5fY29yZS50byh0aGlzLl9jb3JlLnJlbGF0aXZlKHBvc2l0aW9uKSwgZmFsc2UsIHRydWUpO1xcblxcdFxcdH0sIHRoaXMpKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIERlZmF1bHQgb3B0aW9ucy5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICovXFxuXFx0SGFzaC5EZWZhdWx0cyA9IHtcXG5cXHRcXHRVUkxoYXNoTGlzdGVuZXI6IGZhbHNlXFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBEZXN0cm95cyB0aGUgcGx1Z2luLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKi9cXG5cXHRIYXNoLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0dmFyIGhhbmRsZXIsIHByb3BlcnR5O1xcblxcblxcdFxcdCQod2luZG93KS5vZmYoJ2hhc2hjaGFuZ2Uub3dsLm5hdmlnYXRpb24nKTtcXG5cXG5cXHRcXHRmb3IgKGhhbmRsZXIgaW4gdGhpcy5faGFuZGxlcnMpIHtcXG5cXHRcXHRcXHR0aGlzLl9jb3JlLiRlbGVtZW50Lm9mZihoYW5kbGVyLCB0aGlzLl9oYW5kbGVyc1toYW5kbGVyXSk7XFxuXFx0XFx0fVxcblxcdFxcdGZvciAocHJvcGVydHkgaW4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykpIHtcXG5cXHRcXHRcXHR0eXBlb2YgdGhpc1twcm9wZXJ0eV0gIT0gJ2Z1bmN0aW9uJyAmJiAodGhpc1twcm9wZXJ0eV0gPSBudWxsKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQkLmZuLm93bENhcm91c2VsLkNvbnN0cnVjdG9yLlBsdWdpbnMuSGFzaCA9IEhhc2g7XFxuXFxufSkod2luZG93LlplcHRvIHx8IF9fd2VicGFja19wcm92aWRlZF93aW5kb3dfZG90X2pRdWVyeSwgd2luZG93LCBkb2N1bWVudCk7XFxuXFxuLyoqXFxuICogU3VwcG9ydCBQbHVnaW5cXG4gKlxcbiAqIEB2ZXJzaW9uIDIuMS4wXFxuICogQGF1dGhvciBWaXZpZCBQbGFuZXQgU29mdHdhcmUgR21iSFxcbiAqIEBhdXRob3IgQXJ0dXMgS29sYW5vd3NraVxcbiAqIEBhdXRob3IgRGF2aWQgRGV1dHNjaFxcbiAqIEBsaWNlbnNlIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxcbiAqL1xcbjsoZnVuY3Rpb24oJCwgd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XFxuXFxuXFx0dmFyIHN0eWxlID0gJCgnPHN1cHBvcnQ+JykuZ2V0KDApLnN0eWxlLFxcblxcdFxcdHByZWZpeGVzID0gJ1dlYmtpdCBNb3ogTyBtcycuc3BsaXQoJyAnKSxcXG5cXHRcXHRldmVudHMgPSB7XFxuXFx0XFx0XFx0dHJhbnNpdGlvbjoge1xcblxcdFxcdFxcdFxcdGVuZDoge1xcblxcdFxcdFxcdFxcdFxcdFdlYmtpdFRyYW5zaXRpb246ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcXG5cXHRcXHRcXHRcXHRcXHRNb3pUcmFuc2l0aW9uOiAndHJhbnNpdGlvbmVuZCcsXFxuXFx0XFx0XFx0XFx0XFx0T1RyYW5zaXRpb246ICdvVHJhbnNpdGlvbkVuZCcsXFxuXFx0XFx0XFx0XFx0XFx0dHJhbnNpdGlvbjogJ3RyYW5zaXRpb25lbmQnXFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0YW5pbWF0aW9uOiB7XFxuXFx0XFx0XFx0XFx0ZW5kOiB7XFxuXFx0XFx0XFx0XFx0XFx0V2Via2l0QW5pbWF0aW9uOiAnd2Via2l0QW5pbWF0aW9uRW5kJyxcXG5cXHRcXHRcXHRcXHRcXHRNb3pBbmltYXRpb246ICdhbmltYXRpb25lbmQnLFxcblxcdFxcdFxcdFxcdFxcdE9BbmltYXRpb246ICdvQW5pbWF0aW9uRW5kJyxcXG5cXHRcXHRcXHRcXHRcXHRhbmltYXRpb246ICdhbmltYXRpb25lbmQnXFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdHRlc3RzID0ge1xcblxcdFxcdFxcdGNzc3RyYW5zZm9ybXM6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdHJldHVybiAhIXRlc3QoJ3RyYW5zZm9ybScpO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0Y3NzdHJhbnNmb3JtczNkOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gISF0ZXN0KCdwZXJzcGVjdGl2ZScpO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0Y3NzdHJhbnNpdGlvbnM6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdHJldHVybiAhIXRlc3QoJ3RyYW5zaXRpb24nKTtcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdGNzc2FuaW1hdGlvbnM6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdHJldHVybiAhIXRlc3QoJ2FuaW1hdGlvbicpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcblxcdGZ1bmN0aW9uIHRlc3QocHJvcGVydHksIHByZWZpeGVkKSB7XFxuXFx0XFx0dmFyIHJlc3VsdCA9IGZhbHNlLFxcblxcdFxcdFxcdHVwcGVyID0gcHJvcGVydHkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zbGljZSgxKTtcXG5cXG5cXHRcXHQkLmVhY2goKHByb3BlcnR5ICsgJyAnICsgcHJlZml4ZXMuam9pbih1cHBlciArICcgJykgKyB1cHBlcikuc3BsaXQoJyAnKSwgZnVuY3Rpb24oaSwgcHJvcGVydHkpIHtcXG5cXHRcXHRcXHRpZiAoc3R5bGVbcHJvcGVydHldICE9PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRcXHRyZXN1bHQgPSBwcmVmaXhlZCA/IHByb3BlcnR5IDogdHJ1ZTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0pO1xcblxcblxcdFxcdHJldHVybiByZXN1bHQ7XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIHByZWZpeGVkKHByb3BlcnR5KSB7XFxuXFx0XFx0cmV0dXJuIHRlc3QocHJvcGVydHksIHRydWUpO1xcblxcdH1cXG5cXG5cXHRpZiAodGVzdHMuY3NzdHJhbnNpdGlvbnMoKSkge1xcblxcdFxcdC8qIGpzaGludCAtVzA1MyAqL1xcblxcdFxcdCQuc3VwcG9ydC50cmFuc2l0aW9uID0gbmV3IFN0cmluZyhwcmVmaXhlZCgndHJhbnNpdGlvbicpKVxcblxcdFxcdCQuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCA9IGV2ZW50cy50cmFuc2l0aW9uLmVuZFsgJC5zdXBwb3J0LnRyYW5zaXRpb24gXTtcXG5cXHR9XFxuXFxuXFx0aWYgKHRlc3RzLmNzc2FuaW1hdGlvbnMoKSkge1xcblxcdFxcdC8qIGpzaGludCAtVzA1MyAqL1xcblxcdFxcdCQuc3VwcG9ydC5hbmltYXRpb24gPSBuZXcgU3RyaW5nKHByZWZpeGVkKCdhbmltYXRpb24nKSlcXG5cXHRcXHQkLnN1cHBvcnQuYW5pbWF0aW9uLmVuZCA9IGV2ZW50cy5hbmltYXRpb24uZW5kWyAkLnN1cHBvcnQuYW5pbWF0aW9uIF07XFxuXFx0fVxcblxcblxcdGlmICh0ZXN0cy5jc3N0cmFuc2Zvcm1zKCkpIHtcXG5cXHRcXHQvKiBqc2hpbnQgLVcwNTMgKi9cXG5cXHRcXHQkLnN1cHBvcnQudHJhbnNmb3JtID0gbmV3IFN0cmluZyhwcmVmaXhlZCgndHJhbnNmb3JtJykpO1xcblxcdFxcdCQuc3VwcG9ydC50cmFuc2Zvcm0zZCA9IHRlc3RzLmNzc3RyYW5zZm9ybXMzZCgpO1xcblxcdH1cXG5cXG59KSh3aW5kb3cuWmVwdG8gfHwgX193ZWJwYWNrX3Byb3ZpZGVkX3dpbmRvd19kb3RfalF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50KTtcXG5cXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygxKSwgX193ZWJwYWNrX3JlcXVpcmVfXygxKSkpXFxuXFxuLy8vLy8vLy8vLy8vLy8vLy8vXFxuLy8gV0VCUEFDSyBGT09URVJcXG4vLyAuL34vb3dsLmNhcm91c2VsL2Rpc3Qvb3dsLmNhcm91c2VsLmpzXFxuLy8gbW9kdWxlIGlkID0gOFxcbi8vIG1vZHVsZSBjaHVua3MgPSAwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vfi9vd2wuY2Fyb3VzZWwvZGlzdC9vd2wuY2Fyb3VzZWwuanM/XCIpO1xuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcIi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihwcm9jZXNzKSB7LyoqXFxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXFxuICpcXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXFxuICovXFxuXFxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcXG4gIHZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxcbiAgICBTeW1ib2wuZm9yICYmXFxuICAgIFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSkgfHxcXG4gICAgMHhlYWM3O1xcblxcbiAgdmFyIGlzVmFsaWRFbGVtZW50ID0gZnVuY3Rpb24ob2JqZWN0KSB7XFxuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxcbiAgICAgIG9iamVjdCAhPT0gbnVsbCAmJlxcbiAgICAgIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xcbiAgfTtcXG5cXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxcbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxcbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xcbiAgbW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKShpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XFxufSBlbHNlIHtcXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXFxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXFxuICBtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMjApKCk7XFxufVxcblxcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSlcXG5cXG4vLy8vLy8vLy8vLy8vLy8vLy9cXG4vLyBXRUJQQUNLIEZPT1RFUlxcbi8vIC4vfi9wcm9wLXR5cGVzL2luZGV4LmpzXFxuLy8gbW9kdWxlIGlkID0gOVxcbi8vIG1vZHVsZSBjaHVua3MgPSAwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vfi9wcm9wLXR5cGVzL2luZGV4LmpzP1wiKTtcblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcXG5cXG4vLyBsb2FkIHRoZSBzdHlsZXNcXG52YXIgY29udGVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmksIGNvbnRlbnQsICcnXV07XFxuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxcbnZhciB0cmFuc2Zvcm07XFxuXFxudmFyIG9wdGlvbnMgPSB7fVxcbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXFxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxcbnZhciB1cGRhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpKGNvbnRlbnQsIG9wdGlvbnMpO1xcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcXG5pZihmYWxzZSkge1xcblxcdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXFxuXFx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XFxuXFx0XFx0bW9kdWxlLmhvdC5hY2NlcHQoXFxcIiEhLi4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL293bC5jYXJvdXNlbC5taW4uY3NzXFxcIiwgZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFxcXCIhIS4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9vd2wuY2Fyb3VzZWwubWluLmNzc1xcXCIpO1xcblxcdFxcdFxcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xcblxcdFxcdFxcdHVwZGF0ZShuZXdDb250ZW50KTtcXG5cXHRcXHR9KTtcXG5cXHR9XFxuXFx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xcblxcdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xcbn1cXG5cXG4vLy8vLy8vLy8vLy8vLy8vLy9cXG4vLyBXRUJQQUNLIEZPT1RFUlxcbi8vIC4vfi9vd2wuY2Fyb3VzZWwvZGlzdC9hc3NldHMvb3dsLmNhcm91c2VsLm1pbi5jc3NcXG4vLyBtb2R1bGUgaWQgPSAxMFxcbi8vIG1vZHVsZSBjaHVua3MgPSAwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vfi9vd2wuY2Fyb3VzZWwvZGlzdC9hc3NldHMvb3dsLmNhcm91c2VsLm1pbi5jc3M/XCIpO1xuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xcblxcbi8vIGxvYWQgdGhlIHN0eWxlc1xcbnZhciBjb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XFxuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaSwgY29udGVudCwgJyddXTtcXG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXFxudmFyIHRyYW5zZm9ybTtcXG5cXG52YXIgb3B0aW9ucyA9IHt9XFxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXFxudmFyIHVwZGF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNykoY29udGVudCwgb3B0aW9ucyk7XFxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XFxuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxcbmlmKGZhbHNlKSB7XFxuXFx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcXG5cXHRpZighY29udGVudC5sb2NhbHMpIHtcXG5cXHRcXHRtb2R1bGUuaG90LmFjY2VwdChcXFwiISEuLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vb3dsLnRoZW1lLmRlZmF1bHQubWluLmNzc1xcXCIsIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcXFwiISEuLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vb3dsLnRoZW1lLmRlZmF1bHQubWluLmNzc1xcXCIpO1xcblxcdFxcdFxcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xcblxcdFxcdFxcdHVwZGF0ZShuZXdDb250ZW50KTtcXG5cXHRcXHR9KTtcXG5cXHR9XFxuXFx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xcblxcdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xcbn1cXG5cXG4vLy8vLy8vLy8vLy8vLy8vLy9cXG4vLyBXRUJQQUNLIEZPT1RFUlxcbi8vIC4vfi9vd2wuY2Fyb3VzZWwvZGlzdC9hc3NldHMvb3dsLnRoZW1lLmRlZmF1bHQubWluLmNzc1xcbi8vIG1vZHVsZSBpZCA9IDExXFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9+L293bC5jYXJvdXNlbC9kaXN0L2Fzc2V0cy9vd2wudGhlbWUuZGVmYXVsdC5taW4uY3NzP1wiKTtcblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5ldmFsKFwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzEyX187XFxuXFxuLy8vLy8vLy8vLy8vLy8vLy8vXFxuLy8gV0VCUEFDSyBGT09URVJcXG4vLyBleHRlcm5hbCB7XFxcInJvb3RcXFwiOlxcXCJSZWFjdFxcXCIsXFxcImNvbW1vbmpzMlxcXCI6XFxcInJlYWN0XFxcIixcXFwiY29tbW9uanNcXFwiOlxcXCJyZWFjdFxcXCIsXFxcImFtZFxcXCI6XFxcInJlYWN0XFxcIn1cXG4vLyBtb2R1bGUgaWQgPSAxMlxcbi8vIG1vZHVsZSBjaHVua3MgPSAwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vL2V4dGVybmFsXyU3QiUyMnJvb3QlMjI6JTIyUmVhY3QlMjIsJTIyY29tbW9uanMyJTIyOiUyMnJlYWN0JTIyLCUyMmNvbW1vbmpzJTIyOiUyMnJlYWN0JTIyLCUyMmFtZCUyMjolMjJyZWFjdCUyMiU3RD9cIik7XG5cbi8qKiovIH0pLFxuLyogMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFxcXCJfX2VzTW9kdWxlXFxcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oJCkgey8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfcmVhY3RfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfcmVhY3RfX19kZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9yZWFjdF9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18ubihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fKTtcXG5cXG5cXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xcblxcbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xcblxcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cXG5cXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXFxcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFxcXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXFxcIm9iamVjdFxcXCIgfHwgdHlwZW9mIGNhbGwgPT09IFxcXCJmdW5jdGlvblxcXCIpID8gY2FsbCA6IHNlbGY7IH1cXG5cXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcXFwiZnVuY3Rpb25cXFwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcXFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxcblxcblxcblxcblxcbnZhciBPd2xfQ2Fyb3VzZWxfT3B0aW9ucyA9IHtcXG5cXG4gICAgLy8gb3B0aW9uc1xcbiAgICBpdGVtczogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEubnVtYmVyLFxcbiAgICBtYXJnaW46IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLm51bWJlcixcXG4gICAgbG9vcDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYm9vbCxcXG4gICAgY2VudGVyOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5ib29sLFxcbiAgICBtb3VzZURyYWc6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmJvb2wsXFxuICAgIHRvdWNoRHJhZzogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYm9vbCxcXG4gICAgcHVsbERyYWc6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmJvb2wsXFxuICAgIGZyZWVEcmFnOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5ib29sLFxcbiAgICBzdGFnZVBhZGRpbmc6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLm51bWJlcixcXG4gICAgbWVyZ2U6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmJvb2wsXFxuICAgIG1lcmdlRml0OiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5ib29sLFxcbiAgICBhdXRvV2lkdGg6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmJvb2wsXFxuICAgIHN0YXJ0UG9zaXRpb246IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLm9uZU9mVHlwZShbX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEubnVtYmVyLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5zdHJpbmddKSxcXG4gICAgVVJMaGFzaExpc3RlbmVyOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5ib29sLFxcbiAgICBuYXY6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmJvb2wsXFxuICAgIHJld2luZDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYm9vbCxcXG4gICAgbmF2VGV4dDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEub25lT2ZUeXBlKFtfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5hcnJheU9mKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLnN0cmluZyksIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmFycmF5T2YoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuZWxlbWVudCldKSxcXG4gICAgbmF2RWxlbWVudDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuc3RyaW5nLFxcbiAgICBzbGlkZUJ5OiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5vbmVPZlR5cGUoW19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLm51bWJlciwgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuc3RyaW5nXSksXFxuICAgIGRvdHM6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmJvb2wsXFxuICAgIGRvdHNFYWNoOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5vbmVPZlR5cGUoW19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLm51bWJlciwgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYm9vbF0pLFxcbiAgICBkb3REYXRhOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5ib29sLFxcbiAgICBsYXp5TG9hZDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYm9vbCxcXG4gICAgbGF6eUNvbnRlbnQ6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmJvb2wsXFxuICAgIGF1dG9wbGF5OiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5ib29sLFxcbiAgICBhdXRvcGxheVRpbWVvdXQ6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLm51bWJlcixcXG4gICAgYXV0b3BsYXlIb3ZlclBhdXNlOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5ib29sLFxcbiAgICBzbWFydFNwZWVkOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5udW1iZXIsXFxuICAgIGZsdWlkU3BlZWQ6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmJvb2wsXFxuICAgIGF1dG9wbGF5U3BlZWQ6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLm9uZU9mVHlwZShbX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEubnVtYmVyLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5ib29sXSksXFxuICAgIG5hdlNwZWVkOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5vbmVPZlR5cGUoW19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLm51bWJlciwgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYm9vbF0pLFxcbiAgICBkb3RzU3BlZWQ6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLm9uZU9mVHlwZShbX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEubnVtYmVyLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5ib29sXSksXFxuICAgIGRyYWdFbmRTcGVlZDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEub25lT2ZUeXBlKFtfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5udW1iZXIsIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmJvb2xdKSxcXG4gICAgY2FsbGJhY2tzOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5ib29sLFxcbiAgICByZXNwb25zaXZlOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5vYmplY3QsXFxuICAgIHJlc3BvbnNpdmVSZWZyZXNoUmF0ZTogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEubnVtYmVyLFxcbiAgICByZXNwb25zaXZlQmFzZUVsZW1lbnQ6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmVsZW1lbnQsXFxuICAgIHZpZGVvOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5ib29sLFxcbiAgICB2aWRlb0hlaWdodDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEub25lT2ZUeXBlKFtfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5udW1iZXIsIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmJvb2xdKSxcXG4gICAgdmlkZW9XaWR0aDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEub25lT2ZUeXBlKFtfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5udW1iZXIsIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmJvb2xdKSxcXG4gICAgYW5pbWF0ZU91dDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEub25lT2ZUeXBlKFtfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5zdHJpbmcsIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmJvb2xdKSxcXG4gICAgYW5pbWF0ZUluOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5vbmVPZlR5cGUoW19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLnN0cmluZywgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYm9vbF0pLFxcbiAgICBmYWxsYmFja0Vhc2luZzogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuc3RyaW5nLFxcbiAgICBpbmZvOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5vbmVPZlR5cGUoW19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmZ1bmMsIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmJvb2xdKSxcXG4gICAgbmVzdGVkSXRlbVNlbGVjdG9yOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5vbmVPZlR5cGUoW19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLnN0cmluZywgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYm9vbF0pLFxcbiAgICBpdGVtRWxlbWVudDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuc3RyaW5nLFxcbiAgICBzdGFnZUVsZW1lbnQ6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLnN0cmluZyxcXG4gICAgbmF2Q29udGFpbmVyOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5vbmVPZlR5cGUoW19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLnN0cmluZywgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYm9vbF0pLFxcbiAgICBkb3RzQ29udGFpbmVyOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5vbmVPZlR5cGUoW19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLnN0cmluZywgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYm9vbF0pLFxcblxcbiAgICAvLyBkb20gY2xhc3NcXG4gICAgcmVmcmVzaENsYXNzOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5zdHJpbmcsXFxuICAgIGxvYWRpbmdDbGFzczogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuc3RyaW5nLFxcbiAgICBsb2FkZWRDbGFzczogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuc3RyaW5nLFxcbiAgICBydGxDbGFzczogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuc3RyaW5nLFxcbiAgICBkcmFnQ2xhc3M6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLnN0cmluZyxcXG4gICAgZ3JhYkNsYXNzOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5zdHJpbmcsXFxuICAgIHN0YWdlQ2xhc3M6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLnN0cmluZyxcXG4gICAgc3RhZ2VPdXRlckNsYXNzOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5zdHJpbmcsXFxuICAgIG5hdkNvbnRhaW5lckNsYXNzOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5zdHJpbmcsXFxuICAgIG5hdkNsYXNzOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5hcnJheU9mKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLnN0cmluZyksXFxuICAgIGNvbnRyb2xzQ2xhc3M6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLnN0cmluZyxcXG4gICAgZG90Q2xhc3M6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLnN0cmluZyxcXG4gICAgZG90c0NsYXNzOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5zdHJpbmcsXFxuICAgIGF1dG9IZWlnaHRDbGFzczogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuc3RyaW5nLFxcbiAgICByZXNwb25zaXZlQ2xhc3M6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLm9uZU9mVHlwZShbX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuc3RyaW5nLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5ib29sXSksXFxuXFxuICAgIC8vIGV2ZW50XFxuICAgIG9uSW5pdGlhbGl6ZTogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuZnVuYyxcXG4gICAgb25Jbml0aWFsaXplZDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuZnVuYyxcXG4gICAgb25SZXNpemU6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmZ1bmMsXFxuICAgIG9uUmVzaXplZDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuZnVuYyxcXG4gICAgb25SZWZyZXNoOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5mdW5jLFxcbiAgICBvblJlZnJlc2hlZDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuZnVuYyxcXG4gICAgb25EcmFnOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5mdW5jLFxcbiAgICBvbkRyYWdnZWQ6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmZ1bmMsXFxuICAgIG9uVHJhbnNsYXRlOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5mdW5jLFxcbiAgICBvblRyYW5zbGF0ZWQ6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmZ1bmMsXFxuICAgIG9uQ2hhbmdlOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5mdW5jLFxcbiAgICBvbkNoYW5nZWQ6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmZ1bmMsXFxuICAgIG9uTG9hZExhenk6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmZ1bmMsXFxuICAgIG9uTG9hZGVkTGF6eTogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuZnVuYyxcXG4gICAgb25TdG9wVmlkZW86IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmZ1bmMsXFxuICAgIG9uUGxheVZpZGVvOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5mdW5jXFxufTtcXG5cXG52YXIgT3dsQ2Fyb3VzZWwgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xcbiAgICBfaW5oZXJpdHMoT3dsQ2Fyb3VzZWwsIF9Db21wb25lbnQpO1xcblxcbiAgICBmdW5jdGlvbiBPd2xDYXJvdXNlbChwcm9wcywgY29udGV4dCkge1xcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE93bENhcm91c2VsKTtcXG5cXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChPd2xDYXJvdXNlbC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE93bENhcm91c2VsKSkuY2FsbCh0aGlzLCBwcm9wcywgY29udGV4dCkpO1xcblxcbiAgICAgICAgX3RoaXMubmV4dCA9IF90aGlzLm5leHQuYmluZChfdGhpcyk7XFxuICAgICAgICBfdGhpcy5wcmV2ID0gX3RoaXMucHJldi5iaW5kKF90aGlzKTtcXG4gICAgICAgIF90aGlzLnRvID0gX3RoaXMudG8uYmluZChfdGhpcyk7XFxuICAgICAgICBfdGhpcy5jcmVhdGUgPSBfdGhpcy5jcmVhdGUuYmluZChfdGhpcyk7XFxuICAgICAgICBfdGhpcy5kZXN0b3J5ID0gX3RoaXMuZGVzdG9yeS5iaW5kKF90aGlzKTtcXG4gICAgICAgIF90aGlzLnBsYXkgPSBfdGhpcy5wbGF5LmJpbmQoX3RoaXMpO1xcbiAgICAgICAgX3RoaXMuc3RvcCA9IF90aGlzLnN0b3AuYmluZChfdGhpcyk7XFxuICAgICAgICByZXR1cm4gX3RoaXM7XFxuICAgIH1cXG5cXG4gICAgX2NyZWF0ZUNsYXNzKE93bENhcm91c2VsLCBbe1xcbiAgICAgICAga2V5OiAnY29tcG9uZW50V2lsbE1vdW50JyxcXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XFxuICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XFxuICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XFxuICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcXG5cXG4gICAgICAgICAgICB0aGlzLl9maWx0ZXJQcm9wcyh0aGlzLnByb3BzKTtcXG4gICAgICAgIH1cXG4gICAgfSwge1xcbiAgICAgICAga2V5OiAnY29tcG9uZW50RGlkTW91bnQnLFxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xcbiAgICAgICAgICAgIHRoaXMub3dsQ2Fyb3VzZWwgPSAkKHRoaXMuaW5zdCk7XFxuICAgICAgICAgICAgdGhpcy5vd2xDYXJvdXNlbC5vd2xDYXJvdXNlbCh0aGlzLm9wdGlvbnMpO1xcbiAgICAgICAgfVxcbiAgICB9LCB7XFxuICAgICAgICBrZXk6ICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyxcXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xcbiAgICAgICAgICAgIHRoaXMuX2ZpbHRlclByb3BzKG5leHRQcm9wcyk7XFxuICAgICAgICAgICAgdGhpcy5kZXN0b3J5KCk7XFxuICAgICAgICB9XFxuICAgIH0sIHtcXG4gICAgICAgIGtleTogJ2NvbXBvbmVudERpZFVwZGF0ZScsXFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKCkge1xcbiAgICAgICAgICAgIHRoaXMub3dsQ2Fyb3VzZWwgPSAkKHRoaXMuaW5zdCk7XFxuICAgICAgICAgICAgdGhpcy5vd2xDYXJvdXNlbC5vd2xDYXJvdXNlbCh0aGlzLm9wdGlvbnMpO1xcbiAgICAgICAgfVxcbiAgICB9LCB7XFxuICAgICAgICBrZXk6ICdjb21wb25lbnRXaWxsVW5tb3VudCcsXFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XFxuICAgICAgICAgICAgdGhpcy5kZXN0b3J5KCk7XFxuICAgICAgICB9XFxuICAgIH0sIHtcXG4gICAgICAgIGtleTogJ25leHQnLFxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG5leHQoc3BlZWQpIHtcXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNwZWVkID09ICdudW1iZXInKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMub3dsQ2Fyb3VzZWwudHJpZ2dlcignbmV4dC5vd2wuY2Fyb3VzZWwnLCBbc3BlZWRdKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICB0aGlzLm93bENhcm91c2VsLnRyaWdnZXIoJ25leHQub3dsLmNhcm91c2VsJyk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9LCB7XFxuICAgICAgICBrZXk6ICdwcmV2JyxcXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwcmV2KHNwZWVkKSB7XFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzcGVlZCA9PSAnbnVtYmVyJykge1xcbiAgICAgICAgICAgICAgICB0aGlzLm93bENhcm91c2VsLnRyaWdnZXIoJ3ByZXYub3dsLmNhcm91c2VsJywgW3NwZWVkXSk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5vd2xDYXJvdXNlbC50cmlnZ2VyKCdwcmV2Lm93bC5jYXJvdXNlbCcpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vIHJlZnJlc2goZXZlbnQsIHNwZWVkKSB7XFxuICAgICAgICAvLyB9XFxuXFxuICAgIH0sIHtcXG4gICAgICAgIGtleTogJ3RvJyxcXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0byhwb3NpdGlvbiwgc3BlZWQpIHtcXG4gICAgICAgICAgICBpZiAodHlwZW9mIHBvc2l0aW9uID09ICdudW1iZXInICYmIHR5cGVvZiBzcGVlZCA9PSAnbnVtYmVyJykge1xcbiAgICAgICAgICAgICAgICB0aGlzLm93bENhcm91c2VsLnRyaWdnZXIoJ3RvLm93bC5jYXJvdXNlbCcsIFtwb3NpdGlvbiwgc3BlZWRdKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICB0aGlzLm93bENhcm91c2VsLnRyaWdnZXIoJ3RvLm93bC5jYXJvdXNlbCcpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfSwge1xcbiAgICAgICAga2V5OiAnY3JlYXRlJyxcXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUoKSB7XFxuICAgICAgICAgICAgdGhpcy5vd2xDYXJvdXNlbC5vd2xDYXJvdXNlbCh0aGlzLm9wdGlvbnMpO1xcbiAgICAgICAgfVxcbiAgICB9LCB7XFxuICAgICAgICBrZXk6ICdkZXN0b3J5JyxcXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0b3J5KCkge1xcbiAgICAgICAgICAgIHRoaXMub3dsQ2Fyb3VzZWwudHJpZ2dlcignZGVzdHJveS5vd2wuY2Fyb3VzZWwnKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vIHJlcGxhY2UoZGF0YSkge1xcblxcbiAgICAgICAgLy8gfVxcblxcbiAgICAgICAgLy8gYWRkKGRhdGEsIHBvc2l0aW9uKSB7XFxuXFxuICAgICAgICAvLyB9XFxuXFxuICAgICAgICAvLyByZW1vdmUocG9zaXRpb24pIHtcXG5cXG4gICAgICAgIC8vIH1cXG5cXG4gICAgfSwge1xcbiAgICAgICAga2V5OiAncGxheScsXFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcGxheSh0aW1lb3V0LCBzcGVlZCkge1xcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGltZW91dCA9PSAnbnVtYmVyJyAmJiB0eXBlb2Ygc3BlZWQgPT0gJ251bWJlcicpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5vd2xDYXJvdXNlbC50cmlnZ2VyKCdwbGF5Lm93bC5hdXRvcGxheScsIFt0aW1lb3V0LCBzcGVlZF0pO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHRoaXMub3dsQ2Fyb3VzZWwudHJpZ2dlcigncGxheS5vd2wuYXV0b3BsYXknKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH0sIHtcXG4gICAgICAgIGtleTogJ3N0b3AnLFxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3AoKSB7XFxuICAgICAgICAgICAgdGhpcy5vd2xDYXJvdXNlbC50cmlnZ2VyKCdzdG9wLm93bC5hdXRvcGxheScpO1xcbiAgICAgICAgfVxcbiAgICB9LCB7XFxuICAgICAgICBrZXk6ICdfZmlsdGVyUHJvcHMnLFxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9maWx0ZXJQcm9wcyhwcm9wcykge1xcbiAgICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xcblxcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xcbiAgICAgICAgICAgIHRoaXMucHJvcHNXaXRob3V0T3B0aW9ucyA9IHt9O1xcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHByb3BzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcXG4gICAgICAgICAgICAgICAgaWYgKE93bF9DYXJvdXNlbF9PcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIHtcXG4gICAgICAgICAgICAgICAgICAgIF90aGlzMi5vcHRpb25zW2tleV0gPSBwcm9wc1trZXldO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMyLnByb3BzV2l0aG91dE9wdGlvbnNba2V5XSA9IHByb3BzW2tleV07XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgfSwge1xcbiAgICAgICAga2V5OiAncmVuZGVyJyxcXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XFxuICAgICAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XFxuXFxuICAgICAgICAgICAgdmFyIF9wcm9wc1dpdGhvdXRPcHRpb25zID0gdGhpcy5wcm9wc1dpdGhvdXRPcHRpb25zLFxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUgPSBfcHJvcHNXaXRob3V0T3B0aW9ucy5jbGFzc05hbWUsXFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gX3Byb3BzV2l0aG91dE9wdGlvbnMuY2hpbGRyZW4sXFxuICAgICAgICAgICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wc1dpdGhvdXRPcHRpb25zLCBbJ2NsYXNzTmFtZScsICdjaGlsZHJlbiddKTtcXG5cXG4gICAgICAgICAgICByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX3JlYWN0X19fZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoXFxuICAgICAgICAgICAgICAgICdkaXYnLFxcbiAgICAgICAgICAgICAgICBfZXh0ZW5kcyh7XFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdvd2wtY2Fyb3VzZWwgJyArIGNsYXNzTmFtZSxcXG4gICAgICAgICAgICAgICAgICAgIHJlZjogZnVuY3Rpb24gcmVmKGluc3QpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMzLmluc3QgPSBpbnN0O1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9LCBwcm9wcyksXFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuXFxuICAgICAgICAgICAgKTtcXG4gICAgICAgIH1cXG4gICAgfV0pO1xcblxcbiAgICByZXR1cm4gT3dsQ2Fyb3VzZWw7XFxufShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfcmVhY3RfX1tcXFwiQ29tcG9uZW50XFxcIl0pO1xcblxcbk93bENhcm91c2VsLnByb3BUeXBlcyA9IE93bF9DYXJvdXNlbF9PcHRpb25zO1xcblxcbk93bENhcm91c2VsLmRlZmF1bHRQcm9wcyA9IHtcXG4gICAgY2xhc3NOYW1lOiAnJ1xcbn07XFxuXFxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1xcXCJkZWZhdWx0XFxcIl0gPSAoT3dsQ2Fyb3VzZWwpO1xcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKSlcXG5cXG4vLy8vLy8vLy8vLy8vLy8vLy9cXG4vLyBXRUJQQUNLIEZPT1RFUlxcbi8vIC4vY29tcG9uZW50cy9Pd2xDYXJvdXNlbC5qc3hcXG4vLyBtb2R1bGUgaWQgPSAxM1xcbi8vIG1vZHVsZSBjaHVua3MgPSAwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9Pd2xDYXJvdXNlbC5qc3g/XCIpO1xuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJ2YXIgZXNjYXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KShmYWxzZSk7XFxuLy8gaW1wb3J0c1xcblxcblxcbi8vIG1vZHVsZVxcbmV4cG9ydHMucHVzaChbbW9kdWxlLmksIFxcXCIvKipcXFxcbiAqIE93bCBDYXJvdXNlbCB2Mi4yLjBcXFxcbiAqIENvcHlyaWdodCAyMDEzLTIwMTYgRGF2aWQgRGV1dHNjaFxcXFxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vT3dsQ2Fyb3VzZWwyL093bENhcm91c2VsMi9ibG9iL21hc3Rlci9MSUNFTlNFKVxcXFxuICovXFxcXG4ub3dsLWNhcm91c2VsLC5vd2wtY2Fyb3VzZWwgLm93bC1pdGVtey13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjp0cmFuc3BhcmVudDtwb3NpdGlvbjpyZWxhdGl2ZX0ub3dsLWNhcm91c2Vse2Rpc3BsYXk6bm9uZTt3aWR0aDoxMDAlO3otaW5kZXg6MX0ub3dsLWNhcm91c2VsIC5vd2wtc3RhZ2V7cG9zaXRpb246cmVsYXRpdmU7LW1zLXRvdWNoLWFjdGlvbjpwYW4tWX0ub3dsLWNhcm91c2VsIC5vd2wtc3RhZ2U6YWZ0ZXJ7Y29udGVudDpcXFxcXFxcIi5cXFxcXFxcIjtkaXNwbGF5OmJsb2NrO2NsZWFyOmJvdGg7dmlzaWJpbGl0eTpoaWRkZW47bGluZS1oZWlnaHQ6MDtoZWlnaHQ6MH0ub3dsLWNhcm91c2VsIC5vd2wtc3RhZ2Utb3V0ZXJ7cG9zaXRpb246cmVsYXRpdmU7b3ZlcmZsb3c6aGlkZGVuOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsMCwwKX0ub3dsLWNhcm91c2VsIC5vd2wtaXRlbXttaW4taGVpZ2h0OjFweDtmbG9hdDpsZWZ0Oy13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTpoaWRkZW47LXdlYmtpdC10b3VjaC1jYWxsb3V0Om5vbmV9Lm93bC1jYXJvdXNlbCAub3dsLWl0ZW0gaW1ne2Rpc3BsYXk6YmxvY2s7d2lkdGg6MTAwJTstd2Via2l0LXRyYW5zZm9ybS1zdHlsZTpwcmVzZXJ2ZS0zZH0ub3dsLWNhcm91c2VsIC5vd2wtZG90cy5kaXNhYmxlZCwub3dsLWNhcm91c2VsIC5vd2wtbmF2LmRpc2FibGVke2Rpc3BsYXk6bm9uZX0ubm8tanMgLm93bC1jYXJvdXNlbCwub3dsLWNhcm91c2VsLm93bC1sb2FkZWR7ZGlzcGxheTpibG9ja30ub3dsLWNhcm91c2VsIC5vd2wtZG90LC5vd2wtY2Fyb3VzZWwgLm93bC1uYXYgLm93bC1uZXh0LC5vd2wtY2Fyb3VzZWwgLm93bC1uYXYgLm93bC1wcmV2e2N1cnNvcjpwb2ludGVyO2N1cnNvcjpoYW5kOy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTsta2h0bWwtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZX0ub3dsLWNhcm91c2VsLm93bC1sb2FkaW5ne29wYWNpdHk6MDtkaXNwbGF5OmJsb2NrfS5vd2wtY2Fyb3VzZWwub3dsLWhpZGRlbntvcGFjaXR5OjB9Lm93bC1jYXJvdXNlbC5vd2wtcmVmcmVzaCAub3dsLWl0ZW17dmlzaWJpbGl0eTpoaWRkZW59Lm93bC1jYXJvdXNlbC5vd2wtZHJhZyAub3dsLWl0ZW17LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lfS5vd2wtY2Fyb3VzZWwub3dsLWdyYWJ7Y3Vyc29yOm1vdmU7Y3Vyc29yOmdyYWJ9Lm93bC1jYXJvdXNlbC5vd2wtcnRse2RpcmVjdGlvbjpydGx9Lm93bC1jYXJvdXNlbC5vd2wtcnRsIC5vd2wtaXRlbXtmbG9hdDpyaWdodH0ub3dsLWNhcm91c2VsIC5hbmltYXRlZHstd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjoxczthbmltYXRpb24tZHVyYXRpb246MXM7LXdlYmtpdC1hbmltYXRpb24tZmlsbC1tb2RlOmJvdGg7YW5pbWF0aW9uLWZpbGwtbW9kZTpib3RofS5vd2wtY2Fyb3VzZWwgLm93bC1hbmltYXRlZC1pbnt6LWluZGV4OjB9Lm93bC1jYXJvdXNlbCAub3dsLWFuaW1hdGVkLW91dHt6LWluZGV4OjF9Lm93bC1jYXJvdXNlbCAuZmFkZU91dHstd2Via2l0LWFuaW1hdGlvbi1uYW1lOmZhZGVPdXQ7YW5pbWF0aW9uLW5hbWU6ZmFkZU91dH1ALXdlYmtpdC1rZXlmcmFtZXMgZmFkZU91dHswJXtvcGFjaXR5OjF9MTAwJXtvcGFjaXR5OjB9fUBrZXlmcmFtZXMgZmFkZU91dHswJXtvcGFjaXR5OjF9MTAwJXtvcGFjaXR5OjB9fS5vd2wtaGVpZ2h0e3RyYW5zaXRpb246aGVpZ2h0IC41cyBlYXNlLWluLW91dH0ub3dsLWNhcm91c2VsIC5vd2wtaXRlbSAub3dsLWxhenl7b3BhY2l0eTowO3RyYW5zaXRpb246b3BhY2l0eSAuNHMgZWFzZX0ub3dsLWNhcm91c2VsIC5vd2wtaXRlbSBpbWcub3dsLWxhenl7LXdlYmtpdC10cmFuc2Zvcm0tc3R5bGU6cHJlc2VydmUtM2Q7dHJhbnNmb3JtLXN0eWxlOnByZXNlcnZlLTNkfS5vd2wtY2Fyb3VzZWwgLm93bC12aWRlby13cmFwcGVye3Bvc2l0aW9uOnJlbGF0aXZlO2hlaWdodDoxMDAlO2JhY2tncm91bmQ6IzAwMH0ub3dsLWNhcm91c2VsIC5vd2wtdmlkZW8tcGxheS1pY29ue3Bvc2l0aW9uOmFic29sdXRlO2hlaWdodDo4MHB4O3dpZHRoOjgwcHg7bGVmdDo1MCU7dG9wOjUwJTttYXJnaW4tbGVmdDotNDBweDttYXJnaW4tdG9wOi00MHB4O2JhY2tncm91bmQ6dXJsKFxcXCIgKyBlc2NhcGUoX193ZWJwYWNrX3JlcXVpcmVfXygxNykpICsgXFxcIikgbm8tcmVwZWF0O2N1cnNvcjpwb2ludGVyO3otaW5kZXg6MTstd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHk6aGlkZGVuO3RyYW5zaXRpb246LXdlYmtpdC10cmFuc2Zvcm0gLjFzIGVhc2U7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gLjFzIGVhc2V9Lm93bC1jYXJvdXNlbCAub3dsLXZpZGVvLXBsYXktaWNvbjpob3Zlcnstd2Via2l0LXRyYW5zZm9ybTpzY2FsZSgxLjMsMS4zKTstbXMtdHJhbnNmb3JtOnNjYWxlKDEuMywxLjMpO3RyYW5zZm9ybTpzY2FsZSgxLjMsMS4zKX0ub3dsLWNhcm91c2VsIC5vd2wtdmlkZW8tcGxheWluZyAub3dsLXZpZGVvLXBsYXktaWNvbiwub3dsLWNhcm91c2VsIC5vd2wtdmlkZW8tcGxheWluZyAub3dsLXZpZGVvLXRue2Rpc3BsYXk6bm9uZX0ub3dsLWNhcm91c2VsIC5vd2wtdmlkZW8tdG57b3BhY2l0eTowO2hlaWdodDoxMDAlO2JhY2tncm91bmQtcG9zaXRpb246Y2VudGVyIGNlbnRlcjtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1zaXplOmNvbnRhaW47dHJhbnNpdGlvbjpvcGFjaXR5IC40cyBlYXNlfS5vd2wtY2Fyb3VzZWwgLm93bC12aWRlby1mcmFtZXtwb3NpdGlvbjpyZWxhdGl2ZTt6LWluZGV4OjE7aGVpZ2h0OjEwMCU7d2lkdGg6MTAwJX1cXFwiLCBcXFwiXFxcIl0pO1xcblxcbi8vIGV4cG9ydHNcXG5cXG5cXG4vLy8vLy8vLy8vLy8vLy8vLy9cXG4vLyBXRUJQQUNLIEZPT1RFUlxcbi8vIC4vfi9jc3MtbG9hZGVyIS4vfi9vd2wuY2Fyb3VzZWwvZGlzdC9hc3NldHMvb3dsLmNhcm91c2VsLm1pbi5jc3NcXG4vLyBtb2R1bGUgaWQgPSAxNFxcbi8vIG1vZHVsZSBjaHVua3MgPSAwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vfi9vd2wuY2Fyb3VzZWwvZGlzdC9hc3NldHMvb3dsLmNhcm91c2VsLm1pbi5jc3M/Li9+L2Nzcy1sb2FkZXJcIik7XG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNSkoZmFsc2UpO1xcbi8vIGltcG9ydHNcXG5cXG5cXG4vLyBtb2R1bGVcXG5leHBvcnRzLnB1c2goW21vZHVsZS5pLCBcXFwiLyoqXFxcXG4gKiBPd2wgQ2Fyb3VzZWwgdjIuMi4wXFxcXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE2IERhdmlkIERldXRzY2hcXFxcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL093bENhcm91c2VsMi9Pd2xDYXJvdXNlbDIvYmxvYi9tYXN0ZXIvTElDRU5TRSlcXFxcbiAqL1xcXFxuLm93bC10aGVtZSAub3dsLWRvdHMsLm93bC10aGVtZSAub3dsLW5hdnt0ZXh0LWFsaWduOmNlbnRlcjstd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6dHJhbnNwYXJlbnR9Lm93bC10aGVtZSAub3dsLW5hdnttYXJnaW4tdG9wOjEwcHh9Lm93bC10aGVtZSAub3dsLW5hdiBbY2xhc3MqPW93bC1de2NvbG9yOiNGRkY7Zm9udC1zaXplOjE0cHg7bWFyZ2luOjVweDtwYWRkaW5nOjRweCA3cHg7YmFja2dyb3VuZDojRDZENkQ2O2Rpc3BsYXk6aW5saW5lLWJsb2NrO2N1cnNvcjpwb2ludGVyO2JvcmRlci1yYWRpdXM6M3B4fS5vd2wtdGhlbWUgLm93bC1uYXYgW2NsYXNzKj1vd2wtXTpob3ZlcntiYWNrZ3JvdW5kOiM4Njk3OTE7Y29sb3I6I0ZGRjt0ZXh0LWRlY29yYXRpb246bm9uZX0ub3dsLXRoZW1lIC5vd2wtbmF2IC5kaXNhYmxlZHtvcGFjaXR5Oi41O2N1cnNvcjpkZWZhdWx0fS5vd2wtdGhlbWUgLm93bC1uYXYuZGlzYWJsZWQrLm93bC1kb3Rze21hcmdpbi10b3A6MTBweH0ub3dsLXRoZW1lIC5vd2wtZG90cyAub3dsLWRvdHtkaXNwbGF5OmlubGluZS1ibG9jazt6b29tOjF9Lm93bC10aGVtZSAub3dsLWRvdHMgLm93bC1kb3Qgc3Bhbnt3aWR0aDoxMHB4O2hlaWdodDoxMHB4O21hcmdpbjo1cHggN3B4O2JhY2tncm91bmQ6I0Q2RDZENjtkaXNwbGF5OmJsb2NrOy13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTp2aXNpYmxlO3RyYW5zaXRpb246b3BhY2l0eSAuMnMgZWFzZTtib3JkZXItcmFkaXVzOjMwcHh9Lm93bC10aGVtZSAub3dsLWRvdHMgLm93bC1kb3QuYWN0aXZlIHNwYW4sLm93bC10aGVtZSAub3dsLWRvdHMgLm93bC1kb3Q6aG92ZXIgc3BhbntiYWNrZ3JvdW5kOiM4Njk3OTF9XFxcIiwgXFxcIlxcXCJdKTtcXG5cXG4vLyBleHBvcnRzXFxuXFxuXFxuLy8vLy8vLy8vLy8vLy8vLy8vXFxuLy8gV0VCUEFDSyBGT09URVJcXG4vLyAuL34vY3NzLWxvYWRlciEuL34vb3dsLmNhcm91c2VsL2Rpc3QvYXNzZXRzL293bC50aGVtZS5kZWZhdWx0Lm1pbi5jc3NcXG4vLyBtb2R1bGUgaWQgPSAxNVxcbi8vIG1vZHVsZSBjaHVua3MgPSAwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vfi9vd2wuY2Fyb3VzZWwvZGlzdC9hc3NldHMvb3dsLnRoZW1lLmRlZmF1bHQubWluLmNzcz8uL34vY3NzLWxvYWRlclwiKTtcblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5ldmFsKFwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlc2NhcGUodXJsKSB7XFxuICAgIGlmICh0eXBlb2YgdXJsICE9PSAnc3RyaW5nJykge1xcbiAgICAgICAgcmV0dXJuIHVybFxcbiAgICB9XFxuICAgIC8vIElmIHVybCBpcyBhbHJlYWR5IHdyYXBwZWQgaW4gcXVvdGVzLCByZW1vdmUgdGhlbVxcbiAgICBpZiAoL15bJ1xcXCJdLipbJ1xcXCJdJC8udGVzdCh1cmwpKSB7XFxuICAgICAgICB1cmwgPSB1cmwuc2xpY2UoMSwgLTEpO1xcbiAgICB9XFxuICAgIC8vIFNob3VsZCB1cmwgYmUgd3JhcHBlZD9cXG4gICAgLy8gU2VlIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtdmFsdWVzLTMvI3VybHNcXG4gICAgaWYgKC9bXFxcIicoKSBcXFxcdFxcXFxuXS8udGVzdCh1cmwpKSB7XFxuICAgICAgICByZXR1cm4gJ1xcXCInICsgdXJsLnJlcGxhY2UoL1xcXCIvZywgJ1xcXFxcXFxcXFxcIicpLnJlcGxhY2UoL1xcXFxuL2csICdcXFxcXFxcXG4nKSArICdcXFwiJ1xcbiAgICB9XFxuXFxuICAgIHJldHVybiB1cmxcXG59XFxuXFxuXFxuLy8vLy8vLy8vLy8vLy8vLy8vXFxuLy8gV0VCUEFDSyBGT09URVJcXG4vLyAuL34vY3NzLWxvYWRlci9saWIvdXJsL2VzY2FwZS5qc1xcbi8vIG1vZHVsZSBpZCA9IDE2XFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9+L2Nzcy1sb2FkZXIvbGliL3VybC9lc2NhcGUuanM/XCIpO1xuXG4vKioqLyB9KSxcbi8qIDE3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18ucCArIFxcXCI0YTM3ZjgwMDg5NTljNzVmNjE5YmYwYTNhNGUyZDdhMi5wbmdcXFwiO1xcblxcbi8vLy8vLy8vLy8vLy8vLy8vL1xcbi8vIFdFQlBBQ0sgRk9PVEVSXFxuLy8gLi9+L293bC5jYXJvdXNlbC9kaXN0L2Fzc2V0cy9vd2wudmlkZW8ucGxheS5wbmdcXG4vLyBtb2R1bGUgaWQgPSAxN1xcbi8vIG1vZHVsZSBjaHVua3MgPSAwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vfi9vd2wuY2Fyb3VzZWwvZGlzdC9hc3NldHMvb3dsLnZpZGVvLnBsYXkucG5nP1wiKTtcblxuLyoqKi8gfSksXG4vKiAxOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCIvKlxcbm9iamVjdC1hc3NpZ25cXG4oYykgU2luZHJlIFNvcmh1c1xcbkBsaWNlbnNlIE1JVFxcbiovXFxuXFxuXFxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcXG5cXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcXG5cXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIE9iamVjdCh2YWwpO1xcbn1cXG5cXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XFxuXFx0dHJ5IHtcXG5cXHRcXHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cXG5cXG5cXHRcXHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XFxuXFx0XFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xcblxcdFxcdHRlc3QxWzVdID0gJ2RlJztcXG5cXHRcXHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcXG5cXHRcXHR2YXIgdGVzdDIgPSB7fTtcXG5cXHRcXHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcXG5cXHRcXHRcXHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XFxuXFx0XFx0fVxcblxcdFxcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRlc3QyW25dO1xcblxcdFxcdH0pO1xcblxcdFxcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxcblxcdFxcdHZhciB0ZXN0MyA9IHt9O1xcblxcdFxcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xcblxcdFxcdFxcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XFxuXFx0XFx0fSk7XFxuXFx0XFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XFxuXFx0XFx0XFx0XFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0fSBjYXRjaCAoZXJyKSB7XFxuXFx0XFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cXG5cXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0fVxcbn1cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xcblxcdHZhciBmcm9tO1xcblxcdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XFxuXFx0dmFyIHN5bWJvbHM7XFxuXFxuXFx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcXG5cXHRcXHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XFxuXFxuXFx0XFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcXG5cXHRcXHRcXHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XFxuXFx0XFx0XFx0XFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcXG5cXHRcXHRcXHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xcblxcdFxcdFxcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xcblxcdFxcdFxcdFxcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcXG5cXHRcXHRcXHRcXHRcXHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdHJldHVybiB0bztcXG59O1xcblxcblxcbi8vLy8vLy8vLy8vLy8vLy8vL1xcbi8vIFdFQlBBQ0sgRk9PVEVSXFxuLy8gLi9+L29iamVjdC1hc3NpZ24vaW5kZXguanNcXG4vLyBtb2R1bGUgaWQgPSAxOFxcbi8vIG1vZHVsZSBjaHVua3MgPSAwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vfi9vYmplY3QtYXNzaWduL2luZGV4LmpzP1wiKTtcblxuLyoqKi8gfSksXG4vKiAxOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCIvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24ocHJvY2Vzcykgey8qKlxcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxcbiAqXFxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXFxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxcbiAqL1xcblxcblxcblxcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XFxuICB2YXIgaW52YXJpYW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcXG4gIHZhciB3YXJuaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcXG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XFxuICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XFxufVxcblxcbi8qKlxcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cXG4gKlxcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXFxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXFxcInByb3BcXFwiLCBcXFwiY29udGV4dFxcXCIsIFxcXCJjaGlsZCBjb250ZXh0XFxcIlxcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXFxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cXG4gKiBAcHJpdmF0ZVxcbiAqL1xcbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XFxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcXG4gICAgICBpZiAodHlwZVNwZWNzLmhhc093blByb3BlcnR5KHR5cGVTcGVjTmFtZSkpIHtcXG4gICAgICAgIHZhciBlcnJvcjtcXG4gICAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXFxuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXFxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxcbiAgICAgICAgICBpbnZhcmlhbnQodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdID09PSAnZnVuY3Rpb24nLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSAnICsgJ3RoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAlc2AuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0pO1xcbiAgICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcXG4gICAgICAgICAgZXJyb3IgPSBleDtcXG4gICAgICAgIH1cXG4gICAgICAgIHdhcm5pbmcoIWVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgRXJyb3IsICclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvcik7XFxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcXG5cXG4gICAgICAgICAgdmFyIHN0YWNrID0gZ2V0U3RhY2sgPyBnZXRTdGFjaygpIDogJyc7XFxuXFxuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgJXMgdHlwZTogJXMlcycsIGxvY2F0aW9uLCBlcnJvci5tZXNzYWdlLCBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJyk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxufVxcblxcbm1vZHVsZS5leHBvcnRzID0gY2hlY2tQcm9wVHlwZXM7XFxuXFxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oMCkpKVxcblxcbi8vLy8vLy8vLy8vLy8vLy8vL1xcbi8vIFdFQlBBQ0sgRk9PVEVSXFxuLy8gLi9+L3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanNcXG4vLyBtb2R1bGUgaWQgPSAxOVxcbi8vIG1vZHVsZSBjaHVua3MgPSAwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vfi9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzP1wiKTtcblxuLyoqKi8gfSksXG4vKiAyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCIvKipcXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cXG4gKlxcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cXG4gKi9cXG5cXG5cXG5cXG52YXIgZW1wdHlGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XFxudmFyIGludmFyaWFudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XFxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xcbiAgZnVuY3Rpb24gc2hpbShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xcbiAgICBpZiAoc2VjcmV0ID09PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xcbiAgICAgIC8vIEl0IGlzIHN0aWxsIHNhZmUgd2hlbiBjYWxsZWQgZnJvbSBSZWFjdC5cXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgaW52YXJpYW50KFxcbiAgICAgIGZhbHNlLFxcbiAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcXG4gICAgICAnVXNlIFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpIHRvIGNhbGwgdGhlbS4gJyArXFxuICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXFxuICAgICk7XFxuICB9O1xcbiAgc2hpbS5pc1JlcXVpcmVkID0gc2hpbTtcXG4gIGZ1bmN0aW9uIGdldFNoaW0oKSB7XFxuICAgIHJldHVybiBzaGltO1xcbiAgfTtcXG4gIC8vIEltcG9ydGFudCFcXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanNgLlxcbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xcbiAgICBhcnJheTogc2hpbSxcXG4gICAgYm9vbDogc2hpbSxcXG4gICAgZnVuYzogc2hpbSxcXG4gICAgbnVtYmVyOiBzaGltLFxcbiAgICBvYmplY3Q6IHNoaW0sXFxuICAgIHN0cmluZzogc2hpbSxcXG4gICAgc3ltYm9sOiBzaGltLFxcblxcbiAgICBhbnk6IHNoaW0sXFxuICAgIGFycmF5T2Y6IGdldFNoaW0sXFxuICAgIGVsZW1lbnQ6IHNoaW0sXFxuICAgIGluc3RhbmNlT2Y6IGdldFNoaW0sXFxuICAgIG5vZGU6IHNoaW0sXFxuICAgIG9iamVjdE9mOiBnZXRTaGltLFxcbiAgICBvbmVPZjogZ2V0U2hpbSxcXG4gICAgb25lT2ZUeXBlOiBnZXRTaGltLFxcbiAgICBzaGFwZTogZ2V0U2hpbSxcXG4gICAgZXhhY3Q6IGdldFNoaW1cXG4gIH07XFxuXFxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGVtcHR5RnVuY3Rpb247XFxuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcXG5cXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcXG59O1xcblxcblxcbi8vLy8vLy8vLy8vLy8vLy8vL1xcbi8vIFdFQlBBQ0sgRk9PVEVSXFxuLy8gLi9+L3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzXFxuLy8gbW9kdWxlIGlkID0gMjBcXG4vLyBtb2R1bGUgY2h1bmtzID0gMFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL34vcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanM/XCIpO1xuXG4vKioqLyB9KSxcbi8qIDIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihwcm9jZXNzKSB7LyoqXFxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXFxuICpcXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXFxuICovXFxuXFxuXFxuXFxudmFyIGVtcHR5RnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xcbnZhciBpbnZhcmlhbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xcbnZhciB3YXJuaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcXG52YXIgYXNzaWduID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XFxuXFxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcXG52YXIgY2hlY2tQcm9wVHlwZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKSB7XFxuICAvKiBnbG9iYWwgU3ltYm9sICovXFxuICB2YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XFxuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cXG5cXG4gIC8qKlxcbiAgICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxcbiAgICpcXG4gICAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxcbiAgICpcXG4gICAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XFxuICAgKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcXG4gICAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcXG4gICAqICAgICAgIC4uLlxcbiAgICogICAgIH1cXG4gICAqXFxuICAgKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn1cXG4gICAqL1xcbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XFxuICAgIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XFxuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgIHJldHVybiBpdGVyYXRvckZuO1xcbiAgICB9XFxuICB9XFxuXFxuICAvKipcXG4gICAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXFxuICAgKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxcbiAgICpcXG4gICAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcXG4gICAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcXG4gICAqICAgICBwcm9wVHlwZXM6IHtcXG4gICAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFxcXCJkZXNjcmlwdGlvblxcXCIuXFxuICAgKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxcbiAgICpcXG4gICAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFxcXCJjYXRlZ29yeVxcXCIuXFxuICAgKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXFxuICAgKlxcbiAgICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFxcXCJkaWFsb2dcXFwiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxcbiAgICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxcbiAgICogICAgIH0sXFxuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cXG4gICAqICAgfSk7XFxuICAgKlxcbiAgICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxcbiAgICpcXG4gICAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxcbiAgICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XFxuICAgKlxcbiAgICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xcbiAgICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxcbiAgICpcXG4gICAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xcbiAgICogICAgcHJvcFR5cGVzOiB7XFxuICAgKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcXFwiaHJlZlxcXCIuXFxuICAgKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xcbiAgICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XFxuICAgKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXFxuICAgKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xcbiAgICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcXG4gICAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcXG4gICAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxcbiAgICogICAgICAgICAgKTtcXG4gICAqICAgICAgICB9XFxuICAgKiAgICAgIH1cXG4gICAqICAgIH0sXFxuICAgKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cXG4gICAqICB9KTtcXG4gICAqXFxuICAgKiBAaW50ZXJuYWxcXG4gICAqL1xcblxcbiAgdmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcXG5cXG4gIC8vIEltcG9ydGFudCFcXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzYC5cXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcXG4gICAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxcbiAgICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxcbiAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcXG4gICAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXFxuICAgIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxcbiAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcXG4gICAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXFxuXFxuICAgIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcXG4gICAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxcbiAgICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcXG4gICAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcXG4gICAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXFxuICAgIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcXG4gICAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIsXFxuICAgIGV4YWN0OiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyLFxcbiAgfTtcXG5cXG4gIC8qKlxcbiAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxcbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXFxuICAgKi9cXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cXG4gIGZ1bmN0aW9uIGlzKHgsIHkpIHtcXG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxcbiAgICBpZiAoeCA9PT0geSkge1xcbiAgICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxcbiAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXFxuICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXFxuICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcXG4gICAgfVxcbiAgfVxcbiAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXFxuXFxuICAvKipcXG4gICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcXG4gICAqIFByb3BUeXBlcyBkaXJlY3RseSBhbmQgaW5zcGVjdCB0aGVpciBvdXRwdXQuIEhvd2V2ZXIsIHdlIGRvbid0IHVzZSByZWFsXFxuICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXFxuICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XFxuICAgKiBoYXBwZW5zIGluIG9uZU9mVHlwZSgpIGZvciBhbnkgdHlwZSBiZWZvcmUgdGhlIG9uZSB0aGF0IG1hdGNoZWQuXFxuICAgKi9cXG4gIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSkge1xcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xcbiAgICB0aGlzLnN0YWNrID0gJyc7XFxuICB9XFxuICAvLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXFxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcXG5cXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XFxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XFxuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlID0ge307XFxuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50ID0gMDtcXG4gICAgfVxcbiAgICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcXG4gICAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XFxuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xcblxcbiAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XFxuICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xcbiAgICAgICAgICAvLyBOZXcgYmVoYXZpb3Igb25seSBmb3IgdXNlcnMgb2YgYHByb3AtdHlwZXNgIHBhY2thZ2VcXG4gICAgICAgICAgaW52YXJpYW50KFxcbiAgICAgICAgICAgIGZhbHNlLFxcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcXG4gICAgICAgICAgICAnVXNlIGBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKWAgdG8gY2FsbCB0aGVtLiAnICtcXG4gICAgICAgICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcXG4gICAgICAgICAgKTtcXG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXFxuICAgICAgICAgIHZhciBjYWNoZUtleSA9IGNvbXBvbmVudE5hbWUgKyAnOicgKyBwcm9wTmFtZTtcXG4gICAgICAgICAgaWYgKFxcbiAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcXG4gICAgICAgICAgICAvLyBBdm9pZCBzcGFtbWluZyB0aGUgY29uc29sZSBiZWNhdXNlIHRoZXkgYXJlIG9mdGVuIG5vdCBhY3Rpb25hYmxlIGV4Y2VwdCBmb3IgbGliIGF1dGhvcnNcXG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA8IDNcXG4gICAgICAgICAgKSB7XFxuICAgICAgICAgICAgd2FybmluZyhcXG4gICAgICAgICAgICAgIGZhbHNlLFxcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIGZvciB0aGUgYCVzYCBwcm9wIG9uIGAlc2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICtcXG4gICAgICAgICAgICAgICdhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXFxuICAgICAgICAgICAgICAnWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyAnICtcXG4gICAgICAgICAgICAgICdsaWJyYXJ5LiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgJyArICdmb3IgZGV0YWlscy4nLFxcbiAgICAgICAgICAgICAgcHJvcEZ1bGxOYW1lLFxcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxcbiAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldID0gdHJ1ZTtcXG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xcbiAgICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcXG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgJyArICgnaW4gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYG51bGxgLicpKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBudWxsO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgdmFyIGNoYWluZWRDaGVja1R5cGUgPSBjaGVja1R5cGUuYmluZChudWxsLCBmYWxzZSk7XFxuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xcblxcbiAgICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XFxuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcXG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xcbiAgICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXFxuICAgICAgICAvLyBjaGVjaywgYnV0IHdlIGNhbiBvZmZlciBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGhlcmUgcmF0aGVyIHRoYW5cXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cXG4gICAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XFxuXFxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBudWxsO1xcbiAgICB9XFxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpIHtcXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcXG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xcbiAgICAgIH1cXG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XFxuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xcbiAgICAgIH1cXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJywgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcXG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gbnVsbDtcXG4gICAgfVxcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcXG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcXG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBudWxsO1xcbiAgICB9XFxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyKGV4cGVjdGVkQ2xhc3MpIHtcXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XFxuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcXG4gICAgICAgIHZhciBleHBlY3RlZENsYXNzTmFtZSA9IGV4cGVjdGVkQ2xhc3MubmFtZSB8fCBBTk9OWU1PVVM7XFxuICAgICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XFxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBudWxsO1xcbiAgICB9XFxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIoZXhwZWN0ZWRWYWx1ZXMpIHtcXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XFxuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgaWYgKGlzKHByb3BWYWx1ZSwgZXhwZWN0ZWRWYWx1ZXNbaV0pKSB7XFxuICAgICAgICAgIHJldHVybiBudWxsO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMpO1xcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdmFsdWUgYCcgKyBwcm9wVmFsdWUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcXG4gICAgfVxcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcXG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBvYmplY3RPZi4nKTtcXG4gICAgICB9XFxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcXG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcXG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XFxuICAgICAgfVxcbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcXG4gICAgICAgIGlmIChwcm9wVmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xcbiAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gbnVsbDtcXG4gICAgfVxcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XFxuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcXG4gICAgfVxcblxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcXG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XFxuICAgICAgaWYgKHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICB3YXJuaW5nKFxcbiAgICAgICAgICBmYWxzZSxcXG4gICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLiBFeHBlY3RlZCBhbiBhcnJheSBvZiBjaGVjayBmdW5jdGlvbnMsIGJ1dCAnICtcXG4gICAgICAgICAgJ3JlY2VpdmVkICVzIGF0IGluZGV4ICVzLicsXFxuICAgICAgICAgIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyhjaGVja2VyKSxcXG4gICAgICAgICAgaVxcbiAgICAgICAgKTtcXG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XFxuICAgICAgICBpZiAoY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KSA9PSBudWxsKSB7XFxuICAgICAgICAgIHJldHVybiBudWxsO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcXG4gICAgfVxcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XFxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xcbiAgICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcXG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcXG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XFxuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xcbiAgICAgIH1cXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XFxuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcXG4gICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XFxuICAgICAgICBpZiAoZXJyb3IpIHtcXG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gbnVsbDtcXG4gICAgfVxcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XFxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XFxuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcXG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XFxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XFxuICAgICAgfVxcbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgYWxsIGtleXMgaW4gY2FzZSBzb21lIGFyZSByZXF1aXJlZCBidXQgbWlzc2luZyBmcm9tXFxuICAgICAgLy8gcHJvcHMuXFxuICAgICAgdmFyIGFsbEtleXMgPSBhc3NpZ24oe30sIHByb3BzW3Byb3BOYW1lXSwgc2hhcGVUeXBlcyk7XFxuICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcXG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XFxuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcXG4gICAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Aga2V5IGAnICsga2V5ICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJyArXFxuICAgICAgICAgICAgJ1xcXFxuQmFkIG9iamVjdDogJyArIEpTT04uc3RyaW5naWZ5KHByb3BzW3Byb3BOYW1lXSwgbnVsbCwgJyAgJykgK1xcbiAgICAgICAgICAgICdcXFxcblZhbGlkIGtleXM6ICcgKyAgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc2hhcGVUeXBlcyksIG51bGwsICcgICcpXFxuICAgICAgICAgICk7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XFxuICAgICAgICBpZiAoZXJyb3IpIHtcXG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gbnVsbDtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xcbiAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wVmFsdWUpIHtcXG4gICAgICBjYXNlICdudW1iZXInOlxcbiAgICAgIGNhc2UgJ3N0cmluZyc6XFxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxcbiAgICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XFxuICAgICAgY2FzZSAnb2JqZWN0JzpcXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcXG4gICAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XFxuICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XFxuICAgICAgICBpZiAoaXRlcmF0b3JGbikge1xcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcXG4gICAgICAgICAgdmFyIHN0ZXA7XFxuICAgICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcXG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXFxuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xcbiAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcXG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xcbiAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcXG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgIGRlZmF1bHQ6XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcXG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cXG4gICAgaWYgKHByb3BUeXBlID09PSAnc3ltYm9sJykge1xcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9XFxuXFxuICAgIC8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gPT09ICdTeW1ib2wnXFxuICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXFxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHByb3BWYWx1ZSBpbnN0YW5jZW9mIFN5bWJvbCkge1xcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG5cXG4gIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cXG4gIGZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xcbiAgICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XFxuICAgICAgcmV0dXJuICdhcnJheSc7XFxuICAgIH1cXG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xcbiAgICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cXG4gICAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cXG4gICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cXG4gICAgICByZXR1cm4gJ29iamVjdCc7XFxuICAgIH1cXG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XFxuICAgICAgcmV0dXJuICdzeW1ib2wnO1xcbiAgICB9XFxuICAgIHJldHVybiBwcm9wVHlwZTtcXG4gIH1cXG5cXG4gIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cXG4gIC8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxcbiAgZnVuY3Rpb24gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKSB7XFxuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcXG4gICAgICByZXR1cm4gJycgKyBwcm9wVmFsdWU7XFxuICAgIH1cXG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcXG4gICAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xcbiAgICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XFxuICAgICAgICByZXR1cm4gJ2RhdGUnO1xcbiAgICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XFxuICAgICAgICByZXR1cm4gJ3JlZ2V4cCc7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiBwcm9wVHlwZTtcXG4gIH1cXG5cXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCBpcyBwb3N0Zml4ZWQgdG8gYSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgdHlwZS5cXG4gIC8vIEZvciBleGFtcGxlLCBcXFwidW5kZWZpbmVkXFxcIiBvciBcXFwib2YgdHlwZSBhcnJheVxcXCJcXG4gIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xcbiAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcXG4gICAgc3dpdGNoICh0eXBlKSB7XFxuICAgICAgY2FzZSAnYXJyYXknOlxcbiAgICAgIGNhc2UgJ29iamVjdCc6XFxuICAgICAgICByZXR1cm4gJ2FuICcgKyB0eXBlO1xcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxcbiAgICAgIGNhc2UgJ2RhdGUnOlxcbiAgICAgIGNhc2UgJ3JlZ2V4cCc6XFxuICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XFxuICAgICAgZGVmYXVsdDpcXG4gICAgICAgIHJldHVybiB0eXBlO1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxcbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xcbiAgICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcXG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xcbiAgICB9XFxuICAgIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcXG4gIH1cXG5cXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gY2hlY2tQcm9wVHlwZXM7XFxuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcXG5cXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcXG59O1xcblxcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSlcXG5cXG4vLy8vLy8vLy8vLy8vLy8vLy9cXG4vLyBXRUJQQUNLIEZPT1RFUlxcbi8vIC4vfi9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzXFxuLy8gbW9kdWxlIGlkID0gMjFcXG4vLyBtb2R1bGUgY2h1bmtzID0gMFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL34vcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qcz9cIik7XG5cbi8qKiovIH0pLFxuLyogMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZXZhbChcIlxcbi8qKlxcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXFxuICogZW1iZWQgdGhlIGNzcyBvbiB0aGUgcGFnZS4gVGhpcyBicmVha3MgYWxsIHJlbGF0aXZlIHVybHMgYmVjYXVzZSBub3cgdGhleSBhcmUgcmVsYXRpdmUgdG8gYVxcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXFxuICpcXG4gKiBPbmUgc29sdXRpb24gaXMgdG8gb25seSB1c2UgZnVsbCB1cmxzLCBidXQgdGhhdCBtYXkgYmUgaW1wb3NzaWJsZS5cXG4gKlxcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXFxcImZpeGVzXFxcIiB0aGUgcmVsYXRpdmUgdXJscyB0byBiZSBhYnNvbHV0ZSBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgcGFnZSBsb2NhdGlvbi5cXG4gKlxcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxcbiAqXFxuICovXFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzKSB7XFxuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxcbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgJiYgd2luZG93LmxvY2F0aW9uO1xcblxcbiAgaWYgKCFsb2NhdGlvbikge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoXFxcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXFxcIik7XFxuICB9XFxuXFxuXFx0Ly8gYmxhbmsgb3IgbnVsbD9cXG5cXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcXFwic3RyaW5nXFxcIikge1xcblxcdCAgcmV0dXJuIGNzcztcXG4gIH1cXG5cXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcXFwiLy9cXFwiICsgbG9jYXRpb24uaG9zdDtcXG4gIHZhciBjdXJyZW50RGlyID0gYmFzZVVybCArIGxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1xcXFwvW15cXFxcL10qJC8sIFxcXCIvXFxcIik7XFxuXFxuXFx0Ly8gY29udmVydCBlYWNoIHVybCguLi4pXFxuXFx0LypcXG5cXHRUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBqdXN0IGEgd2F5IHRvIHJlY3Vyc2l2ZWx5IG1hdGNoIGJyYWNrZXRzIHdpdGhpblxcblxcdGEgc3RyaW5nLlxcblxcblxcdCAvdXJsXFxcXHMqXFxcXCggID0gTWF0Y2ggb24gdGhlIHdvcmQgXFxcInVybFxcXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xcblxcdCAgICggID0gU3RhcnQgYSBjYXB0dXJpbmcgZ3JvdXBcXG5cXHQgICAgICg/OiAgPSBTdGFydCBhIG5vbi1jYXB0dXJpbmcgZ3JvdXBcXG5cXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcXG5cXHQgICAgICAgICB8ICA9IE9SXFxuXFx0ICAgICAgICAgXFxcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xcblxcdCAgICAgICAgICAgICAoPzogID0gU3RhcnQgYW5vdGhlciBub24tY2FwdHVyaW5nIGdyb3Vwc1xcblxcdCAgICAgICAgICAgICAgICAgW14pKF0rICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xcblxcdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxcblxcdCAgICAgICAgICAgICAgICAgXFxcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xcblxcdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcXG5cXHQgICAgICAgICAgICAgICAgIFxcXFwpICA9IE1hdGNoIGEgZW5kIHBhcmVudGhlc2VzXFxuXFx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXFxuICAgICAgICAgICAgICAqXFxcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xcbiAgICAgICAgICApICA9IENsb3NlIG5vbi1jYXB0dXJpbmcgZ3JvdXBcXG4gICAgICAgICAgKiAgPSBNYXRjaCBhbnl0aGluZ1xcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxcblxcdCBcXFxcKSAgPSBNYXRjaCBhIGNsb3NlIHBhcmVuc1xcblxcblxcdCAvZ2kgID0gR2V0IGFsbCBtYXRjaGVzLCBub3QgdGhlIGZpcnN0LiAgQmUgY2FzZSBpbnNlbnNpdGl2ZS5cXG5cXHQgKi9cXG5cXHR2YXIgZml4ZWRDc3MgPSBjc3MucmVwbGFjZSgvdXJsXFxcXHMqXFxcXCgoKD86W14pKF18XFxcXCgoPzpbXikoXSt8XFxcXChbXikoXSpcXFxcKSkqXFxcXCkpKilcXFxcKS9naSwgZnVuY3Rpb24oZnVsbE1hdGNoLCBvcmlnVXJsKSB7XFxuXFx0XFx0Ly8gc3RyaXAgcXVvdGVzIChpZiB0aGV5IGV4aXN0KVxcblxcdFxcdHZhciB1bnF1b3RlZE9yaWdVcmwgPSBvcmlnVXJsXFxuXFx0XFx0XFx0LnRyaW0oKVxcblxcdFxcdFxcdC5yZXBsYWNlKC9eXFxcIiguKilcXFwiJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KVxcblxcdFxcdFxcdC5yZXBsYWNlKC9eJyguKiknJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KTtcXG5cXG5cXHRcXHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxcblxcdFxcdGlmICgvXigjfGRhdGE6fGh0dHA6XFxcXC9cXFxcL3xodHRwczpcXFxcL1xcXFwvfGZpbGU6XFxcXC9cXFxcL1xcXFwvKS9pLnRlc3QodW5xdW90ZWRPcmlnVXJsKSkge1xcblxcdFxcdCAgcmV0dXJuIGZ1bGxNYXRjaDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcXG5cXHRcXHR2YXIgbmV3VXJsO1xcblxcblxcdFxcdGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcXFwiLy9cXFwiKSA9PT0gMCkge1xcblxcdFxcdCAgXFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xcblxcdFxcdFxcdG5ld1VybCA9IHVucXVvdGVkT3JpZ1VybDtcXG5cXHRcXHR9IGVsc2UgaWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFxcXCIvXFxcIikgPT09IDApIHtcXG5cXHRcXHRcXHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcXG5cXHRcXHRcXHRuZXdVcmwgPSBiYXNlVXJsICsgdW5xdW90ZWRPcmlnVXJsOyAvLyBhbHJlYWR5IHN0YXJ0cyB3aXRoICcvJ1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gY3VycmVudCBkaXJlY3RvcnlcXG5cXHRcXHRcXHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXFxcLlxcXFwvLywgXFxcIlxcXCIpOyAvLyBTdHJpcCBsZWFkaW5nICcuLydcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxcblxcdFxcdHJldHVybiBcXFwidXJsKFxcXCIgKyBKU09OLnN0cmluZ2lmeShuZXdVcmwpICsgXFxcIilcXFwiO1xcblxcdH0pO1xcblxcblxcdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgY3NzXFxuXFx0cmV0dXJuIGZpeGVkQ3NzO1xcbn07XFxuXFxuXFxuLy8vLy8vLy8vLy8vLy8vLy8vXFxuLy8gV0VCUEFDSyBGT09URVJcXG4vLyAuL34vc3R5bGUtbG9hZGVyL2ZpeFVybHMuanNcXG4vLyBtb2R1bGUgaWQgPSAyMlxcbi8vIG1vZHVsZSBjaHVua3MgPSAwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vfi9zdHlsZS1sb2FkZXIvZml4VXJscy5qcz9cIik7XG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbn0pOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-owl-carousel3/lib/OwlCarousel.js\n");

/***/ })

}]);